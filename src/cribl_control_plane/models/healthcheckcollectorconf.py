"""Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT."""

from __future__ import annotations
from .healthcheckauthenticationbasic import (
    HealthCheckAuthenticationBasic,
    HealthCheckAuthenticationBasicSecret,
    HealthCheckAuthenticationBasicSecretTypedDict,
    HealthCheckAuthenticationBasicTypedDict,
    HealthCheckAuthenticationLogin,
    HealthCheckAuthenticationLoginSecret,
    HealthCheckAuthenticationLoginSecretTypedDict,
    HealthCheckAuthenticationLoginTypedDict,
    HealthCheckAuthenticationOauth,
    HealthCheckAuthenticationOauthSecret,
    HealthCheckAuthenticationOauthSecretTypedDict,
    HealthCheckAuthenticationOauthTypedDict,
)
from .hiddendefaultbreakersoptionsdatabasecollectorconf import (
    HiddenDefaultBreakersOptionsDatabaseCollectorConf,
)
from .itemstypehealthcheckauthenticationloginauthrequestheaders import (
    ItemsTypeHealthCheckAuthenticationLoginAuthRequestHeaders,
    ItemsTypeHealthCheckAuthenticationLoginAuthRequestHeadersTypedDict,
)
from .itemstypehealthcheckcollectmethodpostcollectrequestparams import (
    ItemsTypeHealthCheckCollectMethodPostCollectRequestParams,
    ItemsTypeHealthCheckCollectMethodPostCollectRequestParamsTypedDict,
)
from .retrytypeoptionshealthcheckcollectorconfretryrules import (
    RetryTypeOptionsHealthCheckCollectorConfRetryRules,
)
from cribl_control_plane import models, utils
from cribl_control_plane.types import BaseModel, UNSET_SENTINEL
from cribl_control_plane.utils.unions import parse_open_union
from enum import Enum
from functools import partial
import pydantic
from pydantic import ConfigDict, field_serializer, model_serializer
from pydantic.functional_validators import BeforeValidator
from typing import Any, List, Literal, Optional, Union
from typing_extensions import Annotated, NotRequired, TypeAliasType, TypedDict


class HealthCheckAuthenticationNoneAuthentication(
    str, Enum, metaclass=utils.OpenEnumMeta
):
    r"""Authentication method for Discover and Collect REST calls. You can specify API Key–based authentication by adding the appropriate Collect headers."""

    NONE = "none"
    BASIC = "basic"
    BASIC_SECRET = "basicSecret"
    LOGIN = "login"
    LOGIN_SECRET = "loginSecret"
    OAUTH = "oauth"
    OAUTH_SECRET = "oauthSecret"


class HealthCheckAuthenticationNoneHealthCheckDiscoveryDiscoverTypeNoneDiscoverType(
    str, Enum, metaclass=utils.OpenEnumMeta
):
    r"""Defines how task discovery will be performed. Use None to skip the discovery. Use HTTP Request to make a REST call to discover tasks. Use Item List to enumerate items for collect to retrieve. Use JSON Response to manually define discover tasks as a JSON array of objects. Each entry returned by the discover operation will result in a collect task."""

    # HTTP Request
    HTTP = "http"
    # JSON Response
    JSON = "json"
    # Item List
    LIST = "list"
    # None
    NONE = "none"


class HealthCheckAuthenticationNoneHealthCheckDiscoveryDiscoverTypeNoneTypedDict(
    TypedDict
):
    discover_type: (
        HealthCheckAuthenticationNoneHealthCheckDiscoveryDiscoverTypeNoneDiscoverType
    )
    r"""Defines how task discovery will be performed. Use None to skip the discovery. Use HTTP Request to make a REST call to discover tasks. Use Item List to enumerate items for collect to retrieve. Use JSON Response to manually define discover tasks as a JSON array of objects. Each entry returned by the discover operation will result in a collect task."""


class HealthCheckAuthenticationNoneHealthCheckDiscoveryDiscoverTypeNone(BaseModel):
    discover_type: Annotated[
        HealthCheckAuthenticationNoneHealthCheckDiscoveryDiscoverTypeNoneDiscoverType,
        pydantic.Field(alias="discoverType"),
    ]
    r"""Defines how task discovery will be performed. Use None to skip the discovery. Use HTTP Request to make a REST call to discover tasks. Use Item List to enumerate items for collect to retrieve. Use JSON Response to manually define discover tasks as a JSON array of objects. Each entry returned by the discover operation will result in a collect task."""

    @field_serializer("discover_type")
    def serialize_discover_type(self, value):
        if isinstance(value, str):
            try:
                return models.HealthCheckAuthenticationNoneHealthCheckDiscoveryDiscoverTypeNoneDiscoverType(
                    value
                )
            except ValueError:
                return value
        return value


class HealthCheckAuthenticationNoneHealthCheckDiscoveryDiscoverTypeListDiscoverType(
    str, Enum, metaclass=utils.OpenEnumMeta
):
    r"""Defines how task discovery will be performed. Use None to skip the discovery. Use HTTP Request to make a REST call to discover tasks. Use Item List to enumerate items for collect to retrieve. Use JSON Response to manually define discover tasks as a JSON array of objects. Each entry returned by the discover operation will result in a collect task."""

    # HTTP Request
    HTTP = "http"
    # JSON Response
    JSON = "json"
    # Item List
    LIST = "list"
    # None
    NONE = "none"


class HealthCheckAuthenticationNoneHealthCheckDiscoveryDiscoverTypeListTypedDict(
    TypedDict
):
    discover_type: (
        HealthCheckAuthenticationNoneHealthCheckDiscoveryDiscoverTypeListDiscoverType
    )
    r"""Defines how task discovery will be performed. Use None to skip the discovery. Use HTTP Request to make a REST call to discover tasks. Use Item List to enumerate items for collect to retrieve. Use JSON Response to manually define discover tasks as a JSON array of objects. Each entry returned by the discover operation will result in a collect task."""
    item_list: List[str]
    r"""Comma-separated list of items to return from the Discover task. Each item returned will generate a collect task, and can be referenced using `${id}` in the collect URL, headers, or parameters."""


class HealthCheckAuthenticationNoneHealthCheckDiscoveryDiscoverTypeList(BaseModel):
    discover_type: Annotated[
        HealthCheckAuthenticationNoneHealthCheckDiscoveryDiscoverTypeListDiscoverType,
        pydantic.Field(alias="discoverType"),
    ]
    r"""Defines how task discovery will be performed. Use None to skip the discovery. Use HTTP Request to make a REST call to discover tasks. Use Item List to enumerate items for collect to retrieve. Use JSON Response to manually define discover tasks as a JSON array of objects. Each entry returned by the discover operation will result in a collect task."""

    item_list: Annotated[List[str], pydantic.Field(alias="itemList")]
    r"""Comma-separated list of items to return from the Discover task. Each item returned will generate a collect task, and can be referenced using `${id}` in the collect URL, headers, or parameters."""

    @field_serializer("discover_type")
    def serialize_discover_type(self, value):
        if isinstance(value, str):
            try:
                return models.HealthCheckAuthenticationNoneHealthCheckDiscoveryDiscoverTypeListDiscoverType(
                    value
                )
            except ValueError:
                return value
        return value


class HealthCheckAuthenticationNoneHealthCheckDiscoveryDiscoverTypeJSONDiscoverType(
    str, Enum, metaclass=utils.OpenEnumMeta
):
    r"""Defines how task discovery will be performed. Use None to skip the discovery. Use HTTP Request to make a REST call to discover tasks. Use Item List to enumerate items for collect to retrieve. Use JSON Response to manually define discover tasks as a JSON array of objects. Each entry returned by the discover operation will result in a collect task."""

    # HTTP Request
    HTTP = "http"
    # JSON Response
    JSON = "json"
    # Item List
    LIST = "list"
    # None
    NONE = "none"


class HealthCheckAuthenticationNoneHealthCheckDiscoveryDiscoverTypeJSONTypedDict(
    TypedDict
):
    discover_type: (
        HealthCheckAuthenticationNoneHealthCheckDiscoveryDiscoverTypeJSONDiscoverType
    )
    r"""Defines how task discovery will be performed. Use None to skip the discovery. Use HTTP Request to make a REST call to discover tasks. Use Item List to enumerate items for collect to retrieve. Use JSON Response to manually define discover tasks as a JSON array of objects. Each entry returned by the discover operation will result in a collect task."""
    manual_discover_result: str
    r"""Allows hard-coding the Discover result. Must be a JSON object. Works with the Discover Data field."""
    discover_data_field: NotRequired[str]
    r"""Within the response JSON, name of the field or array element to pull results from. Leave blank if the result is an array of values. Sample entry: items, json: { items: [{id: 'first'},{id: 'second'}] }"""


class HealthCheckAuthenticationNoneHealthCheckDiscoveryDiscoverTypeJSON(BaseModel):
    discover_type: Annotated[
        HealthCheckAuthenticationNoneHealthCheckDiscoveryDiscoverTypeJSONDiscoverType,
        pydantic.Field(alias="discoverType"),
    ]
    r"""Defines how task discovery will be performed. Use None to skip the discovery. Use HTTP Request to make a REST call to discover tasks. Use Item List to enumerate items for collect to retrieve. Use JSON Response to manually define discover tasks as a JSON array of objects. Each entry returned by the discover operation will result in a collect task."""

    manual_discover_result: Annotated[str, pydantic.Field(alias="manualDiscoverResult")]
    r"""Allows hard-coding the Discover result. Must be a JSON object. Works with the Discover Data field."""

    discover_data_field: Annotated[
        Optional[str], pydantic.Field(alias="discoverDataField")
    ] = None
    r"""Within the response JSON, name of the field or array element to pull results from. Leave blank if the result is an array of values. Sample entry: items, json: { items: [{id: 'first'},{id: 'second'}] }"""

    @field_serializer("discover_type")
    def serialize_discover_type(self, value):
        if isinstance(value, str):
            try:
                return models.HealthCheckAuthenticationNoneHealthCheckDiscoveryDiscoverTypeJSONDiscoverType(
                    value
                )
            except ValueError:
                return value
        return value

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(["discoverDataField"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


class HealthCheckAuthenticationNoneHealthCheckDiscoveryDiscoverTypeHTTPDiscoverMethodPostWithBodyDiscoverMethod(
    str, Enum, metaclass=utils.OpenEnumMeta
):
    r"""Discover HTTP method."""

    # GET
    GET = "get"
    # POST
    POST = "post"
    # POST with Body
    POST_WITH_BODY = "post_with_body"


class HealthCheckAuthenticationNoneHealthCheckDiscoveryDiscoverTypeHTTPDiscoverMethodPostWithBodyDiscoverType(
    str, Enum, metaclass=utils.OpenEnumMeta
):
    r"""Defines how task discovery will be performed. Use None to skip the discovery. Use HTTP Request to make a REST call to discover tasks. Use Item List to enumerate items for collect to retrieve. Use JSON Response to manually define discover tasks as a JSON array of objects. Each entry returned by the discover operation will result in a collect task."""

    # HTTP Request
    HTTP = "http"
    # JSON Response
    JSON = "json"
    # Item List
    LIST = "list"
    # None
    NONE = "none"


class HealthCheckAuthenticationNoneHealthCheckDiscoveryDiscoverTypeHTTPDiscoverMethodPostWithBodyTypedDict(
    TypedDict
):
    discover_method: HealthCheckAuthenticationNoneHealthCheckDiscoveryDiscoverTypeHTTPDiscoverMethodPostWithBodyDiscoverMethod
    r"""Discover HTTP method."""
    discover_type: HealthCheckAuthenticationNoneHealthCheckDiscoveryDiscoverTypeHTTPDiscoverMethodPostWithBodyDiscoverType
    r"""Defines how task discovery will be performed. Use None to skip the discovery. Use HTTP Request to make a REST call to discover tasks. Use Item List to enumerate items for collect to retrieve. Use JSON Response to manually define discover tasks as a JSON array of objects. Each entry returned by the discover operation will result in a collect task."""
    discover_url: str
    r"""Expression to derive URL to use for the Discover operation (can be a constant)."""
    discover_body: NotRequired[str]
    r"""Template for POST body to send with the discover request."""
    discover_request_headers: NotRequired[
        List[ItemsTypeHealthCheckAuthenticationLoginAuthRequestHeadersTypedDict]
    ]
    r"""Optional discover request headers."""
    discover_data_field: NotRequired[str]
    r"""Path to field in the response object which contains discover results (e.g.: level1.name), leave blank if the result is an array."""


class HealthCheckAuthenticationNoneHealthCheckDiscoveryDiscoverTypeHTTPDiscoverMethodPostWithBody(
    BaseModel
):
    discover_method: Annotated[
        HealthCheckAuthenticationNoneHealthCheckDiscoveryDiscoverTypeHTTPDiscoverMethodPostWithBodyDiscoverMethod,
        pydantic.Field(alias="discoverMethod"),
    ]
    r"""Discover HTTP method."""

    discover_type: Annotated[
        HealthCheckAuthenticationNoneHealthCheckDiscoveryDiscoverTypeHTTPDiscoverMethodPostWithBodyDiscoverType,
        pydantic.Field(alias="discoverType"),
    ]
    r"""Defines how task discovery will be performed. Use None to skip the discovery. Use HTTP Request to make a REST call to discover tasks. Use Item List to enumerate items for collect to retrieve. Use JSON Response to manually define discover tasks as a JSON array of objects. Each entry returned by the discover operation will result in a collect task."""

    discover_url: Annotated[str, pydantic.Field(alias="discoverUrl")]
    r"""Expression to derive URL to use for the Discover operation (can be a constant)."""

    discover_body: Annotated[Optional[str], pydantic.Field(alias="discoverBody")] = None
    r"""Template for POST body to send with the discover request."""

    discover_request_headers: Annotated[
        Optional[List[ItemsTypeHealthCheckAuthenticationLoginAuthRequestHeaders]],
        pydantic.Field(alias="discoverRequestHeaders"),
    ] = None
    r"""Optional discover request headers."""

    discover_data_field: Annotated[
        Optional[str], pydantic.Field(alias="discoverDataField")
    ] = None
    r"""Path to field in the response object which contains discover results (e.g.: level1.name), leave blank if the result is an array."""

    @field_serializer("discover_method")
    def serialize_discover_method(self, value):
        if isinstance(value, str):
            try:
                return models.HealthCheckAuthenticationNoneHealthCheckDiscoveryDiscoverTypeHTTPDiscoverMethodPostWithBodyDiscoverMethod(
                    value
                )
            except ValueError:
                return value
        return value

    @field_serializer("discover_type")
    def serialize_discover_type(self, value):
        if isinstance(value, str):
            try:
                return models.HealthCheckAuthenticationNoneHealthCheckDiscoveryDiscoverTypeHTTPDiscoverMethodPostWithBodyDiscoverType(
                    value
                )
            except ValueError:
                return value
        return value

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(
            ["discoverBody", "discoverRequestHeaders", "discoverDataField"]
        )
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


class HealthCheckAuthenticationNoneHealthCheckDiscoveryDiscoverTypeHTTPDiscoverMethodPostDiscoverMethod(
    str, Enum, metaclass=utils.OpenEnumMeta
):
    r"""Discover HTTP method."""

    # GET
    GET = "get"
    # POST
    POST = "post"
    # POST with Body
    POST_WITH_BODY = "post_with_body"


class HealthCheckAuthenticationNoneHealthCheckDiscoveryDiscoverTypeHTTPDiscoverMethodPostDiscoverType(
    str, Enum, metaclass=utils.OpenEnumMeta
):
    r"""Defines how task discovery will be performed. Use None to skip the discovery. Use HTTP Request to make a REST call to discover tasks. Use Item List to enumerate items for collect to retrieve. Use JSON Response to manually define discover tasks as a JSON array of objects. Each entry returned by the discover operation will result in a collect task."""

    # HTTP Request
    HTTP = "http"
    # JSON Response
    JSON = "json"
    # Item List
    LIST = "list"
    # None
    NONE = "none"


class HealthCheckAuthenticationNoneHealthCheckDiscoveryDiscoverTypeHTTPDiscoverMethodPostTypedDict(
    TypedDict
):
    discover_method: HealthCheckAuthenticationNoneHealthCheckDiscoveryDiscoverTypeHTTPDiscoverMethodPostDiscoverMethod
    r"""Discover HTTP method."""
    discover_type: HealthCheckAuthenticationNoneHealthCheckDiscoveryDiscoverTypeHTTPDiscoverMethodPostDiscoverType
    r"""Defines how task discovery will be performed. Use None to skip the discovery. Use HTTP Request to make a REST call to discover tasks. Use Item List to enumerate items for collect to retrieve. Use JSON Response to manually define discover tasks as a JSON array of objects. Each entry returned by the discover operation will result in a collect task."""
    discover_url: str
    r"""Expression to derive URL to use for the Discover operation (can be a constant)."""
    discover_request_params: NotRequired[
        List[ItemsTypeHealthCheckCollectMethodPostCollectRequestParamsTypedDict]
    ]
    r"""Optional discover request parameters."""
    discover_request_headers: NotRequired[
        List[ItemsTypeHealthCheckAuthenticationLoginAuthRequestHeadersTypedDict]
    ]
    r"""Optional discover request headers."""
    discover_data_field: NotRequired[str]
    r"""Path to field in the response object which contains discover results (e.g.: level1.name), leave blank if the result is an array."""


class HealthCheckAuthenticationNoneHealthCheckDiscoveryDiscoverTypeHTTPDiscoverMethodPost(
    BaseModel
):
    discover_method: Annotated[
        HealthCheckAuthenticationNoneHealthCheckDiscoveryDiscoverTypeHTTPDiscoverMethodPostDiscoverMethod,
        pydantic.Field(alias="discoverMethod"),
    ]
    r"""Discover HTTP method."""

    discover_type: Annotated[
        HealthCheckAuthenticationNoneHealthCheckDiscoveryDiscoverTypeHTTPDiscoverMethodPostDiscoverType,
        pydantic.Field(alias="discoverType"),
    ]
    r"""Defines how task discovery will be performed. Use None to skip the discovery. Use HTTP Request to make a REST call to discover tasks. Use Item List to enumerate items for collect to retrieve. Use JSON Response to manually define discover tasks as a JSON array of objects. Each entry returned by the discover operation will result in a collect task."""

    discover_url: Annotated[str, pydantic.Field(alias="discoverUrl")]
    r"""Expression to derive URL to use for the Discover operation (can be a constant)."""

    discover_request_params: Annotated[
        Optional[List[ItemsTypeHealthCheckCollectMethodPostCollectRequestParams]],
        pydantic.Field(alias="discoverRequestParams"),
    ] = None
    r"""Optional discover request parameters."""

    discover_request_headers: Annotated[
        Optional[List[ItemsTypeHealthCheckAuthenticationLoginAuthRequestHeaders]],
        pydantic.Field(alias="discoverRequestHeaders"),
    ] = None
    r"""Optional discover request headers."""

    discover_data_field: Annotated[
        Optional[str], pydantic.Field(alias="discoverDataField")
    ] = None
    r"""Path to field in the response object which contains discover results (e.g.: level1.name), leave blank if the result is an array."""

    @field_serializer("discover_method")
    def serialize_discover_method(self, value):
        if isinstance(value, str):
            try:
                return models.HealthCheckAuthenticationNoneHealthCheckDiscoveryDiscoverTypeHTTPDiscoverMethodPostDiscoverMethod(
                    value
                )
            except ValueError:
                return value
        return value

    @field_serializer("discover_type")
    def serialize_discover_type(self, value):
        if isinstance(value, str):
            try:
                return models.HealthCheckAuthenticationNoneHealthCheckDiscoveryDiscoverTypeHTTPDiscoverMethodPostDiscoverType(
                    value
                )
            except ValueError:
                return value
        return value

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(
            ["discoverRequestParams", "discoverRequestHeaders", "discoverDataField"]
        )
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


class HealthCheckAuthenticationNoneHealthCheckDiscoveryDiscoverTypeHTTPDiscoverMethodGetDiscoverMethod(
    str, Enum, metaclass=utils.OpenEnumMeta
):
    r"""Discover HTTP method."""

    # GET
    GET = "get"
    # POST
    POST = "post"
    # POST with Body
    POST_WITH_BODY = "post_with_body"


class HealthCheckAuthenticationNoneHealthCheckDiscoveryDiscoverTypeHTTPDiscoverMethodGetDiscoverType(
    str, Enum, metaclass=utils.OpenEnumMeta
):
    r"""Defines how task discovery will be performed. Use None to skip the discovery. Use HTTP Request to make a REST call to discover tasks. Use Item List to enumerate items for collect to retrieve. Use JSON Response to manually define discover tasks as a JSON array of objects. Each entry returned by the discover operation will result in a collect task."""

    # HTTP Request
    HTTP = "http"
    # JSON Response
    JSON = "json"
    # Item List
    LIST = "list"
    # None
    NONE = "none"


class HealthCheckAuthenticationNoneHealthCheckDiscoveryDiscoverTypeHTTPDiscoverMethodGetTypedDict(
    TypedDict
):
    discover_method: HealthCheckAuthenticationNoneHealthCheckDiscoveryDiscoverTypeHTTPDiscoverMethodGetDiscoverMethod
    r"""Discover HTTP method."""
    discover_type: HealthCheckAuthenticationNoneHealthCheckDiscoveryDiscoverTypeHTTPDiscoverMethodGetDiscoverType
    r"""Defines how task discovery will be performed. Use None to skip the discovery. Use HTTP Request to make a REST call to discover tasks. Use Item List to enumerate items for collect to retrieve. Use JSON Response to manually define discover tasks as a JSON array of objects. Each entry returned by the discover operation will result in a collect task."""
    discover_url: str
    r"""Expression to derive URL to use for the Discover operation (can be a constant)."""
    discover_request_params: NotRequired[
        List[ItemsTypeHealthCheckCollectMethodPostCollectRequestParamsTypedDict]
    ]
    r"""Optional discover request parameters."""
    discover_request_headers: NotRequired[
        List[ItemsTypeHealthCheckAuthenticationLoginAuthRequestHeadersTypedDict]
    ]
    r"""Optional discover request headers."""
    discover_data_field: NotRequired[str]
    r"""Path to field in the response object which contains discover results (e.g.: level1.name), leave blank if the result is an array."""


class HealthCheckAuthenticationNoneHealthCheckDiscoveryDiscoverTypeHTTPDiscoverMethodGet(
    BaseModel
):
    discover_method: Annotated[
        HealthCheckAuthenticationNoneHealthCheckDiscoveryDiscoverTypeHTTPDiscoverMethodGetDiscoverMethod,
        pydantic.Field(alias="discoverMethod"),
    ]
    r"""Discover HTTP method."""

    discover_type: Annotated[
        HealthCheckAuthenticationNoneHealthCheckDiscoveryDiscoverTypeHTTPDiscoverMethodGetDiscoverType,
        pydantic.Field(alias="discoverType"),
    ]
    r"""Defines how task discovery will be performed. Use None to skip the discovery. Use HTTP Request to make a REST call to discover tasks. Use Item List to enumerate items for collect to retrieve. Use JSON Response to manually define discover tasks as a JSON array of objects. Each entry returned by the discover operation will result in a collect task."""

    discover_url: Annotated[str, pydantic.Field(alias="discoverUrl")]
    r"""Expression to derive URL to use for the Discover operation (can be a constant)."""

    discover_request_params: Annotated[
        Optional[List[ItemsTypeHealthCheckCollectMethodPostCollectRequestParams]],
        pydantic.Field(alias="discoverRequestParams"),
    ] = None
    r"""Optional discover request parameters."""

    discover_request_headers: Annotated[
        Optional[List[ItemsTypeHealthCheckAuthenticationLoginAuthRequestHeaders]],
        pydantic.Field(alias="discoverRequestHeaders"),
    ] = None
    r"""Optional discover request headers."""

    discover_data_field: Annotated[
        Optional[str], pydantic.Field(alias="discoverDataField")
    ] = None
    r"""Path to field in the response object which contains discover results (e.g.: level1.name), leave blank if the result is an array."""

    @field_serializer("discover_method")
    def serialize_discover_method(self, value):
        if isinstance(value, str):
            try:
                return models.HealthCheckAuthenticationNoneHealthCheckDiscoveryDiscoverTypeHTTPDiscoverMethodGetDiscoverMethod(
                    value
                )
            except ValueError:
                return value
        return value

    @field_serializer("discover_type")
    def serialize_discover_type(self, value):
        if isinstance(value, str):
            try:
                return models.HealthCheckAuthenticationNoneHealthCheckDiscoveryDiscoverTypeHTTPDiscoverMethodGetDiscoverType(
                    value
                )
            except ValueError:
                return value
        return value

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(
            ["discoverRequestParams", "discoverRequestHeaders", "discoverDataField"]
        )
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


HealthCheckAuthenticationNoneHealthCheckDiscoveryDiscoverTypeHTTPTypedDict = TypeAliasType(
    "HealthCheckAuthenticationNoneHealthCheckDiscoveryDiscoverTypeHTTPTypedDict",
    Union[
        HealthCheckAuthenticationNoneHealthCheckDiscoveryDiscoverTypeHTTPDiscoverMethodGetTypedDict,
        HealthCheckAuthenticationNoneHealthCheckDiscoveryDiscoverTypeHTTPDiscoverMethodPostTypedDict,
        HealthCheckAuthenticationNoneHealthCheckDiscoveryDiscoverTypeHTTPDiscoverMethodPostWithBodyTypedDict,
    ],
)


class UnknownHealthCheckAuthenticationNoneHealthCheckDiscoveryDiscoverTypeHTTP(
    BaseModel
):
    r"""A HealthCheckAuthenticationNoneHealthCheckDiscoveryDiscoverTypeHTTP variant the SDK doesn't recognize. Preserves the raw payload."""

    discover_method: Literal["UNKNOWN"] = "UNKNOWN"
    raw: Any
    is_unknown: Literal[True] = True

    model_config = ConfigDict(frozen=True)


_HEALTH_CHECK_AUTHENTICATION_NONE_HEALTH_CHECK_DISCOVERY_DISCOVER_TYPE_HTTP_VARIANTS: dict[
    str, Any
] = {
    "get": HealthCheckAuthenticationNoneHealthCheckDiscoveryDiscoverTypeHTTPDiscoverMethodGet,
    "post": HealthCheckAuthenticationNoneHealthCheckDiscoveryDiscoverTypeHTTPDiscoverMethodPost,
    "post_with_body": HealthCheckAuthenticationNoneHealthCheckDiscoveryDiscoverTypeHTTPDiscoverMethodPostWithBody,
}


HealthCheckAuthenticationNoneHealthCheckDiscoveryDiscoverTypeHTTP = Annotated[
    Union[
        HealthCheckAuthenticationNoneHealthCheckDiscoveryDiscoverTypeHTTPDiscoverMethodGet,
        HealthCheckAuthenticationNoneHealthCheckDiscoveryDiscoverTypeHTTPDiscoverMethodPost,
        HealthCheckAuthenticationNoneHealthCheckDiscoveryDiscoverTypeHTTPDiscoverMethodPostWithBody,
        UnknownHealthCheckAuthenticationNoneHealthCheckDiscoveryDiscoverTypeHTTP,
    ],
    BeforeValidator(
        partial(
            parse_open_union,
            disc_key="discoverMethod",
            variants=_HEALTH_CHECK_AUTHENTICATION_NONE_HEALTH_CHECK_DISCOVERY_DISCOVER_TYPE_HTTP_VARIANTS,
            unknown_cls=UnknownHealthCheckAuthenticationNoneHealthCheckDiscoveryDiscoverTypeHTTP,
            union_name="HealthCheckAuthenticationNoneHealthCheckDiscoveryDiscoverTypeHTTP",
        )
    ),
]


HealthCheckAuthenticationNoneDiscoveryTypedDict = TypeAliasType(
    "HealthCheckAuthenticationNoneDiscoveryTypedDict",
    Union[
        HealthCheckAuthenticationNoneHealthCheckDiscoveryDiscoverTypeNoneTypedDict,
        HealthCheckAuthenticationNoneHealthCheckDiscoveryDiscoverTypeListTypedDict,
        HealthCheckAuthenticationNoneHealthCheckDiscoveryDiscoverTypeJSONTypedDict,
        HealthCheckAuthenticationNoneHealthCheckDiscoveryDiscoverTypeHTTPTypedDict,
    ],
)


class UnknownHealthCheckAuthenticationNoneDiscovery(BaseModel):
    r"""A HealthCheckAuthenticationNoneDiscovery variant the SDK doesn't recognize. Preserves the raw payload."""

    discover_type: Literal["UNKNOWN"] = "UNKNOWN"
    raw: Any
    is_unknown: Literal[True] = True

    model_config = ConfigDict(frozen=True)


_HEALTH_CHECK_AUTHENTICATION_NONE_DISCOVERY_VARIANTS: dict[str, Any] = {
    "http": HealthCheckAuthenticationNoneHealthCheckDiscoveryDiscoverTypeHTTP,
    "json": HealthCheckAuthenticationNoneHealthCheckDiscoveryDiscoverTypeJSON,
    "list": HealthCheckAuthenticationNoneHealthCheckDiscoveryDiscoverTypeList,
    "none": HealthCheckAuthenticationNoneHealthCheckDiscoveryDiscoverTypeNone,
}


HealthCheckAuthenticationNoneDiscovery = Annotated[
    Union[
        HealthCheckAuthenticationNoneHealthCheckDiscoveryDiscoverTypeHTTP,
        HealthCheckAuthenticationNoneHealthCheckDiscoveryDiscoverTypeJSON,
        HealthCheckAuthenticationNoneHealthCheckDiscoveryDiscoverTypeList,
        HealthCheckAuthenticationNoneHealthCheckDiscoveryDiscoverTypeNone,
        UnknownHealthCheckAuthenticationNoneDiscovery,
    ],
    BeforeValidator(
        partial(
            parse_open_union,
            disc_key="discoverType",
            variants=_HEALTH_CHECK_AUTHENTICATION_NONE_DISCOVERY_VARIANTS,
            unknown_cls=UnknownHealthCheckAuthenticationNoneDiscovery,
            union_name="HealthCheckAuthenticationNoneDiscovery",
        )
    ),
]


class HealthCheckAuthenticationNoneHealthCheckMethod(
    str, Enum, metaclass=utils.OpenEnumMeta
):
    r"""Health check HTTP method."""

    # GET
    GET = "get"
    # POST
    POST = "post"
    # POST with Body
    POST_WITH_BODY = "post_with_body"


class HealthCheckAuthenticationNoneCollectRequestHeaderTypedDict(TypedDict):
    name: str
    r"""Header Name"""
    value: str
    r"""JavaScript expression to compute the header value (can be a constant)."""


class HealthCheckAuthenticationNoneCollectRequestHeader(BaseModel):
    name: str
    r"""Header Name"""

    value: str
    r"""JavaScript expression to compute the header value (can be a constant)."""


class HealthCheckAuthenticationNoneHealthCheckRetryRulesTypeBackoffTypedDict(TypedDict):
    type: RetryTypeOptionsHealthCheckCollectorConfRetryRules
    r"""The algorithm to use when performing HTTP retries"""
    interval: NotRequired[float]
    r"""Time interval between failed request and first retry (kickoff). Maximum allowed value is 20,000 ms (1/3 minute)."""
    limit: NotRequired[float]
    r"""The maximum number of times to retry a failed HTTP request"""
    multiplier: NotRequired[float]
    r"""Base for exponential backoff, e.g., base 2 means that retries will occur after 2, then 4, then 8 seconds, and so on"""
    codes: NotRequired[List[float]]
    r"""List of HTTP codes that trigger a retry. Leave empty to use the default list of 429 and 503."""
    enable_header: NotRequired[bool]
    r"""Honor any Retry-After header that specifies a delay (in seconds) or a timestamp after which to retry the request. The delay is limited to 20 seconds, even if the Retry-After header specifies a longer delay. When disabled, all Retry-After headers are ignored."""


class HealthCheckAuthenticationNoneHealthCheckRetryRulesTypeBackoff(BaseModel):
    type: RetryTypeOptionsHealthCheckCollectorConfRetryRules
    r"""The algorithm to use when performing HTTP retries"""

    interval: Optional[float] = None
    r"""Time interval between failed request and first retry (kickoff). Maximum allowed value is 20,000 ms (1/3 minute)."""

    limit: Optional[float] = None
    r"""The maximum number of times to retry a failed HTTP request"""

    multiplier: Optional[float] = None
    r"""Base for exponential backoff, e.g., base 2 means that retries will occur after 2, then 4, then 8 seconds, and so on"""

    codes: Optional[List[float]] = None
    r"""List of HTTP codes that trigger a retry. Leave empty to use the default list of 429 and 503."""

    enable_header: Annotated[Optional[bool], pydantic.Field(alias="enableHeader")] = (
        None
    )
    r"""Honor any Retry-After header that specifies a delay (in seconds) or a timestamp after which to retry the request. The delay is limited to 20 seconds, even if the Retry-After header specifies a longer delay. When disabled, all Retry-After headers are ignored."""

    @field_serializer("type")
    def serialize_type(self, value):
        if isinstance(value, str):
            try:
                return models.RetryTypeOptionsHealthCheckCollectorConfRetryRules(value)
            except ValueError:
                return value
        return value

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(
            ["interval", "limit", "multiplier", "codes", "enableHeader"]
        )
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


class HealthCheckAuthenticationNoneHealthCheckRetryRulesTypeStaticTypedDict(TypedDict):
    type: RetryTypeOptionsHealthCheckCollectorConfRetryRules
    r"""The algorithm to use when performing HTTP retries"""
    interval: NotRequired[float]
    r"""Time interval between retries. Maximum allowed value is 20,000 ms (1/3 minute)."""
    limit: NotRequired[float]
    r"""The maximum number of times to retry a failed HTTP request"""
    codes: NotRequired[List[float]]
    r"""List of HTTP codes that trigger a retry. Leave empty to use the default list of 429 and 503."""
    enable_header: NotRequired[bool]
    r"""Honor any Retry-After header that specifies a delay (in seconds) or a timestamp after which to retry the request. The delay is limited to 20 seconds, even if the Retry-After header specifies a longer delay. When disabled, all Retry-After headers are ignored."""


class HealthCheckAuthenticationNoneHealthCheckRetryRulesTypeStatic(BaseModel):
    type: RetryTypeOptionsHealthCheckCollectorConfRetryRules
    r"""The algorithm to use when performing HTTP retries"""

    interval: Optional[float] = None
    r"""Time interval between retries. Maximum allowed value is 20,000 ms (1/3 minute)."""

    limit: Optional[float] = None
    r"""The maximum number of times to retry a failed HTTP request"""

    codes: Optional[List[float]] = None
    r"""List of HTTP codes that trigger a retry. Leave empty to use the default list of 429 and 503."""

    enable_header: Annotated[Optional[bool], pydantic.Field(alias="enableHeader")] = (
        None
    )
    r"""Honor any Retry-After header that specifies a delay (in seconds) or a timestamp after which to retry the request. The delay is limited to 20 seconds, even if the Retry-After header specifies a longer delay. When disabled, all Retry-After headers are ignored."""

    @field_serializer("type")
    def serialize_type(self, value):
        if isinstance(value, str):
            try:
                return models.RetryTypeOptionsHealthCheckCollectorConfRetryRules(value)
            except ValueError:
                return value
        return value

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(["interval", "limit", "codes", "enableHeader"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


class HealthCheckAuthenticationNoneHealthCheckRetryRulesTypeNoneTypedDict(TypedDict):
    type: RetryTypeOptionsHealthCheckCollectorConfRetryRules
    r"""The algorithm to use when performing HTTP retries"""


class HealthCheckAuthenticationNoneHealthCheckRetryRulesTypeNone(BaseModel):
    type: RetryTypeOptionsHealthCheckCollectorConfRetryRules
    r"""The algorithm to use when performing HTTP retries"""

    @field_serializer("type")
    def serialize_type(self, value):
        if isinstance(value, str):
            try:
                return models.RetryTypeOptionsHealthCheckCollectorConfRetryRules(value)
            except ValueError:
                return value
        return value


HealthCheckAuthenticationNoneRetryRulesTypedDict = TypeAliasType(
    "HealthCheckAuthenticationNoneRetryRulesTypedDict",
    Union[
        HealthCheckAuthenticationNoneHealthCheckRetryRulesTypeNoneTypedDict,
        HealthCheckAuthenticationNoneHealthCheckRetryRulesTypeStaticTypedDict,
        HealthCheckAuthenticationNoneHealthCheckRetryRulesTypeBackoffTypedDict,
    ],
)


class UnknownHealthCheckAuthenticationNoneRetryRules(BaseModel):
    r"""A HealthCheckAuthenticationNoneRetryRules variant the SDK doesn't recognize. Preserves the raw payload."""

    type: Literal["UNKNOWN"] = "UNKNOWN"
    raw: Any
    is_unknown: Literal[True] = True

    model_config = ConfigDict(frozen=True)


_HEALTH_CHECK_AUTHENTICATION_NONE_RETRY_RULES_VARIANTS: dict[str, Any] = {
    "none": HealthCheckAuthenticationNoneHealthCheckRetryRulesTypeNone,
    "static": HealthCheckAuthenticationNoneHealthCheckRetryRulesTypeStatic,
    "backoff": HealthCheckAuthenticationNoneHealthCheckRetryRulesTypeBackoff,
}


HealthCheckAuthenticationNoneRetryRules = Annotated[
    Union[
        HealthCheckAuthenticationNoneHealthCheckRetryRulesTypeNone,
        HealthCheckAuthenticationNoneHealthCheckRetryRulesTypeStatic,
        HealthCheckAuthenticationNoneHealthCheckRetryRulesTypeBackoff,
        UnknownHealthCheckAuthenticationNoneRetryRules,
    ],
    BeforeValidator(
        partial(
            parse_open_union,
            disc_key="type",
            variants=_HEALTH_CHECK_AUTHENTICATION_NONE_RETRY_RULES_VARIANTS,
            unknown_cls=UnknownHealthCheckAuthenticationNoneRetryRules,
            union_name="HealthCheckAuthenticationNoneRetryRules",
        )
    ),
]


class HealthCheckAuthenticationNoneTypedDict(TypedDict):
    authentication: HealthCheckAuthenticationNoneAuthentication
    r"""Authentication method for Discover and Collect REST calls. You can specify API Key–based authentication by adding the appropriate Collect headers."""
    collect_url: str
    r"""Expression to derive URL to use for the health check operation (can be a constant)."""
    collect_method: HealthCheckAuthenticationNoneHealthCheckMethod
    r"""Health check HTTP method."""
    discovery: NotRequired[HealthCheckAuthenticationNoneDiscoveryTypedDict]
    collect_request_headers: NotRequired[
        List[HealthCheckAuthenticationNoneCollectRequestHeaderTypedDict]
    ]
    r"""Optional health check request headers."""
    authenticate_collect: NotRequired[bool]
    r"""Enable to make auth health check call."""
    timeout: NotRequired[float]
    r"""HTTP request inactivity timeout, use 0 to disable"""
    reject_unauthorized: NotRequired[bool]
    r"""Whether to reject certificates that cannot be verified against a valid CA (e.g., self-signed certificates)."""
    default_breakers: NotRequired[HiddenDefaultBreakersOptionsDatabaseCollectorConf]
    safe_headers: NotRequired[List[str]]
    r"""List of headers that are safe to log in plain text."""
    retry_rules: NotRequired[HealthCheckAuthenticationNoneRetryRulesTypedDict]


class HealthCheckAuthenticationNone(BaseModel):
    authentication: HealthCheckAuthenticationNoneAuthentication
    r"""Authentication method for Discover and Collect REST calls. You can specify API Key–based authentication by adding the appropriate Collect headers."""

    collect_url: Annotated[str, pydantic.Field(alias="collectUrl")]
    r"""Expression to derive URL to use for the health check operation (can be a constant)."""

    collect_method: Annotated[
        HealthCheckAuthenticationNoneHealthCheckMethod,
        pydantic.Field(alias="collectMethod"),
    ]
    r"""Health check HTTP method."""

    discovery: Optional[HealthCheckAuthenticationNoneDiscovery] = None

    collect_request_headers: Annotated[
        Optional[List[HealthCheckAuthenticationNoneCollectRequestHeader]],
        pydantic.Field(alias="collectRequestHeaders"),
    ] = None
    r"""Optional health check request headers."""

    authenticate_collect: Annotated[
        Optional[bool], pydantic.Field(alias="authenticateCollect")
    ] = None
    r"""Enable to make auth health check call."""

    timeout: Optional[float] = None
    r"""HTTP request inactivity timeout, use 0 to disable"""

    reject_unauthorized: Annotated[
        Optional[bool], pydantic.Field(alias="rejectUnauthorized")
    ] = None
    r"""Whether to reject certificates that cannot be verified against a valid CA (e.g., self-signed certificates)."""

    default_breakers: Annotated[
        Optional[HiddenDefaultBreakersOptionsDatabaseCollectorConf],
        pydantic.Field(alias="defaultBreakers"),
    ] = None

    safe_headers: Annotated[
        Optional[List[str]], pydantic.Field(alias="safeHeaders")
    ] = None
    r"""List of headers that are safe to log in plain text."""

    retry_rules: Annotated[
        Optional[HealthCheckAuthenticationNoneRetryRules],
        pydantic.Field(alias="retryRules"),
    ] = None

    @field_serializer("authentication")
    def serialize_authentication(self, value):
        if isinstance(value, str):
            try:
                return models.HealthCheckAuthenticationNoneAuthentication(value)
            except ValueError:
                return value
        return value

    @field_serializer("collect_method")
    def serialize_collect_method(self, value):
        if isinstance(value, str):
            try:
                return models.HealthCheckAuthenticationNoneHealthCheckMethod(value)
            except ValueError:
                return value
        return value

    @field_serializer("default_breakers")
    def serialize_default_breakers(self, value):
        if isinstance(value, str):
            try:
                return models.HiddenDefaultBreakersOptionsDatabaseCollectorConf(value)
            except ValueError:
                return value
        return value

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(
            [
                "discovery",
                "collectRequestHeaders",
                "authenticateCollect",
                "timeout",
                "rejectUnauthorized",
                "defaultBreakers",
                "safeHeaders",
                "retryRules",
            ]
        )
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


class HealthCheckCollectMethodPostWithBodyHealthCheckMethod(
    str, Enum, metaclass=utils.OpenEnumMeta
):
    r"""Health check HTTP method."""

    # GET
    GET = "get"
    # POST
    POST = "post"
    # POST with Body
    POST_WITH_BODY = "post_with_body"


class HealthCheckCollectMethodPostWithBodyHealthCheckDiscoveryDiscoverTypeNoneDiscoverType(
    str, Enum, metaclass=utils.OpenEnumMeta
):
    r"""Defines how task discovery will be performed. Use None to skip the discovery. Use HTTP Request to make a REST call to discover tasks. Use Item List to enumerate items for collect to retrieve. Use JSON Response to manually define discover tasks as a JSON array of objects. Each entry returned by the discover operation will result in a collect task."""

    # HTTP Request
    HTTP = "http"
    # JSON Response
    JSON = "json"
    # Item List
    LIST = "list"
    # None
    NONE = "none"


class HealthCheckCollectMethodPostWithBodyHealthCheckDiscoveryDiscoverTypeNoneTypedDict(
    TypedDict
):
    discover_type: HealthCheckCollectMethodPostWithBodyHealthCheckDiscoveryDiscoverTypeNoneDiscoverType
    r"""Defines how task discovery will be performed. Use None to skip the discovery. Use HTTP Request to make a REST call to discover tasks. Use Item List to enumerate items for collect to retrieve. Use JSON Response to manually define discover tasks as a JSON array of objects. Each entry returned by the discover operation will result in a collect task."""


class HealthCheckCollectMethodPostWithBodyHealthCheckDiscoveryDiscoverTypeNone(
    BaseModel
):
    discover_type: Annotated[
        HealthCheckCollectMethodPostWithBodyHealthCheckDiscoveryDiscoverTypeNoneDiscoverType,
        pydantic.Field(alias="discoverType"),
    ]
    r"""Defines how task discovery will be performed. Use None to skip the discovery. Use HTTP Request to make a REST call to discover tasks. Use Item List to enumerate items for collect to retrieve. Use JSON Response to manually define discover tasks as a JSON array of objects. Each entry returned by the discover operation will result in a collect task."""

    @field_serializer("discover_type")
    def serialize_discover_type(self, value):
        if isinstance(value, str):
            try:
                return models.HealthCheckCollectMethodPostWithBodyHealthCheckDiscoveryDiscoverTypeNoneDiscoverType(
                    value
                )
            except ValueError:
                return value
        return value


class HealthCheckCollectMethodPostWithBodyHealthCheckDiscoveryDiscoverTypeListDiscoverType(
    str, Enum, metaclass=utils.OpenEnumMeta
):
    r"""Defines how task discovery will be performed. Use None to skip the discovery. Use HTTP Request to make a REST call to discover tasks. Use Item List to enumerate items for collect to retrieve. Use JSON Response to manually define discover tasks as a JSON array of objects. Each entry returned by the discover operation will result in a collect task."""

    # HTTP Request
    HTTP = "http"
    # JSON Response
    JSON = "json"
    # Item List
    LIST = "list"
    # None
    NONE = "none"


class HealthCheckCollectMethodPostWithBodyHealthCheckDiscoveryDiscoverTypeListTypedDict(
    TypedDict
):
    discover_type: HealthCheckCollectMethodPostWithBodyHealthCheckDiscoveryDiscoverTypeListDiscoverType
    r"""Defines how task discovery will be performed. Use None to skip the discovery. Use HTTP Request to make a REST call to discover tasks. Use Item List to enumerate items for collect to retrieve. Use JSON Response to manually define discover tasks as a JSON array of objects. Each entry returned by the discover operation will result in a collect task."""
    item_list: List[str]
    r"""Comma-separated list of items to return from the Discover task. Each item returned will generate a collect task, and can be referenced using `${id}` in the collect URL, headers, or parameters."""


class HealthCheckCollectMethodPostWithBodyHealthCheckDiscoveryDiscoverTypeList(
    BaseModel
):
    discover_type: Annotated[
        HealthCheckCollectMethodPostWithBodyHealthCheckDiscoveryDiscoverTypeListDiscoverType,
        pydantic.Field(alias="discoverType"),
    ]
    r"""Defines how task discovery will be performed. Use None to skip the discovery. Use HTTP Request to make a REST call to discover tasks. Use Item List to enumerate items for collect to retrieve. Use JSON Response to manually define discover tasks as a JSON array of objects. Each entry returned by the discover operation will result in a collect task."""

    item_list: Annotated[List[str], pydantic.Field(alias="itemList")]
    r"""Comma-separated list of items to return from the Discover task. Each item returned will generate a collect task, and can be referenced using `${id}` in the collect URL, headers, or parameters."""

    @field_serializer("discover_type")
    def serialize_discover_type(self, value):
        if isinstance(value, str):
            try:
                return models.HealthCheckCollectMethodPostWithBodyHealthCheckDiscoveryDiscoverTypeListDiscoverType(
                    value
                )
            except ValueError:
                return value
        return value


class HealthCheckCollectMethodPostWithBodyHealthCheckDiscoveryDiscoverTypeJSONDiscoverType(
    str, Enum, metaclass=utils.OpenEnumMeta
):
    r"""Defines how task discovery will be performed. Use None to skip the discovery. Use HTTP Request to make a REST call to discover tasks. Use Item List to enumerate items for collect to retrieve. Use JSON Response to manually define discover tasks as a JSON array of objects. Each entry returned by the discover operation will result in a collect task."""

    # HTTP Request
    HTTP = "http"
    # JSON Response
    JSON = "json"
    # Item List
    LIST = "list"
    # None
    NONE = "none"


class HealthCheckCollectMethodPostWithBodyHealthCheckDiscoveryDiscoverTypeJSONTypedDict(
    TypedDict
):
    discover_type: HealthCheckCollectMethodPostWithBodyHealthCheckDiscoveryDiscoverTypeJSONDiscoverType
    r"""Defines how task discovery will be performed. Use None to skip the discovery. Use HTTP Request to make a REST call to discover tasks. Use Item List to enumerate items for collect to retrieve. Use JSON Response to manually define discover tasks as a JSON array of objects. Each entry returned by the discover operation will result in a collect task."""
    manual_discover_result: str
    r"""Allows hard-coding the Discover result. Must be a JSON object. Works with the Discover Data field."""
    discover_data_field: NotRequired[str]
    r"""Within the response JSON, name of the field or array element to pull results from. Leave blank if the result is an array of values. Sample entry: items, json: { items: [{id: 'first'},{id: 'second'}] }"""


class HealthCheckCollectMethodPostWithBodyHealthCheckDiscoveryDiscoverTypeJSON(
    BaseModel
):
    discover_type: Annotated[
        HealthCheckCollectMethodPostWithBodyHealthCheckDiscoveryDiscoverTypeJSONDiscoverType,
        pydantic.Field(alias="discoverType"),
    ]
    r"""Defines how task discovery will be performed. Use None to skip the discovery. Use HTTP Request to make a REST call to discover tasks. Use Item List to enumerate items for collect to retrieve. Use JSON Response to manually define discover tasks as a JSON array of objects. Each entry returned by the discover operation will result in a collect task."""

    manual_discover_result: Annotated[str, pydantic.Field(alias="manualDiscoverResult")]
    r"""Allows hard-coding the Discover result. Must be a JSON object. Works with the Discover Data field."""

    discover_data_field: Annotated[
        Optional[str], pydantic.Field(alias="discoverDataField")
    ] = None
    r"""Within the response JSON, name of the field or array element to pull results from. Leave blank if the result is an array of values. Sample entry: items, json: { items: [{id: 'first'},{id: 'second'}] }"""

    @field_serializer("discover_type")
    def serialize_discover_type(self, value):
        if isinstance(value, str):
            try:
                return models.HealthCheckCollectMethodPostWithBodyHealthCheckDiscoveryDiscoverTypeJSONDiscoverType(
                    value
                )
            except ValueError:
                return value
        return value

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(["discoverDataField"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


class HealthCheckCollectMethodPostWithBodyHealthCheckDiscoveryDiscoverTypeHTTPDiscoverMethodPostWithBodyDiscoverMethod(
    str, Enum, metaclass=utils.OpenEnumMeta
):
    r"""Discover HTTP method."""

    # GET
    GET = "get"
    # POST
    POST = "post"
    # POST with Body
    POST_WITH_BODY = "post_with_body"


class HealthCheckCollectMethodPostWithBodyHealthCheckDiscoveryDiscoverTypeHTTPDiscoverMethodPostWithBodyDiscoverType(
    str, Enum, metaclass=utils.OpenEnumMeta
):
    r"""Defines how task discovery will be performed. Use None to skip the discovery. Use HTTP Request to make a REST call to discover tasks. Use Item List to enumerate items for collect to retrieve. Use JSON Response to manually define discover tasks as a JSON array of objects. Each entry returned by the discover operation will result in a collect task."""

    # HTTP Request
    HTTP = "http"
    # JSON Response
    JSON = "json"
    # Item List
    LIST = "list"
    # None
    NONE = "none"


class HealthCheckCollectMethodPostWithBodyHealthCheckDiscoveryDiscoverTypeHTTPDiscoverMethodPostWithBodyTypedDict(
    TypedDict
):
    discover_method: HealthCheckCollectMethodPostWithBodyHealthCheckDiscoveryDiscoverTypeHTTPDiscoverMethodPostWithBodyDiscoverMethod
    r"""Discover HTTP method."""
    discover_type: HealthCheckCollectMethodPostWithBodyHealthCheckDiscoveryDiscoverTypeHTTPDiscoverMethodPostWithBodyDiscoverType
    r"""Defines how task discovery will be performed. Use None to skip the discovery. Use HTTP Request to make a REST call to discover tasks. Use Item List to enumerate items for collect to retrieve. Use JSON Response to manually define discover tasks as a JSON array of objects. Each entry returned by the discover operation will result in a collect task."""
    discover_url: str
    r"""Expression to derive URL to use for the Discover operation (can be a constant)."""
    discover_body: NotRequired[str]
    r"""Template for POST body to send with the discover request."""
    discover_request_headers: NotRequired[
        List[ItemsTypeHealthCheckAuthenticationLoginAuthRequestHeadersTypedDict]
    ]
    r"""Optional discover request headers."""
    discover_data_field: NotRequired[str]
    r"""Path to field in the response object which contains discover results (e.g.: level1.name), leave blank if the result is an array."""


class HealthCheckCollectMethodPostWithBodyHealthCheckDiscoveryDiscoverTypeHTTPDiscoverMethodPostWithBody(
    BaseModel
):
    discover_method: Annotated[
        HealthCheckCollectMethodPostWithBodyHealthCheckDiscoveryDiscoverTypeHTTPDiscoverMethodPostWithBodyDiscoverMethod,
        pydantic.Field(alias="discoverMethod"),
    ]
    r"""Discover HTTP method."""

    discover_type: Annotated[
        HealthCheckCollectMethodPostWithBodyHealthCheckDiscoveryDiscoverTypeHTTPDiscoverMethodPostWithBodyDiscoverType,
        pydantic.Field(alias="discoverType"),
    ]
    r"""Defines how task discovery will be performed. Use None to skip the discovery. Use HTTP Request to make a REST call to discover tasks. Use Item List to enumerate items for collect to retrieve. Use JSON Response to manually define discover tasks as a JSON array of objects. Each entry returned by the discover operation will result in a collect task."""

    discover_url: Annotated[str, pydantic.Field(alias="discoverUrl")]
    r"""Expression to derive URL to use for the Discover operation (can be a constant)."""

    discover_body: Annotated[Optional[str], pydantic.Field(alias="discoverBody")] = None
    r"""Template for POST body to send with the discover request."""

    discover_request_headers: Annotated[
        Optional[List[ItemsTypeHealthCheckAuthenticationLoginAuthRequestHeaders]],
        pydantic.Field(alias="discoverRequestHeaders"),
    ] = None
    r"""Optional discover request headers."""

    discover_data_field: Annotated[
        Optional[str], pydantic.Field(alias="discoverDataField")
    ] = None
    r"""Path to field in the response object which contains discover results (e.g.: level1.name), leave blank if the result is an array."""

    @field_serializer("discover_method")
    def serialize_discover_method(self, value):
        if isinstance(value, str):
            try:
                return models.HealthCheckCollectMethodPostWithBodyHealthCheckDiscoveryDiscoverTypeHTTPDiscoverMethodPostWithBodyDiscoverMethod(
                    value
                )
            except ValueError:
                return value
        return value

    @field_serializer("discover_type")
    def serialize_discover_type(self, value):
        if isinstance(value, str):
            try:
                return models.HealthCheckCollectMethodPostWithBodyHealthCheckDiscoveryDiscoverTypeHTTPDiscoverMethodPostWithBodyDiscoverType(
                    value
                )
            except ValueError:
                return value
        return value

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(
            ["discoverBody", "discoverRequestHeaders", "discoverDataField"]
        )
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


class HealthCheckCollectMethodPostWithBodyHealthCheckDiscoveryDiscoverTypeHTTPDiscoverMethodPostDiscoverMethod(
    str, Enum, metaclass=utils.OpenEnumMeta
):
    r"""Discover HTTP method."""

    # GET
    GET = "get"
    # POST
    POST = "post"
    # POST with Body
    POST_WITH_BODY = "post_with_body"


class HealthCheckCollectMethodPostWithBodyHealthCheckDiscoveryDiscoverTypeHTTPDiscoverMethodPostDiscoverType(
    str, Enum, metaclass=utils.OpenEnumMeta
):
    r"""Defines how task discovery will be performed. Use None to skip the discovery. Use HTTP Request to make a REST call to discover tasks. Use Item List to enumerate items for collect to retrieve. Use JSON Response to manually define discover tasks as a JSON array of objects. Each entry returned by the discover operation will result in a collect task."""

    # HTTP Request
    HTTP = "http"
    # JSON Response
    JSON = "json"
    # Item List
    LIST = "list"
    # None
    NONE = "none"


class HealthCheckCollectMethodPostWithBodyHealthCheckDiscoveryDiscoverTypeHTTPDiscoverMethodPostTypedDict(
    TypedDict
):
    discover_method: HealthCheckCollectMethodPostWithBodyHealthCheckDiscoveryDiscoverTypeHTTPDiscoverMethodPostDiscoverMethod
    r"""Discover HTTP method."""
    discover_type: HealthCheckCollectMethodPostWithBodyHealthCheckDiscoveryDiscoverTypeHTTPDiscoverMethodPostDiscoverType
    r"""Defines how task discovery will be performed. Use None to skip the discovery. Use HTTP Request to make a REST call to discover tasks. Use Item List to enumerate items for collect to retrieve. Use JSON Response to manually define discover tasks as a JSON array of objects. Each entry returned by the discover operation will result in a collect task."""
    discover_url: str
    r"""Expression to derive URL to use for the Discover operation (can be a constant)."""
    discover_request_params: NotRequired[
        List[ItemsTypeHealthCheckCollectMethodPostCollectRequestParamsTypedDict]
    ]
    r"""Optional discover request parameters."""
    discover_request_headers: NotRequired[
        List[ItemsTypeHealthCheckAuthenticationLoginAuthRequestHeadersTypedDict]
    ]
    r"""Optional discover request headers."""
    discover_data_field: NotRequired[str]
    r"""Path to field in the response object which contains discover results (e.g.: level1.name), leave blank if the result is an array."""


class HealthCheckCollectMethodPostWithBodyHealthCheckDiscoveryDiscoverTypeHTTPDiscoverMethodPost(
    BaseModel
):
    discover_method: Annotated[
        HealthCheckCollectMethodPostWithBodyHealthCheckDiscoveryDiscoverTypeHTTPDiscoverMethodPostDiscoverMethod,
        pydantic.Field(alias="discoverMethod"),
    ]
    r"""Discover HTTP method."""

    discover_type: Annotated[
        HealthCheckCollectMethodPostWithBodyHealthCheckDiscoveryDiscoverTypeHTTPDiscoverMethodPostDiscoverType,
        pydantic.Field(alias="discoverType"),
    ]
    r"""Defines how task discovery will be performed. Use None to skip the discovery. Use HTTP Request to make a REST call to discover tasks. Use Item List to enumerate items for collect to retrieve. Use JSON Response to manually define discover tasks as a JSON array of objects. Each entry returned by the discover operation will result in a collect task."""

    discover_url: Annotated[str, pydantic.Field(alias="discoverUrl")]
    r"""Expression to derive URL to use for the Discover operation (can be a constant)."""

    discover_request_params: Annotated[
        Optional[List[ItemsTypeHealthCheckCollectMethodPostCollectRequestParams]],
        pydantic.Field(alias="discoverRequestParams"),
    ] = None
    r"""Optional discover request parameters."""

    discover_request_headers: Annotated[
        Optional[List[ItemsTypeHealthCheckAuthenticationLoginAuthRequestHeaders]],
        pydantic.Field(alias="discoverRequestHeaders"),
    ] = None
    r"""Optional discover request headers."""

    discover_data_field: Annotated[
        Optional[str], pydantic.Field(alias="discoverDataField")
    ] = None
    r"""Path to field in the response object which contains discover results (e.g.: level1.name), leave blank if the result is an array."""

    @field_serializer("discover_method")
    def serialize_discover_method(self, value):
        if isinstance(value, str):
            try:
                return models.HealthCheckCollectMethodPostWithBodyHealthCheckDiscoveryDiscoverTypeHTTPDiscoverMethodPostDiscoverMethod(
                    value
                )
            except ValueError:
                return value
        return value

    @field_serializer("discover_type")
    def serialize_discover_type(self, value):
        if isinstance(value, str):
            try:
                return models.HealthCheckCollectMethodPostWithBodyHealthCheckDiscoveryDiscoverTypeHTTPDiscoverMethodPostDiscoverType(
                    value
                )
            except ValueError:
                return value
        return value

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(
            ["discoverRequestParams", "discoverRequestHeaders", "discoverDataField"]
        )
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


class HealthCheckCollectMethodPostWithBodyHealthCheckDiscoveryDiscoverTypeHTTPDiscoverMethodGetDiscoverMethod(
    str, Enum, metaclass=utils.OpenEnumMeta
):
    r"""Discover HTTP method."""

    # GET
    GET = "get"
    # POST
    POST = "post"
    # POST with Body
    POST_WITH_BODY = "post_with_body"


class HealthCheckCollectMethodPostWithBodyHealthCheckDiscoveryDiscoverTypeHTTPDiscoverMethodGetDiscoverType(
    str, Enum, metaclass=utils.OpenEnumMeta
):
    r"""Defines how task discovery will be performed. Use None to skip the discovery. Use HTTP Request to make a REST call to discover tasks. Use Item List to enumerate items for collect to retrieve. Use JSON Response to manually define discover tasks as a JSON array of objects. Each entry returned by the discover operation will result in a collect task."""

    # HTTP Request
    HTTP = "http"
    # JSON Response
    JSON = "json"
    # Item List
    LIST = "list"
    # None
    NONE = "none"


class HealthCheckCollectMethodPostWithBodyHealthCheckDiscoveryDiscoverTypeHTTPDiscoverMethodGetTypedDict(
    TypedDict
):
    discover_method: HealthCheckCollectMethodPostWithBodyHealthCheckDiscoveryDiscoverTypeHTTPDiscoverMethodGetDiscoverMethod
    r"""Discover HTTP method."""
    discover_type: HealthCheckCollectMethodPostWithBodyHealthCheckDiscoveryDiscoverTypeHTTPDiscoverMethodGetDiscoverType
    r"""Defines how task discovery will be performed. Use None to skip the discovery. Use HTTP Request to make a REST call to discover tasks. Use Item List to enumerate items for collect to retrieve. Use JSON Response to manually define discover tasks as a JSON array of objects. Each entry returned by the discover operation will result in a collect task."""
    discover_url: str
    r"""Expression to derive URL to use for the Discover operation (can be a constant)."""
    discover_request_params: NotRequired[
        List[ItemsTypeHealthCheckCollectMethodPostCollectRequestParamsTypedDict]
    ]
    r"""Optional discover request parameters."""
    discover_request_headers: NotRequired[
        List[ItemsTypeHealthCheckAuthenticationLoginAuthRequestHeadersTypedDict]
    ]
    r"""Optional discover request headers."""
    discover_data_field: NotRequired[str]
    r"""Path to field in the response object which contains discover results (e.g.: level1.name), leave blank if the result is an array."""


class HealthCheckCollectMethodPostWithBodyHealthCheckDiscoveryDiscoverTypeHTTPDiscoverMethodGet(
    BaseModel
):
    discover_method: Annotated[
        HealthCheckCollectMethodPostWithBodyHealthCheckDiscoveryDiscoverTypeHTTPDiscoverMethodGetDiscoverMethod,
        pydantic.Field(alias="discoverMethod"),
    ]
    r"""Discover HTTP method."""

    discover_type: Annotated[
        HealthCheckCollectMethodPostWithBodyHealthCheckDiscoveryDiscoverTypeHTTPDiscoverMethodGetDiscoverType,
        pydantic.Field(alias="discoverType"),
    ]
    r"""Defines how task discovery will be performed. Use None to skip the discovery. Use HTTP Request to make a REST call to discover tasks. Use Item List to enumerate items for collect to retrieve. Use JSON Response to manually define discover tasks as a JSON array of objects. Each entry returned by the discover operation will result in a collect task."""

    discover_url: Annotated[str, pydantic.Field(alias="discoverUrl")]
    r"""Expression to derive URL to use for the Discover operation (can be a constant)."""

    discover_request_params: Annotated[
        Optional[List[ItemsTypeHealthCheckCollectMethodPostCollectRequestParams]],
        pydantic.Field(alias="discoverRequestParams"),
    ] = None
    r"""Optional discover request parameters."""

    discover_request_headers: Annotated[
        Optional[List[ItemsTypeHealthCheckAuthenticationLoginAuthRequestHeaders]],
        pydantic.Field(alias="discoverRequestHeaders"),
    ] = None
    r"""Optional discover request headers."""

    discover_data_field: Annotated[
        Optional[str], pydantic.Field(alias="discoverDataField")
    ] = None
    r"""Path to field in the response object which contains discover results (e.g.: level1.name), leave blank if the result is an array."""

    @field_serializer("discover_method")
    def serialize_discover_method(self, value):
        if isinstance(value, str):
            try:
                return models.HealthCheckCollectMethodPostWithBodyHealthCheckDiscoveryDiscoverTypeHTTPDiscoverMethodGetDiscoverMethod(
                    value
                )
            except ValueError:
                return value
        return value

    @field_serializer("discover_type")
    def serialize_discover_type(self, value):
        if isinstance(value, str):
            try:
                return models.HealthCheckCollectMethodPostWithBodyHealthCheckDiscoveryDiscoverTypeHTTPDiscoverMethodGetDiscoverType(
                    value
                )
            except ValueError:
                return value
        return value

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(
            ["discoverRequestParams", "discoverRequestHeaders", "discoverDataField"]
        )
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


HealthCheckCollectMethodPostWithBodyHealthCheckDiscoveryDiscoverTypeHTTPTypedDict = TypeAliasType(
    "HealthCheckCollectMethodPostWithBodyHealthCheckDiscoveryDiscoverTypeHTTPTypedDict",
    Union[
        HealthCheckCollectMethodPostWithBodyHealthCheckDiscoveryDiscoverTypeHTTPDiscoverMethodGetTypedDict,
        HealthCheckCollectMethodPostWithBodyHealthCheckDiscoveryDiscoverTypeHTTPDiscoverMethodPostTypedDict,
        HealthCheckCollectMethodPostWithBodyHealthCheckDiscoveryDiscoverTypeHTTPDiscoverMethodPostWithBodyTypedDict,
    ],
)


class UnknownHealthCheckCollectMethodPostWithBodyHealthCheckDiscoveryDiscoverTypeHTTP(
    BaseModel
):
    r"""A HealthCheckCollectMethodPostWithBodyHealthCheckDiscoveryDiscoverTypeHTTP variant the SDK doesn't recognize. Preserves the raw payload."""

    discover_method: Literal["UNKNOWN"] = "UNKNOWN"
    raw: Any
    is_unknown: Literal[True] = True

    model_config = ConfigDict(frozen=True)


_HEALTH_CHECK_COLLECT_METHOD_POST_WITH_BODY_HEALTH_CHECK_DISCOVERY_DISCOVER_TYPE_HTTP_VARIANTS: dict[
    str, Any
] = {
    "get": HealthCheckCollectMethodPostWithBodyHealthCheckDiscoveryDiscoverTypeHTTPDiscoverMethodGet,
    "post": HealthCheckCollectMethodPostWithBodyHealthCheckDiscoveryDiscoverTypeHTTPDiscoverMethodPost,
    "post_with_body": HealthCheckCollectMethodPostWithBodyHealthCheckDiscoveryDiscoverTypeHTTPDiscoverMethodPostWithBody,
}


HealthCheckCollectMethodPostWithBodyHealthCheckDiscoveryDiscoverTypeHTTP = Annotated[
    Union[
        HealthCheckCollectMethodPostWithBodyHealthCheckDiscoveryDiscoverTypeHTTPDiscoverMethodGet,
        HealthCheckCollectMethodPostWithBodyHealthCheckDiscoveryDiscoverTypeHTTPDiscoverMethodPost,
        HealthCheckCollectMethodPostWithBodyHealthCheckDiscoveryDiscoverTypeHTTPDiscoverMethodPostWithBody,
        UnknownHealthCheckCollectMethodPostWithBodyHealthCheckDiscoveryDiscoverTypeHTTP,
    ],
    BeforeValidator(
        partial(
            parse_open_union,
            disc_key="discoverMethod",
            variants=_HEALTH_CHECK_COLLECT_METHOD_POST_WITH_BODY_HEALTH_CHECK_DISCOVERY_DISCOVER_TYPE_HTTP_VARIANTS,
            unknown_cls=UnknownHealthCheckCollectMethodPostWithBodyHealthCheckDiscoveryDiscoverTypeHTTP,
            union_name="HealthCheckCollectMethodPostWithBodyHealthCheckDiscoveryDiscoverTypeHTTP",
        )
    ),
]


HealthCheckCollectMethodPostWithBodyDiscoveryTypedDict = TypeAliasType(
    "HealthCheckCollectMethodPostWithBodyDiscoveryTypedDict",
    Union[
        HealthCheckCollectMethodPostWithBodyHealthCheckDiscoveryDiscoverTypeNoneTypedDict,
        HealthCheckCollectMethodPostWithBodyHealthCheckDiscoveryDiscoverTypeListTypedDict,
        HealthCheckCollectMethodPostWithBodyHealthCheckDiscoveryDiscoverTypeJSONTypedDict,
        HealthCheckCollectMethodPostWithBodyHealthCheckDiscoveryDiscoverTypeHTTPTypedDict,
    ],
)


class UnknownHealthCheckCollectMethodPostWithBodyDiscovery(BaseModel):
    r"""A HealthCheckCollectMethodPostWithBodyDiscovery variant the SDK doesn't recognize. Preserves the raw payload."""

    discover_type: Literal["UNKNOWN"] = "UNKNOWN"
    raw: Any
    is_unknown: Literal[True] = True

    model_config = ConfigDict(frozen=True)


_HEALTH_CHECK_COLLECT_METHOD_POST_WITH_BODY_DISCOVERY_VARIANTS: dict[str, Any] = {
    "http": HealthCheckCollectMethodPostWithBodyHealthCheckDiscoveryDiscoverTypeHTTP,
    "json": HealthCheckCollectMethodPostWithBodyHealthCheckDiscoveryDiscoverTypeJSON,
    "list": HealthCheckCollectMethodPostWithBodyHealthCheckDiscoveryDiscoverTypeList,
    "none": HealthCheckCollectMethodPostWithBodyHealthCheckDiscoveryDiscoverTypeNone,
}


HealthCheckCollectMethodPostWithBodyDiscovery = Annotated[
    Union[
        HealthCheckCollectMethodPostWithBodyHealthCheckDiscoveryDiscoverTypeHTTP,
        HealthCheckCollectMethodPostWithBodyHealthCheckDiscoveryDiscoverTypeJSON,
        HealthCheckCollectMethodPostWithBodyHealthCheckDiscoveryDiscoverTypeList,
        HealthCheckCollectMethodPostWithBodyHealthCheckDiscoveryDiscoverTypeNone,
        UnknownHealthCheckCollectMethodPostWithBodyDiscovery,
    ],
    BeforeValidator(
        partial(
            parse_open_union,
            disc_key="discoverType",
            variants=_HEALTH_CHECK_COLLECT_METHOD_POST_WITH_BODY_DISCOVERY_VARIANTS,
            unknown_cls=UnknownHealthCheckCollectMethodPostWithBodyDiscovery,
            union_name="HealthCheckCollectMethodPostWithBodyDiscovery",
        )
    ),
]


class HealthCheckCollectMethodPostWithBodyCollectRequestHeaderTypedDict(TypedDict):
    name: str
    r"""Header Name"""
    value: str
    r"""JavaScript expression to compute the header value (can be a constant)."""


class HealthCheckCollectMethodPostWithBodyCollectRequestHeader(BaseModel):
    name: str
    r"""Header Name"""

    value: str
    r"""JavaScript expression to compute the header value (can be a constant)."""


class HealthCheckCollectMethodPostWithBodyAuthentication(
    str, Enum, metaclass=utils.OpenEnumMeta
):
    r"""Authentication method for Discover and Collect REST calls. You can specify API Key–based authentication by adding the appropriate Collect headers."""

    NONE = "none"
    BASIC = "basic"
    BASIC_SECRET = "basicSecret"
    LOGIN = "login"
    LOGIN_SECRET = "loginSecret"
    OAUTH = "oauth"
    OAUTH_SECRET = "oauthSecret"


class HealthCheckCollectMethodPostWithBodyHealthCheckRetryRulesTypeBackoffTypedDict(
    TypedDict
):
    type: RetryTypeOptionsHealthCheckCollectorConfRetryRules
    r"""The algorithm to use when performing HTTP retries"""
    interval: NotRequired[float]
    r"""Time interval between failed request and first retry (kickoff). Maximum allowed value is 20,000 ms (1/3 minute)."""
    limit: NotRequired[float]
    r"""The maximum number of times to retry a failed HTTP request"""
    multiplier: NotRequired[float]
    r"""Base for exponential backoff, e.g., base 2 means that retries will occur after 2, then 4, then 8 seconds, and so on"""
    codes: NotRequired[List[float]]
    r"""List of HTTP codes that trigger a retry. Leave empty to use the default list of 429 and 503."""
    enable_header: NotRequired[bool]
    r"""Honor any Retry-After header that specifies a delay (in seconds) or a timestamp after which to retry the request. The delay is limited to 20 seconds, even if the Retry-After header specifies a longer delay. When disabled, all Retry-After headers are ignored."""


class HealthCheckCollectMethodPostWithBodyHealthCheckRetryRulesTypeBackoff(BaseModel):
    type: RetryTypeOptionsHealthCheckCollectorConfRetryRules
    r"""The algorithm to use when performing HTTP retries"""

    interval: Optional[float] = None
    r"""Time interval between failed request and first retry (kickoff). Maximum allowed value is 20,000 ms (1/3 minute)."""

    limit: Optional[float] = None
    r"""The maximum number of times to retry a failed HTTP request"""

    multiplier: Optional[float] = None
    r"""Base for exponential backoff, e.g., base 2 means that retries will occur after 2, then 4, then 8 seconds, and so on"""

    codes: Optional[List[float]] = None
    r"""List of HTTP codes that trigger a retry. Leave empty to use the default list of 429 and 503."""

    enable_header: Annotated[Optional[bool], pydantic.Field(alias="enableHeader")] = (
        None
    )
    r"""Honor any Retry-After header that specifies a delay (in seconds) or a timestamp after which to retry the request. The delay is limited to 20 seconds, even if the Retry-After header specifies a longer delay. When disabled, all Retry-After headers are ignored."""

    @field_serializer("type")
    def serialize_type(self, value):
        if isinstance(value, str):
            try:
                return models.RetryTypeOptionsHealthCheckCollectorConfRetryRules(value)
            except ValueError:
                return value
        return value

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(
            ["interval", "limit", "multiplier", "codes", "enableHeader"]
        )
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


class HealthCheckCollectMethodPostWithBodyHealthCheckRetryRulesTypeStaticTypedDict(
    TypedDict
):
    type: RetryTypeOptionsHealthCheckCollectorConfRetryRules
    r"""The algorithm to use when performing HTTP retries"""
    interval: NotRequired[float]
    r"""Time interval between retries. Maximum allowed value is 20,000 ms (1/3 minute)."""
    limit: NotRequired[float]
    r"""The maximum number of times to retry a failed HTTP request"""
    codes: NotRequired[List[float]]
    r"""List of HTTP codes that trigger a retry. Leave empty to use the default list of 429 and 503."""
    enable_header: NotRequired[bool]
    r"""Honor any Retry-After header that specifies a delay (in seconds) or a timestamp after which to retry the request. The delay is limited to 20 seconds, even if the Retry-After header specifies a longer delay. When disabled, all Retry-After headers are ignored."""


class HealthCheckCollectMethodPostWithBodyHealthCheckRetryRulesTypeStatic(BaseModel):
    type: RetryTypeOptionsHealthCheckCollectorConfRetryRules
    r"""The algorithm to use when performing HTTP retries"""

    interval: Optional[float] = None
    r"""Time interval between retries. Maximum allowed value is 20,000 ms (1/3 minute)."""

    limit: Optional[float] = None
    r"""The maximum number of times to retry a failed HTTP request"""

    codes: Optional[List[float]] = None
    r"""List of HTTP codes that trigger a retry. Leave empty to use the default list of 429 and 503."""

    enable_header: Annotated[Optional[bool], pydantic.Field(alias="enableHeader")] = (
        None
    )
    r"""Honor any Retry-After header that specifies a delay (in seconds) or a timestamp after which to retry the request. The delay is limited to 20 seconds, even if the Retry-After header specifies a longer delay. When disabled, all Retry-After headers are ignored."""

    @field_serializer("type")
    def serialize_type(self, value):
        if isinstance(value, str):
            try:
                return models.RetryTypeOptionsHealthCheckCollectorConfRetryRules(value)
            except ValueError:
                return value
        return value

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(["interval", "limit", "codes", "enableHeader"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


class HealthCheckCollectMethodPostWithBodyHealthCheckRetryRulesTypeNoneTypedDict(
    TypedDict
):
    type: RetryTypeOptionsHealthCheckCollectorConfRetryRules
    r"""The algorithm to use when performing HTTP retries"""


class HealthCheckCollectMethodPostWithBodyHealthCheckRetryRulesTypeNone(BaseModel):
    type: RetryTypeOptionsHealthCheckCollectorConfRetryRules
    r"""The algorithm to use when performing HTTP retries"""

    @field_serializer("type")
    def serialize_type(self, value):
        if isinstance(value, str):
            try:
                return models.RetryTypeOptionsHealthCheckCollectorConfRetryRules(value)
            except ValueError:
                return value
        return value


HealthCheckCollectMethodPostWithBodyRetryRulesTypedDict = TypeAliasType(
    "HealthCheckCollectMethodPostWithBodyRetryRulesTypedDict",
    Union[
        HealthCheckCollectMethodPostWithBodyHealthCheckRetryRulesTypeNoneTypedDict,
        HealthCheckCollectMethodPostWithBodyHealthCheckRetryRulesTypeStaticTypedDict,
        HealthCheckCollectMethodPostWithBodyHealthCheckRetryRulesTypeBackoffTypedDict,
    ],
)


class UnknownHealthCheckCollectMethodPostWithBodyRetryRules(BaseModel):
    r"""A HealthCheckCollectMethodPostWithBodyRetryRules variant the SDK doesn't recognize. Preserves the raw payload."""

    type: Literal["UNKNOWN"] = "UNKNOWN"
    raw: Any
    is_unknown: Literal[True] = True

    model_config = ConfigDict(frozen=True)


_HEALTH_CHECK_COLLECT_METHOD_POST_WITH_BODY_RETRY_RULES_VARIANTS: dict[str, Any] = {
    "none": HealthCheckCollectMethodPostWithBodyHealthCheckRetryRulesTypeNone,
    "static": HealthCheckCollectMethodPostWithBodyHealthCheckRetryRulesTypeStatic,
    "backoff": HealthCheckCollectMethodPostWithBodyHealthCheckRetryRulesTypeBackoff,
}


HealthCheckCollectMethodPostWithBodyRetryRules = Annotated[
    Union[
        HealthCheckCollectMethodPostWithBodyHealthCheckRetryRulesTypeNone,
        HealthCheckCollectMethodPostWithBodyHealthCheckRetryRulesTypeStatic,
        HealthCheckCollectMethodPostWithBodyHealthCheckRetryRulesTypeBackoff,
        UnknownHealthCheckCollectMethodPostWithBodyRetryRules,
    ],
    BeforeValidator(
        partial(
            parse_open_union,
            disc_key="type",
            variants=_HEALTH_CHECK_COLLECT_METHOD_POST_WITH_BODY_RETRY_RULES_VARIANTS,
            unknown_cls=UnknownHealthCheckCollectMethodPostWithBodyRetryRules,
            union_name="HealthCheckCollectMethodPostWithBodyRetryRules",
        )
    ),
]


class HealthCheckCollectMethodPostWithBodyTypedDict(TypedDict):
    collect_method: HealthCheckCollectMethodPostWithBodyHealthCheckMethod
    r"""Health check HTTP method."""
    collect_url: str
    r"""Expression to derive URL to use for the health check operation (can be a constant)."""
    authentication: HealthCheckCollectMethodPostWithBodyAuthentication
    r"""Authentication method for Discover and Collect REST calls. You can specify API Key–based authentication by adding the appropriate Collect headers."""
    collect_body: NotRequired[str]
    r"""Template for POST body to send with the health check request. You can reference parameters from the Discover response, using template params of the form: ${variable}."""
    discovery: NotRequired[HealthCheckCollectMethodPostWithBodyDiscoveryTypedDict]
    collect_request_headers: NotRequired[
        List[HealthCheckCollectMethodPostWithBodyCollectRequestHeaderTypedDict]
    ]
    r"""Optional health check request headers."""
    authenticate_collect: NotRequired[bool]
    r"""Enable to make auth health check call."""
    timeout: NotRequired[float]
    r"""HTTP request inactivity timeout, use 0 to disable"""
    reject_unauthorized: NotRequired[bool]
    r"""Whether to reject certificates that cannot be verified against a valid CA (e.g., self-signed certificates)."""
    default_breakers: NotRequired[HiddenDefaultBreakersOptionsDatabaseCollectorConf]
    safe_headers: NotRequired[List[str]]
    r"""List of headers that are safe to log in plain text."""
    retry_rules: NotRequired[HealthCheckCollectMethodPostWithBodyRetryRulesTypedDict]


class HealthCheckCollectMethodPostWithBody(BaseModel):
    collect_method: Annotated[
        HealthCheckCollectMethodPostWithBodyHealthCheckMethod,
        pydantic.Field(alias="collectMethod"),
    ]
    r"""Health check HTTP method."""

    collect_url: Annotated[str, pydantic.Field(alias="collectUrl")]
    r"""Expression to derive URL to use for the health check operation (can be a constant)."""

    authentication: HealthCheckCollectMethodPostWithBodyAuthentication
    r"""Authentication method for Discover and Collect REST calls. You can specify API Key–based authentication by adding the appropriate Collect headers."""

    collect_body: Annotated[Optional[str], pydantic.Field(alias="collectBody")] = None
    r"""Template for POST body to send with the health check request. You can reference parameters from the Discover response, using template params of the form: ${variable}."""

    discovery: Optional[HealthCheckCollectMethodPostWithBodyDiscovery] = None

    collect_request_headers: Annotated[
        Optional[List[HealthCheckCollectMethodPostWithBodyCollectRequestHeader]],
        pydantic.Field(alias="collectRequestHeaders"),
    ] = None
    r"""Optional health check request headers."""

    authenticate_collect: Annotated[
        Optional[bool], pydantic.Field(alias="authenticateCollect")
    ] = None
    r"""Enable to make auth health check call."""

    timeout: Optional[float] = None
    r"""HTTP request inactivity timeout, use 0 to disable"""

    reject_unauthorized: Annotated[
        Optional[bool], pydantic.Field(alias="rejectUnauthorized")
    ] = None
    r"""Whether to reject certificates that cannot be verified against a valid CA (e.g., self-signed certificates)."""

    default_breakers: Annotated[
        Optional[HiddenDefaultBreakersOptionsDatabaseCollectorConf],
        pydantic.Field(alias="defaultBreakers"),
    ] = None

    safe_headers: Annotated[
        Optional[List[str]], pydantic.Field(alias="safeHeaders")
    ] = None
    r"""List of headers that are safe to log in plain text."""

    retry_rules: Annotated[
        Optional[HealthCheckCollectMethodPostWithBodyRetryRules],
        pydantic.Field(alias="retryRules"),
    ] = None

    @field_serializer("collect_method")
    def serialize_collect_method(self, value):
        if isinstance(value, str):
            try:
                return models.HealthCheckCollectMethodPostWithBodyHealthCheckMethod(
                    value
                )
            except ValueError:
                return value
        return value

    @field_serializer("authentication")
    def serialize_authentication(self, value):
        if isinstance(value, str):
            try:
                return models.HealthCheckCollectMethodPostWithBodyAuthentication(value)
            except ValueError:
                return value
        return value

    @field_serializer("default_breakers")
    def serialize_default_breakers(self, value):
        if isinstance(value, str):
            try:
                return models.HiddenDefaultBreakersOptionsDatabaseCollectorConf(value)
            except ValueError:
                return value
        return value

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(
            [
                "collectBody",
                "discovery",
                "collectRequestHeaders",
                "authenticateCollect",
                "timeout",
                "rejectUnauthorized",
                "defaultBreakers",
                "safeHeaders",
                "retryRules",
            ]
        )
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


class HealthCheckCollectMethodPostHealthCheckMethod(
    str, Enum, metaclass=utils.OpenEnumMeta
):
    r"""Health check HTTP method."""

    # GET
    GET = "get"
    # POST
    POST = "post"
    # POST with Body
    POST_WITH_BODY = "post_with_body"


class HealthCheckCollectMethodPostHealthCheckDiscoveryDiscoverTypeNoneDiscoverType(
    str, Enum, metaclass=utils.OpenEnumMeta
):
    r"""Defines how task discovery will be performed. Use None to skip the discovery. Use HTTP Request to make a REST call to discover tasks. Use Item List to enumerate items for collect to retrieve. Use JSON Response to manually define discover tasks as a JSON array of objects. Each entry returned by the discover operation will result in a collect task."""

    # HTTP Request
    HTTP = "http"
    # JSON Response
    JSON = "json"
    # Item List
    LIST = "list"
    # None
    NONE = "none"


class HealthCheckCollectMethodPostHealthCheckDiscoveryDiscoverTypeNoneTypedDict(
    TypedDict
):
    discover_type: (
        HealthCheckCollectMethodPostHealthCheckDiscoveryDiscoverTypeNoneDiscoverType
    )
    r"""Defines how task discovery will be performed. Use None to skip the discovery. Use HTTP Request to make a REST call to discover tasks. Use Item List to enumerate items for collect to retrieve. Use JSON Response to manually define discover tasks as a JSON array of objects. Each entry returned by the discover operation will result in a collect task."""


class HealthCheckCollectMethodPostHealthCheckDiscoveryDiscoverTypeNone(BaseModel):
    discover_type: Annotated[
        HealthCheckCollectMethodPostHealthCheckDiscoveryDiscoverTypeNoneDiscoverType,
        pydantic.Field(alias="discoverType"),
    ]
    r"""Defines how task discovery will be performed. Use None to skip the discovery. Use HTTP Request to make a REST call to discover tasks. Use Item List to enumerate items for collect to retrieve. Use JSON Response to manually define discover tasks as a JSON array of objects. Each entry returned by the discover operation will result in a collect task."""

    @field_serializer("discover_type")
    def serialize_discover_type(self, value):
        if isinstance(value, str):
            try:
                return models.HealthCheckCollectMethodPostHealthCheckDiscoveryDiscoverTypeNoneDiscoverType(
                    value
                )
            except ValueError:
                return value
        return value


class HealthCheckCollectMethodPostHealthCheckDiscoveryDiscoverTypeListDiscoverType(
    str, Enum, metaclass=utils.OpenEnumMeta
):
    r"""Defines how task discovery will be performed. Use None to skip the discovery. Use HTTP Request to make a REST call to discover tasks. Use Item List to enumerate items for collect to retrieve. Use JSON Response to manually define discover tasks as a JSON array of objects. Each entry returned by the discover operation will result in a collect task."""

    # HTTP Request
    HTTP = "http"
    # JSON Response
    JSON = "json"
    # Item List
    LIST = "list"
    # None
    NONE = "none"


class HealthCheckCollectMethodPostHealthCheckDiscoveryDiscoverTypeListTypedDict(
    TypedDict
):
    discover_type: (
        HealthCheckCollectMethodPostHealthCheckDiscoveryDiscoverTypeListDiscoverType
    )
    r"""Defines how task discovery will be performed. Use None to skip the discovery. Use HTTP Request to make a REST call to discover tasks. Use Item List to enumerate items for collect to retrieve. Use JSON Response to manually define discover tasks as a JSON array of objects. Each entry returned by the discover operation will result in a collect task."""
    item_list: List[str]
    r"""Comma-separated list of items to return from the Discover task. Each item returned will generate a collect task, and can be referenced using `${id}` in the collect URL, headers, or parameters."""


class HealthCheckCollectMethodPostHealthCheckDiscoveryDiscoverTypeList(BaseModel):
    discover_type: Annotated[
        HealthCheckCollectMethodPostHealthCheckDiscoveryDiscoverTypeListDiscoverType,
        pydantic.Field(alias="discoverType"),
    ]
    r"""Defines how task discovery will be performed. Use None to skip the discovery. Use HTTP Request to make a REST call to discover tasks. Use Item List to enumerate items for collect to retrieve. Use JSON Response to manually define discover tasks as a JSON array of objects. Each entry returned by the discover operation will result in a collect task."""

    item_list: Annotated[List[str], pydantic.Field(alias="itemList")]
    r"""Comma-separated list of items to return from the Discover task. Each item returned will generate a collect task, and can be referenced using `${id}` in the collect URL, headers, or parameters."""

    @field_serializer("discover_type")
    def serialize_discover_type(self, value):
        if isinstance(value, str):
            try:
                return models.HealthCheckCollectMethodPostHealthCheckDiscoveryDiscoverTypeListDiscoverType(
                    value
                )
            except ValueError:
                return value
        return value


class HealthCheckCollectMethodPostHealthCheckDiscoveryDiscoverTypeJSONDiscoverType(
    str, Enum, metaclass=utils.OpenEnumMeta
):
    r"""Defines how task discovery will be performed. Use None to skip the discovery. Use HTTP Request to make a REST call to discover tasks. Use Item List to enumerate items for collect to retrieve. Use JSON Response to manually define discover tasks as a JSON array of objects. Each entry returned by the discover operation will result in a collect task."""

    # HTTP Request
    HTTP = "http"
    # JSON Response
    JSON = "json"
    # Item List
    LIST = "list"
    # None
    NONE = "none"


class HealthCheckCollectMethodPostHealthCheckDiscoveryDiscoverTypeJSONTypedDict(
    TypedDict
):
    discover_type: (
        HealthCheckCollectMethodPostHealthCheckDiscoveryDiscoverTypeJSONDiscoverType
    )
    r"""Defines how task discovery will be performed. Use None to skip the discovery. Use HTTP Request to make a REST call to discover tasks. Use Item List to enumerate items for collect to retrieve. Use JSON Response to manually define discover tasks as a JSON array of objects. Each entry returned by the discover operation will result in a collect task."""
    manual_discover_result: str
    r"""Allows hard-coding the Discover result. Must be a JSON object. Works with the Discover Data field."""
    discover_data_field: NotRequired[str]
    r"""Within the response JSON, name of the field or array element to pull results from. Leave blank if the result is an array of values. Sample entry: items, json: { items: [{id: 'first'},{id: 'second'}] }"""


class HealthCheckCollectMethodPostHealthCheckDiscoveryDiscoverTypeJSON(BaseModel):
    discover_type: Annotated[
        HealthCheckCollectMethodPostHealthCheckDiscoveryDiscoverTypeJSONDiscoverType,
        pydantic.Field(alias="discoverType"),
    ]
    r"""Defines how task discovery will be performed. Use None to skip the discovery. Use HTTP Request to make a REST call to discover tasks. Use Item List to enumerate items for collect to retrieve. Use JSON Response to manually define discover tasks as a JSON array of objects. Each entry returned by the discover operation will result in a collect task."""

    manual_discover_result: Annotated[str, pydantic.Field(alias="manualDiscoverResult")]
    r"""Allows hard-coding the Discover result. Must be a JSON object. Works with the Discover Data field."""

    discover_data_field: Annotated[
        Optional[str], pydantic.Field(alias="discoverDataField")
    ] = None
    r"""Within the response JSON, name of the field or array element to pull results from. Leave blank if the result is an array of values. Sample entry: items, json: { items: [{id: 'first'},{id: 'second'}] }"""

    @field_serializer("discover_type")
    def serialize_discover_type(self, value):
        if isinstance(value, str):
            try:
                return models.HealthCheckCollectMethodPostHealthCheckDiscoveryDiscoverTypeJSONDiscoverType(
                    value
                )
            except ValueError:
                return value
        return value

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(["discoverDataField"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


class HealthCheckCollectMethodPostHealthCheckDiscoveryDiscoverTypeHTTPDiscoverMethodPostWithBodyDiscoverMethod(
    str, Enum, metaclass=utils.OpenEnumMeta
):
    r"""Discover HTTP method."""

    # GET
    GET = "get"
    # POST
    POST = "post"
    # POST with Body
    POST_WITH_BODY = "post_with_body"


class HealthCheckCollectMethodPostHealthCheckDiscoveryDiscoverTypeHTTPDiscoverMethodPostWithBodyDiscoverType(
    str, Enum, metaclass=utils.OpenEnumMeta
):
    r"""Defines how task discovery will be performed. Use None to skip the discovery. Use HTTP Request to make a REST call to discover tasks. Use Item List to enumerate items for collect to retrieve. Use JSON Response to manually define discover tasks as a JSON array of objects. Each entry returned by the discover operation will result in a collect task."""

    # HTTP Request
    HTTP = "http"
    # JSON Response
    JSON = "json"
    # Item List
    LIST = "list"
    # None
    NONE = "none"


class HealthCheckCollectMethodPostHealthCheckDiscoveryDiscoverTypeHTTPDiscoverMethodPostWithBodyTypedDict(
    TypedDict
):
    discover_method: HealthCheckCollectMethodPostHealthCheckDiscoveryDiscoverTypeHTTPDiscoverMethodPostWithBodyDiscoverMethod
    r"""Discover HTTP method."""
    discover_type: HealthCheckCollectMethodPostHealthCheckDiscoveryDiscoverTypeHTTPDiscoverMethodPostWithBodyDiscoverType
    r"""Defines how task discovery will be performed. Use None to skip the discovery. Use HTTP Request to make a REST call to discover tasks. Use Item List to enumerate items for collect to retrieve. Use JSON Response to manually define discover tasks as a JSON array of objects. Each entry returned by the discover operation will result in a collect task."""
    discover_url: str
    r"""Expression to derive URL to use for the Discover operation (can be a constant)."""
    discover_body: NotRequired[str]
    r"""Template for POST body to send with the discover request."""
    discover_request_headers: NotRequired[
        List[ItemsTypeHealthCheckAuthenticationLoginAuthRequestHeadersTypedDict]
    ]
    r"""Optional discover request headers."""
    discover_data_field: NotRequired[str]
    r"""Path to field in the response object which contains discover results (e.g.: level1.name), leave blank if the result is an array."""


class HealthCheckCollectMethodPostHealthCheckDiscoveryDiscoverTypeHTTPDiscoverMethodPostWithBody(
    BaseModel
):
    discover_method: Annotated[
        HealthCheckCollectMethodPostHealthCheckDiscoveryDiscoverTypeHTTPDiscoverMethodPostWithBodyDiscoverMethod,
        pydantic.Field(alias="discoverMethod"),
    ]
    r"""Discover HTTP method."""

    discover_type: Annotated[
        HealthCheckCollectMethodPostHealthCheckDiscoveryDiscoverTypeHTTPDiscoverMethodPostWithBodyDiscoverType,
        pydantic.Field(alias="discoverType"),
    ]
    r"""Defines how task discovery will be performed. Use None to skip the discovery. Use HTTP Request to make a REST call to discover tasks. Use Item List to enumerate items for collect to retrieve. Use JSON Response to manually define discover tasks as a JSON array of objects. Each entry returned by the discover operation will result in a collect task."""

    discover_url: Annotated[str, pydantic.Field(alias="discoverUrl")]
    r"""Expression to derive URL to use for the Discover operation (can be a constant)."""

    discover_body: Annotated[Optional[str], pydantic.Field(alias="discoverBody")] = None
    r"""Template for POST body to send with the discover request."""

    discover_request_headers: Annotated[
        Optional[List[ItemsTypeHealthCheckAuthenticationLoginAuthRequestHeaders]],
        pydantic.Field(alias="discoverRequestHeaders"),
    ] = None
    r"""Optional discover request headers."""

    discover_data_field: Annotated[
        Optional[str], pydantic.Field(alias="discoverDataField")
    ] = None
    r"""Path to field in the response object which contains discover results (e.g.: level1.name), leave blank if the result is an array."""

    @field_serializer("discover_method")
    def serialize_discover_method(self, value):
        if isinstance(value, str):
            try:
                return models.HealthCheckCollectMethodPostHealthCheckDiscoveryDiscoverTypeHTTPDiscoverMethodPostWithBodyDiscoverMethod(
                    value
                )
            except ValueError:
                return value
        return value

    @field_serializer("discover_type")
    def serialize_discover_type(self, value):
        if isinstance(value, str):
            try:
                return models.HealthCheckCollectMethodPostHealthCheckDiscoveryDiscoverTypeHTTPDiscoverMethodPostWithBodyDiscoverType(
                    value
                )
            except ValueError:
                return value
        return value

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(
            ["discoverBody", "discoverRequestHeaders", "discoverDataField"]
        )
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


class HealthCheckCollectMethodPostHealthCheckDiscoveryDiscoverTypeHTTPDiscoverMethodPostDiscoverMethod(
    str, Enum, metaclass=utils.OpenEnumMeta
):
    r"""Discover HTTP method."""

    # GET
    GET = "get"
    # POST
    POST = "post"
    # POST with Body
    POST_WITH_BODY = "post_with_body"


class HealthCheckCollectMethodPostHealthCheckDiscoveryDiscoverTypeHTTPDiscoverMethodPostDiscoverType(
    str, Enum, metaclass=utils.OpenEnumMeta
):
    r"""Defines how task discovery will be performed. Use None to skip the discovery. Use HTTP Request to make a REST call to discover tasks. Use Item List to enumerate items for collect to retrieve. Use JSON Response to manually define discover tasks as a JSON array of objects. Each entry returned by the discover operation will result in a collect task."""

    # HTTP Request
    HTTP = "http"
    # JSON Response
    JSON = "json"
    # Item List
    LIST = "list"
    # None
    NONE = "none"


class HealthCheckCollectMethodPostHealthCheckDiscoveryDiscoverTypeHTTPDiscoverMethodPostTypedDict(
    TypedDict
):
    discover_method: HealthCheckCollectMethodPostHealthCheckDiscoveryDiscoverTypeHTTPDiscoverMethodPostDiscoverMethod
    r"""Discover HTTP method."""
    discover_type: HealthCheckCollectMethodPostHealthCheckDiscoveryDiscoverTypeHTTPDiscoverMethodPostDiscoverType
    r"""Defines how task discovery will be performed. Use None to skip the discovery. Use HTTP Request to make a REST call to discover tasks. Use Item List to enumerate items for collect to retrieve. Use JSON Response to manually define discover tasks as a JSON array of objects. Each entry returned by the discover operation will result in a collect task."""
    discover_url: str
    r"""Expression to derive URL to use for the Discover operation (can be a constant)."""
    discover_request_params: NotRequired[
        List[ItemsTypeHealthCheckCollectMethodPostCollectRequestParamsTypedDict]
    ]
    r"""Optional discover request parameters."""
    discover_request_headers: NotRequired[
        List[ItemsTypeHealthCheckAuthenticationLoginAuthRequestHeadersTypedDict]
    ]
    r"""Optional discover request headers."""
    discover_data_field: NotRequired[str]
    r"""Path to field in the response object which contains discover results (e.g.: level1.name), leave blank if the result is an array."""


class HealthCheckCollectMethodPostHealthCheckDiscoveryDiscoverTypeHTTPDiscoverMethodPost(
    BaseModel
):
    discover_method: Annotated[
        HealthCheckCollectMethodPostHealthCheckDiscoveryDiscoverTypeHTTPDiscoverMethodPostDiscoverMethod,
        pydantic.Field(alias="discoverMethod"),
    ]
    r"""Discover HTTP method."""

    discover_type: Annotated[
        HealthCheckCollectMethodPostHealthCheckDiscoveryDiscoverTypeHTTPDiscoverMethodPostDiscoverType,
        pydantic.Field(alias="discoverType"),
    ]
    r"""Defines how task discovery will be performed. Use None to skip the discovery. Use HTTP Request to make a REST call to discover tasks. Use Item List to enumerate items for collect to retrieve. Use JSON Response to manually define discover tasks as a JSON array of objects. Each entry returned by the discover operation will result in a collect task."""

    discover_url: Annotated[str, pydantic.Field(alias="discoverUrl")]
    r"""Expression to derive URL to use for the Discover operation (can be a constant)."""

    discover_request_params: Annotated[
        Optional[List[ItemsTypeHealthCheckCollectMethodPostCollectRequestParams]],
        pydantic.Field(alias="discoverRequestParams"),
    ] = None
    r"""Optional discover request parameters."""

    discover_request_headers: Annotated[
        Optional[List[ItemsTypeHealthCheckAuthenticationLoginAuthRequestHeaders]],
        pydantic.Field(alias="discoverRequestHeaders"),
    ] = None
    r"""Optional discover request headers."""

    discover_data_field: Annotated[
        Optional[str], pydantic.Field(alias="discoverDataField")
    ] = None
    r"""Path to field in the response object which contains discover results (e.g.: level1.name), leave blank if the result is an array."""

    @field_serializer("discover_method")
    def serialize_discover_method(self, value):
        if isinstance(value, str):
            try:
                return models.HealthCheckCollectMethodPostHealthCheckDiscoveryDiscoverTypeHTTPDiscoverMethodPostDiscoverMethod(
                    value
                )
            except ValueError:
                return value
        return value

    @field_serializer("discover_type")
    def serialize_discover_type(self, value):
        if isinstance(value, str):
            try:
                return models.HealthCheckCollectMethodPostHealthCheckDiscoveryDiscoverTypeHTTPDiscoverMethodPostDiscoverType(
                    value
                )
            except ValueError:
                return value
        return value

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(
            ["discoverRequestParams", "discoverRequestHeaders", "discoverDataField"]
        )
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


class HealthCheckCollectMethodPostHealthCheckDiscoveryDiscoverTypeHTTPDiscoverMethodGetDiscoverMethod(
    str, Enum, metaclass=utils.OpenEnumMeta
):
    r"""Discover HTTP method."""

    # GET
    GET = "get"
    # POST
    POST = "post"
    # POST with Body
    POST_WITH_BODY = "post_with_body"


class HealthCheckCollectMethodPostHealthCheckDiscoveryDiscoverTypeHTTPDiscoverMethodGetDiscoverType(
    str, Enum, metaclass=utils.OpenEnumMeta
):
    r"""Defines how task discovery will be performed. Use None to skip the discovery. Use HTTP Request to make a REST call to discover tasks. Use Item List to enumerate items for collect to retrieve. Use JSON Response to manually define discover tasks as a JSON array of objects. Each entry returned by the discover operation will result in a collect task."""

    # HTTP Request
    HTTP = "http"
    # JSON Response
    JSON = "json"
    # Item List
    LIST = "list"
    # None
    NONE = "none"


class HealthCheckCollectMethodPostHealthCheckDiscoveryDiscoverTypeHTTPDiscoverMethodGetTypedDict(
    TypedDict
):
    discover_method: HealthCheckCollectMethodPostHealthCheckDiscoveryDiscoverTypeHTTPDiscoverMethodGetDiscoverMethod
    r"""Discover HTTP method."""
    discover_type: HealthCheckCollectMethodPostHealthCheckDiscoveryDiscoverTypeHTTPDiscoverMethodGetDiscoverType
    r"""Defines how task discovery will be performed. Use None to skip the discovery. Use HTTP Request to make a REST call to discover tasks. Use Item List to enumerate items for collect to retrieve. Use JSON Response to manually define discover tasks as a JSON array of objects. Each entry returned by the discover operation will result in a collect task."""
    discover_url: str
    r"""Expression to derive URL to use for the Discover operation (can be a constant)."""
    discover_request_params: NotRequired[
        List[ItemsTypeHealthCheckCollectMethodPostCollectRequestParamsTypedDict]
    ]
    r"""Optional discover request parameters."""
    discover_request_headers: NotRequired[
        List[ItemsTypeHealthCheckAuthenticationLoginAuthRequestHeadersTypedDict]
    ]
    r"""Optional discover request headers."""
    discover_data_field: NotRequired[str]
    r"""Path to field in the response object which contains discover results (e.g.: level1.name), leave blank if the result is an array."""


class HealthCheckCollectMethodPostHealthCheckDiscoveryDiscoverTypeHTTPDiscoverMethodGet(
    BaseModel
):
    discover_method: Annotated[
        HealthCheckCollectMethodPostHealthCheckDiscoveryDiscoverTypeHTTPDiscoverMethodGetDiscoverMethod,
        pydantic.Field(alias="discoverMethod"),
    ]
    r"""Discover HTTP method."""

    discover_type: Annotated[
        HealthCheckCollectMethodPostHealthCheckDiscoveryDiscoverTypeHTTPDiscoverMethodGetDiscoverType,
        pydantic.Field(alias="discoverType"),
    ]
    r"""Defines how task discovery will be performed. Use None to skip the discovery. Use HTTP Request to make a REST call to discover tasks. Use Item List to enumerate items for collect to retrieve. Use JSON Response to manually define discover tasks as a JSON array of objects. Each entry returned by the discover operation will result in a collect task."""

    discover_url: Annotated[str, pydantic.Field(alias="discoverUrl")]
    r"""Expression to derive URL to use for the Discover operation (can be a constant)."""

    discover_request_params: Annotated[
        Optional[List[ItemsTypeHealthCheckCollectMethodPostCollectRequestParams]],
        pydantic.Field(alias="discoverRequestParams"),
    ] = None
    r"""Optional discover request parameters."""

    discover_request_headers: Annotated[
        Optional[List[ItemsTypeHealthCheckAuthenticationLoginAuthRequestHeaders]],
        pydantic.Field(alias="discoverRequestHeaders"),
    ] = None
    r"""Optional discover request headers."""

    discover_data_field: Annotated[
        Optional[str], pydantic.Field(alias="discoverDataField")
    ] = None
    r"""Path to field in the response object which contains discover results (e.g.: level1.name), leave blank if the result is an array."""

    @field_serializer("discover_method")
    def serialize_discover_method(self, value):
        if isinstance(value, str):
            try:
                return models.HealthCheckCollectMethodPostHealthCheckDiscoveryDiscoverTypeHTTPDiscoverMethodGetDiscoverMethod(
                    value
                )
            except ValueError:
                return value
        return value

    @field_serializer("discover_type")
    def serialize_discover_type(self, value):
        if isinstance(value, str):
            try:
                return models.HealthCheckCollectMethodPostHealthCheckDiscoveryDiscoverTypeHTTPDiscoverMethodGetDiscoverType(
                    value
                )
            except ValueError:
                return value
        return value

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(
            ["discoverRequestParams", "discoverRequestHeaders", "discoverDataField"]
        )
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


HealthCheckCollectMethodPostHealthCheckDiscoveryDiscoverTypeHTTPTypedDict = TypeAliasType(
    "HealthCheckCollectMethodPostHealthCheckDiscoveryDiscoverTypeHTTPTypedDict",
    Union[
        HealthCheckCollectMethodPostHealthCheckDiscoveryDiscoverTypeHTTPDiscoverMethodGetTypedDict,
        HealthCheckCollectMethodPostHealthCheckDiscoveryDiscoverTypeHTTPDiscoverMethodPostTypedDict,
        HealthCheckCollectMethodPostHealthCheckDiscoveryDiscoverTypeHTTPDiscoverMethodPostWithBodyTypedDict,
    ],
)


class UnknownHealthCheckCollectMethodPostHealthCheckDiscoveryDiscoverTypeHTTP(
    BaseModel
):
    r"""A HealthCheckCollectMethodPostHealthCheckDiscoveryDiscoverTypeHTTP variant the SDK doesn't recognize. Preserves the raw payload."""

    discover_method: Literal["UNKNOWN"] = "UNKNOWN"
    raw: Any
    is_unknown: Literal[True] = True

    model_config = ConfigDict(frozen=True)


_HEALTH_CHECK_COLLECT_METHOD_POST_HEALTH_CHECK_DISCOVERY_DISCOVER_TYPE_HTTP_VARIANTS: dict[
    str, Any
] = {
    "get": HealthCheckCollectMethodPostHealthCheckDiscoveryDiscoverTypeHTTPDiscoverMethodGet,
    "post": HealthCheckCollectMethodPostHealthCheckDiscoveryDiscoverTypeHTTPDiscoverMethodPost,
    "post_with_body": HealthCheckCollectMethodPostHealthCheckDiscoveryDiscoverTypeHTTPDiscoverMethodPostWithBody,
}


HealthCheckCollectMethodPostHealthCheckDiscoveryDiscoverTypeHTTP = Annotated[
    Union[
        HealthCheckCollectMethodPostHealthCheckDiscoveryDiscoverTypeHTTPDiscoverMethodGet,
        HealthCheckCollectMethodPostHealthCheckDiscoveryDiscoverTypeHTTPDiscoverMethodPost,
        HealthCheckCollectMethodPostHealthCheckDiscoveryDiscoverTypeHTTPDiscoverMethodPostWithBody,
        UnknownHealthCheckCollectMethodPostHealthCheckDiscoveryDiscoverTypeHTTP,
    ],
    BeforeValidator(
        partial(
            parse_open_union,
            disc_key="discoverMethod",
            variants=_HEALTH_CHECK_COLLECT_METHOD_POST_HEALTH_CHECK_DISCOVERY_DISCOVER_TYPE_HTTP_VARIANTS,
            unknown_cls=UnknownHealthCheckCollectMethodPostHealthCheckDiscoveryDiscoverTypeHTTP,
            union_name="HealthCheckCollectMethodPostHealthCheckDiscoveryDiscoverTypeHTTP",
        )
    ),
]


HealthCheckCollectMethodPostDiscoveryTypedDict = TypeAliasType(
    "HealthCheckCollectMethodPostDiscoveryTypedDict",
    Union[
        HealthCheckCollectMethodPostHealthCheckDiscoveryDiscoverTypeNoneTypedDict,
        HealthCheckCollectMethodPostHealthCheckDiscoveryDiscoverTypeListTypedDict,
        HealthCheckCollectMethodPostHealthCheckDiscoveryDiscoverTypeJSONTypedDict,
        HealthCheckCollectMethodPostHealthCheckDiscoveryDiscoverTypeHTTPTypedDict,
    ],
)


class UnknownHealthCheckCollectMethodPostDiscovery(BaseModel):
    r"""A HealthCheckCollectMethodPostDiscovery variant the SDK doesn't recognize. Preserves the raw payload."""

    discover_type: Literal["UNKNOWN"] = "UNKNOWN"
    raw: Any
    is_unknown: Literal[True] = True

    model_config = ConfigDict(frozen=True)


_HEALTH_CHECK_COLLECT_METHOD_POST_DISCOVERY_VARIANTS: dict[str, Any] = {
    "http": HealthCheckCollectMethodPostHealthCheckDiscoveryDiscoverTypeHTTP,
    "json": HealthCheckCollectMethodPostHealthCheckDiscoveryDiscoverTypeJSON,
    "list": HealthCheckCollectMethodPostHealthCheckDiscoveryDiscoverTypeList,
    "none": HealthCheckCollectMethodPostHealthCheckDiscoveryDiscoverTypeNone,
}


HealthCheckCollectMethodPostDiscovery = Annotated[
    Union[
        HealthCheckCollectMethodPostHealthCheckDiscoveryDiscoverTypeHTTP,
        HealthCheckCollectMethodPostHealthCheckDiscoveryDiscoverTypeJSON,
        HealthCheckCollectMethodPostHealthCheckDiscoveryDiscoverTypeList,
        HealthCheckCollectMethodPostHealthCheckDiscoveryDiscoverTypeNone,
        UnknownHealthCheckCollectMethodPostDiscovery,
    ],
    BeforeValidator(
        partial(
            parse_open_union,
            disc_key="discoverType",
            variants=_HEALTH_CHECK_COLLECT_METHOD_POST_DISCOVERY_VARIANTS,
            unknown_cls=UnknownHealthCheckCollectMethodPostDiscovery,
            union_name="HealthCheckCollectMethodPostDiscovery",
        )
    ),
]


class HealthCheckCollectMethodPostCollectRequestHeaderTypedDict(TypedDict):
    name: str
    r"""Header Name"""
    value: str
    r"""JavaScript expression to compute the header value (can be a constant)."""


class HealthCheckCollectMethodPostCollectRequestHeader(BaseModel):
    name: str
    r"""Header Name"""

    value: str
    r"""JavaScript expression to compute the header value (can be a constant)."""


class HealthCheckCollectMethodPostAuthentication(
    str, Enum, metaclass=utils.OpenEnumMeta
):
    r"""Authentication method for Discover and Collect REST calls. You can specify API Key–based authentication by adding the appropriate Collect headers."""

    NONE = "none"
    BASIC = "basic"
    BASIC_SECRET = "basicSecret"
    LOGIN = "login"
    LOGIN_SECRET = "loginSecret"
    OAUTH = "oauth"
    OAUTH_SECRET = "oauthSecret"


class HealthCheckCollectMethodPostHealthCheckRetryRulesTypeBackoffTypedDict(TypedDict):
    type: RetryTypeOptionsHealthCheckCollectorConfRetryRules
    r"""The algorithm to use when performing HTTP retries"""
    interval: NotRequired[float]
    r"""Time interval between failed request and first retry (kickoff). Maximum allowed value is 20,000 ms (1/3 minute)."""
    limit: NotRequired[float]
    r"""The maximum number of times to retry a failed HTTP request"""
    multiplier: NotRequired[float]
    r"""Base for exponential backoff, e.g., base 2 means that retries will occur after 2, then 4, then 8 seconds, and so on"""
    codes: NotRequired[List[float]]
    r"""List of HTTP codes that trigger a retry. Leave empty to use the default list of 429 and 503."""
    enable_header: NotRequired[bool]
    r"""Honor any Retry-After header that specifies a delay (in seconds) or a timestamp after which to retry the request. The delay is limited to 20 seconds, even if the Retry-After header specifies a longer delay. When disabled, all Retry-After headers are ignored."""


class HealthCheckCollectMethodPostHealthCheckRetryRulesTypeBackoff(BaseModel):
    type: RetryTypeOptionsHealthCheckCollectorConfRetryRules
    r"""The algorithm to use when performing HTTP retries"""

    interval: Optional[float] = None
    r"""Time interval between failed request and first retry (kickoff). Maximum allowed value is 20,000 ms (1/3 minute)."""

    limit: Optional[float] = None
    r"""The maximum number of times to retry a failed HTTP request"""

    multiplier: Optional[float] = None
    r"""Base for exponential backoff, e.g., base 2 means that retries will occur after 2, then 4, then 8 seconds, and so on"""

    codes: Optional[List[float]] = None
    r"""List of HTTP codes that trigger a retry. Leave empty to use the default list of 429 and 503."""

    enable_header: Annotated[Optional[bool], pydantic.Field(alias="enableHeader")] = (
        None
    )
    r"""Honor any Retry-After header that specifies a delay (in seconds) or a timestamp after which to retry the request. The delay is limited to 20 seconds, even if the Retry-After header specifies a longer delay. When disabled, all Retry-After headers are ignored."""

    @field_serializer("type")
    def serialize_type(self, value):
        if isinstance(value, str):
            try:
                return models.RetryTypeOptionsHealthCheckCollectorConfRetryRules(value)
            except ValueError:
                return value
        return value

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(
            ["interval", "limit", "multiplier", "codes", "enableHeader"]
        )
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


class HealthCheckCollectMethodPostHealthCheckRetryRulesTypeStaticTypedDict(TypedDict):
    type: RetryTypeOptionsHealthCheckCollectorConfRetryRules
    r"""The algorithm to use when performing HTTP retries"""
    interval: NotRequired[float]
    r"""Time interval between retries. Maximum allowed value is 20,000 ms (1/3 minute)."""
    limit: NotRequired[float]
    r"""The maximum number of times to retry a failed HTTP request"""
    codes: NotRequired[List[float]]
    r"""List of HTTP codes that trigger a retry. Leave empty to use the default list of 429 and 503."""
    enable_header: NotRequired[bool]
    r"""Honor any Retry-After header that specifies a delay (in seconds) or a timestamp after which to retry the request. The delay is limited to 20 seconds, even if the Retry-After header specifies a longer delay. When disabled, all Retry-After headers are ignored."""


class HealthCheckCollectMethodPostHealthCheckRetryRulesTypeStatic(BaseModel):
    type: RetryTypeOptionsHealthCheckCollectorConfRetryRules
    r"""The algorithm to use when performing HTTP retries"""

    interval: Optional[float] = None
    r"""Time interval between retries. Maximum allowed value is 20,000 ms (1/3 minute)."""

    limit: Optional[float] = None
    r"""The maximum number of times to retry a failed HTTP request"""

    codes: Optional[List[float]] = None
    r"""List of HTTP codes that trigger a retry. Leave empty to use the default list of 429 and 503."""

    enable_header: Annotated[Optional[bool], pydantic.Field(alias="enableHeader")] = (
        None
    )
    r"""Honor any Retry-After header that specifies a delay (in seconds) or a timestamp after which to retry the request. The delay is limited to 20 seconds, even if the Retry-After header specifies a longer delay. When disabled, all Retry-After headers are ignored."""

    @field_serializer("type")
    def serialize_type(self, value):
        if isinstance(value, str):
            try:
                return models.RetryTypeOptionsHealthCheckCollectorConfRetryRules(value)
            except ValueError:
                return value
        return value

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(["interval", "limit", "codes", "enableHeader"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


class HealthCheckCollectMethodPostHealthCheckRetryRulesTypeNoneTypedDict(TypedDict):
    type: RetryTypeOptionsHealthCheckCollectorConfRetryRules
    r"""The algorithm to use when performing HTTP retries"""


class HealthCheckCollectMethodPostHealthCheckRetryRulesTypeNone(BaseModel):
    type: RetryTypeOptionsHealthCheckCollectorConfRetryRules
    r"""The algorithm to use when performing HTTP retries"""

    @field_serializer("type")
    def serialize_type(self, value):
        if isinstance(value, str):
            try:
                return models.RetryTypeOptionsHealthCheckCollectorConfRetryRules(value)
            except ValueError:
                return value
        return value


HealthCheckCollectMethodPostRetryRulesTypedDict = TypeAliasType(
    "HealthCheckCollectMethodPostRetryRulesTypedDict",
    Union[
        HealthCheckCollectMethodPostHealthCheckRetryRulesTypeNoneTypedDict,
        HealthCheckCollectMethodPostHealthCheckRetryRulesTypeStaticTypedDict,
        HealthCheckCollectMethodPostHealthCheckRetryRulesTypeBackoffTypedDict,
    ],
)


class UnknownHealthCheckCollectMethodPostRetryRules(BaseModel):
    r"""A HealthCheckCollectMethodPostRetryRules variant the SDK doesn't recognize. Preserves the raw payload."""

    type: Literal["UNKNOWN"] = "UNKNOWN"
    raw: Any
    is_unknown: Literal[True] = True

    model_config = ConfigDict(frozen=True)


_HEALTH_CHECK_COLLECT_METHOD_POST_RETRY_RULES_VARIANTS: dict[str, Any] = {
    "none": HealthCheckCollectMethodPostHealthCheckRetryRulesTypeNone,
    "static": HealthCheckCollectMethodPostHealthCheckRetryRulesTypeStatic,
    "backoff": HealthCheckCollectMethodPostHealthCheckRetryRulesTypeBackoff,
}


HealthCheckCollectMethodPostRetryRules = Annotated[
    Union[
        HealthCheckCollectMethodPostHealthCheckRetryRulesTypeNone,
        HealthCheckCollectMethodPostHealthCheckRetryRulesTypeStatic,
        HealthCheckCollectMethodPostHealthCheckRetryRulesTypeBackoff,
        UnknownHealthCheckCollectMethodPostRetryRules,
    ],
    BeforeValidator(
        partial(
            parse_open_union,
            disc_key="type",
            variants=_HEALTH_CHECK_COLLECT_METHOD_POST_RETRY_RULES_VARIANTS,
            unknown_cls=UnknownHealthCheckCollectMethodPostRetryRules,
            union_name="HealthCheckCollectMethodPostRetryRules",
        )
    ),
]


class HealthCheckCollectMethodPostTypedDict(TypedDict):
    collect_method: HealthCheckCollectMethodPostHealthCheckMethod
    r"""Health check HTTP method."""
    collect_url: str
    r"""Expression to derive URL to use for the health check operation (can be a constant)."""
    authentication: HealthCheckCollectMethodPostAuthentication
    r"""Authentication method for Discover and Collect REST calls. You can specify API Key–based authentication by adding the appropriate Collect headers."""
    collect_request_params: NotRequired[
        List[ItemsTypeHealthCheckCollectMethodPostCollectRequestParamsTypedDict]
    ]
    r"""Optional health check request parameters."""
    discovery: NotRequired[HealthCheckCollectMethodPostDiscoveryTypedDict]
    collect_request_headers: NotRequired[
        List[HealthCheckCollectMethodPostCollectRequestHeaderTypedDict]
    ]
    r"""Optional health check request headers."""
    authenticate_collect: NotRequired[bool]
    r"""Enable to make auth health check call."""
    timeout: NotRequired[float]
    r"""HTTP request inactivity timeout, use 0 to disable"""
    reject_unauthorized: NotRequired[bool]
    r"""Whether to reject certificates that cannot be verified against a valid CA (e.g., self-signed certificates)."""
    default_breakers: NotRequired[HiddenDefaultBreakersOptionsDatabaseCollectorConf]
    safe_headers: NotRequired[List[str]]
    r"""List of headers that are safe to log in plain text."""
    retry_rules: NotRequired[HealthCheckCollectMethodPostRetryRulesTypedDict]


class HealthCheckCollectMethodPost(BaseModel):
    collect_method: Annotated[
        HealthCheckCollectMethodPostHealthCheckMethod,
        pydantic.Field(alias="collectMethod"),
    ]
    r"""Health check HTTP method."""

    collect_url: Annotated[str, pydantic.Field(alias="collectUrl")]
    r"""Expression to derive URL to use for the health check operation (can be a constant)."""

    authentication: HealthCheckCollectMethodPostAuthentication
    r"""Authentication method for Discover and Collect REST calls. You can specify API Key–based authentication by adding the appropriate Collect headers."""

    collect_request_params: Annotated[
        Optional[List[ItemsTypeHealthCheckCollectMethodPostCollectRequestParams]],
        pydantic.Field(alias="collectRequestParams"),
    ] = None
    r"""Optional health check request parameters."""

    discovery: Optional[HealthCheckCollectMethodPostDiscovery] = None

    collect_request_headers: Annotated[
        Optional[List[HealthCheckCollectMethodPostCollectRequestHeader]],
        pydantic.Field(alias="collectRequestHeaders"),
    ] = None
    r"""Optional health check request headers."""

    authenticate_collect: Annotated[
        Optional[bool], pydantic.Field(alias="authenticateCollect")
    ] = None
    r"""Enable to make auth health check call."""

    timeout: Optional[float] = None
    r"""HTTP request inactivity timeout, use 0 to disable"""

    reject_unauthorized: Annotated[
        Optional[bool], pydantic.Field(alias="rejectUnauthorized")
    ] = None
    r"""Whether to reject certificates that cannot be verified against a valid CA (e.g., self-signed certificates)."""

    default_breakers: Annotated[
        Optional[HiddenDefaultBreakersOptionsDatabaseCollectorConf],
        pydantic.Field(alias="defaultBreakers"),
    ] = None

    safe_headers: Annotated[
        Optional[List[str]], pydantic.Field(alias="safeHeaders")
    ] = None
    r"""List of headers that are safe to log in plain text."""

    retry_rules: Annotated[
        Optional[HealthCheckCollectMethodPostRetryRules],
        pydantic.Field(alias="retryRules"),
    ] = None

    @field_serializer("collect_method")
    def serialize_collect_method(self, value):
        if isinstance(value, str):
            try:
                return models.HealthCheckCollectMethodPostHealthCheckMethod(value)
            except ValueError:
                return value
        return value

    @field_serializer("authentication")
    def serialize_authentication(self, value):
        if isinstance(value, str):
            try:
                return models.HealthCheckCollectMethodPostAuthentication(value)
            except ValueError:
                return value
        return value

    @field_serializer("default_breakers")
    def serialize_default_breakers(self, value):
        if isinstance(value, str):
            try:
                return models.HiddenDefaultBreakersOptionsDatabaseCollectorConf(value)
            except ValueError:
                return value
        return value

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(
            [
                "collectRequestParams",
                "discovery",
                "collectRequestHeaders",
                "authenticateCollect",
                "timeout",
                "rejectUnauthorized",
                "defaultBreakers",
                "safeHeaders",
                "retryRules",
            ]
        )
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


class HealthCheckCollectMethodGetHealthCheckMethod(
    str, Enum, metaclass=utils.OpenEnumMeta
):
    r"""Health check HTTP method."""

    # GET
    GET = "get"
    # POST
    POST = "post"
    # POST with Body
    POST_WITH_BODY = "post_with_body"


class HealthCheckCollectMethodGetCollectRequestParamTypedDict(TypedDict):
    name: str
    r"""Parameter name"""
    value: str
    r"""JavaScript expression to compute the parameter value (can be a constant)."""


class HealthCheckCollectMethodGetCollectRequestParam(BaseModel):
    name: str
    r"""Parameter name"""

    value: str
    r"""JavaScript expression to compute the parameter value (can be a constant)."""


class HealthCheckCollectMethodGetHealthCheckDiscoveryDiscoverTypeNoneDiscoverType(
    str, Enum, metaclass=utils.OpenEnumMeta
):
    r"""Defines how task discovery will be performed. Use None to skip the discovery. Use HTTP Request to make a REST call to discover tasks. Use Item List to enumerate items for collect to retrieve. Use JSON Response to manually define discover tasks as a JSON array of objects. Each entry returned by the discover operation will result in a collect task."""

    # HTTP Request
    HTTP = "http"
    # JSON Response
    JSON = "json"
    # Item List
    LIST = "list"
    # None
    NONE = "none"


class HealthCheckCollectMethodGetHealthCheckDiscoveryDiscoverTypeNoneTypedDict(
    TypedDict
):
    discover_type: (
        HealthCheckCollectMethodGetHealthCheckDiscoveryDiscoverTypeNoneDiscoverType
    )
    r"""Defines how task discovery will be performed. Use None to skip the discovery. Use HTTP Request to make a REST call to discover tasks. Use Item List to enumerate items for collect to retrieve. Use JSON Response to manually define discover tasks as a JSON array of objects. Each entry returned by the discover operation will result in a collect task."""


class HealthCheckCollectMethodGetHealthCheckDiscoveryDiscoverTypeNone(BaseModel):
    discover_type: Annotated[
        HealthCheckCollectMethodGetHealthCheckDiscoveryDiscoverTypeNoneDiscoverType,
        pydantic.Field(alias="discoverType"),
    ]
    r"""Defines how task discovery will be performed. Use None to skip the discovery. Use HTTP Request to make a REST call to discover tasks. Use Item List to enumerate items for collect to retrieve. Use JSON Response to manually define discover tasks as a JSON array of objects. Each entry returned by the discover operation will result in a collect task."""

    @field_serializer("discover_type")
    def serialize_discover_type(self, value):
        if isinstance(value, str):
            try:
                return models.HealthCheckCollectMethodGetHealthCheckDiscoveryDiscoverTypeNoneDiscoverType(
                    value
                )
            except ValueError:
                return value
        return value


class HealthCheckCollectMethodGetHealthCheckDiscoveryDiscoverTypeListDiscoverType(
    str, Enum, metaclass=utils.OpenEnumMeta
):
    r"""Defines how task discovery will be performed. Use None to skip the discovery. Use HTTP Request to make a REST call to discover tasks. Use Item List to enumerate items for collect to retrieve. Use JSON Response to manually define discover tasks as a JSON array of objects. Each entry returned by the discover operation will result in a collect task."""

    # HTTP Request
    HTTP = "http"
    # JSON Response
    JSON = "json"
    # Item List
    LIST = "list"
    # None
    NONE = "none"


class HealthCheckCollectMethodGetHealthCheckDiscoveryDiscoverTypeListTypedDict(
    TypedDict
):
    discover_type: (
        HealthCheckCollectMethodGetHealthCheckDiscoveryDiscoverTypeListDiscoverType
    )
    r"""Defines how task discovery will be performed. Use None to skip the discovery. Use HTTP Request to make a REST call to discover tasks. Use Item List to enumerate items for collect to retrieve. Use JSON Response to manually define discover tasks as a JSON array of objects. Each entry returned by the discover operation will result in a collect task."""
    item_list: List[str]
    r"""Comma-separated list of items to return from the Discover task. Each item returned will generate a collect task, and can be referenced using `${id}` in the collect URL, headers, or parameters."""


class HealthCheckCollectMethodGetHealthCheckDiscoveryDiscoverTypeList(BaseModel):
    discover_type: Annotated[
        HealthCheckCollectMethodGetHealthCheckDiscoveryDiscoverTypeListDiscoverType,
        pydantic.Field(alias="discoverType"),
    ]
    r"""Defines how task discovery will be performed. Use None to skip the discovery. Use HTTP Request to make a REST call to discover tasks. Use Item List to enumerate items for collect to retrieve. Use JSON Response to manually define discover tasks as a JSON array of objects. Each entry returned by the discover operation will result in a collect task."""

    item_list: Annotated[List[str], pydantic.Field(alias="itemList")]
    r"""Comma-separated list of items to return from the Discover task. Each item returned will generate a collect task, and can be referenced using `${id}` in the collect URL, headers, or parameters."""

    @field_serializer("discover_type")
    def serialize_discover_type(self, value):
        if isinstance(value, str):
            try:
                return models.HealthCheckCollectMethodGetHealthCheckDiscoveryDiscoverTypeListDiscoverType(
                    value
                )
            except ValueError:
                return value
        return value


class HealthCheckCollectMethodGetHealthCheckDiscoveryDiscoverTypeJSONDiscoverType(
    str, Enum, metaclass=utils.OpenEnumMeta
):
    r"""Defines how task discovery will be performed. Use None to skip the discovery. Use HTTP Request to make a REST call to discover tasks. Use Item List to enumerate items for collect to retrieve. Use JSON Response to manually define discover tasks as a JSON array of objects. Each entry returned by the discover operation will result in a collect task."""

    # HTTP Request
    HTTP = "http"
    # JSON Response
    JSON = "json"
    # Item List
    LIST = "list"
    # None
    NONE = "none"


class HealthCheckCollectMethodGetHealthCheckDiscoveryDiscoverTypeJSONTypedDict(
    TypedDict
):
    discover_type: (
        HealthCheckCollectMethodGetHealthCheckDiscoveryDiscoverTypeJSONDiscoverType
    )
    r"""Defines how task discovery will be performed. Use None to skip the discovery. Use HTTP Request to make a REST call to discover tasks. Use Item List to enumerate items for collect to retrieve. Use JSON Response to manually define discover tasks as a JSON array of objects. Each entry returned by the discover operation will result in a collect task."""
    manual_discover_result: str
    r"""Allows hard-coding the Discover result. Must be a JSON object. Works with the Discover Data field."""
    discover_data_field: NotRequired[str]
    r"""Within the response JSON, name of the field or array element to pull results from. Leave blank if the result is an array of values. Sample entry: items, json: { items: [{id: 'first'},{id: 'second'}] }"""


class HealthCheckCollectMethodGetHealthCheckDiscoveryDiscoverTypeJSON(BaseModel):
    discover_type: Annotated[
        HealthCheckCollectMethodGetHealthCheckDiscoveryDiscoverTypeJSONDiscoverType,
        pydantic.Field(alias="discoverType"),
    ]
    r"""Defines how task discovery will be performed. Use None to skip the discovery. Use HTTP Request to make a REST call to discover tasks. Use Item List to enumerate items for collect to retrieve. Use JSON Response to manually define discover tasks as a JSON array of objects. Each entry returned by the discover operation will result in a collect task."""

    manual_discover_result: Annotated[str, pydantic.Field(alias="manualDiscoverResult")]
    r"""Allows hard-coding the Discover result. Must be a JSON object. Works with the Discover Data field."""

    discover_data_field: Annotated[
        Optional[str], pydantic.Field(alias="discoverDataField")
    ] = None
    r"""Within the response JSON, name of the field or array element to pull results from. Leave blank if the result is an array of values. Sample entry: items, json: { items: [{id: 'first'},{id: 'second'}] }"""

    @field_serializer("discover_type")
    def serialize_discover_type(self, value):
        if isinstance(value, str):
            try:
                return models.HealthCheckCollectMethodGetHealthCheckDiscoveryDiscoverTypeJSONDiscoverType(
                    value
                )
            except ValueError:
                return value
        return value

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(["discoverDataField"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


class HealthCheckCollectMethodGetHealthCheckDiscoveryDiscoverTypeHTTPDiscoverMethodPostWithBodyDiscoverMethod(
    str, Enum, metaclass=utils.OpenEnumMeta
):
    r"""Discover HTTP method."""

    # GET
    GET = "get"
    # POST
    POST = "post"
    # POST with Body
    POST_WITH_BODY = "post_with_body"


class HealthCheckCollectMethodGetHealthCheckDiscoveryDiscoverTypeHTTPDiscoverMethodPostWithBodyDiscoverType(
    str, Enum, metaclass=utils.OpenEnumMeta
):
    r"""Defines how task discovery will be performed. Use None to skip the discovery. Use HTTP Request to make a REST call to discover tasks. Use Item List to enumerate items for collect to retrieve. Use JSON Response to manually define discover tasks as a JSON array of objects. Each entry returned by the discover operation will result in a collect task."""

    # HTTP Request
    HTTP = "http"
    # JSON Response
    JSON = "json"
    # Item List
    LIST = "list"
    # None
    NONE = "none"


class HealthCheckCollectMethodGetHealthCheckDiscoveryDiscoverTypeHTTPDiscoverMethodPostWithBodyTypedDict(
    TypedDict
):
    discover_method: HealthCheckCollectMethodGetHealthCheckDiscoveryDiscoverTypeHTTPDiscoverMethodPostWithBodyDiscoverMethod
    r"""Discover HTTP method."""
    discover_type: HealthCheckCollectMethodGetHealthCheckDiscoveryDiscoverTypeHTTPDiscoverMethodPostWithBodyDiscoverType
    r"""Defines how task discovery will be performed. Use None to skip the discovery. Use HTTP Request to make a REST call to discover tasks. Use Item List to enumerate items for collect to retrieve. Use JSON Response to manually define discover tasks as a JSON array of objects. Each entry returned by the discover operation will result in a collect task."""
    discover_url: str
    r"""Expression to derive URL to use for the Discover operation (can be a constant)."""
    discover_body: NotRequired[str]
    r"""Template for POST body to send with the discover request."""
    discover_request_headers: NotRequired[
        List[ItemsTypeHealthCheckAuthenticationLoginAuthRequestHeadersTypedDict]
    ]
    r"""Optional discover request headers."""
    discover_data_field: NotRequired[str]
    r"""Path to field in the response object which contains discover results (e.g.: level1.name), leave blank if the result is an array."""


class HealthCheckCollectMethodGetHealthCheckDiscoveryDiscoverTypeHTTPDiscoverMethodPostWithBody(
    BaseModel
):
    discover_method: Annotated[
        HealthCheckCollectMethodGetHealthCheckDiscoveryDiscoverTypeHTTPDiscoverMethodPostWithBodyDiscoverMethod,
        pydantic.Field(alias="discoverMethod"),
    ]
    r"""Discover HTTP method."""

    discover_type: Annotated[
        HealthCheckCollectMethodGetHealthCheckDiscoveryDiscoverTypeHTTPDiscoverMethodPostWithBodyDiscoverType,
        pydantic.Field(alias="discoverType"),
    ]
    r"""Defines how task discovery will be performed. Use None to skip the discovery. Use HTTP Request to make a REST call to discover tasks. Use Item List to enumerate items for collect to retrieve. Use JSON Response to manually define discover tasks as a JSON array of objects. Each entry returned by the discover operation will result in a collect task."""

    discover_url: Annotated[str, pydantic.Field(alias="discoverUrl")]
    r"""Expression to derive URL to use for the Discover operation (can be a constant)."""

    discover_body: Annotated[Optional[str], pydantic.Field(alias="discoverBody")] = None
    r"""Template for POST body to send with the discover request."""

    discover_request_headers: Annotated[
        Optional[List[ItemsTypeHealthCheckAuthenticationLoginAuthRequestHeaders]],
        pydantic.Field(alias="discoverRequestHeaders"),
    ] = None
    r"""Optional discover request headers."""

    discover_data_field: Annotated[
        Optional[str], pydantic.Field(alias="discoverDataField")
    ] = None
    r"""Path to field in the response object which contains discover results (e.g.: level1.name), leave blank if the result is an array."""

    @field_serializer("discover_method")
    def serialize_discover_method(self, value):
        if isinstance(value, str):
            try:
                return models.HealthCheckCollectMethodGetHealthCheckDiscoveryDiscoverTypeHTTPDiscoverMethodPostWithBodyDiscoverMethod(
                    value
                )
            except ValueError:
                return value
        return value

    @field_serializer("discover_type")
    def serialize_discover_type(self, value):
        if isinstance(value, str):
            try:
                return models.HealthCheckCollectMethodGetHealthCheckDiscoveryDiscoverTypeHTTPDiscoverMethodPostWithBodyDiscoverType(
                    value
                )
            except ValueError:
                return value
        return value

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(
            ["discoverBody", "discoverRequestHeaders", "discoverDataField"]
        )
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


class HealthCheckCollectMethodGetHealthCheckDiscoveryDiscoverTypeHTTPDiscoverMethodPostDiscoverMethod(
    str, Enum, metaclass=utils.OpenEnumMeta
):
    r"""Discover HTTP method."""

    # GET
    GET = "get"
    # POST
    POST = "post"
    # POST with Body
    POST_WITH_BODY = "post_with_body"


class HealthCheckCollectMethodGetHealthCheckDiscoveryDiscoverTypeHTTPDiscoverMethodPostDiscoverType(
    str, Enum, metaclass=utils.OpenEnumMeta
):
    r"""Defines how task discovery will be performed. Use None to skip the discovery. Use HTTP Request to make a REST call to discover tasks. Use Item List to enumerate items for collect to retrieve. Use JSON Response to manually define discover tasks as a JSON array of objects. Each entry returned by the discover operation will result in a collect task."""

    # HTTP Request
    HTTP = "http"
    # JSON Response
    JSON = "json"
    # Item List
    LIST = "list"
    # None
    NONE = "none"


class HealthCheckCollectMethodGetHealthCheckDiscoveryDiscoverTypeHTTPDiscoverMethodPostTypedDict(
    TypedDict
):
    discover_method: HealthCheckCollectMethodGetHealthCheckDiscoveryDiscoverTypeHTTPDiscoverMethodPostDiscoverMethod
    r"""Discover HTTP method."""
    discover_type: HealthCheckCollectMethodGetHealthCheckDiscoveryDiscoverTypeHTTPDiscoverMethodPostDiscoverType
    r"""Defines how task discovery will be performed. Use None to skip the discovery. Use HTTP Request to make a REST call to discover tasks. Use Item List to enumerate items for collect to retrieve. Use JSON Response to manually define discover tasks as a JSON array of objects. Each entry returned by the discover operation will result in a collect task."""
    discover_url: str
    r"""Expression to derive URL to use for the Discover operation (can be a constant)."""
    discover_request_params: NotRequired[
        List[ItemsTypeHealthCheckCollectMethodPostCollectRequestParamsTypedDict]
    ]
    r"""Optional discover request parameters."""
    discover_request_headers: NotRequired[
        List[ItemsTypeHealthCheckAuthenticationLoginAuthRequestHeadersTypedDict]
    ]
    r"""Optional discover request headers."""
    discover_data_field: NotRequired[str]
    r"""Path to field in the response object which contains discover results (e.g.: level1.name), leave blank if the result is an array."""


class HealthCheckCollectMethodGetHealthCheckDiscoveryDiscoverTypeHTTPDiscoverMethodPost(
    BaseModel
):
    discover_method: Annotated[
        HealthCheckCollectMethodGetHealthCheckDiscoveryDiscoverTypeHTTPDiscoverMethodPostDiscoverMethod,
        pydantic.Field(alias="discoverMethod"),
    ]
    r"""Discover HTTP method."""

    discover_type: Annotated[
        HealthCheckCollectMethodGetHealthCheckDiscoveryDiscoverTypeHTTPDiscoverMethodPostDiscoverType,
        pydantic.Field(alias="discoverType"),
    ]
    r"""Defines how task discovery will be performed. Use None to skip the discovery. Use HTTP Request to make a REST call to discover tasks. Use Item List to enumerate items for collect to retrieve. Use JSON Response to manually define discover tasks as a JSON array of objects. Each entry returned by the discover operation will result in a collect task."""

    discover_url: Annotated[str, pydantic.Field(alias="discoverUrl")]
    r"""Expression to derive URL to use for the Discover operation (can be a constant)."""

    discover_request_params: Annotated[
        Optional[List[ItemsTypeHealthCheckCollectMethodPostCollectRequestParams]],
        pydantic.Field(alias="discoverRequestParams"),
    ] = None
    r"""Optional discover request parameters."""

    discover_request_headers: Annotated[
        Optional[List[ItemsTypeHealthCheckAuthenticationLoginAuthRequestHeaders]],
        pydantic.Field(alias="discoverRequestHeaders"),
    ] = None
    r"""Optional discover request headers."""

    discover_data_field: Annotated[
        Optional[str], pydantic.Field(alias="discoverDataField")
    ] = None
    r"""Path to field in the response object which contains discover results (e.g.: level1.name), leave blank if the result is an array."""

    @field_serializer("discover_method")
    def serialize_discover_method(self, value):
        if isinstance(value, str):
            try:
                return models.HealthCheckCollectMethodGetHealthCheckDiscoveryDiscoverTypeHTTPDiscoverMethodPostDiscoverMethod(
                    value
                )
            except ValueError:
                return value
        return value

    @field_serializer("discover_type")
    def serialize_discover_type(self, value):
        if isinstance(value, str):
            try:
                return models.HealthCheckCollectMethodGetHealthCheckDiscoveryDiscoverTypeHTTPDiscoverMethodPostDiscoverType(
                    value
                )
            except ValueError:
                return value
        return value

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(
            ["discoverRequestParams", "discoverRequestHeaders", "discoverDataField"]
        )
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


class HealthCheckCollectMethodGetHealthCheckDiscoveryDiscoverTypeHTTPDiscoverMethodGetDiscoverMethod(
    str, Enum, metaclass=utils.OpenEnumMeta
):
    r"""Discover HTTP method."""

    # GET
    GET = "get"
    # POST
    POST = "post"
    # POST with Body
    POST_WITH_BODY = "post_with_body"


class HealthCheckCollectMethodGetHealthCheckDiscoveryDiscoverTypeHTTPDiscoverMethodGetDiscoverType(
    str, Enum, metaclass=utils.OpenEnumMeta
):
    r"""Defines how task discovery will be performed. Use None to skip the discovery. Use HTTP Request to make a REST call to discover tasks. Use Item List to enumerate items for collect to retrieve. Use JSON Response to manually define discover tasks as a JSON array of objects. Each entry returned by the discover operation will result in a collect task."""

    # HTTP Request
    HTTP = "http"
    # JSON Response
    JSON = "json"
    # Item List
    LIST = "list"
    # None
    NONE = "none"


class HealthCheckCollectMethodGetHealthCheckDiscoveryDiscoverTypeHTTPDiscoverMethodGetTypedDict(
    TypedDict
):
    discover_method: HealthCheckCollectMethodGetHealthCheckDiscoveryDiscoverTypeHTTPDiscoverMethodGetDiscoverMethod
    r"""Discover HTTP method."""
    discover_type: HealthCheckCollectMethodGetHealthCheckDiscoveryDiscoverTypeHTTPDiscoverMethodGetDiscoverType
    r"""Defines how task discovery will be performed. Use None to skip the discovery. Use HTTP Request to make a REST call to discover tasks. Use Item List to enumerate items for collect to retrieve. Use JSON Response to manually define discover tasks as a JSON array of objects. Each entry returned by the discover operation will result in a collect task."""
    discover_url: str
    r"""Expression to derive URL to use for the Discover operation (can be a constant)."""
    discover_request_params: NotRequired[
        List[ItemsTypeHealthCheckCollectMethodPostCollectRequestParamsTypedDict]
    ]
    r"""Optional discover request parameters."""
    discover_request_headers: NotRequired[
        List[ItemsTypeHealthCheckAuthenticationLoginAuthRequestHeadersTypedDict]
    ]
    r"""Optional discover request headers."""
    discover_data_field: NotRequired[str]
    r"""Path to field in the response object which contains discover results (e.g.: level1.name), leave blank if the result is an array."""


class HealthCheckCollectMethodGetHealthCheckDiscoveryDiscoverTypeHTTPDiscoverMethodGet(
    BaseModel
):
    discover_method: Annotated[
        HealthCheckCollectMethodGetHealthCheckDiscoveryDiscoverTypeHTTPDiscoverMethodGetDiscoverMethod,
        pydantic.Field(alias="discoverMethod"),
    ]
    r"""Discover HTTP method."""

    discover_type: Annotated[
        HealthCheckCollectMethodGetHealthCheckDiscoveryDiscoverTypeHTTPDiscoverMethodGetDiscoverType,
        pydantic.Field(alias="discoverType"),
    ]
    r"""Defines how task discovery will be performed. Use None to skip the discovery. Use HTTP Request to make a REST call to discover tasks. Use Item List to enumerate items for collect to retrieve. Use JSON Response to manually define discover tasks as a JSON array of objects. Each entry returned by the discover operation will result in a collect task."""

    discover_url: Annotated[str, pydantic.Field(alias="discoverUrl")]
    r"""Expression to derive URL to use for the Discover operation (can be a constant)."""

    discover_request_params: Annotated[
        Optional[List[ItemsTypeHealthCheckCollectMethodPostCollectRequestParams]],
        pydantic.Field(alias="discoverRequestParams"),
    ] = None
    r"""Optional discover request parameters."""

    discover_request_headers: Annotated[
        Optional[List[ItemsTypeHealthCheckAuthenticationLoginAuthRequestHeaders]],
        pydantic.Field(alias="discoverRequestHeaders"),
    ] = None
    r"""Optional discover request headers."""

    discover_data_field: Annotated[
        Optional[str], pydantic.Field(alias="discoverDataField")
    ] = None
    r"""Path to field in the response object which contains discover results (e.g.: level1.name), leave blank if the result is an array."""

    @field_serializer("discover_method")
    def serialize_discover_method(self, value):
        if isinstance(value, str):
            try:
                return models.HealthCheckCollectMethodGetHealthCheckDiscoveryDiscoverTypeHTTPDiscoverMethodGetDiscoverMethod(
                    value
                )
            except ValueError:
                return value
        return value

    @field_serializer("discover_type")
    def serialize_discover_type(self, value):
        if isinstance(value, str):
            try:
                return models.HealthCheckCollectMethodGetHealthCheckDiscoveryDiscoverTypeHTTPDiscoverMethodGetDiscoverType(
                    value
                )
            except ValueError:
                return value
        return value

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(
            ["discoverRequestParams", "discoverRequestHeaders", "discoverDataField"]
        )
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


HealthCheckCollectMethodGetHealthCheckDiscoveryDiscoverTypeHTTPTypedDict = TypeAliasType(
    "HealthCheckCollectMethodGetHealthCheckDiscoveryDiscoverTypeHTTPTypedDict",
    Union[
        HealthCheckCollectMethodGetHealthCheckDiscoveryDiscoverTypeHTTPDiscoverMethodGetTypedDict,
        HealthCheckCollectMethodGetHealthCheckDiscoveryDiscoverTypeHTTPDiscoverMethodPostTypedDict,
        HealthCheckCollectMethodGetHealthCheckDiscoveryDiscoverTypeHTTPDiscoverMethodPostWithBodyTypedDict,
    ],
)


class UnknownHealthCheckCollectMethodGetHealthCheckDiscoveryDiscoverTypeHTTP(BaseModel):
    r"""A HealthCheckCollectMethodGetHealthCheckDiscoveryDiscoverTypeHTTP variant the SDK doesn't recognize. Preserves the raw payload."""

    discover_method: Literal["UNKNOWN"] = "UNKNOWN"
    raw: Any
    is_unknown: Literal[True] = True

    model_config = ConfigDict(frozen=True)


_HEALTH_CHECK_COLLECT_METHOD_GET_HEALTH_CHECK_DISCOVERY_DISCOVER_TYPE_HTTP_VARIANTS: dict[
    str, Any
] = {
    "get": HealthCheckCollectMethodGetHealthCheckDiscoveryDiscoverTypeHTTPDiscoverMethodGet,
    "post": HealthCheckCollectMethodGetHealthCheckDiscoveryDiscoverTypeHTTPDiscoverMethodPost,
    "post_with_body": HealthCheckCollectMethodGetHealthCheckDiscoveryDiscoverTypeHTTPDiscoverMethodPostWithBody,
}


HealthCheckCollectMethodGetHealthCheckDiscoveryDiscoverTypeHTTP = Annotated[
    Union[
        HealthCheckCollectMethodGetHealthCheckDiscoveryDiscoverTypeHTTPDiscoverMethodGet,
        HealthCheckCollectMethodGetHealthCheckDiscoveryDiscoverTypeHTTPDiscoverMethodPost,
        HealthCheckCollectMethodGetHealthCheckDiscoveryDiscoverTypeHTTPDiscoverMethodPostWithBody,
        UnknownHealthCheckCollectMethodGetHealthCheckDiscoveryDiscoverTypeHTTP,
    ],
    BeforeValidator(
        partial(
            parse_open_union,
            disc_key="discoverMethod",
            variants=_HEALTH_CHECK_COLLECT_METHOD_GET_HEALTH_CHECK_DISCOVERY_DISCOVER_TYPE_HTTP_VARIANTS,
            unknown_cls=UnknownHealthCheckCollectMethodGetHealthCheckDiscoveryDiscoverTypeHTTP,
            union_name="HealthCheckCollectMethodGetHealthCheckDiscoveryDiscoverTypeHTTP",
        )
    ),
]


HealthCheckCollectMethodGetDiscoveryTypedDict = TypeAliasType(
    "HealthCheckCollectMethodGetDiscoveryTypedDict",
    Union[
        HealthCheckCollectMethodGetHealthCheckDiscoveryDiscoverTypeNoneTypedDict,
        HealthCheckCollectMethodGetHealthCheckDiscoveryDiscoverTypeListTypedDict,
        HealthCheckCollectMethodGetHealthCheckDiscoveryDiscoverTypeJSONTypedDict,
        HealthCheckCollectMethodGetHealthCheckDiscoveryDiscoverTypeHTTPTypedDict,
    ],
)


class UnknownHealthCheckCollectMethodGetDiscovery(BaseModel):
    r"""A HealthCheckCollectMethodGetDiscovery variant the SDK doesn't recognize. Preserves the raw payload."""

    discover_type: Literal["UNKNOWN"] = "UNKNOWN"
    raw: Any
    is_unknown: Literal[True] = True

    model_config = ConfigDict(frozen=True)


_HEALTH_CHECK_COLLECT_METHOD_GET_DISCOVERY_VARIANTS: dict[str, Any] = {
    "http": HealthCheckCollectMethodGetHealthCheckDiscoveryDiscoverTypeHTTP,
    "json": HealthCheckCollectMethodGetHealthCheckDiscoveryDiscoverTypeJSON,
    "list": HealthCheckCollectMethodGetHealthCheckDiscoveryDiscoverTypeList,
    "none": HealthCheckCollectMethodGetHealthCheckDiscoveryDiscoverTypeNone,
}


HealthCheckCollectMethodGetDiscovery = Annotated[
    Union[
        HealthCheckCollectMethodGetHealthCheckDiscoveryDiscoverTypeHTTP,
        HealthCheckCollectMethodGetHealthCheckDiscoveryDiscoverTypeJSON,
        HealthCheckCollectMethodGetHealthCheckDiscoveryDiscoverTypeList,
        HealthCheckCollectMethodGetHealthCheckDiscoveryDiscoverTypeNone,
        UnknownHealthCheckCollectMethodGetDiscovery,
    ],
    BeforeValidator(
        partial(
            parse_open_union,
            disc_key="discoverType",
            variants=_HEALTH_CHECK_COLLECT_METHOD_GET_DISCOVERY_VARIANTS,
            unknown_cls=UnknownHealthCheckCollectMethodGetDiscovery,
            union_name="HealthCheckCollectMethodGetDiscovery",
        )
    ),
]


class HealthCheckCollectMethodGetCollectRequestHeaderTypedDict(TypedDict):
    name: str
    r"""Header Name"""
    value: str
    r"""JavaScript expression to compute the header value (can be a constant)."""


class HealthCheckCollectMethodGetCollectRequestHeader(BaseModel):
    name: str
    r"""Header Name"""

    value: str
    r"""JavaScript expression to compute the header value (can be a constant)."""


class HealthCheckCollectMethodGetAuthentication(
    str, Enum, metaclass=utils.OpenEnumMeta
):
    r"""Authentication method for Discover and Collect REST calls. You can specify API Key–based authentication by adding the appropriate Collect headers."""

    NONE = "none"
    BASIC = "basic"
    BASIC_SECRET = "basicSecret"
    LOGIN = "login"
    LOGIN_SECRET = "loginSecret"
    OAUTH = "oauth"
    OAUTH_SECRET = "oauthSecret"


class HealthCheckCollectMethodGetHealthCheckRetryRulesTypeBackoffTypedDict(TypedDict):
    type: RetryTypeOptionsHealthCheckCollectorConfRetryRules
    r"""The algorithm to use when performing HTTP retries"""
    interval: NotRequired[float]
    r"""Time interval between failed request and first retry (kickoff). Maximum allowed value is 20,000 ms (1/3 minute)."""
    limit: NotRequired[float]
    r"""The maximum number of times to retry a failed HTTP request"""
    multiplier: NotRequired[float]
    r"""Base for exponential backoff, e.g., base 2 means that retries will occur after 2, then 4, then 8 seconds, and so on"""
    codes: NotRequired[List[float]]
    r"""List of HTTP codes that trigger a retry. Leave empty to use the default list of 429 and 503."""
    enable_header: NotRequired[bool]
    r"""Honor any Retry-After header that specifies a delay (in seconds) or a timestamp after which to retry the request. The delay is limited to 20 seconds, even if the Retry-After header specifies a longer delay. When disabled, all Retry-After headers are ignored."""


class HealthCheckCollectMethodGetHealthCheckRetryRulesTypeBackoff(BaseModel):
    type: RetryTypeOptionsHealthCheckCollectorConfRetryRules
    r"""The algorithm to use when performing HTTP retries"""

    interval: Optional[float] = None
    r"""Time interval between failed request and first retry (kickoff). Maximum allowed value is 20,000 ms (1/3 minute)."""

    limit: Optional[float] = None
    r"""The maximum number of times to retry a failed HTTP request"""

    multiplier: Optional[float] = None
    r"""Base for exponential backoff, e.g., base 2 means that retries will occur after 2, then 4, then 8 seconds, and so on"""

    codes: Optional[List[float]] = None
    r"""List of HTTP codes that trigger a retry. Leave empty to use the default list of 429 and 503."""

    enable_header: Annotated[Optional[bool], pydantic.Field(alias="enableHeader")] = (
        None
    )
    r"""Honor any Retry-After header that specifies a delay (in seconds) or a timestamp after which to retry the request. The delay is limited to 20 seconds, even if the Retry-After header specifies a longer delay. When disabled, all Retry-After headers are ignored."""

    @field_serializer("type")
    def serialize_type(self, value):
        if isinstance(value, str):
            try:
                return models.RetryTypeOptionsHealthCheckCollectorConfRetryRules(value)
            except ValueError:
                return value
        return value

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(
            ["interval", "limit", "multiplier", "codes", "enableHeader"]
        )
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


class HealthCheckCollectMethodGetHealthCheckRetryRulesTypeStaticTypedDict(TypedDict):
    type: RetryTypeOptionsHealthCheckCollectorConfRetryRules
    r"""The algorithm to use when performing HTTP retries"""
    interval: NotRequired[float]
    r"""Time interval between retries. Maximum allowed value is 20,000 ms (1/3 minute)."""
    limit: NotRequired[float]
    r"""The maximum number of times to retry a failed HTTP request"""
    codes: NotRequired[List[float]]
    r"""List of HTTP codes that trigger a retry. Leave empty to use the default list of 429 and 503."""
    enable_header: NotRequired[bool]
    r"""Honor any Retry-After header that specifies a delay (in seconds) or a timestamp after which to retry the request. The delay is limited to 20 seconds, even if the Retry-After header specifies a longer delay. When disabled, all Retry-After headers are ignored."""


class HealthCheckCollectMethodGetHealthCheckRetryRulesTypeStatic(BaseModel):
    type: RetryTypeOptionsHealthCheckCollectorConfRetryRules
    r"""The algorithm to use when performing HTTP retries"""

    interval: Optional[float] = None
    r"""Time interval between retries. Maximum allowed value is 20,000 ms (1/3 minute)."""

    limit: Optional[float] = None
    r"""The maximum number of times to retry a failed HTTP request"""

    codes: Optional[List[float]] = None
    r"""List of HTTP codes that trigger a retry. Leave empty to use the default list of 429 and 503."""

    enable_header: Annotated[Optional[bool], pydantic.Field(alias="enableHeader")] = (
        None
    )
    r"""Honor any Retry-After header that specifies a delay (in seconds) or a timestamp after which to retry the request. The delay is limited to 20 seconds, even if the Retry-After header specifies a longer delay. When disabled, all Retry-After headers are ignored."""

    @field_serializer("type")
    def serialize_type(self, value):
        if isinstance(value, str):
            try:
                return models.RetryTypeOptionsHealthCheckCollectorConfRetryRules(value)
            except ValueError:
                return value
        return value

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(["interval", "limit", "codes", "enableHeader"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


class HealthCheckCollectMethodGetHealthCheckRetryRulesTypeNoneTypedDict(TypedDict):
    type: RetryTypeOptionsHealthCheckCollectorConfRetryRules
    r"""The algorithm to use when performing HTTP retries"""


class HealthCheckCollectMethodGetHealthCheckRetryRulesTypeNone(BaseModel):
    type: RetryTypeOptionsHealthCheckCollectorConfRetryRules
    r"""The algorithm to use when performing HTTP retries"""

    @field_serializer("type")
    def serialize_type(self, value):
        if isinstance(value, str):
            try:
                return models.RetryTypeOptionsHealthCheckCollectorConfRetryRules(value)
            except ValueError:
                return value
        return value


HealthCheckCollectMethodGetRetryRulesTypedDict = TypeAliasType(
    "HealthCheckCollectMethodGetRetryRulesTypedDict",
    Union[
        HealthCheckCollectMethodGetHealthCheckRetryRulesTypeNoneTypedDict,
        HealthCheckCollectMethodGetHealthCheckRetryRulesTypeStaticTypedDict,
        HealthCheckCollectMethodGetHealthCheckRetryRulesTypeBackoffTypedDict,
    ],
)


class UnknownHealthCheckCollectMethodGetRetryRules(BaseModel):
    r"""A HealthCheckCollectMethodGetRetryRules variant the SDK doesn't recognize. Preserves the raw payload."""

    type: Literal["UNKNOWN"] = "UNKNOWN"
    raw: Any
    is_unknown: Literal[True] = True

    model_config = ConfigDict(frozen=True)


_HEALTH_CHECK_COLLECT_METHOD_GET_RETRY_RULES_VARIANTS: dict[str, Any] = {
    "none": HealthCheckCollectMethodGetHealthCheckRetryRulesTypeNone,
    "static": HealthCheckCollectMethodGetHealthCheckRetryRulesTypeStatic,
    "backoff": HealthCheckCollectMethodGetHealthCheckRetryRulesTypeBackoff,
}


HealthCheckCollectMethodGetRetryRules = Annotated[
    Union[
        HealthCheckCollectMethodGetHealthCheckRetryRulesTypeNone,
        HealthCheckCollectMethodGetHealthCheckRetryRulesTypeStatic,
        HealthCheckCollectMethodGetHealthCheckRetryRulesTypeBackoff,
        UnknownHealthCheckCollectMethodGetRetryRules,
    ],
    BeforeValidator(
        partial(
            parse_open_union,
            disc_key="type",
            variants=_HEALTH_CHECK_COLLECT_METHOD_GET_RETRY_RULES_VARIANTS,
            unknown_cls=UnknownHealthCheckCollectMethodGetRetryRules,
            union_name="HealthCheckCollectMethodGetRetryRules",
        )
    ),
]


class HealthCheckCollectMethodGetTypedDict(TypedDict):
    collect_method: HealthCheckCollectMethodGetHealthCheckMethod
    r"""Health check HTTP method."""
    collect_url: str
    r"""Expression to derive URL to use for the health check operation (can be a constant)."""
    authentication: HealthCheckCollectMethodGetAuthentication
    r"""Authentication method for Discover and Collect REST calls. You can specify API Key–based authentication by adding the appropriate Collect headers."""
    collect_request_params: NotRequired[
        List[HealthCheckCollectMethodGetCollectRequestParamTypedDict]
    ]
    r"""Optional health check request parameters."""
    discovery: NotRequired[HealthCheckCollectMethodGetDiscoveryTypedDict]
    collect_request_headers: NotRequired[
        List[HealthCheckCollectMethodGetCollectRequestHeaderTypedDict]
    ]
    r"""Optional health check request headers."""
    authenticate_collect: NotRequired[bool]
    r"""Enable to make auth health check call."""
    timeout: NotRequired[float]
    r"""HTTP request inactivity timeout, use 0 to disable"""
    reject_unauthorized: NotRequired[bool]
    r"""Whether to reject certificates that cannot be verified against a valid CA (e.g., self-signed certificates)."""
    default_breakers: NotRequired[HiddenDefaultBreakersOptionsDatabaseCollectorConf]
    safe_headers: NotRequired[List[str]]
    r"""List of headers that are safe to log in plain text."""
    retry_rules: NotRequired[HealthCheckCollectMethodGetRetryRulesTypedDict]


class HealthCheckCollectMethodGet(BaseModel):
    collect_method: Annotated[
        HealthCheckCollectMethodGetHealthCheckMethod,
        pydantic.Field(alias="collectMethod"),
    ]
    r"""Health check HTTP method."""

    collect_url: Annotated[str, pydantic.Field(alias="collectUrl")]
    r"""Expression to derive URL to use for the health check operation (can be a constant)."""

    authentication: HealthCheckCollectMethodGetAuthentication
    r"""Authentication method for Discover and Collect REST calls. You can specify API Key–based authentication by adding the appropriate Collect headers."""

    collect_request_params: Annotated[
        Optional[List[HealthCheckCollectMethodGetCollectRequestParam]],
        pydantic.Field(alias="collectRequestParams"),
    ] = None
    r"""Optional health check request parameters."""

    discovery: Optional[HealthCheckCollectMethodGetDiscovery] = None

    collect_request_headers: Annotated[
        Optional[List[HealthCheckCollectMethodGetCollectRequestHeader]],
        pydantic.Field(alias="collectRequestHeaders"),
    ] = None
    r"""Optional health check request headers."""

    authenticate_collect: Annotated[
        Optional[bool], pydantic.Field(alias="authenticateCollect")
    ] = None
    r"""Enable to make auth health check call."""

    timeout: Optional[float] = None
    r"""HTTP request inactivity timeout, use 0 to disable"""

    reject_unauthorized: Annotated[
        Optional[bool], pydantic.Field(alias="rejectUnauthorized")
    ] = None
    r"""Whether to reject certificates that cannot be verified against a valid CA (e.g., self-signed certificates)."""

    default_breakers: Annotated[
        Optional[HiddenDefaultBreakersOptionsDatabaseCollectorConf],
        pydantic.Field(alias="defaultBreakers"),
    ] = None

    safe_headers: Annotated[
        Optional[List[str]], pydantic.Field(alias="safeHeaders")
    ] = None
    r"""List of headers that are safe to log in plain text."""

    retry_rules: Annotated[
        Optional[HealthCheckCollectMethodGetRetryRules],
        pydantic.Field(alias="retryRules"),
    ] = None

    @field_serializer("collect_method")
    def serialize_collect_method(self, value):
        if isinstance(value, str):
            try:
                return models.HealthCheckCollectMethodGetHealthCheckMethod(value)
            except ValueError:
                return value
        return value

    @field_serializer("authentication")
    def serialize_authentication(self, value):
        if isinstance(value, str):
            try:
                return models.HealthCheckCollectMethodGetAuthentication(value)
            except ValueError:
                return value
        return value

    @field_serializer("default_breakers")
    def serialize_default_breakers(self, value):
        if isinstance(value, str):
            try:
                return models.HiddenDefaultBreakersOptionsDatabaseCollectorConf(value)
            except ValueError:
                return value
        return value

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(
            [
                "collectRequestParams",
                "discovery",
                "collectRequestHeaders",
                "authenticateCollect",
                "timeout",
                "rejectUnauthorized",
                "defaultBreakers",
                "safeHeaders",
                "retryRules",
            ]
        )
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


HealthCheckCollectorConfTypedDict = TypeAliasType(
    "HealthCheckCollectorConfTypedDict",
    Union[
        HealthCheckAuthenticationNoneTypedDict,
        HealthCheckCollectMethodGetTypedDict,
        HealthCheckCollectMethodPostTypedDict,
        HealthCheckCollectMethodPostWithBodyTypedDict,
        HealthCheckAuthenticationBasicSecretTypedDict,
        HealthCheckAuthenticationBasicTypedDict,
        HealthCheckAuthenticationLoginSecretTypedDict,
        HealthCheckAuthenticationLoginTypedDict,
        HealthCheckAuthenticationOauthTypedDict,
        HealthCheckAuthenticationOauthSecretTypedDict,
    ],
)


class UnknownHealthCheckCollectorConf(BaseModel):
    r"""A HealthCheckCollectorConf variant the SDK doesn't recognize. Preserves the raw payload."""

    authentication: Literal["UNKNOWN"] = "UNKNOWN"
    raw: Any
    is_unknown: Literal[True] = True

    model_config = ConfigDict(frozen=True)


_HEALTH_CHECK_COLLECTOR_CONF_VARIANTS: dict[str, Any] = {
    "none": HealthCheckAuthenticationNone,
    "basic": HealthCheckAuthenticationBasic,
    "basicSecret": HealthCheckAuthenticationBasicSecret,
    "login": HealthCheckAuthenticationLogin,
    "loginSecret": HealthCheckAuthenticationLoginSecret,
    "oauth": HealthCheckAuthenticationOauth,
    "oauthSecret": HealthCheckAuthenticationOauthSecret,
}


HealthCheckCollectorConf = Annotated[
    Union[
        HealthCheckAuthenticationNone,
        HealthCheckAuthenticationBasic,
        HealthCheckAuthenticationBasicSecret,
        HealthCheckAuthenticationLogin,
        HealthCheckAuthenticationLoginSecret,
        HealthCheckAuthenticationOauth,
        HealthCheckAuthenticationOauthSecret,
        UnknownHealthCheckCollectorConf,
    ],
    BeforeValidator(
        partial(
            parse_open_union,
            disc_key="authentication",
            variants=_HEALTH_CHECK_COLLECTOR_CONF_VARIANTS,
            unknown_cls=UnknownHealthCheckCollectorConf,
            union_name="HealthCheckCollectorConf",
        )
    ),
]


try:
    HealthCheckAuthenticationNoneHealthCheckDiscoveryDiscoverTypeNone.model_rebuild()
except NameError:
    pass
try:
    HealthCheckAuthenticationNoneHealthCheckDiscoveryDiscoverTypeList.model_rebuild()
except NameError:
    pass
try:
    HealthCheckAuthenticationNoneHealthCheckDiscoveryDiscoverTypeJSON.model_rebuild()
except NameError:
    pass
try:
    HealthCheckAuthenticationNoneHealthCheckDiscoveryDiscoverTypeHTTPDiscoverMethodPostWithBody.model_rebuild()
except NameError:
    pass
try:
    HealthCheckAuthenticationNoneHealthCheckDiscoveryDiscoverTypeHTTPDiscoverMethodPost.model_rebuild()
except NameError:
    pass
try:
    HealthCheckAuthenticationNoneHealthCheckDiscoveryDiscoverTypeHTTPDiscoverMethodGet.model_rebuild()
except NameError:
    pass
try:
    HealthCheckAuthenticationNoneHealthCheckRetryRulesTypeBackoff.model_rebuild()
except NameError:
    pass
try:
    HealthCheckAuthenticationNoneHealthCheckRetryRulesTypeStatic.model_rebuild()
except NameError:
    pass
try:
    HealthCheckAuthenticationNone.model_rebuild()
except NameError:
    pass
try:
    HealthCheckCollectMethodPostWithBodyHealthCheckDiscoveryDiscoverTypeNone.model_rebuild()
except NameError:
    pass
try:
    HealthCheckCollectMethodPostWithBodyHealthCheckDiscoveryDiscoverTypeList.model_rebuild()
except NameError:
    pass
try:
    HealthCheckCollectMethodPostWithBodyHealthCheckDiscoveryDiscoverTypeJSON.model_rebuild()
except NameError:
    pass
try:
    HealthCheckCollectMethodPostWithBodyHealthCheckDiscoveryDiscoverTypeHTTPDiscoverMethodPostWithBody.model_rebuild()
except NameError:
    pass
try:
    HealthCheckCollectMethodPostWithBodyHealthCheckDiscoveryDiscoverTypeHTTPDiscoverMethodPost.model_rebuild()
except NameError:
    pass
try:
    HealthCheckCollectMethodPostWithBodyHealthCheckDiscoveryDiscoverTypeHTTPDiscoverMethodGet.model_rebuild()
except NameError:
    pass
try:
    HealthCheckCollectMethodPostWithBodyHealthCheckRetryRulesTypeBackoff.model_rebuild()
except NameError:
    pass
try:
    HealthCheckCollectMethodPostWithBodyHealthCheckRetryRulesTypeStatic.model_rebuild()
except NameError:
    pass
try:
    HealthCheckCollectMethodPostWithBody.model_rebuild()
except NameError:
    pass
try:
    HealthCheckCollectMethodPostHealthCheckDiscoveryDiscoverTypeNone.model_rebuild()
except NameError:
    pass
try:
    HealthCheckCollectMethodPostHealthCheckDiscoveryDiscoverTypeList.model_rebuild()
except NameError:
    pass
try:
    HealthCheckCollectMethodPostHealthCheckDiscoveryDiscoverTypeJSON.model_rebuild()
except NameError:
    pass
try:
    HealthCheckCollectMethodPostHealthCheckDiscoveryDiscoverTypeHTTPDiscoverMethodPostWithBody.model_rebuild()
except NameError:
    pass
try:
    HealthCheckCollectMethodPostHealthCheckDiscoveryDiscoverTypeHTTPDiscoverMethodPost.model_rebuild()
except NameError:
    pass
try:
    HealthCheckCollectMethodPostHealthCheckDiscoveryDiscoverTypeHTTPDiscoverMethodGet.model_rebuild()
except NameError:
    pass
try:
    HealthCheckCollectMethodPostHealthCheckRetryRulesTypeBackoff.model_rebuild()
except NameError:
    pass
try:
    HealthCheckCollectMethodPostHealthCheckRetryRulesTypeStatic.model_rebuild()
except NameError:
    pass
try:
    HealthCheckCollectMethodPost.model_rebuild()
except NameError:
    pass
try:
    HealthCheckCollectMethodGetHealthCheckDiscoveryDiscoverTypeNone.model_rebuild()
except NameError:
    pass
try:
    HealthCheckCollectMethodGetHealthCheckDiscoveryDiscoverTypeList.model_rebuild()
except NameError:
    pass
try:
    HealthCheckCollectMethodGetHealthCheckDiscoveryDiscoverTypeJSON.model_rebuild()
except NameError:
    pass
try:
    HealthCheckCollectMethodGetHealthCheckDiscoveryDiscoverTypeHTTPDiscoverMethodPostWithBody.model_rebuild()
except NameError:
    pass
try:
    HealthCheckCollectMethodGetHealthCheckDiscoveryDiscoverTypeHTTPDiscoverMethodPost.model_rebuild()
except NameError:
    pass
try:
    HealthCheckCollectMethodGetHealthCheckDiscoveryDiscoverTypeHTTPDiscoverMethodGet.model_rebuild()
except NameError:
    pass
try:
    HealthCheckCollectMethodGetHealthCheckRetryRulesTypeBackoff.model_rebuild()
except NameError:
    pass
try:
    HealthCheckCollectMethodGetHealthCheckRetryRulesTypeStatic.model_rebuild()
except NameError:
    pass
try:
    HealthCheckCollectMethodGet.model_rebuild()
except NameError:
    pass
