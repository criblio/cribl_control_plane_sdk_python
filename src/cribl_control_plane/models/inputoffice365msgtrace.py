"""Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT."""

from __future__ import annotations
from .connectionstype import ConnectionsType, ConnectionsTypeTypedDict
from .metadata1type import Metadata1Type, Metadata1TypeTypedDict
from .plantypeoptions import PlanTypeOptions
from .pqtype import PqType, PqTypeTypedDict
from .retryrulestype import RetryRulesType, RetryRulesTypeTypedDict
from cribl_control_plane import models, utils
from cribl_control_plane.types import BaseModel
from cribl_control_plane.utils import validate_open_enum
from enum import Enum
import pydantic
from pydantic import field_serializer
from pydantic.functional_validators import PlainValidator
from typing import List, Optional, Union
from typing_extensions import Annotated, NotRequired, TypeAliasType, TypedDict


class InputOffice365MsgTraceAuthenticationMethod9(
    str, Enum, metaclass=utils.OpenEnumMeta
):
    r"""Select authentication method."""

    MANUAL = "manual"
    SECRET = "secret"
    OAUTH = "oauth"
    OAUTH_SECRET = "oauthSecret"
    OAUTH_CERT = "oauthCert"


class InputOffice365MsgTraceType9(str, Enum):
    OFFICE365_MSG_TRACE = "office365_msg_trace"


class InputOffice365MsgTraceLogLevel9(str, Enum, metaclass=utils.OpenEnumMeta):
    r"""Log Level (verbosity) for collection runtime behavior."""

    ERROR = "error"
    WARN = "warn"
    INFO = "info"
    DEBUG = "debug"
    SILLY = "silly"


class CertOptions9TypedDict(TypedDict):
    priv_key_path: str
    r"""Path to the private key to use. Key should be in PEM format. Can reference $ENV_VARS."""
    cert_path: str
    r"""Path to the certificate to use. Certificate should be in PEM format. Can reference $ENV_VARS."""
    certificate_name: NotRequired[str]
    r"""The name of the predefined certificate."""
    passphrase: NotRequired[str]
    r"""Passphrase to use to decrypt the private key."""


class CertOptions9(BaseModel):
    priv_key_path: Annotated[str, pydantic.Field(alias="privKeyPath")]
    r"""Path to the private key to use. Key should be in PEM format. Can reference $ENV_VARS."""

    cert_path: Annotated[str, pydantic.Field(alias="certPath")]
    r"""Path to the certificate to use. Certificate should be in PEM format. Can reference $ENV_VARS."""

    certificate_name: Annotated[
        Optional[str], pydantic.Field(alias="certificateName")
    ] = None
    r"""The name of the predefined certificate."""

    passphrase: Optional[str] = None
    r"""Passphrase to use to decrypt the private key."""


class InputOffice365MsgTraceOffice365MsgTrace9TypedDict(TypedDict):
    type: InputOffice365MsgTraceType9
    tenant_id: str
    r"""Directory ID (tenant identifier) in Azure Active Directory."""
    client_id: str
    r"""client_id to pass in the OAuth request parameter."""
    cert_options: CertOptions9TypedDict
    auth_type: NotRequired[InputOffice365MsgTraceAuthenticationMethod9]
    r"""Select authentication method."""
    id: NotRequired[str]
    r"""Unique ID for this input"""
    disabled: NotRequired[bool]
    pipeline: NotRequired[str]
    r"""Pipeline to process data from this Source before sending it through the Routes"""
    send_to_routes: NotRequired[bool]
    r"""Select whether to send data to Routes, or directly to Destinations."""
    environment: NotRequired[str]
    r"""Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere."""
    pq_enabled: NotRequired[bool]
    r"""Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers)."""
    streamtags: NotRequired[List[str]]
    r"""Tags for filtering and grouping in @{product}"""
    connections: NotRequired[List[ConnectionsTypeTypedDict]]
    r"""Direct connections to Destinations, and optionally via a Pipeline or a Pack"""
    pq: NotRequired[PqTypeTypedDict]
    url: NotRequired[str]
    r"""URL to use when retrieving report data."""
    interval: NotRequired[float]
    r"""How often (in minutes) to run the report. Must divide evenly into 60 minutes to create a predictable schedule, or Save will fail."""
    start_date: NotRequired[str]
    r"""Backward offset for the search range's head. (E.g.: -3h@h) Message Trace data is delayed; this parameter (with Date range end) compensates for delay and gaps."""
    end_date: NotRequired[str]
    r"""Backward offset for the search range's tail. (E.g.: -2h@h) Message Trace data is delayed; this parameter (with Date range start) compensates for delay and gaps."""
    timeout: NotRequired[float]
    r"""HTTP request inactivity timeout. Maximum is 2400 (40 minutes); enter 0 to wait indefinitely."""
    disable_time_filter: NotRequired[bool]
    r"""Disables time filtering of events when a date range is specified."""
    reschedule_dropped_tasks: NotRequired[bool]
    r"""Reschedule tasks that failed with non-fatal errors"""
    max_task_reschedule: NotRequired[float]
    r"""Maximum number of times a task can be rescheduled"""
    log_level: NotRequired[InputOffice365MsgTraceLogLevel9]
    r"""Log Level (verbosity) for collection runtime behavior."""
    job_timeout: NotRequired[str]
    r"""Maximum time the job is allowed to run (e.g., 30, 45s or 15m). Units are seconds, if not specified. Enter 0 for unlimited time."""
    keep_alive_time: NotRequired[float]
    r"""How often workers should check in with the scheduler to keep job subscription alive"""
    max_missed_keep_alives: NotRequired[float]
    r"""The number of Keep Alive Time periods before an inactive worker will have its job subscription revoked."""
    ttl: NotRequired[str]
    r"""Time to keep the job's artifacts on disk after job completion. This also affects how long a job is listed in the Job Inspector."""
    ignore_group_jobs_limit: NotRequired[bool]
    r"""When enabled, this job's artifacts are not counted toward the Worker Group's finished job artifacts limit. Artifacts will be removed only after the Collector's configured time to live."""
    metadata: NotRequired[List[Metadata1TypeTypedDict]]
    r"""Fields to add to events from this input"""
    retry_rules: NotRequired[RetryRulesTypeTypedDict]
    description: NotRequired[str]
    username: NotRequired[str]
    r"""Username to run Message Trace API call."""
    password: NotRequired[str]
    r"""Password to run Message Trace API call."""
    credentials_secret: NotRequired[str]
    r"""Select or create a secret that references your credentials."""
    client_secret: NotRequired[str]
    r"""client_secret to pass in the OAuth request parameter."""
    resource: NotRequired[str]
    r"""Resource to pass in the OAuth request parameter."""
    plan_type: NotRequired[PlanTypeOptions]
    r"""Office 365 subscription plan for your organization, typically Office 365 Enterprise"""
    text_secret: NotRequired[str]
    r"""Select or create a secret that references your client_secret to pass in the OAuth request parameter."""


class InputOffice365MsgTraceOffice365MsgTrace9(BaseModel):
    type: InputOffice365MsgTraceType9

    tenant_id: Annotated[str, pydantic.Field(alias="tenantId")]
    r"""Directory ID (tenant identifier) in Azure Active Directory."""

    client_id: Annotated[str, pydantic.Field(alias="clientId")]
    r"""client_id to pass in the OAuth request parameter."""

    cert_options: Annotated[CertOptions9, pydantic.Field(alias="certOptions")]

    auth_type: Annotated[
        Annotated[
            Optional[InputOffice365MsgTraceAuthenticationMethod9],
            PlainValidator(validate_open_enum(False)),
        ],
        pydantic.Field(alias="authType"),
    ] = InputOffice365MsgTraceAuthenticationMethod9.OAUTH
    r"""Select authentication method."""

    id: Optional[str] = None
    r"""Unique ID for this input"""

    disabled: Optional[bool] = False

    pipeline: Optional[str] = None
    r"""Pipeline to process data from this Source before sending it through the Routes"""

    send_to_routes: Annotated[Optional[bool], pydantic.Field(alias="sendToRoutes")] = (
        True
    )
    r"""Select whether to send data to Routes, or directly to Destinations."""

    environment: Optional[str] = None
    r"""Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere."""

    pq_enabled: Annotated[Optional[bool], pydantic.Field(alias="pqEnabled")] = False
    r"""Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers)."""

    streamtags: Optional[List[str]] = None
    r"""Tags for filtering and grouping in @{product}"""

    connections: Optional[List[ConnectionsType]] = None
    r"""Direct connections to Destinations, and optionally via a Pipeline or a Pack"""

    pq: Optional[PqType] = None

    url: Optional[str] = (
        "https://reports.office365.com/ecp/reportingwebservice/reporting.svc/MessageTrace"
    )
    r"""URL to use when retrieving report data."""

    interval: Optional[float] = 60
    r"""How often (in minutes) to run the report. Must divide evenly into 60 minutes to create a predictable schedule, or Save will fail."""

    start_date: Annotated[Optional[str], pydantic.Field(alias="startDate")] = None
    r"""Backward offset for the search range's head. (E.g.: -3h@h) Message Trace data is delayed; this parameter (with Date range end) compensates for delay and gaps."""

    end_date: Annotated[Optional[str], pydantic.Field(alias="endDate")] = None
    r"""Backward offset for the search range's tail. (E.g.: -2h@h) Message Trace data is delayed; this parameter (with Date range start) compensates for delay and gaps."""

    timeout: Optional[float] = 300
    r"""HTTP request inactivity timeout. Maximum is 2400 (40 minutes); enter 0 to wait indefinitely."""

    disable_time_filter: Annotated[
        Optional[bool], pydantic.Field(alias="disableTimeFilter")
    ] = True
    r"""Disables time filtering of events when a date range is specified."""

    reschedule_dropped_tasks: Annotated[
        Optional[bool], pydantic.Field(alias="rescheduleDroppedTasks")
    ] = True
    r"""Reschedule tasks that failed with non-fatal errors"""

    max_task_reschedule: Annotated[
        Optional[float], pydantic.Field(alias="maxTaskReschedule")
    ] = 1
    r"""Maximum number of times a task can be rescheduled"""

    log_level: Annotated[
        Annotated[
            Optional[InputOffice365MsgTraceLogLevel9],
            PlainValidator(validate_open_enum(False)),
        ],
        pydantic.Field(alias="logLevel"),
    ] = InputOffice365MsgTraceLogLevel9.INFO
    r"""Log Level (verbosity) for collection runtime behavior."""

    job_timeout: Annotated[Optional[str], pydantic.Field(alias="jobTimeout")] = "0"
    r"""Maximum time the job is allowed to run (e.g., 30, 45s or 15m). Units are seconds, if not specified. Enter 0 for unlimited time."""

    keep_alive_time: Annotated[
        Optional[float], pydantic.Field(alias="keepAliveTime")
    ] = 30
    r"""How often workers should check in with the scheduler to keep job subscription alive"""

    max_missed_keep_alives: Annotated[
        Optional[float], pydantic.Field(alias="maxMissedKeepAlives")
    ] = 3
    r"""The number of Keep Alive Time periods before an inactive worker will have its job subscription revoked."""

    ttl: Optional[str] = "4h"
    r"""Time to keep the job's artifacts on disk after job completion. This also affects how long a job is listed in the Job Inspector."""

    ignore_group_jobs_limit: Annotated[
        Optional[bool], pydantic.Field(alias="ignoreGroupJobsLimit")
    ] = False
    r"""When enabled, this job's artifacts are not counted toward the Worker Group's finished job artifacts limit. Artifacts will be removed only after the Collector's configured time to live."""

    metadata: Optional[List[Metadata1Type]] = None
    r"""Fields to add to events from this input"""

    retry_rules: Annotated[
        Optional[RetryRulesType], pydantic.Field(alias="retryRules")
    ] = None

    description: Optional[str] = None

    username: Optional[str] = None
    r"""Username to run Message Trace API call."""

    password: Optional[str] = None
    r"""Password to run Message Trace API call."""

    credentials_secret: Annotated[
        Optional[str], pydantic.Field(alias="credentialsSecret")
    ] = None
    r"""Select or create a secret that references your credentials."""

    client_secret: Annotated[Optional[str], pydantic.Field(alias="clientSecret")] = None
    r"""client_secret to pass in the OAuth request parameter."""

    resource: Optional[str] = "https://outlook.office365.com"
    r"""Resource to pass in the OAuth request parameter."""

    plan_type: Annotated[
        Annotated[Optional[PlanTypeOptions], PlainValidator(validate_open_enum(False))],
        pydantic.Field(alias="planType"),
    ] = PlanTypeOptions.ENTERPRISE_GCC
    r"""Office 365 subscription plan for your organization, typically Office 365 Enterprise"""

    text_secret: Annotated[Optional[str], pydantic.Field(alias="textSecret")] = None
    r"""Select or create a secret that references your client_secret to pass in the OAuth request parameter."""

    @field_serializer("auth_type")
    def serialize_auth_type(self, value):
        if isinstance(value, str):
            try:
                return models.InputOffice365MsgTraceAuthenticationMethod9(value)
            except ValueError:
                return value
        return value

    @field_serializer("log_level")
    def serialize_log_level(self, value):
        if isinstance(value, str):
            try:
                return models.InputOffice365MsgTraceLogLevel9(value)
            except ValueError:
                return value
        return value

    @field_serializer("plan_type")
    def serialize_plan_type(self, value):
        if isinstance(value, str):
            try:
                return models.PlanTypeOptions(value)
            except ValueError:
                return value
        return value


class InputOffice365MsgTraceAuthenticationMethod8(
    str, Enum, metaclass=utils.OpenEnumMeta
):
    r"""Select authentication method."""

    MANUAL = "manual"
    SECRET = "secret"
    OAUTH = "oauth"
    OAUTH_SECRET = "oauthSecret"
    OAUTH_CERT = "oauthCert"


class InputOffice365MsgTraceType8(str, Enum):
    OFFICE365_MSG_TRACE = "office365_msg_trace"


class InputOffice365MsgTraceLogLevel8(str, Enum, metaclass=utils.OpenEnumMeta):
    r"""Log Level (verbosity) for collection runtime behavior."""

    ERROR = "error"
    WARN = "warn"
    INFO = "info"
    DEBUG = "debug"
    SILLY = "silly"


class CertOptions8TypedDict(TypedDict):
    priv_key_path: str
    r"""Path to the private key to use. Key should be in PEM format. Can reference $ENV_VARS."""
    cert_path: str
    r"""Path to the certificate to use. Certificate should be in PEM format. Can reference $ENV_VARS."""
    certificate_name: NotRequired[str]
    r"""The name of the predefined certificate."""
    passphrase: NotRequired[str]
    r"""Passphrase to use to decrypt the private key."""


class CertOptions8(BaseModel):
    priv_key_path: Annotated[str, pydantic.Field(alias="privKeyPath")]
    r"""Path to the private key to use. Key should be in PEM format. Can reference $ENV_VARS."""

    cert_path: Annotated[str, pydantic.Field(alias="certPath")]
    r"""Path to the certificate to use. Certificate should be in PEM format. Can reference $ENV_VARS."""

    certificate_name: Annotated[
        Optional[str], pydantic.Field(alias="certificateName")
    ] = None
    r"""The name of the predefined certificate."""

    passphrase: Optional[str] = None
    r"""Passphrase to use to decrypt the private key."""


class InputOffice365MsgTraceOffice365MsgTrace8TypedDict(TypedDict):
    type: InputOffice365MsgTraceType8
    tenant_id: str
    r"""Directory ID (tenant identifier) in Azure Active Directory."""
    client_id: str
    r"""client_id to pass in the OAuth request parameter."""
    text_secret: str
    r"""Select or create a secret that references your client_secret to pass in the OAuth request parameter."""
    auth_type: NotRequired[InputOffice365MsgTraceAuthenticationMethod8]
    r"""Select authentication method."""
    id: NotRequired[str]
    r"""Unique ID for this input"""
    disabled: NotRequired[bool]
    pipeline: NotRequired[str]
    r"""Pipeline to process data from this Source before sending it through the Routes"""
    send_to_routes: NotRequired[bool]
    r"""Select whether to send data to Routes, or directly to Destinations."""
    environment: NotRequired[str]
    r"""Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere."""
    pq_enabled: NotRequired[bool]
    r"""Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers)."""
    streamtags: NotRequired[List[str]]
    r"""Tags for filtering and grouping in @{product}"""
    connections: NotRequired[List[ConnectionsTypeTypedDict]]
    r"""Direct connections to Destinations, and optionally via a Pipeline or a Pack"""
    pq: NotRequired[PqTypeTypedDict]
    url: NotRequired[str]
    r"""URL to use when retrieving report data."""
    interval: NotRequired[float]
    r"""How often (in minutes) to run the report. Must divide evenly into 60 minutes to create a predictable schedule, or Save will fail."""
    start_date: NotRequired[str]
    r"""Backward offset for the search range's head. (E.g.: -3h@h) Message Trace data is delayed; this parameter (with Date range end) compensates for delay and gaps."""
    end_date: NotRequired[str]
    r"""Backward offset for the search range's tail. (E.g.: -2h@h) Message Trace data is delayed; this parameter (with Date range start) compensates for delay and gaps."""
    timeout: NotRequired[float]
    r"""HTTP request inactivity timeout. Maximum is 2400 (40 minutes); enter 0 to wait indefinitely."""
    disable_time_filter: NotRequired[bool]
    r"""Disables time filtering of events when a date range is specified."""
    reschedule_dropped_tasks: NotRequired[bool]
    r"""Reschedule tasks that failed with non-fatal errors"""
    max_task_reschedule: NotRequired[float]
    r"""Maximum number of times a task can be rescheduled"""
    log_level: NotRequired[InputOffice365MsgTraceLogLevel8]
    r"""Log Level (verbosity) for collection runtime behavior."""
    job_timeout: NotRequired[str]
    r"""Maximum time the job is allowed to run (e.g., 30, 45s or 15m). Units are seconds, if not specified. Enter 0 for unlimited time."""
    keep_alive_time: NotRequired[float]
    r"""How often workers should check in with the scheduler to keep job subscription alive"""
    max_missed_keep_alives: NotRequired[float]
    r"""The number of Keep Alive Time periods before an inactive worker will have its job subscription revoked."""
    ttl: NotRequired[str]
    r"""Time to keep the job's artifacts on disk after job completion. This also affects how long a job is listed in the Job Inspector."""
    ignore_group_jobs_limit: NotRequired[bool]
    r"""When enabled, this job's artifacts are not counted toward the Worker Group's finished job artifacts limit. Artifacts will be removed only after the Collector's configured time to live."""
    metadata: NotRequired[List[Metadata1TypeTypedDict]]
    r"""Fields to add to events from this input"""
    retry_rules: NotRequired[RetryRulesTypeTypedDict]
    description: NotRequired[str]
    username: NotRequired[str]
    r"""Username to run Message Trace API call."""
    password: NotRequired[str]
    r"""Password to run Message Trace API call."""
    credentials_secret: NotRequired[str]
    r"""Select or create a secret that references your credentials."""
    client_secret: NotRequired[str]
    r"""client_secret to pass in the OAuth request parameter."""
    resource: NotRequired[str]
    r"""Resource to pass in the OAuth request parameter."""
    plan_type: NotRequired[PlanTypeOptions]
    r"""Office 365 subscription plan for your organization, typically Office 365 Enterprise"""
    cert_options: NotRequired[CertOptions8TypedDict]


class InputOffice365MsgTraceOffice365MsgTrace8(BaseModel):
    type: InputOffice365MsgTraceType8

    tenant_id: Annotated[str, pydantic.Field(alias="tenantId")]
    r"""Directory ID (tenant identifier) in Azure Active Directory."""

    client_id: Annotated[str, pydantic.Field(alias="clientId")]
    r"""client_id to pass in the OAuth request parameter."""

    text_secret: Annotated[str, pydantic.Field(alias="textSecret")]
    r"""Select or create a secret that references your client_secret to pass in the OAuth request parameter."""

    auth_type: Annotated[
        Annotated[
            Optional[InputOffice365MsgTraceAuthenticationMethod8],
            PlainValidator(validate_open_enum(False)),
        ],
        pydantic.Field(alias="authType"),
    ] = InputOffice365MsgTraceAuthenticationMethod8.OAUTH
    r"""Select authentication method."""

    id: Optional[str] = None
    r"""Unique ID for this input"""

    disabled: Optional[bool] = False

    pipeline: Optional[str] = None
    r"""Pipeline to process data from this Source before sending it through the Routes"""

    send_to_routes: Annotated[Optional[bool], pydantic.Field(alias="sendToRoutes")] = (
        True
    )
    r"""Select whether to send data to Routes, or directly to Destinations."""

    environment: Optional[str] = None
    r"""Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere."""

    pq_enabled: Annotated[Optional[bool], pydantic.Field(alias="pqEnabled")] = False
    r"""Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers)."""

    streamtags: Optional[List[str]] = None
    r"""Tags for filtering and grouping in @{product}"""

    connections: Optional[List[ConnectionsType]] = None
    r"""Direct connections to Destinations, and optionally via a Pipeline or a Pack"""

    pq: Optional[PqType] = None

    url: Optional[str] = (
        "https://reports.office365.com/ecp/reportingwebservice/reporting.svc/MessageTrace"
    )
    r"""URL to use when retrieving report data."""

    interval: Optional[float] = 60
    r"""How often (in minutes) to run the report. Must divide evenly into 60 minutes to create a predictable schedule, or Save will fail."""

    start_date: Annotated[Optional[str], pydantic.Field(alias="startDate")] = None
    r"""Backward offset for the search range's head. (E.g.: -3h@h) Message Trace data is delayed; this parameter (with Date range end) compensates for delay and gaps."""

    end_date: Annotated[Optional[str], pydantic.Field(alias="endDate")] = None
    r"""Backward offset for the search range's tail. (E.g.: -2h@h) Message Trace data is delayed; this parameter (with Date range start) compensates for delay and gaps."""

    timeout: Optional[float] = 300
    r"""HTTP request inactivity timeout. Maximum is 2400 (40 minutes); enter 0 to wait indefinitely."""

    disable_time_filter: Annotated[
        Optional[bool], pydantic.Field(alias="disableTimeFilter")
    ] = True
    r"""Disables time filtering of events when a date range is specified."""

    reschedule_dropped_tasks: Annotated[
        Optional[bool], pydantic.Field(alias="rescheduleDroppedTasks")
    ] = True
    r"""Reschedule tasks that failed with non-fatal errors"""

    max_task_reschedule: Annotated[
        Optional[float], pydantic.Field(alias="maxTaskReschedule")
    ] = 1
    r"""Maximum number of times a task can be rescheduled"""

    log_level: Annotated[
        Annotated[
            Optional[InputOffice365MsgTraceLogLevel8],
            PlainValidator(validate_open_enum(False)),
        ],
        pydantic.Field(alias="logLevel"),
    ] = InputOffice365MsgTraceLogLevel8.INFO
    r"""Log Level (verbosity) for collection runtime behavior."""

    job_timeout: Annotated[Optional[str], pydantic.Field(alias="jobTimeout")] = "0"
    r"""Maximum time the job is allowed to run (e.g., 30, 45s or 15m). Units are seconds, if not specified. Enter 0 for unlimited time."""

    keep_alive_time: Annotated[
        Optional[float], pydantic.Field(alias="keepAliveTime")
    ] = 30
    r"""How often workers should check in with the scheduler to keep job subscription alive"""

    max_missed_keep_alives: Annotated[
        Optional[float], pydantic.Field(alias="maxMissedKeepAlives")
    ] = 3
    r"""The number of Keep Alive Time periods before an inactive worker will have its job subscription revoked."""

    ttl: Optional[str] = "4h"
    r"""Time to keep the job's artifacts on disk after job completion. This also affects how long a job is listed in the Job Inspector."""

    ignore_group_jobs_limit: Annotated[
        Optional[bool], pydantic.Field(alias="ignoreGroupJobsLimit")
    ] = False
    r"""When enabled, this job's artifacts are not counted toward the Worker Group's finished job artifacts limit. Artifacts will be removed only after the Collector's configured time to live."""

    metadata: Optional[List[Metadata1Type]] = None
    r"""Fields to add to events from this input"""

    retry_rules: Annotated[
        Optional[RetryRulesType], pydantic.Field(alias="retryRules")
    ] = None

    description: Optional[str] = None

    username: Optional[str] = None
    r"""Username to run Message Trace API call."""

    password: Optional[str] = None
    r"""Password to run Message Trace API call."""

    credentials_secret: Annotated[
        Optional[str], pydantic.Field(alias="credentialsSecret")
    ] = None
    r"""Select or create a secret that references your credentials."""

    client_secret: Annotated[Optional[str], pydantic.Field(alias="clientSecret")] = None
    r"""client_secret to pass in the OAuth request parameter."""

    resource: Optional[str] = "https://outlook.office365.com"
    r"""Resource to pass in the OAuth request parameter."""

    plan_type: Annotated[
        Annotated[Optional[PlanTypeOptions], PlainValidator(validate_open_enum(False))],
        pydantic.Field(alias="planType"),
    ] = PlanTypeOptions.ENTERPRISE_GCC
    r"""Office 365 subscription plan for your organization, typically Office 365 Enterprise"""

    cert_options: Annotated[
        Optional[CertOptions8], pydantic.Field(alias="certOptions")
    ] = None

    @field_serializer("auth_type")
    def serialize_auth_type(self, value):
        if isinstance(value, str):
            try:
                return models.InputOffice365MsgTraceAuthenticationMethod8(value)
            except ValueError:
                return value
        return value

    @field_serializer("log_level")
    def serialize_log_level(self, value):
        if isinstance(value, str):
            try:
                return models.InputOffice365MsgTraceLogLevel8(value)
            except ValueError:
                return value
        return value

    @field_serializer("plan_type")
    def serialize_plan_type(self, value):
        if isinstance(value, str):
            try:
                return models.PlanTypeOptions(value)
            except ValueError:
                return value
        return value


class InputOffice365MsgTraceAuthenticationMethod7(
    str, Enum, metaclass=utils.OpenEnumMeta
):
    r"""Select authentication method."""

    MANUAL = "manual"
    SECRET = "secret"
    OAUTH = "oauth"
    OAUTH_SECRET = "oauthSecret"
    OAUTH_CERT = "oauthCert"


class InputOffice365MsgTraceType7(str, Enum):
    OFFICE365_MSG_TRACE = "office365_msg_trace"


class InputOffice365MsgTraceLogLevel7(str, Enum, metaclass=utils.OpenEnumMeta):
    r"""Log Level (verbosity) for collection runtime behavior."""

    ERROR = "error"
    WARN = "warn"
    INFO = "info"
    DEBUG = "debug"
    SILLY = "silly"


class CertOptions7TypedDict(TypedDict):
    priv_key_path: str
    r"""Path to the private key to use. Key should be in PEM format. Can reference $ENV_VARS."""
    cert_path: str
    r"""Path to the certificate to use. Certificate should be in PEM format. Can reference $ENV_VARS."""
    certificate_name: NotRequired[str]
    r"""The name of the predefined certificate."""
    passphrase: NotRequired[str]
    r"""Passphrase to use to decrypt the private key."""


class CertOptions7(BaseModel):
    priv_key_path: Annotated[str, pydantic.Field(alias="privKeyPath")]
    r"""Path to the private key to use. Key should be in PEM format. Can reference $ENV_VARS."""

    cert_path: Annotated[str, pydantic.Field(alias="certPath")]
    r"""Path to the certificate to use. Certificate should be in PEM format. Can reference $ENV_VARS."""

    certificate_name: Annotated[
        Optional[str], pydantic.Field(alias="certificateName")
    ] = None
    r"""The name of the predefined certificate."""

    passphrase: Optional[str] = None
    r"""Passphrase to use to decrypt the private key."""


class InputOffice365MsgTraceOffice365MsgTrace7TypedDict(TypedDict):
    type: InputOffice365MsgTraceType7
    client_secret: str
    r"""client_secret to pass in the OAuth request parameter."""
    tenant_id: str
    r"""Directory ID (tenant identifier) in Azure Active Directory."""
    client_id: str
    r"""client_id to pass in the OAuth request parameter."""
    auth_type: NotRequired[InputOffice365MsgTraceAuthenticationMethod7]
    r"""Select authentication method."""
    id: NotRequired[str]
    r"""Unique ID for this input"""
    disabled: NotRequired[bool]
    pipeline: NotRequired[str]
    r"""Pipeline to process data from this Source before sending it through the Routes"""
    send_to_routes: NotRequired[bool]
    r"""Select whether to send data to Routes, or directly to Destinations."""
    environment: NotRequired[str]
    r"""Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere."""
    pq_enabled: NotRequired[bool]
    r"""Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers)."""
    streamtags: NotRequired[List[str]]
    r"""Tags for filtering and grouping in @{product}"""
    connections: NotRequired[List[ConnectionsTypeTypedDict]]
    r"""Direct connections to Destinations, and optionally via a Pipeline or a Pack"""
    pq: NotRequired[PqTypeTypedDict]
    url: NotRequired[str]
    r"""URL to use when retrieving report data."""
    interval: NotRequired[float]
    r"""How often (in minutes) to run the report. Must divide evenly into 60 minutes to create a predictable schedule, or Save will fail."""
    start_date: NotRequired[str]
    r"""Backward offset for the search range's head. (E.g.: -3h@h) Message Trace data is delayed; this parameter (with Date range end) compensates for delay and gaps."""
    end_date: NotRequired[str]
    r"""Backward offset for the search range's tail. (E.g.: -2h@h) Message Trace data is delayed; this parameter (with Date range start) compensates for delay and gaps."""
    timeout: NotRequired[float]
    r"""HTTP request inactivity timeout. Maximum is 2400 (40 minutes); enter 0 to wait indefinitely."""
    disable_time_filter: NotRequired[bool]
    r"""Disables time filtering of events when a date range is specified."""
    reschedule_dropped_tasks: NotRequired[bool]
    r"""Reschedule tasks that failed with non-fatal errors"""
    max_task_reschedule: NotRequired[float]
    r"""Maximum number of times a task can be rescheduled"""
    log_level: NotRequired[InputOffice365MsgTraceLogLevel7]
    r"""Log Level (verbosity) for collection runtime behavior."""
    job_timeout: NotRequired[str]
    r"""Maximum time the job is allowed to run (e.g., 30, 45s or 15m). Units are seconds, if not specified. Enter 0 for unlimited time."""
    keep_alive_time: NotRequired[float]
    r"""How often workers should check in with the scheduler to keep job subscription alive"""
    max_missed_keep_alives: NotRequired[float]
    r"""The number of Keep Alive Time periods before an inactive worker will have its job subscription revoked."""
    ttl: NotRequired[str]
    r"""Time to keep the job's artifacts on disk after job completion. This also affects how long a job is listed in the Job Inspector."""
    ignore_group_jobs_limit: NotRequired[bool]
    r"""When enabled, this job's artifacts are not counted toward the Worker Group's finished job artifacts limit. Artifacts will be removed only after the Collector's configured time to live."""
    metadata: NotRequired[List[Metadata1TypeTypedDict]]
    r"""Fields to add to events from this input"""
    retry_rules: NotRequired[RetryRulesTypeTypedDict]
    description: NotRequired[str]
    username: NotRequired[str]
    r"""Username to run Message Trace API call."""
    password: NotRequired[str]
    r"""Password to run Message Trace API call."""
    credentials_secret: NotRequired[str]
    r"""Select or create a secret that references your credentials."""
    resource: NotRequired[str]
    r"""Resource to pass in the OAuth request parameter."""
    plan_type: NotRequired[PlanTypeOptions]
    r"""Office 365 subscription plan for your organization, typically Office 365 Enterprise"""
    text_secret: NotRequired[str]
    r"""Select or create a secret that references your client_secret to pass in the OAuth request parameter."""
    cert_options: NotRequired[CertOptions7TypedDict]


class InputOffice365MsgTraceOffice365MsgTrace7(BaseModel):
    type: InputOffice365MsgTraceType7

    client_secret: Annotated[str, pydantic.Field(alias="clientSecret")]
    r"""client_secret to pass in the OAuth request parameter."""

    tenant_id: Annotated[str, pydantic.Field(alias="tenantId")]
    r"""Directory ID (tenant identifier) in Azure Active Directory."""

    client_id: Annotated[str, pydantic.Field(alias="clientId")]
    r"""client_id to pass in the OAuth request parameter."""

    auth_type: Annotated[
        Annotated[
            Optional[InputOffice365MsgTraceAuthenticationMethod7],
            PlainValidator(validate_open_enum(False)),
        ],
        pydantic.Field(alias="authType"),
    ] = InputOffice365MsgTraceAuthenticationMethod7.OAUTH
    r"""Select authentication method."""

    id: Optional[str] = None
    r"""Unique ID for this input"""

    disabled: Optional[bool] = False

    pipeline: Optional[str] = None
    r"""Pipeline to process data from this Source before sending it through the Routes"""

    send_to_routes: Annotated[Optional[bool], pydantic.Field(alias="sendToRoutes")] = (
        True
    )
    r"""Select whether to send data to Routes, or directly to Destinations."""

    environment: Optional[str] = None
    r"""Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere."""

    pq_enabled: Annotated[Optional[bool], pydantic.Field(alias="pqEnabled")] = False
    r"""Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers)."""

    streamtags: Optional[List[str]] = None
    r"""Tags for filtering and grouping in @{product}"""

    connections: Optional[List[ConnectionsType]] = None
    r"""Direct connections to Destinations, and optionally via a Pipeline or a Pack"""

    pq: Optional[PqType] = None

    url: Optional[str] = (
        "https://reports.office365.com/ecp/reportingwebservice/reporting.svc/MessageTrace"
    )
    r"""URL to use when retrieving report data."""

    interval: Optional[float] = 60
    r"""How often (in minutes) to run the report. Must divide evenly into 60 minutes to create a predictable schedule, or Save will fail."""

    start_date: Annotated[Optional[str], pydantic.Field(alias="startDate")] = None
    r"""Backward offset for the search range's head. (E.g.: -3h@h) Message Trace data is delayed; this parameter (with Date range end) compensates for delay and gaps."""

    end_date: Annotated[Optional[str], pydantic.Field(alias="endDate")] = None
    r"""Backward offset for the search range's tail. (E.g.: -2h@h) Message Trace data is delayed; this parameter (with Date range start) compensates for delay and gaps."""

    timeout: Optional[float] = 300
    r"""HTTP request inactivity timeout. Maximum is 2400 (40 minutes); enter 0 to wait indefinitely."""

    disable_time_filter: Annotated[
        Optional[bool], pydantic.Field(alias="disableTimeFilter")
    ] = True
    r"""Disables time filtering of events when a date range is specified."""

    reschedule_dropped_tasks: Annotated[
        Optional[bool], pydantic.Field(alias="rescheduleDroppedTasks")
    ] = True
    r"""Reschedule tasks that failed with non-fatal errors"""

    max_task_reschedule: Annotated[
        Optional[float], pydantic.Field(alias="maxTaskReschedule")
    ] = 1
    r"""Maximum number of times a task can be rescheduled"""

    log_level: Annotated[
        Annotated[
            Optional[InputOffice365MsgTraceLogLevel7],
            PlainValidator(validate_open_enum(False)),
        ],
        pydantic.Field(alias="logLevel"),
    ] = InputOffice365MsgTraceLogLevel7.INFO
    r"""Log Level (verbosity) for collection runtime behavior."""

    job_timeout: Annotated[Optional[str], pydantic.Field(alias="jobTimeout")] = "0"
    r"""Maximum time the job is allowed to run (e.g., 30, 45s or 15m). Units are seconds, if not specified. Enter 0 for unlimited time."""

    keep_alive_time: Annotated[
        Optional[float], pydantic.Field(alias="keepAliveTime")
    ] = 30
    r"""How often workers should check in with the scheduler to keep job subscription alive"""

    max_missed_keep_alives: Annotated[
        Optional[float], pydantic.Field(alias="maxMissedKeepAlives")
    ] = 3
    r"""The number of Keep Alive Time periods before an inactive worker will have its job subscription revoked."""

    ttl: Optional[str] = "4h"
    r"""Time to keep the job's artifacts on disk after job completion. This also affects how long a job is listed in the Job Inspector."""

    ignore_group_jobs_limit: Annotated[
        Optional[bool], pydantic.Field(alias="ignoreGroupJobsLimit")
    ] = False
    r"""When enabled, this job's artifacts are not counted toward the Worker Group's finished job artifacts limit. Artifacts will be removed only after the Collector's configured time to live."""

    metadata: Optional[List[Metadata1Type]] = None
    r"""Fields to add to events from this input"""

    retry_rules: Annotated[
        Optional[RetryRulesType], pydantic.Field(alias="retryRules")
    ] = None

    description: Optional[str] = None

    username: Optional[str] = None
    r"""Username to run Message Trace API call."""

    password: Optional[str] = None
    r"""Password to run Message Trace API call."""

    credentials_secret: Annotated[
        Optional[str], pydantic.Field(alias="credentialsSecret")
    ] = None
    r"""Select or create a secret that references your credentials."""

    resource: Optional[str] = "https://outlook.office365.com"
    r"""Resource to pass in the OAuth request parameter."""

    plan_type: Annotated[
        Annotated[Optional[PlanTypeOptions], PlainValidator(validate_open_enum(False))],
        pydantic.Field(alias="planType"),
    ] = PlanTypeOptions.ENTERPRISE_GCC
    r"""Office 365 subscription plan for your organization, typically Office 365 Enterprise"""

    text_secret: Annotated[Optional[str], pydantic.Field(alias="textSecret")] = None
    r"""Select or create a secret that references your client_secret to pass in the OAuth request parameter."""

    cert_options: Annotated[
        Optional[CertOptions7], pydantic.Field(alias="certOptions")
    ] = None

    @field_serializer("auth_type")
    def serialize_auth_type(self, value):
        if isinstance(value, str):
            try:
                return models.InputOffice365MsgTraceAuthenticationMethod7(value)
            except ValueError:
                return value
        return value

    @field_serializer("log_level")
    def serialize_log_level(self, value):
        if isinstance(value, str):
            try:
                return models.InputOffice365MsgTraceLogLevel7(value)
            except ValueError:
                return value
        return value

    @field_serializer("plan_type")
    def serialize_plan_type(self, value):
        if isinstance(value, str):
            try:
                return models.PlanTypeOptions(value)
            except ValueError:
                return value
        return value


class InputOffice365MsgTraceAuthenticationMethod6(
    str, Enum, metaclass=utils.OpenEnumMeta
):
    r"""Select authentication method."""

    MANUAL = "manual"
    SECRET = "secret"
    OAUTH = "oauth"
    OAUTH_SECRET = "oauthSecret"
    OAUTH_CERT = "oauthCert"


class InputOffice365MsgTraceType6(str, Enum):
    OFFICE365_MSG_TRACE = "office365_msg_trace"


class InputOffice365MsgTraceLogLevel6(str, Enum, metaclass=utils.OpenEnumMeta):
    r"""Log Level (verbosity) for collection runtime behavior."""

    ERROR = "error"
    WARN = "warn"
    INFO = "info"
    DEBUG = "debug"
    SILLY = "silly"


class CertOptions6TypedDict(TypedDict):
    priv_key_path: str
    r"""Path to the private key to use. Key should be in PEM format. Can reference $ENV_VARS."""
    cert_path: str
    r"""Path to the certificate to use. Certificate should be in PEM format. Can reference $ENV_VARS."""
    certificate_name: NotRequired[str]
    r"""The name of the predefined certificate."""
    passphrase: NotRequired[str]
    r"""Passphrase to use to decrypt the private key."""


class CertOptions6(BaseModel):
    priv_key_path: Annotated[str, pydantic.Field(alias="privKeyPath")]
    r"""Path to the private key to use. Key should be in PEM format. Can reference $ENV_VARS."""

    cert_path: Annotated[str, pydantic.Field(alias="certPath")]
    r"""Path to the certificate to use. Certificate should be in PEM format. Can reference $ENV_VARS."""

    certificate_name: Annotated[
        Optional[str], pydantic.Field(alias="certificateName")
    ] = None
    r"""The name of the predefined certificate."""

    passphrase: Optional[str] = None
    r"""Passphrase to use to decrypt the private key."""


class InputOffice365MsgTraceOffice365MsgTrace6TypedDict(TypedDict):
    type: InputOffice365MsgTraceType6
    credentials_secret: str
    r"""Select or create a secret that references your credentials."""
    auth_type: NotRequired[InputOffice365MsgTraceAuthenticationMethod6]
    r"""Select authentication method."""
    id: NotRequired[str]
    r"""Unique ID for this input"""
    disabled: NotRequired[bool]
    pipeline: NotRequired[str]
    r"""Pipeline to process data from this Source before sending it through the Routes"""
    send_to_routes: NotRequired[bool]
    r"""Select whether to send data to Routes, or directly to Destinations."""
    environment: NotRequired[str]
    r"""Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere."""
    pq_enabled: NotRequired[bool]
    r"""Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers)."""
    streamtags: NotRequired[List[str]]
    r"""Tags for filtering and grouping in @{product}"""
    connections: NotRequired[List[ConnectionsTypeTypedDict]]
    r"""Direct connections to Destinations, and optionally via a Pipeline or a Pack"""
    pq: NotRequired[PqTypeTypedDict]
    url: NotRequired[str]
    r"""URL to use when retrieving report data."""
    interval: NotRequired[float]
    r"""How often (in minutes) to run the report. Must divide evenly into 60 minutes to create a predictable schedule, or Save will fail."""
    start_date: NotRequired[str]
    r"""Backward offset for the search range's head. (E.g.: -3h@h) Message Trace data is delayed; this parameter (with Date range end) compensates for delay and gaps."""
    end_date: NotRequired[str]
    r"""Backward offset for the search range's tail. (E.g.: -2h@h) Message Trace data is delayed; this parameter (with Date range start) compensates for delay and gaps."""
    timeout: NotRequired[float]
    r"""HTTP request inactivity timeout. Maximum is 2400 (40 minutes); enter 0 to wait indefinitely."""
    disable_time_filter: NotRequired[bool]
    r"""Disables time filtering of events when a date range is specified."""
    reschedule_dropped_tasks: NotRequired[bool]
    r"""Reschedule tasks that failed with non-fatal errors"""
    max_task_reschedule: NotRequired[float]
    r"""Maximum number of times a task can be rescheduled"""
    log_level: NotRequired[InputOffice365MsgTraceLogLevel6]
    r"""Log Level (verbosity) for collection runtime behavior."""
    job_timeout: NotRequired[str]
    r"""Maximum time the job is allowed to run (e.g., 30, 45s or 15m). Units are seconds, if not specified. Enter 0 for unlimited time."""
    keep_alive_time: NotRequired[float]
    r"""How often workers should check in with the scheduler to keep job subscription alive"""
    max_missed_keep_alives: NotRequired[float]
    r"""The number of Keep Alive Time periods before an inactive worker will have its job subscription revoked."""
    ttl: NotRequired[str]
    r"""Time to keep the job's artifacts on disk after job completion. This also affects how long a job is listed in the Job Inspector."""
    ignore_group_jobs_limit: NotRequired[bool]
    r"""When enabled, this job's artifacts are not counted toward the Worker Group's finished job artifacts limit. Artifacts will be removed only after the Collector's configured time to live."""
    metadata: NotRequired[List[Metadata1TypeTypedDict]]
    r"""Fields to add to events from this input"""
    retry_rules: NotRequired[RetryRulesTypeTypedDict]
    description: NotRequired[str]
    username: NotRequired[str]
    r"""Username to run Message Trace API call."""
    password: NotRequired[str]
    r"""Password to run Message Trace API call."""
    client_secret: NotRequired[str]
    r"""client_secret to pass in the OAuth request parameter."""
    tenant_id: NotRequired[str]
    r"""Directory ID (tenant identifier) in Azure Active Directory."""
    client_id: NotRequired[str]
    r"""client_id to pass in the OAuth request parameter."""
    resource: NotRequired[str]
    r"""Resource to pass in the OAuth request parameter."""
    plan_type: NotRequired[PlanTypeOptions]
    r"""Office 365 subscription plan for your organization, typically Office 365 Enterprise"""
    text_secret: NotRequired[str]
    r"""Select or create a secret that references your client_secret to pass in the OAuth request parameter."""
    cert_options: NotRequired[CertOptions6TypedDict]


class InputOffice365MsgTraceOffice365MsgTrace6(BaseModel):
    type: InputOffice365MsgTraceType6

    credentials_secret: Annotated[str, pydantic.Field(alias="credentialsSecret")]
    r"""Select or create a secret that references your credentials."""

    auth_type: Annotated[
        Annotated[
            Optional[InputOffice365MsgTraceAuthenticationMethod6],
            PlainValidator(validate_open_enum(False)),
        ],
        pydantic.Field(alias="authType"),
    ] = InputOffice365MsgTraceAuthenticationMethod6.OAUTH
    r"""Select authentication method."""

    id: Optional[str] = None
    r"""Unique ID for this input"""

    disabled: Optional[bool] = False

    pipeline: Optional[str] = None
    r"""Pipeline to process data from this Source before sending it through the Routes"""

    send_to_routes: Annotated[Optional[bool], pydantic.Field(alias="sendToRoutes")] = (
        True
    )
    r"""Select whether to send data to Routes, or directly to Destinations."""

    environment: Optional[str] = None
    r"""Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere."""

    pq_enabled: Annotated[Optional[bool], pydantic.Field(alias="pqEnabled")] = False
    r"""Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers)."""

    streamtags: Optional[List[str]] = None
    r"""Tags for filtering and grouping in @{product}"""

    connections: Optional[List[ConnectionsType]] = None
    r"""Direct connections to Destinations, and optionally via a Pipeline or a Pack"""

    pq: Optional[PqType] = None

    url: Optional[str] = (
        "https://reports.office365.com/ecp/reportingwebservice/reporting.svc/MessageTrace"
    )
    r"""URL to use when retrieving report data."""

    interval: Optional[float] = 60
    r"""How often (in minutes) to run the report. Must divide evenly into 60 minutes to create a predictable schedule, or Save will fail."""

    start_date: Annotated[Optional[str], pydantic.Field(alias="startDate")] = None
    r"""Backward offset for the search range's head. (E.g.: -3h@h) Message Trace data is delayed; this parameter (with Date range end) compensates for delay and gaps."""

    end_date: Annotated[Optional[str], pydantic.Field(alias="endDate")] = None
    r"""Backward offset for the search range's tail. (E.g.: -2h@h) Message Trace data is delayed; this parameter (with Date range start) compensates for delay and gaps."""

    timeout: Optional[float] = 300
    r"""HTTP request inactivity timeout. Maximum is 2400 (40 minutes); enter 0 to wait indefinitely."""

    disable_time_filter: Annotated[
        Optional[bool], pydantic.Field(alias="disableTimeFilter")
    ] = True
    r"""Disables time filtering of events when a date range is specified."""

    reschedule_dropped_tasks: Annotated[
        Optional[bool], pydantic.Field(alias="rescheduleDroppedTasks")
    ] = True
    r"""Reschedule tasks that failed with non-fatal errors"""

    max_task_reschedule: Annotated[
        Optional[float], pydantic.Field(alias="maxTaskReschedule")
    ] = 1
    r"""Maximum number of times a task can be rescheduled"""

    log_level: Annotated[
        Annotated[
            Optional[InputOffice365MsgTraceLogLevel6],
            PlainValidator(validate_open_enum(False)),
        ],
        pydantic.Field(alias="logLevel"),
    ] = InputOffice365MsgTraceLogLevel6.INFO
    r"""Log Level (verbosity) for collection runtime behavior."""

    job_timeout: Annotated[Optional[str], pydantic.Field(alias="jobTimeout")] = "0"
    r"""Maximum time the job is allowed to run (e.g., 30, 45s or 15m). Units are seconds, if not specified. Enter 0 for unlimited time."""

    keep_alive_time: Annotated[
        Optional[float], pydantic.Field(alias="keepAliveTime")
    ] = 30
    r"""How often workers should check in with the scheduler to keep job subscription alive"""

    max_missed_keep_alives: Annotated[
        Optional[float], pydantic.Field(alias="maxMissedKeepAlives")
    ] = 3
    r"""The number of Keep Alive Time periods before an inactive worker will have its job subscription revoked."""

    ttl: Optional[str] = "4h"
    r"""Time to keep the job's artifacts on disk after job completion. This also affects how long a job is listed in the Job Inspector."""

    ignore_group_jobs_limit: Annotated[
        Optional[bool], pydantic.Field(alias="ignoreGroupJobsLimit")
    ] = False
    r"""When enabled, this job's artifacts are not counted toward the Worker Group's finished job artifacts limit. Artifacts will be removed only after the Collector's configured time to live."""

    metadata: Optional[List[Metadata1Type]] = None
    r"""Fields to add to events from this input"""

    retry_rules: Annotated[
        Optional[RetryRulesType], pydantic.Field(alias="retryRules")
    ] = None

    description: Optional[str] = None

    username: Optional[str] = None
    r"""Username to run Message Trace API call."""

    password: Optional[str] = None
    r"""Password to run Message Trace API call."""

    client_secret: Annotated[Optional[str], pydantic.Field(alias="clientSecret")] = None
    r"""client_secret to pass in the OAuth request parameter."""

    tenant_id: Annotated[Optional[str], pydantic.Field(alias="tenantId")] = None
    r"""Directory ID (tenant identifier) in Azure Active Directory."""

    client_id: Annotated[Optional[str], pydantic.Field(alias="clientId")] = None
    r"""client_id to pass in the OAuth request parameter."""

    resource: Optional[str] = "https://outlook.office365.com"
    r"""Resource to pass in the OAuth request parameter."""

    plan_type: Annotated[
        Annotated[Optional[PlanTypeOptions], PlainValidator(validate_open_enum(False))],
        pydantic.Field(alias="planType"),
    ] = PlanTypeOptions.ENTERPRISE_GCC
    r"""Office 365 subscription plan for your organization, typically Office 365 Enterprise"""

    text_secret: Annotated[Optional[str], pydantic.Field(alias="textSecret")] = None
    r"""Select or create a secret that references your client_secret to pass in the OAuth request parameter."""

    cert_options: Annotated[
        Optional[CertOptions6], pydantic.Field(alias="certOptions")
    ] = None

    @field_serializer("auth_type")
    def serialize_auth_type(self, value):
        if isinstance(value, str):
            try:
                return models.InputOffice365MsgTraceAuthenticationMethod6(value)
            except ValueError:
                return value
        return value

    @field_serializer("log_level")
    def serialize_log_level(self, value):
        if isinstance(value, str):
            try:
                return models.InputOffice365MsgTraceLogLevel6(value)
            except ValueError:
                return value
        return value

    @field_serializer("plan_type")
    def serialize_plan_type(self, value):
        if isinstance(value, str):
            try:
                return models.PlanTypeOptions(value)
            except ValueError:
                return value
        return value


class InputOffice365MsgTraceAuthenticationMethod5(
    str, Enum, metaclass=utils.OpenEnumMeta
):
    r"""Select authentication method."""

    MANUAL = "manual"
    SECRET = "secret"
    OAUTH = "oauth"
    OAUTH_SECRET = "oauthSecret"
    OAUTH_CERT = "oauthCert"


class InputOffice365MsgTraceType5(str, Enum):
    OFFICE365_MSG_TRACE = "office365_msg_trace"


class InputOffice365MsgTraceLogLevel5(str, Enum, metaclass=utils.OpenEnumMeta):
    r"""Log Level (verbosity) for collection runtime behavior."""

    ERROR = "error"
    WARN = "warn"
    INFO = "info"
    DEBUG = "debug"
    SILLY = "silly"


class CertOptions5TypedDict(TypedDict):
    priv_key_path: str
    r"""Path to the private key to use. Key should be in PEM format. Can reference $ENV_VARS."""
    cert_path: str
    r"""Path to the certificate to use. Certificate should be in PEM format. Can reference $ENV_VARS."""
    certificate_name: NotRequired[str]
    r"""The name of the predefined certificate."""
    passphrase: NotRequired[str]
    r"""Passphrase to use to decrypt the private key."""


class CertOptions5(BaseModel):
    priv_key_path: Annotated[str, pydantic.Field(alias="privKeyPath")]
    r"""Path to the private key to use. Key should be in PEM format. Can reference $ENV_VARS."""

    cert_path: Annotated[str, pydantic.Field(alias="certPath")]
    r"""Path to the certificate to use. Certificate should be in PEM format. Can reference $ENV_VARS."""

    certificate_name: Annotated[
        Optional[str], pydantic.Field(alias="certificateName")
    ] = None
    r"""The name of the predefined certificate."""

    passphrase: Optional[str] = None
    r"""Passphrase to use to decrypt the private key."""


class InputOffice365MsgTraceOffice365MsgTrace5TypedDict(TypedDict):
    type: InputOffice365MsgTraceType5
    username: str
    r"""Username to run Message Trace API call."""
    password: str
    r"""Password to run Message Trace API call."""
    auth_type: NotRequired[InputOffice365MsgTraceAuthenticationMethod5]
    r"""Select authentication method."""
    id: NotRequired[str]
    r"""Unique ID for this input"""
    disabled: NotRequired[bool]
    pipeline: NotRequired[str]
    r"""Pipeline to process data from this Source before sending it through the Routes"""
    send_to_routes: NotRequired[bool]
    r"""Select whether to send data to Routes, or directly to Destinations."""
    environment: NotRequired[str]
    r"""Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere."""
    pq_enabled: NotRequired[bool]
    r"""Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers)."""
    streamtags: NotRequired[List[str]]
    r"""Tags for filtering and grouping in @{product}"""
    connections: NotRequired[List[ConnectionsTypeTypedDict]]
    r"""Direct connections to Destinations, and optionally via a Pipeline or a Pack"""
    pq: NotRequired[PqTypeTypedDict]
    url: NotRequired[str]
    r"""URL to use when retrieving report data."""
    interval: NotRequired[float]
    r"""How often (in minutes) to run the report. Must divide evenly into 60 minutes to create a predictable schedule, or Save will fail."""
    start_date: NotRequired[str]
    r"""Backward offset for the search range's head. (E.g.: -3h@h) Message Trace data is delayed; this parameter (with Date range end) compensates for delay and gaps."""
    end_date: NotRequired[str]
    r"""Backward offset for the search range's tail. (E.g.: -2h@h) Message Trace data is delayed; this parameter (with Date range start) compensates for delay and gaps."""
    timeout: NotRequired[float]
    r"""HTTP request inactivity timeout. Maximum is 2400 (40 minutes); enter 0 to wait indefinitely."""
    disable_time_filter: NotRequired[bool]
    r"""Disables time filtering of events when a date range is specified."""
    reschedule_dropped_tasks: NotRequired[bool]
    r"""Reschedule tasks that failed with non-fatal errors"""
    max_task_reschedule: NotRequired[float]
    r"""Maximum number of times a task can be rescheduled"""
    log_level: NotRequired[InputOffice365MsgTraceLogLevel5]
    r"""Log Level (verbosity) for collection runtime behavior."""
    job_timeout: NotRequired[str]
    r"""Maximum time the job is allowed to run (e.g., 30, 45s or 15m). Units are seconds, if not specified. Enter 0 for unlimited time."""
    keep_alive_time: NotRequired[float]
    r"""How often workers should check in with the scheduler to keep job subscription alive"""
    max_missed_keep_alives: NotRequired[float]
    r"""The number of Keep Alive Time periods before an inactive worker will have its job subscription revoked."""
    ttl: NotRequired[str]
    r"""Time to keep the job's artifacts on disk after job completion. This also affects how long a job is listed in the Job Inspector."""
    ignore_group_jobs_limit: NotRequired[bool]
    r"""When enabled, this job's artifacts are not counted toward the Worker Group's finished job artifacts limit. Artifacts will be removed only after the Collector's configured time to live."""
    metadata: NotRequired[List[Metadata1TypeTypedDict]]
    r"""Fields to add to events from this input"""
    retry_rules: NotRequired[RetryRulesTypeTypedDict]
    description: NotRequired[str]
    credentials_secret: NotRequired[str]
    r"""Select or create a secret that references your credentials."""
    client_secret: NotRequired[str]
    r"""client_secret to pass in the OAuth request parameter."""
    tenant_id: NotRequired[str]
    r"""Directory ID (tenant identifier) in Azure Active Directory."""
    client_id: NotRequired[str]
    r"""client_id to pass in the OAuth request parameter."""
    resource: NotRequired[str]
    r"""Resource to pass in the OAuth request parameter."""
    plan_type: NotRequired[PlanTypeOptions]
    r"""Office 365 subscription plan for your organization, typically Office 365 Enterprise"""
    text_secret: NotRequired[str]
    r"""Select or create a secret that references your client_secret to pass in the OAuth request parameter."""
    cert_options: NotRequired[CertOptions5TypedDict]


class InputOffice365MsgTraceOffice365MsgTrace5(BaseModel):
    type: InputOffice365MsgTraceType5

    username: str
    r"""Username to run Message Trace API call."""

    password: str
    r"""Password to run Message Trace API call."""

    auth_type: Annotated[
        Annotated[
            Optional[InputOffice365MsgTraceAuthenticationMethod5],
            PlainValidator(validate_open_enum(False)),
        ],
        pydantic.Field(alias="authType"),
    ] = InputOffice365MsgTraceAuthenticationMethod5.OAUTH
    r"""Select authentication method."""

    id: Optional[str] = None
    r"""Unique ID for this input"""

    disabled: Optional[bool] = False

    pipeline: Optional[str] = None
    r"""Pipeline to process data from this Source before sending it through the Routes"""

    send_to_routes: Annotated[Optional[bool], pydantic.Field(alias="sendToRoutes")] = (
        True
    )
    r"""Select whether to send data to Routes, or directly to Destinations."""

    environment: Optional[str] = None
    r"""Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere."""

    pq_enabled: Annotated[Optional[bool], pydantic.Field(alias="pqEnabled")] = False
    r"""Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers)."""

    streamtags: Optional[List[str]] = None
    r"""Tags for filtering and grouping in @{product}"""

    connections: Optional[List[ConnectionsType]] = None
    r"""Direct connections to Destinations, and optionally via a Pipeline or a Pack"""

    pq: Optional[PqType] = None

    url: Optional[str] = (
        "https://reports.office365.com/ecp/reportingwebservice/reporting.svc/MessageTrace"
    )
    r"""URL to use when retrieving report data."""

    interval: Optional[float] = 60
    r"""How often (in minutes) to run the report. Must divide evenly into 60 minutes to create a predictable schedule, or Save will fail."""

    start_date: Annotated[Optional[str], pydantic.Field(alias="startDate")] = None
    r"""Backward offset for the search range's head. (E.g.: -3h@h) Message Trace data is delayed; this parameter (with Date range end) compensates for delay and gaps."""

    end_date: Annotated[Optional[str], pydantic.Field(alias="endDate")] = None
    r"""Backward offset for the search range's tail. (E.g.: -2h@h) Message Trace data is delayed; this parameter (with Date range start) compensates for delay and gaps."""

    timeout: Optional[float] = 300
    r"""HTTP request inactivity timeout. Maximum is 2400 (40 minutes); enter 0 to wait indefinitely."""

    disable_time_filter: Annotated[
        Optional[bool], pydantic.Field(alias="disableTimeFilter")
    ] = True
    r"""Disables time filtering of events when a date range is specified."""

    reschedule_dropped_tasks: Annotated[
        Optional[bool], pydantic.Field(alias="rescheduleDroppedTasks")
    ] = True
    r"""Reschedule tasks that failed with non-fatal errors"""

    max_task_reschedule: Annotated[
        Optional[float], pydantic.Field(alias="maxTaskReschedule")
    ] = 1
    r"""Maximum number of times a task can be rescheduled"""

    log_level: Annotated[
        Annotated[
            Optional[InputOffice365MsgTraceLogLevel5],
            PlainValidator(validate_open_enum(False)),
        ],
        pydantic.Field(alias="logLevel"),
    ] = InputOffice365MsgTraceLogLevel5.INFO
    r"""Log Level (verbosity) for collection runtime behavior."""

    job_timeout: Annotated[Optional[str], pydantic.Field(alias="jobTimeout")] = "0"
    r"""Maximum time the job is allowed to run (e.g., 30, 45s or 15m). Units are seconds, if not specified. Enter 0 for unlimited time."""

    keep_alive_time: Annotated[
        Optional[float], pydantic.Field(alias="keepAliveTime")
    ] = 30
    r"""How often workers should check in with the scheduler to keep job subscription alive"""

    max_missed_keep_alives: Annotated[
        Optional[float], pydantic.Field(alias="maxMissedKeepAlives")
    ] = 3
    r"""The number of Keep Alive Time periods before an inactive worker will have its job subscription revoked."""

    ttl: Optional[str] = "4h"
    r"""Time to keep the job's artifacts on disk after job completion. This also affects how long a job is listed in the Job Inspector."""

    ignore_group_jobs_limit: Annotated[
        Optional[bool], pydantic.Field(alias="ignoreGroupJobsLimit")
    ] = False
    r"""When enabled, this job's artifacts are not counted toward the Worker Group's finished job artifacts limit. Artifacts will be removed only after the Collector's configured time to live."""

    metadata: Optional[List[Metadata1Type]] = None
    r"""Fields to add to events from this input"""

    retry_rules: Annotated[
        Optional[RetryRulesType], pydantic.Field(alias="retryRules")
    ] = None

    description: Optional[str] = None

    credentials_secret: Annotated[
        Optional[str], pydantic.Field(alias="credentialsSecret")
    ] = None
    r"""Select or create a secret that references your credentials."""

    client_secret: Annotated[Optional[str], pydantic.Field(alias="clientSecret")] = None
    r"""client_secret to pass in the OAuth request parameter."""

    tenant_id: Annotated[Optional[str], pydantic.Field(alias="tenantId")] = None
    r"""Directory ID (tenant identifier) in Azure Active Directory."""

    client_id: Annotated[Optional[str], pydantic.Field(alias="clientId")] = None
    r"""client_id to pass in the OAuth request parameter."""

    resource: Optional[str] = "https://outlook.office365.com"
    r"""Resource to pass in the OAuth request parameter."""

    plan_type: Annotated[
        Annotated[Optional[PlanTypeOptions], PlainValidator(validate_open_enum(False))],
        pydantic.Field(alias="planType"),
    ] = PlanTypeOptions.ENTERPRISE_GCC
    r"""Office 365 subscription plan for your organization, typically Office 365 Enterprise"""

    text_secret: Annotated[Optional[str], pydantic.Field(alias="textSecret")] = None
    r"""Select or create a secret that references your client_secret to pass in the OAuth request parameter."""

    cert_options: Annotated[
        Optional[CertOptions5], pydantic.Field(alias="certOptions")
    ] = None

    @field_serializer("auth_type")
    def serialize_auth_type(self, value):
        if isinstance(value, str):
            try:
                return models.InputOffice365MsgTraceAuthenticationMethod5(value)
            except ValueError:
                return value
        return value

    @field_serializer("log_level")
    def serialize_log_level(self, value):
        if isinstance(value, str):
            try:
                return models.InputOffice365MsgTraceLogLevel5(value)
            except ValueError:
                return value
        return value

    @field_serializer("plan_type")
    def serialize_plan_type(self, value):
        if isinstance(value, str):
            try:
                return models.PlanTypeOptions(value)
            except ValueError:
                return value
        return value


class InputOffice365MsgTraceType4(str, Enum):
    OFFICE365_MSG_TRACE = "office365_msg_trace"


class InputOffice365MsgTraceAuthenticationMethod4(
    str, Enum, metaclass=utils.OpenEnumMeta
):
    r"""Select authentication method."""

    MANUAL = "manual"
    SECRET = "secret"
    OAUTH = "oauth"
    OAUTH_SECRET = "oauthSecret"
    OAUTH_CERT = "oauthCert"


class InputOffice365MsgTraceLogLevel4(str, Enum, metaclass=utils.OpenEnumMeta):
    r"""Log Level (verbosity) for collection runtime behavior."""

    ERROR = "error"
    WARN = "warn"
    INFO = "info"
    DEBUG = "debug"
    SILLY = "silly"


class CertOptions4TypedDict(TypedDict):
    priv_key_path: str
    r"""Path to the private key to use. Key should be in PEM format. Can reference $ENV_VARS."""
    cert_path: str
    r"""Path to the certificate to use. Certificate should be in PEM format. Can reference $ENV_VARS."""
    certificate_name: NotRequired[str]
    r"""The name of the predefined certificate."""
    passphrase: NotRequired[str]
    r"""Passphrase to use to decrypt the private key."""


class CertOptions4(BaseModel):
    priv_key_path: Annotated[str, pydantic.Field(alias="privKeyPath")]
    r"""Path to the private key to use. Key should be in PEM format. Can reference $ENV_VARS."""

    cert_path: Annotated[str, pydantic.Field(alias="certPath")]
    r"""Path to the certificate to use. Certificate should be in PEM format. Can reference $ENV_VARS."""

    certificate_name: Annotated[
        Optional[str], pydantic.Field(alias="certificateName")
    ] = None
    r"""The name of the predefined certificate."""

    passphrase: Optional[str] = None
    r"""Passphrase to use to decrypt the private key."""


class InputOffice365MsgTraceOffice365MsgTrace4TypedDict(TypedDict):
    type: InputOffice365MsgTraceType4
    pq: PqTypeTypedDict
    pq_enabled: NotRequired[bool]
    r"""Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers)."""
    id: NotRequired[str]
    r"""Unique ID for this input"""
    disabled: NotRequired[bool]
    pipeline: NotRequired[str]
    r"""Pipeline to process data from this Source before sending it through the Routes"""
    send_to_routes: NotRequired[bool]
    r"""Select whether to send data to Routes, or directly to Destinations."""
    environment: NotRequired[str]
    r"""Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere."""
    streamtags: NotRequired[List[str]]
    r"""Tags for filtering and grouping in @{product}"""
    connections: NotRequired[List[ConnectionsTypeTypedDict]]
    r"""Direct connections to Destinations, and optionally via a Pipeline or a Pack"""
    url: NotRequired[str]
    r"""URL to use when retrieving report data."""
    interval: NotRequired[float]
    r"""How often (in minutes) to run the report. Must divide evenly into 60 minutes to create a predictable schedule, or Save will fail."""
    start_date: NotRequired[str]
    r"""Backward offset for the search range's head. (E.g.: -3h@h) Message Trace data is delayed; this parameter (with Date range end) compensates for delay and gaps."""
    end_date: NotRequired[str]
    r"""Backward offset for the search range's tail. (E.g.: -2h@h) Message Trace data is delayed; this parameter (with Date range start) compensates for delay and gaps."""
    timeout: NotRequired[float]
    r"""HTTP request inactivity timeout. Maximum is 2400 (40 minutes); enter 0 to wait indefinitely."""
    disable_time_filter: NotRequired[bool]
    r"""Disables time filtering of events when a date range is specified."""
    auth_type: NotRequired[InputOffice365MsgTraceAuthenticationMethod4]
    r"""Select authentication method."""
    reschedule_dropped_tasks: NotRequired[bool]
    r"""Reschedule tasks that failed with non-fatal errors"""
    max_task_reschedule: NotRequired[float]
    r"""Maximum number of times a task can be rescheduled"""
    log_level: NotRequired[InputOffice365MsgTraceLogLevel4]
    r"""Log Level (verbosity) for collection runtime behavior."""
    job_timeout: NotRequired[str]
    r"""Maximum time the job is allowed to run (e.g., 30, 45s or 15m). Units are seconds, if not specified. Enter 0 for unlimited time."""
    keep_alive_time: NotRequired[float]
    r"""How often workers should check in with the scheduler to keep job subscription alive"""
    max_missed_keep_alives: NotRequired[float]
    r"""The number of Keep Alive Time periods before an inactive worker will have its job subscription revoked."""
    ttl: NotRequired[str]
    r"""Time to keep the job's artifacts on disk after job completion. This also affects how long a job is listed in the Job Inspector."""
    ignore_group_jobs_limit: NotRequired[bool]
    r"""When enabled, this job's artifacts are not counted toward the Worker Group's finished job artifacts limit. Artifacts will be removed only after the Collector's configured time to live."""
    metadata: NotRequired[List[Metadata1TypeTypedDict]]
    r"""Fields to add to events from this input"""
    retry_rules: NotRequired[RetryRulesTypeTypedDict]
    description: NotRequired[str]
    username: NotRequired[str]
    r"""Username to run Message Trace API call."""
    password: NotRequired[str]
    r"""Password to run Message Trace API call."""
    credentials_secret: NotRequired[str]
    r"""Select or create a secret that references your credentials."""
    client_secret: NotRequired[str]
    r"""client_secret to pass in the OAuth request parameter."""
    tenant_id: NotRequired[str]
    r"""Directory ID (tenant identifier) in Azure Active Directory."""
    client_id: NotRequired[str]
    r"""client_id to pass in the OAuth request parameter."""
    resource: NotRequired[str]
    r"""Resource to pass in the OAuth request parameter."""
    plan_type: NotRequired[PlanTypeOptions]
    r"""Office 365 subscription plan for your organization, typically Office 365 Enterprise"""
    text_secret: NotRequired[str]
    r"""Select or create a secret that references your client_secret to pass in the OAuth request parameter."""
    cert_options: NotRequired[CertOptions4TypedDict]


class InputOffice365MsgTraceOffice365MsgTrace4(BaseModel):
    type: InputOffice365MsgTraceType4

    pq: PqType

    pq_enabled: Annotated[Optional[bool], pydantic.Field(alias="pqEnabled")] = False
    r"""Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers)."""

    id: Optional[str] = None
    r"""Unique ID for this input"""

    disabled: Optional[bool] = False

    pipeline: Optional[str] = None
    r"""Pipeline to process data from this Source before sending it through the Routes"""

    send_to_routes: Annotated[Optional[bool], pydantic.Field(alias="sendToRoutes")] = (
        True
    )
    r"""Select whether to send data to Routes, or directly to Destinations."""

    environment: Optional[str] = None
    r"""Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere."""

    streamtags: Optional[List[str]] = None
    r"""Tags for filtering and grouping in @{product}"""

    connections: Optional[List[ConnectionsType]] = None
    r"""Direct connections to Destinations, and optionally via a Pipeline or a Pack"""

    url: Optional[str] = (
        "https://reports.office365.com/ecp/reportingwebservice/reporting.svc/MessageTrace"
    )
    r"""URL to use when retrieving report data."""

    interval: Optional[float] = 60
    r"""How often (in minutes) to run the report. Must divide evenly into 60 minutes to create a predictable schedule, or Save will fail."""

    start_date: Annotated[Optional[str], pydantic.Field(alias="startDate")] = None
    r"""Backward offset for the search range's head. (E.g.: -3h@h) Message Trace data is delayed; this parameter (with Date range end) compensates for delay and gaps."""

    end_date: Annotated[Optional[str], pydantic.Field(alias="endDate")] = None
    r"""Backward offset for the search range's tail. (E.g.: -2h@h) Message Trace data is delayed; this parameter (with Date range start) compensates for delay and gaps."""

    timeout: Optional[float] = 300
    r"""HTTP request inactivity timeout. Maximum is 2400 (40 minutes); enter 0 to wait indefinitely."""

    disable_time_filter: Annotated[
        Optional[bool], pydantic.Field(alias="disableTimeFilter")
    ] = True
    r"""Disables time filtering of events when a date range is specified."""

    auth_type: Annotated[
        Annotated[
            Optional[InputOffice365MsgTraceAuthenticationMethod4],
            PlainValidator(validate_open_enum(False)),
        ],
        pydantic.Field(alias="authType"),
    ] = InputOffice365MsgTraceAuthenticationMethod4.OAUTH
    r"""Select authentication method."""

    reschedule_dropped_tasks: Annotated[
        Optional[bool], pydantic.Field(alias="rescheduleDroppedTasks")
    ] = True
    r"""Reschedule tasks that failed with non-fatal errors"""

    max_task_reschedule: Annotated[
        Optional[float], pydantic.Field(alias="maxTaskReschedule")
    ] = 1
    r"""Maximum number of times a task can be rescheduled"""

    log_level: Annotated[
        Annotated[
            Optional[InputOffice365MsgTraceLogLevel4],
            PlainValidator(validate_open_enum(False)),
        ],
        pydantic.Field(alias="logLevel"),
    ] = InputOffice365MsgTraceLogLevel4.INFO
    r"""Log Level (verbosity) for collection runtime behavior."""

    job_timeout: Annotated[Optional[str], pydantic.Field(alias="jobTimeout")] = "0"
    r"""Maximum time the job is allowed to run (e.g., 30, 45s or 15m). Units are seconds, if not specified. Enter 0 for unlimited time."""

    keep_alive_time: Annotated[
        Optional[float], pydantic.Field(alias="keepAliveTime")
    ] = 30
    r"""How often workers should check in with the scheduler to keep job subscription alive"""

    max_missed_keep_alives: Annotated[
        Optional[float], pydantic.Field(alias="maxMissedKeepAlives")
    ] = 3
    r"""The number of Keep Alive Time periods before an inactive worker will have its job subscription revoked."""

    ttl: Optional[str] = "4h"
    r"""Time to keep the job's artifacts on disk after job completion. This also affects how long a job is listed in the Job Inspector."""

    ignore_group_jobs_limit: Annotated[
        Optional[bool], pydantic.Field(alias="ignoreGroupJobsLimit")
    ] = False
    r"""When enabled, this job's artifacts are not counted toward the Worker Group's finished job artifacts limit. Artifacts will be removed only after the Collector's configured time to live."""

    metadata: Optional[List[Metadata1Type]] = None
    r"""Fields to add to events from this input"""

    retry_rules: Annotated[
        Optional[RetryRulesType], pydantic.Field(alias="retryRules")
    ] = None

    description: Optional[str] = None

    username: Optional[str] = None
    r"""Username to run Message Trace API call."""

    password: Optional[str] = None
    r"""Password to run Message Trace API call."""

    credentials_secret: Annotated[
        Optional[str], pydantic.Field(alias="credentialsSecret")
    ] = None
    r"""Select or create a secret that references your credentials."""

    client_secret: Annotated[Optional[str], pydantic.Field(alias="clientSecret")] = None
    r"""client_secret to pass in the OAuth request parameter."""

    tenant_id: Annotated[Optional[str], pydantic.Field(alias="tenantId")] = None
    r"""Directory ID (tenant identifier) in Azure Active Directory."""

    client_id: Annotated[Optional[str], pydantic.Field(alias="clientId")] = None
    r"""client_id to pass in the OAuth request parameter."""

    resource: Optional[str] = "https://outlook.office365.com"
    r"""Resource to pass in the OAuth request parameter."""

    plan_type: Annotated[
        Annotated[Optional[PlanTypeOptions], PlainValidator(validate_open_enum(False))],
        pydantic.Field(alias="planType"),
    ] = PlanTypeOptions.ENTERPRISE_GCC
    r"""Office 365 subscription plan for your organization, typically Office 365 Enterprise"""

    text_secret: Annotated[Optional[str], pydantic.Field(alias="textSecret")] = None
    r"""Select or create a secret that references your client_secret to pass in the OAuth request parameter."""

    cert_options: Annotated[
        Optional[CertOptions4], pydantic.Field(alias="certOptions")
    ] = None

    @field_serializer("auth_type")
    def serialize_auth_type(self, value):
        if isinstance(value, str):
            try:
                return models.InputOffice365MsgTraceAuthenticationMethod4(value)
            except ValueError:
                return value
        return value

    @field_serializer("log_level")
    def serialize_log_level(self, value):
        if isinstance(value, str):
            try:
                return models.InputOffice365MsgTraceLogLevel4(value)
            except ValueError:
                return value
        return value

    @field_serializer("plan_type")
    def serialize_plan_type(self, value):
        if isinstance(value, str):
            try:
                return models.PlanTypeOptions(value)
            except ValueError:
                return value
        return value


class InputOffice365MsgTraceType3(str, Enum):
    OFFICE365_MSG_TRACE = "office365_msg_trace"


class InputOffice365MsgTraceAuthenticationMethod3(
    str, Enum, metaclass=utils.OpenEnumMeta
):
    r"""Select authentication method."""

    MANUAL = "manual"
    SECRET = "secret"
    OAUTH = "oauth"
    OAUTH_SECRET = "oauthSecret"
    OAUTH_CERT = "oauthCert"


class InputOffice365MsgTraceLogLevel3(str, Enum, metaclass=utils.OpenEnumMeta):
    r"""Log Level (verbosity) for collection runtime behavior."""

    ERROR = "error"
    WARN = "warn"
    INFO = "info"
    DEBUG = "debug"
    SILLY = "silly"


class CertOptions3TypedDict(TypedDict):
    priv_key_path: str
    r"""Path to the private key to use. Key should be in PEM format. Can reference $ENV_VARS."""
    cert_path: str
    r"""Path to the certificate to use. Certificate should be in PEM format. Can reference $ENV_VARS."""
    certificate_name: NotRequired[str]
    r"""The name of the predefined certificate."""
    passphrase: NotRequired[str]
    r"""Passphrase to use to decrypt the private key."""


class CertOptions3(BaseModel):
    priv_key_path: Annotated[str, pydantic.Field(alias="privKeyPath")]
    r"""Path to the private key to use. Key should be in PEM format. Can reference $ENV_VARS."""

    cert_path: Annotated[str, pydantic.Field(alias="certPath")]
    r"""Path to the certificate to use. Certificate should be in PEM format. Can reference $ENV_VARS."""

    certificate_name: Annotated[
        Optional[str], pydantic.Field(alias="certificateName")
    ] = None
    r"""The name of the predefined certificate."""

    passphrase: Optional[str] = None
    r"""Passphrase to use to decrypt the private key."""


class InputOffice365MsgTraceOffice365MsgTrace3TypedDict(TypedDict):
    type: InputOffice365MsgTraceType3
    pq_enabled: NotRequired[bool]
    r"""Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers)."""
    id: NotRequired[str]
    r"""Unique ID for this input"""
    disabled: NotRequired[bool]
    pipeline: NotRequired[str]
    r"""Pipeline to process data from this Source before sending it through the Routes"""
    send_to_routes: NotRequired[bool]
    r"""Select whether to send data to Routes, or directly to Destinations."""
    environment: NotRequired[str]
    r"""Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere."""
    streamtags: NotRequired[List[str]]
    r"""Tags for filtering and grouping in @{product}"""
    connections: NotRequired[List[ConnectionsTypeTypedDict]]
    r"""Direct connections to Destinations, and optionally via a Pipeline or a Pack"""
    pq: NotRequired[PqTypeTypedDict]
    url: NotRequired[str]
    r"""URL to use when retrieving report data."""
    interval: NotRequired[float]
    r"""How often (in minutes) to run the report. Must divide evenly into 60 minutes to create a predictable schedule, or Save will fail."""
    start_date: NotRequired[str]
    r"""Backward offset for the search range's head. (E.g.: -3h@h) Message Trace data is delayed; this parameter (with Date range end) compensates for delay and gaps."""
    end_date: NotRequired[str]
    r"""Backward offset for the search range's tail. (E.g.: -2h@h) Message Trace data is delayed; this parameter (with Date range start) compensates for delay and gaps."""
    timeout: NotRequired[float]
    r"""HTTP request inactivity timeout. Maximum is 2400 (40 minutes); enter 0 to wait indefinitely."""
    disable_time_filter: NotRequired[bool]
    r"""Disables time filtering of events when a date range is specified."""
    auth_type: NotRequired[InputOffice365MsgTraceAuthenticationMethod3]
    r"""Select authentication method."""
    reschedule_dropped_tasks: NotRequired[bool]
    r"""Reschedule tasks that failed with non-fatal errors"""
    max_task_reschedule: NotRequired[float]
    r"""Maximum number of times a task can be rescheduled"""
    log_level: NotRequired[InputOffice365MsgTraceLogLevel3]
    r"""Log Level (verbosity) for collection runtime behavior."""
    job_timeout: NotRequired[str]
    r"""Maximum time the job is allowed to run (e.g., 30, 45s or 15m). Units are seconds, if not specified. Enter 0 for unlimited time."""
    keep_alive_time: NotRequired[float]
    r"""How often workers should check in with the scheduler to keep job subscription alive"""
    max_missed_keep_alives: NotRequired[float]
    r"""The number of Keep Alive Time periods before an inactive worker will have its job subscription revoked."""
    ttl: NotRequired[str]
    r"""Time to keep the job's artifacts on disk after job completion. This also affects how long a job is listed in the Job Inspector."""
    ignore_group_jobs_limit: NotRequired[bool]
    r"""When enabled, this job's artifacts are not counted toward the Worker Group's finished job artifacts limit. Artifacts will be removed only after the Collector's configured time to live."""
    metadata: NotRequired[List[Metadata1TypeTypedDict]]
    r"""Fields to add to events from this input"""
    retry_rules: NotRequired[RetryRulesTypeTypedDict]
    description: NotRequired[str]
    username: NotRequired[str]
    r"""Username to run Message Trace API call."""
    password: NotRequired[str]
    r"""Password to run Message Trace API call."""
    credentials_secret: NotRequired[str]
    r"""Select or create a secret that references your credentials."""
    client_secret: NotRequired[str]
    r"""client_secret to pass in the OAuth request parameter."""
    tenant_id: NotRequired[str]
    r"""Directory ID (tenant identifier) in Azure Active Directory."""
    client_id: NotRequired[str]
    r"""client_id to pass in the OAuth request parameter."""
    resource: NotRequired[str]
    r"""Resource to pass in the OAuth request parameter."""
    plan_type: NotRequired[PlanTypeOptions]
    r"""Office 365 subscription plan for your organization, typically Office 365 Enterprise"""
    text_secret: NotRequired[str]
    r"""Select or create a secret that references your client_secret to pass in the OAuth request parameter."""
    cert_options: NotRequired[CertOptions3TypedDict]


class InputOffice365MsgTraceOffice365MsgTrace3(BaseModel):
    type: InputOffice365MsgTraceType3

    pq_enabled: Annotated[Optional[bool], pydantic.Field(alias="pqEnabled")] = False
    r"""Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers)."""

    id: Optional[str] = None
    r"""Unique ID for this input"""

    disabled: Optional[bool] = False

    pipeline: Optional[str] = None
    r"""Pipeline to process data from this Source before sending it through the Routes"""

    send_to_routes: Annotated[Optional[bool], pydantic.Field(alias="sendToRoutes")] = (
        True
    )
    r"""Select whether to send data to Routes, or directly to Destinations."""

    environment: Optional[str] = None
    r"""Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere."""

    streamtags: Optional[List[str]] = None
    r"""Tags for filtering and grouping in @{product}"""

    connections: Optional[List[ConnectionsType]] = None
    r"""Direct connections to Destinations, and optionally via a Pipeline or a Pack"""

    pq: Optional[PqType] = None

    url: Optional[str] = (
        "https://reports.office365.com/ecp/reportingwebservice/reporting.svc/MessageTrace"
    )
    r"""URL to use when retrieving report data."""

    interval: Optional[float] = 60
    r"""How often (in minutes) to run the report. Must divide evenly into 60 minutes to create a predictable schedule, or Save will fail."""

    start_date: Annotated[Optional[str], pydantic.Field(alias="startDate")] = None
    r"""Backward offset for the search range's head. (E.g.: -3h@h) Message Trace data is delayed; this parameter (with Date range end) compensates for delay and gaps."""

    end_date: Annotated[Optional[str], pydantic.Field(alias="endDate")] = None
    r"""Backward offset for the search range's tail. (E.g.: -2h@h) Message Trace data is delayed; this parameter (with Date range start) compensates for delay and gaps."""

    timeout: Optional[float] = 300
    r"""HTTP request inactivity timeout. Maximum is 2400 (40 minutes); enter 0 to wait indefinitely."""

    disable_time_filter: Annotated[
        Optional[bool], pydantic.Field(alias="disableTimeFilter")
    ] = True
    r"""Disables time filtering of events when a date range is specified."""

    auth_type: Annotated[
        Annotated[
            Optional[InputOffice365MsgTraceAuthenticationMethod3],
            PlainValidator(validate_open_enum(False)),
        ],
        pydantic.Field(alias="authType"),
    ] = InputOffice365MsgTraceAuthenticationMethod3.OAUTH
    r"""Select authentication method."""

    reschedule_dropped_tasks: Annotated[
        Optional[bool], pydantic.Field(alias="rescheduleDroppedTasks")
    ] = True
    r"""Reschedule tasks that failed with non-fatal errors"""

    max_task_reschedule: Annotated[
        Optional[float], pydantic.Field(alias="maxTaskReschedule")
    ] = 1
    r"""Maximum number of times a task can be rescheduled"""

    log_level: Annotated[
        Annotated[
            Optional[InputOffice365MsgTraceLogLevel3],
            PlainValidator(validate_open_enum(False)),
        ],
        pydantic.Field(alias="logLevel"),
    ] = InputOffice365MsgTraceLogLevel3.INFO
    r"""Log Level (verbosity) for collection runtime behavior."""

    job_timeout: Annotated[Optional[str], pydantic.Field(alias="jobTimeout")] = "0"
    r"""Maximum time the job is allowed to run (e.g., 30, 45s or 15m). Units are seconds, if not specified. Enter 0 for unlimited time."""

    keep_alive_time: Annotated[
        Optional[float], pydantic.Field(alias="keepAliveTime")
    ] = 30
    r"""How often workers should check in with the scheduler to keep job subscription alive"""

    max_missed_keep_alives: Annotated[
        Optional[float], pydantic.Field(alias="maxMissedKeepAlives")
    ] = 3
    r"""The number of Keep Alive Time periods before an inactive worker will have its job subscription revoked."""

    ttl: Optional[str] = "4h"
    r"""Time to keep the job's artifacts on disk after job completion. This also affects how long a job is listed in the Job Inspector."""

    ignore_group_jobs_limit: Annotated[
        Optional[bool], pydantic.Field(alias="ignoreGroupJobsLimit")
    ] = False
    r"""When enabled, this job's artifacts are not counted toward the Worker Group's finished job artifacts limit. Artifacts will be removed only after the Collector's configured time to live."""

    metadata: Optional[List[Metadata1Type]] = None
    r"""Fields to add to events from this input"""

    retry_rules: Annotated[
        Optional[RetryRulesType], pydantic.Field(alias="retryRules")
    ] = None

    description: Optional[str] = None

    username: Optional[str] = None
    r"""Username to run Message Trace API call."""

    password: Optional[str] = None
    r"""Password to run Message Trace API call."""

    credentials_secret: Annotated[
        Optional[str], pydantic.Field(alias="credentialsSecret")
    ] = None
    r"""Select or create a secret that references your credentials."""

    client_secret: Annotated[Optional[str], pydantic.Field(alias="clientSecret")] = None
    r"""client_secret to pass in the OAuth request parameter."""

    tenant_id: Annotated[Optional[str], pydantic.Field(alias="tenantId")] = None
    r"""Directory ID (tenant identifier) in Azure Active Directory."""

    client_id: Annotated[Optional[str], pydantic.Field(alias="clientId")] = None
    r"""client_id to pass in the OAuth request parameter."""

    resource: Optional[str] = "https://outlook.office365.com"
    r"""Resource to pass in the OAuth request parameter."""

    plan_type: Annotated[
        Annotated[Optional[PlanTypeOptions], PlainValidator(validate_open_enum(False))],
        pydantic.Field(alias="planType"),
    ] = PlanTypeOptions.ENTERPRISE_GCC
    r"""Office 365 subscription plan for your organization, typically Office 365 Enterprise"""

    text_secret: Annotated[Optional[str], pydantic.Field(alias="textSecret")] = None
    r"""Select or create a secret that references your client_secret to pass in the OAuth request parameter."""

    cert_options: Annotated[
        Optional[CertOptions3], pydantic.Field(alias="certOptions")
    ] = None

    @field_serializer("auth_type")
    def serialize_auth_type(self, value):
        if isinstance(value, str):
            try:
                return models.InputOffice365MsgTraceAuthenticationMethod3(value)
            except ValueError:
                return value
        return value

    @field_serializer("log_level")
    def serialize_log_level(self, value):
        if isinstance(value, str):
            try:
                return models.InputOffice365MsgTraceLogLevel3(value)
            except ValueError:
                return value
        return value

    @field_serializer("plan_type")
    def serialize_plan_type(self, value):
        if isinstance(value, str):
            try:
                return models.PlanTypeOptions(value)
            except ValueError:
                return value
        return value


class InputOffice365MsgTraceType2(str, Enum):
    OFFICE365_MSG_TRACE = "office365_msg_trace"


class InputOffice365MsgTraceAuthenticationMethod2(
    str, Enum, metaclass=utils.OpenEnumMeta
):
    r"""Select authentication method."""

    MANUAL = "manual"
    SECRET = "secret"
    OAUTH = "oauth"
    OAUTH_SECRET = "oauthSecret"
    OAUTH_CERT = "oauthCert"


class InputOffice365MsgTraceLogLevel2(str, Enum, metaclass=utils.OpenEnumMeta):
    r"""Log Level (verbosity) for collection runtime behavior."""

    ERROR = "error"
    WARN = "warn"
    INFO = "info"
    DEBUG = "debug"
    SILLY = "silly"


class CertOptions2TypedDict(TypedDict):
    priv_key_path: str
    r"""Path to the private key to use. Key should be in PEM format. Can reference $ENV_VARS."""
    cert_path: str
    r"""Path to the certificate to use. Certificate should be in PEM format. Can reference $ENV_VARS."""
    certificate_name: NotRequired[str]
    r"""The name of the predefined certificate."""
    passphrase: NotRequired[str]
    r"""Passphrase to use to decrypt the private key."""


class CertOptions2(BaseModel):
    priv_key_path: Annotated[str, pydantic.Field(alias="privKeyPath")]
    r"""Path to the private key to use. Key should be in PEM format. Can reference $ENV_VARS."""

    cert_path: Annotated[str, pydantic.Field(alias="certPath")]
    r"""Path to the certificate to use. Certificate should be in PEM format. Can reference $ENV_VARS."""

    certificate_name: Annotated[
        Optional[str], pydantic.Field(alias="certificateName")
    ] = None
    r"""The name of the predefined certificate."""

    passphrase: Optional[str] = None
    r"""Passphrase to use to decrypt the private key."""


class InputOffice365MsgTraceOffice365MsgTrace2TypedDict(TypedDict):
    type: InputOffice365MsgTraceType2
    connections: List[ConnectionsTypeTypedDict]
    r"""Direct connections to Destinations, and optionally via a Pipeline or a Pack"""
    send_to_routes: NotRequired[bool]
    r"""Select whether to send data to Routes, or directly to Destinations."""
    id: NotRequired[str]
    r"""Unique ID for this input"""
    disabled: NotRequired[bool]
    pipeline: NotRequired[str]
    r"""Pipeline to process data from this Source before sending it through the Routes"""
    environment: NotRequired[str]
    r"""Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere."""
    pq_enabled: NotRequired[bool]
    r"""Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers)."""
    streamtags: NotRequired[List[str]]
    r"""Tags for filtering and grouping in @{product}"""
    pq: NotRequired[PqTypeTypedDict]
    url: NotRequired[str]
    r"""URL to use when retrieving report data."""
    interval: NotRequired[float]
    r"""How often (in minutes) to run the report. Must divide evenly into 60 minutes to create a predictable schedule, or Save will fail."""
    start_date: NotRequired[str]
    r"""Backward offset for the search range's head. (E.g.: -3h@h) Message Trace data is delayed; this parameter (with Date range end) compensates for delay and gaps."""
    end_date: NotRequired[str]
    r"""Backward offset for the search range's tail. (E.g.: -2h@h) Message Trace data is delayed; this parameter (with Date range start) compensates for delay and gaps."""
    timeout: NotRequired[float]
    r"""HTTP request inactivity timeout. Maximum is 2400 (40 minutes); enter 0 to wait indefinitely."""
    disable_time_filter: NotRequired[bool]
    r"""Disables time filtering of events when a date range is specified."""
    auth_type: NotRequired[InputOffice365MsgTraceAuthenticationMethod2]
    r"""Select authentication method."""
    reschedule_dropped_tasks: NotRequired[bool]
    r"""Reschedule tasks that failed with non-fatal errors"""
    max_task_reschedule: NotRequired[float]
    r"""Maximum number of times a task can be rescheduled"""
    log_level: NotRequired[InputOffice365MsgTraceLogLevel2]
    r"""Log Level (verbosity) for collection runtime behavior."""
    job_timeout: NotRequired[str]
    r"""Maximum time the job is allowed to run (e.g., 30, 45s or 15m). Units are seconds, if not specified. Enter 0 for unlimited time."""
    keep_alive_time: NotRequired[float]
    r"""How often workers should check in with the scheduler to keep job subscription alive"""
    max_missed_keep_alives: NotRequired[float]
    r"""The number of Keep Alive Time periods before an inactive worker will have its job subscription revoked."""
    ttl: NotRequired[str]
    r"""Time to keep the job's artifacts on disk after job completion. This also affects how long a job is listed in the Job Inspector."""
    ignore_group_jobs_limit: NotRequired[bool]
    r"""When enabled, this job's artifacts are not counted toward the Worker Group's finished job artifacts limit. Artifacts will be removed only after the Collector's configured time to live."""
    metadata: NotRequired[List[Metadata1TypeTypedDict]]
    r"""Fields to add to events from this input"""
    retry_rules: NotRequired[RetryRulesTypeTypedDict]
    description: NotRequired[str]
    username: NotRequired[str]
    r"""Username to run Message Trace API call."""
    password: NotRequired[str]
    r"""Password to run Message Trace API call."""
    credentials_secret: NotRequired[str]
    r"""Select or create a secret that references your credentials."""
    client_secret: NotRequired[str]
    r"""client_secret to pass in the OAuth request parameter."""
    tenant_id: NotRequired[str]
    r"""Directory ID (tenant identifier) in Azure Active Directory."""
    client_id: NotRequired[str]
    r"""client_id to pass in the OAuth request parameter."""
    resource: NotRequired[str]
    r"""Resource to pass in the OAuth request parameter."""
    plan_type: NotRequired[PlanTypeOptions]
    r"""Office 365 subscription plan for your organization, typically Office 365 Enterprise"""
    text_secret: NotRequired[str]
    r"""Select or create a secret that references your client_secret to pass in the OAuth request parameter."""
    cert_options: NotRequired[CertOptions2TypedDict]


class InputOffice365MsgTraceOffice365MsgTrace2(BaseModel):
    type: InputOffice365MsgTraceType2

    connections: List[ConnectionsType]
    r"""Direct connections to Destinations, and optionally via a Pipeline or a Pack"""

    send_to_routes: Annotated[Optional[bool], pydantic.Field(alias="sendToRoutes")] = (
        True
    )
    r"""Select whether to send data to Routes, or directly to Destinations."""

    id: Optional[str] = None
    r"""Unique ID for this input"""

    disabled: Optional[bool] = False

    pipeline: Optional[str] = None
    r"""Pipeline to process data from this Source before sending it through the Routes"""

    environment: Optional[str] = None
    r"""Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere."""

    pq_enabled: Annotated[Optional[bool], pydantic.Field(alias="pqEnabled")] = False
    r"""Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers)."""

    streamtags: Optional[List[str]] = None
    r"""Tags for filtering and grouping in @{product}"""

    pq: Optional[PqType] = None

    url: Optional[str] = (
        "https://reports.office365.com/ecp/reportingwebservice/reporting.svc/MessageTrace"
    )
    r"""URL to use when retrieving report data."""

    interval: Optional[float] = 60
    r"""How often (in minutes) to run the report. Must divide evenly into 60 minutes to create a predictable schedule, or Save will fail."""

    start_date: Annotated[Optional[str], pydantic.Field(alias="startDate")] = None
    r"""Backward offset for the search range's head. (E.g.: -3h@h) Message Trace data is delayed; this parameter (with Date range end) compensates for delay and gaps."""

    end_date: Annotated[Optional[str], pydantic.Field(alias="endDate")] = None
    r"""Backward offset for the search range's tail. (E.g.: -2h@h) Message Trace data is delayed; this parameter (with Date range start) compensates for delay and gaps."""

    timeout: Optional[float] = 300
    r"""HTTP request inactivity timeout. Maximum is 2400 (40 minutes); enter 0 to wait indefinitely."""

    disable_time_filter: Annotated[
        Optional[bool], pydantic.Field(alias="disableTimeFilter")
    ] = True
    r"""Disables time filtering of events when a date range is specified."""

    auth_type: Annotated[
        Annotated[
            Optional[InputOffice365MsgTraceAuthenticationMethod2],
            PlainValidator(validate_open_enum(False)),
        ],
        pydantic.Field(alias="authType"),
    ] = InputOffice365MsgTraceAuthenticationMethod2.OAUTH
    r"""Select authentication method."""

    reschedule_dropped_tasks: Annotated[
        Optional[bool], pydantic.Field(alias="rescheduleDroppedTasks")
    ] = True
    r"""Reschedule tasks that failed with non-fatal errors"""

    max_task_reschedule: Annotated[
        Optional[float], pydantic.Field(alias="maxTaskReschedule")
    ] = 1
    r"""Maximum number of times a task can be rescheduled"""

    log_level: Annotated[
        Annotated[
            Optional[InputOffice365MsgTraceLogLevel2],
            PlainValidator(validate_open_enum(False)),
        ],
        pydantic.Field(alias="logLevel"),
    ] = InputOffice365MsgTraceLogLevel2.INFO
    r"""Log Level (verbosity) for collection runtime behavior."""

    job_timeout: Annotated[Optional[str], pydantic.Field(alias="jobTimeout")] = "0"
    r"""Maximum time the job is allowed to run (e.g., 30, 45s or 15m). Units are seconds, if not specified. Enter 0 for unlimited time."""

    keep_alive_time: Annotated[
        Optional[float], pydantic.Field(alias="keepAliveTime")
    ] = 30
    r"""How often workers should check in with the scheduler to keep job subscription alive"""

    max_missed_keep_alives: Annotated[
        Optional[float], pydantic.Field(alias="maxMissedKeepAlives")
    ] = 3
    r"""The number of Keep Alive Time periods before an inactive worker will have its job subscription revoked."""

    ttl: Optional[str] = "4h"
    r"""Time to keep the job's artifacts on disk after job completion. This also affects how long a job is listed in the Job Inspector."""

    ignore_group_jobs_limit: Annotated[
        Optional[bool], pydantic.Field(alias="ignoreGroupJobsLimit")
    ] = False
    r"""When enabled, this job's artifacts are not counted toward the Worker Group's finished job artifacts limit. Artifacts will be removed only after the Collector's configured time to live."""

    metadata: Optional[List[Metadata1Type]] = None
    r"""Fields to add to events from this input"""

    retry_rules: Annotated[
        Optional[RetryRulesType], pydantic.Field(alias="retryRules")
    ] = None

    description: Optional[str] = None

    username: Optional[str] = None
    r"""Username to run Message Trace API call."""

    password: Optional[str] = None
    r"""Password to run Message Trace API call."""

    credentials_secret: Annotated[
        Optional[str], pydantic.Field(alias="credentialsSecret")
    ] = None
    r"""Select or create a secret that references your credentials."""

    client_secret: Annotated[Optional[str], pydantic.Field(alias="clientSecret")] = None
    r"""client_secret to pass in the OAuth request parameter."""

    tenant_id: Annotated[Optional[str], pydantic.Field(alias="tenantId")] = None
    r"""Directory ID (tenant identifier) in Azure Active Directory."""

    client_id: Annotated[Optional[str], pydantic.Field(alias="clientId")] = None
    r"""client_id to pass in the OAuth request parameter."""

    resource: Optional[str] = "https://outlook.office365.com"
    r"""Resource to pass in the OAuth request parameter."""

    plan_type: Annotated[
        Annotated[Optional[PlanTypeOptions], PlainValidator(validate_open_enum(False))],
        pydantic.Field(alias="planType"),
    ] = PlanTypeOptions.ENTERPRISE_GCC
    r"""Office 365 subscription plan for your organization, typically Office 365 Enterprise"""

    text_secret: Annotated[Optional[str], pydantic.Field(alias="textSecret")] = None
    r"""Select or create a secret that references your client_secret to pass in the OAuth request parameter."""

    cert_options: Annotated[
        Optional[CertOptions2], pydantic.Field(alias="certOptions")
    ] = None

    @field_serializer("auth_type")
    def serialize_auth_type(self, value):
        if isinstance(value, str):
            try:
                return models.InputOffice365MsgTraceAuthenticationMethod2(value)
            except ValueError:
                return value
        return value

    @field_serializer("log_level")
    def serialize_log_level(self, value):
        if isinstance(value, str):
            try:
                return models.InputOffice365MsgTraceLogLevel2(value)
            except ValueError:
                return value
        return value

    @field_serializer("plan_type")
    def serialize_plan_type(self, value):
        if isinstance(value, str):
            try:
                return models.PlanTypeOptions(value)
            except ValueError:
                return value
        return value


class InputOffice365MsgTraceType1(str, Enum):
    OFFICE365_MSG_TRACE = "office365_msg_trace"


class InputOffice365MsgTraceAuthenticationMethod1(
    str, Enum, metaclass=utils.OpenEnumMeta
):
    r"""Select authentication method."""

    MANUAL = "manual"
    SECRET = "secret"
    OAUTH = "oauth"
    OAUTH_SECRET = "oauthSecret"
    OAUTH_CERT = "oauthCert"


class InputOffice365MsgTraceLogLevel1(str, Enum, metaclass=utils.OpenEnumMeta):
    r"""Log Level (verbosity) for collection runtime behavior."""

    ERROR = "error"
    WARN = "warn"
    INFO = "info"
    DEBUG = "debug"
    SILLY = "silly"


class CertOptions1TypedDict(TypedDict):
    priv_key_path: str
    r"""Path to the private key to use. Key should be in PEM format. Can reference $ENV_VARS."""
    cert_path: str
    r"""Path to the certificate to use. Certificate should be in PEM format. Can reference $ENV_VARS."""
    certificate_name: NotRequired[str]
    r"""The name of the predefined certificate."""
    passphrase: NotRequired[str]
    r"""Passphrase to use to decrypt the private key."""


class CertOptions1(BaseModel):
    priv_key_path: Annotated[str, pydantic.Field(alias="privKeyPath")]
    r"""Path to the private key to use. Key should be in PEM format. Can reference $ENV_VARS."""

    cert_path: Annotated[str, pydantic.Field(alias="certPath")]
    r"""Path to the certificate to use. Certificate should be in PEM format. Can reference $ENV_VARS."""

    certificate_name: Annotated[
        Optional[str], pydantic.Field(alias="certificateName")
    ] = None
    r"""The name of the predefined certificate."""

    passphrase: Optional[str] = None
    r"""Passphrase to use to decrypt the private key."""


class InputOffice365MsgTraceOffice365MsgTrace1TypedDict(TypedDict):
    type: InputOffice365MsgTraceType1
    send_to_routes: NotRequired[bool]
    r"""Select whether to send data to Routes, or directly to Destinations."""
    id: NotRequired[str]
    r"""Unique ID for this input"""
    disabled: NotRequired[bool]
    pipeline: NotRequired[str]
    r"""Pipeline to process data from this Source before sending it through the Routes"""
    environment: NotRequired[str]
    r"""Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere."""
    pq_enabled: NotRequired[bool]
    r"""Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers)."""
    streamtags: NotRequired[List[str]]
    r"""Tags for filtering and grouping in @{product}"""
    connections: NotRequired[List[ConnectionsTypeTypedDict]]
    r"""Direct connections to Destinations, and optionally via a Pipeline or a Pack"""
    pq: NotRequired[PqTypeTypedDict]
    url: NotRequired[str]
    r"""URL to use when retrieving report data."""
    interval: NotRequired[float]
    r"""How often (in minutes) to run the report. Must divide evenly into 60 minutes to create a predictable schedule, or Save will fail."""
    start_date: NotRequired[str]
    r"""Backward offset for the search range's head. (E.g.: -3h@h) Message Trace data is delayed; this parameter (with Date range end) compensates for delay and gaps."""
    end_date: NotRequired[str]
    r"""Backward offset for the search range's tail. (E.g.: -2h@h) Message Trace data is delayed; this parameter (with Date range start) compensates for delay and gaps."""
    timeout: NotRequired[float]
    r"""HTTP request inactivity timeout. Maximum is 2400 (40 minutes); enter 0 to wait indefinitely."""
    disable_time_filter: NotRequired[bool]
    r"""Disables time filtering of events when a date range is specified."""
    auth_type: NotRequired[InputOffice365MsgTraceAuthenticationMethod1]
    r"""Select authentication method."""
    reschedule_dropped_tasks: NotRequired[bool]
    r"""Reschedule tasks that failed with non-fatal errors"""
    max_task_reschedule: NotRequired[float]
    r"""Maximum number of times a task can be rescheduled"""
    log_level: NotRequired[InputOffice365MsgTraceLogLevel1]
    r"""Log Level (verbosity) for collection runtime behavior."""
    job_timeout: NotRequired[str]
    r"""Maximum time the job is allowed to run (e.g., 30, 45s or 15m). Units are seconds, if not specified. Enter 0 for unlimited time."""
    keep_alive_time: NotRequired[float]
    r"""How often workers should check in with the scheduler to keep job subscription alive"""
    max_missed_keep_alives: NotRequired[float]
    r"""The number of Keep Alive Time periods before an inactive worker will have its job subscription revoked."""
    ttl: NotRequired[str]
    r"""Time to keep the job's artifacts on disk after job completion. This also affects how long a job is listed in the Job Inspector."""
    ignore_group_jobs_limit: NotRequired[bool]
    r"""When enabled, this job's artifacts are not counted toward the Worker Group's finished job artifacts limit. Artifacts will be removed only after the Collector's configured time to live."""
    metadata: NotRequired[List[Metadata1TypeTypedDict]]
    r"""Fields to add to events from this input"""
    retry_rules: NotRequired[RetryRulesTypeTypedDict]
    description: NotRequired[str]
    username: NotRequired[str]
    r"""Username to run Message Trace API call."""
    password: NotRequired[str]
    r"""Password to run Message Trace API call."""
    credentials_secret: NotRequired[str]
    r"""Select or create a secret that references your credentials."""
    client_secret: NotRequired[str]
    r"""client_secret to pass in the OAuth request parameter."""
    tenant_id: NotRequired[str]
    r"""Directory ID (tenant identifier) in Azure Active Directory."""
    client_id: NotRequired[str]
    r"""client_id to pass in the OAuth request parameter."""
    resource: NotRequired[str]
    r"""Resource to pass in the OAuth request parameter."""
    plan_type: NotRequired[PlanTypeOptions]
    r"""Office 365 subscription plan for your organization, typically Office 365 Enterprise"""
    text_secret: NotRequired[str]
    r"""Select or create a secret that references your client_secret to pass in the OAuth request parameter."""
    cert_options: NotRequired[CertOptions1TypedDict]


class InputOffice365MsgTraceOffice365MsgTrace1(BaseModel):
    type: InputOffice365MsgTraceType1

    send_to_routes: Annotated[Optional[bool], pydantic.Field(alias="sendToRoutes")] = (
        True
    )
    r"""Select whether to send data to Routes, or directly to Destinations."""

    id: Optional[str] = None
    r"""Unique ID for this input"""

    disabled: Optional[bool] = False

    pipeline: Optional[str] = None
    r"""Pipeline to process data from this Source before sending it through the Routes"""

    environment: Optional[str] = None
    r"""Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere."""

    pq_enabled: Annotated[Optional[bool], pydantic.Field(alias="pqEnabled")] = False
    r"""Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers)."""

    streamtags: Optional[List[str]] = None
    r"""Tags for filtering and grouping in @{product}"""

    connections: Optional[List[ConnectionsType]] = None
    r"""Direct connections to Destinations, and optionally via a Pipeline or a Pack"""

    pq: Optional[PqType] = None

    url: Optional[str] = (
        "https://reports.office365.com/ecp/reportingwebservice/reporting.svc/MessageTrace"
    )
    r"""URL to use when retrieving report data."""

    interval: Optional[float] = 60
    r"""How often (in minutes) to run the report. Must divide evenly into 60 minutes to create a predictable schedule, or Save will fail."""

    start_date: Annotated[Optional[str], pydantic.Field(alias="startDate")] = None
    r"""Backward offset for the search range's head. (E.g.: -3h@h) Message Trace data is delayed; this parameter (with Date range end) compensates for delay and gaps."""

    end_date: Annotated[Optional[str], pydantic.Field(alias="endDate")] = None
    r"""Backward offset for the search range's tail. (E.g.: -2h@h) Message Trace data is delayed; this parameter (with Date range start) compensates for delay and gaps."""

    timeout: Optional[float] = 300
    r"""HTTP request inactivity timeout. Maximum is 2400 (40 minutes); enter 0 to wait indefinitely."""

    disable_time_filter: Annotated[
        Optional[bool], pydantic.Field(alias="disableTimeFilter")
    ] = True
    r"""Disables time filtering of events when a date range is specified."""

    auth_type: Annotated[
        Annotated[
            Optional[InputOffice365MsgTraceAuthenticationMethod1],
            PlainValidator(validate_open_enum(False)),
        ],
        pydantic.Field(alias="authType"),
    ] = InputOffice365MsgTraceAuthenticationMethod1.OAUTH
    r"""Select authentication method."""

    reschedule_dropped_tasks: Annotated[
        Optional[bool], pydantic.Field(alias="rescheduleDroppedTasks")
    ] = True
    r"""Reschedule tasks that failed with non-fatal errors"""

    max_task_reschedule: Annotated[
        Optional[float], pydantic.Field(alias="maxTaskReschedule")
    ] = 1
    r"""Maximum number of times a task can be rescheduled"""

    log_level: Annotated[
        Annotated[
            Optional[InputOffice365MsgTraceLogLevel1],
            PlainValidator(validate_open_enum(False)),
        ],
        pydantic.Field(alias="logLevel"),
    ] = InputOffice365MsgTraceLogLevel1.INFO
    r"""Log Level (verbosity) for collection runtime behavior."""

    job_timeout: Annotated[Optional[str], pydantic.Field(alias="jobTimeout")] = "0"
    r"""Maximum time the job is allowed to run (e.g., 30, 45s or 15m). Units are seconds, if not specified. Enter 0 for unlimited time."""

    keep_alive_time: Annotated[
        Optional[float], pydantic.Field(alias="keepAliveTime")
    ] = 30
    r"""How often workers should check in with the scheduler to keep job subscription alive"""

    max_missed_keep_alives: Annotated[
        Optional[float], pydantic.Field(alias="maxMissedKeepAlives")
    ] = 3
    r"""The number of Keep Alive Time periods before an inactive worker will have its job subscription revoked."""

    ttl: Optional[str] = "4h"
    r"""Time to keep the job's artifacts on disk after job completion. This also affects how long a job is listed in the Job Inspector."""

    ignore_group_jobs_limit: Annotated[
        Optional[bool], pydantic.Field(alias="ignoreGroupJobsLimit")
    ] = False
    r"""When enabled, this job's artifacts are not counted toward the Worker Group's finished job artifacts limit. Artifacts will be removed only after the Collector's configured time to live."""

    metadata: Optional[List[Metadata1Type]] = None
    r"""Fields to add to events from this input"""

    retry_rules: Annotated[
        Optional[RetryRulesType], pydantic.Field(alias="retryRules")
    ] = None

    description: Optional[str] = None

    username: Optional[str] = None
    r"""Username to run Message Trace API call."""

    password: Optional[str] = None
    r"""Password to run Message Trace API call."""

    credentials_secret: Annotated[
        Optional[str], pydantic.Field(alias="credentialsSecret")
    ] = None
    r"""Select or create a secret that references your credentials."""

    client_secret: Annotated[Optional[str], pydantic.Field(alias="clientSecret")] = None
    r"""client_secret to pass in the OAuth request parameter."""

    tenant_id: Annotated[Optional[str], pydantic.Field(alias="tenantId")] = None
    r"""Directory ID (tenant identifier) in Azure Active Directory."""

    client_id: Annotated[Optional[str], pydantic.Field(alias="clientId")] = None
    r"""client_id to pass in the OAuth request parameter."""

    resource: Optional[str] = "https://outlook.office365.com"
    r"""Resource to pass in the OAuth request parameter."""

    plan_type: Annotated[
        Annotated[Optional[PlanTypeOptions], PlainValidator(validate_open_enum(False))],
        pydantic.Field(alias="planType"),
    ] = PlanTypeOptions.ENTERPRISE_GCC
    r"""Office 365 subscription plan for your organization, typically Office 365 Enterprise"""

    text_secret: Annotated[Optional[str], pydantic.Field(alias="textSecret")] = None
    r"""Select or create a secret that references your client_secret to pass in the OAuth request parameter."""

    cert_options: Annotated[
        Optional[CertOptions1], pydantic.Field(alias="certOptions")
    ] = None

    @field_serializer("auth_type")
    def serialize_auth_type(self, value):
        if isinstance(value, str):
            try:
                return models.InputOffice365MsgTraceAuthenticationMethod1(value)
            except ValueError:
                return value
        return value

    @field_serializer("log_level")
    def serialize_log_level(self, value):
        if isinstance(value, str):
            try:
                return models.InputOffice365MsgTraceLogLevel1(value)
            except ValueError:
                return value
        return value

    @field_serializer("plan_type")
    def serialize_plan_type(self, value):
        if isinstance(value, str):
            try:
                return models.PlanTypeOptions(value)
            except ValueError:
                return value
        return value


InputOffice365MsgTraceTypedDict = TypeAliasType(
    "InputOffice365MsgTraceTypedDict",
    Union[
        InputOffice365MsgTraceOffice365MsgTrace1TypedDict,
        InputOffice365MsgTraceOffice365MsgTrace2TypedDict,
        InputOffice365MsgTraceOffice365MsgTrace3TypedDict,
        InputOffice365MsgTraceOffice365MsgTrace4TypedDict,
        InputOffice365MsgTraceOffice365MsgTrace5TypedDict,
        InputOffice365MsgTraceOffice365MsgTrace6TypedDict,
        InputOffice365MsgTraceOffice365MsgTrace7TypedDict,
        InputOffice365MsgTraceOffice365MsgTrace8TypedDict,
        InputOffice365MsgTraceOffice365MsgTrace9TypedDict,
    ],
)


InputOffice365MsgTrace = TypeAliasType(
    "InputOffice365MsgTrace",
    Union[
        InputOffice365MsgTraceOffice365MsgTrace1,
        InputOffice365MsgTraceOffice365MsgTrace2,
        InputOffice365MsgTraceOffice365MsgTrace3,
        InputOffice365MsgTraceOffice365MsgTrace4,
        InputOffice365MsgTraceOffice365MsgTrace5,
        InputOffice365MsgTraceOffice365MsgTrace6,
        InputOffice365MsgTraceOffice365MsgTrace7,
        InputOffice365MsgTraceOffice365MsgTrace8,
        InputOffice365MsgTraceOffice365MsgTrace9,
    ],
)
