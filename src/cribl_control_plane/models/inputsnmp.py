"""Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT."""

from __future__ import annotations
from .connectionstype import ConnectionsType, ConnectionsTypeTypedDict
from .metadata1type import Metadata1Type, Metadata1TypeTypedDict
from .pqtype import PqType, PqTypeTypedDict
from .typesnmpoption import TypeSnmpOption
from cribl_control_plane import models, utils
from cribl_control_plane.types import BaseModel
from cribl_control_plane.utils import validate_open_enum
from enum import Enum
import pydantic
from pydantic import field_serializer
from pydantic.functional_validators import PlainValidator
from typing import Any, List, Optional, Union
from typing_extensions import Annotated, NotRequired, TypeAliasType, TypedDict


class AuthenticationProtocol4(str, Enum, metaclass=utils.OpenEnumMeta):
    # None
    NONE = "none"
    # MD5
    MD5 = "md5"
    # SHA1
    SHA = "sha"
    # SHA224
    SHA224 = "sha224"
    # SHA256
    SHA256 = "sha256"
    # SHA384
    SHA384 = "sha384"
    # SHA512
    SHA512 = "sha512"


class V3User4TypedDict(TypedDict):
    name: str
    auth_protocol: NotRequired[AuthenticationProtocol4]
    auth_key: NotRequired[Any]
    priv_protocol: NotRequired[str]


class V3User4(BaseModel):
    name: str

    auth_protocol: Annotated[
        Annotated[
            Optional[AuthenticationProtocol4], PlainValidator(validate_open_enum(False))
        ],
        pydantic.Field(alias="authProtocol"),
    ] = AuthenticationProtocol4.NONE

    auth_key: Annotated[Optional[Any], pydantic.Field(alias="authKey")] = None

    priv_protocol: Annotated[Optional[str], pydantic.Field(alias="privProtocol")] = (
        "none"
    )

    @field_serializer("auth_protocol")
    def serialize_auth_protocol(self, value):
        if isinstance(value, str):
            try:
                return models.AuthenticationProtocol4(value)
            except ValueError:
                return value
        return value


class SNMPv3Authentication4TypedDict(TypedDict):
    r"""Authentication parameters for SNMPv3 trap. Set the log level to debug if you are experiencing authentication or decryption issues."""

    v3_auth_enabled: NotRequired[bool]
    allow_unmatched_trap: NotRequired[bool]
    r"""Pass through traps that don't match any of the configured users. @{product} will not attempt to decrypt these traps."""
    v3_users: NotRequired[List[V3User4TypedDict]]
    r"""User credentials for receiving v3 traps"""


class SNMPv3Authentication4(BaseModel):
    r"""Authentication parameters for SNMPv3 trap. Set the log level to debug if you are experiencing authentication or decryption issues."""

    v3_auth_enabled: Annotated[
        Optional[bool], pydantic.Field(alias="v3AuthEnabled")
    ] = False

    allow_unmatched_trap: Annotated[
        Optional[bool], pydantic.Field(alias="allowUnmatchedTrap")
    ] = False
    r"""Pass through traps that don't match any of the configured users. @{product} will not attempt to decrypt these traps."""

    v3_users: Annotated[Optional[List[V3User4]], pydantic.Field(alias="v3Users")] = None
    r"""User credentials for receiving v3 traps"""


class InputSnmpSnmp4TypedDict(TypedDict):
    type: TypeSnmpOption
    pq: PqTypeTypedDict
    pq_enabled: NotRequired[bool]
    r"""Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers)."""
    id: NotRequired[str]
    r"""Unique ID for this input"""
    disabled: NotRequired[bool]
    pipeline: NotRequired[str]
    r"""Pipeline to process data from this Source before sending it through the Routes"""
    send_to_routes: NotRequired[bool]
    r"""Select whether to send data to Routes, or directly to Destinations."""
    environment: NotRequired[str]
    r"""Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere."""
    streamtags: NotRequired[List[str]]
    r"""Tags for filtering and grouping in @{product}"""
    connections: NotRequired[List[ConnectionsTypeTypedDict]]
    r"""Direct connections to Destinations, and optionally via a Pipeline or a Pack"""
    host: NotRequired[str]
    r"""Address to bind on. For IPv4 (all addresses), use the default '0.0.0.0'. For IPv6, enter '::' (all addresses) or specify an IP address."""
    port: NotRequired[float]
    r"""UDP port to receive SNMP traps on. Defaults to 162."""
    snmp_v3_auth: NotRequired[SNMPv3Authentication4TypedDict]
    r"""Authentication parameters for SNMPv3 trap. Set the log level to debug if you are experiencing authentication or decryption issues."""
    max_buffer_size: NotRequired[float]
    r"""Maximum number of events to buffer when downstream is blocking."""
    ip_whitelist_regex: NotRequired[str]
    r"""Regex matching IP addresses that are allowed to send data"""
    metadata: NotRequired[List[Metadata1TypeTypedDict]]
    r"""Fields to add to events from this input"""
    udp_socket_rx_buf_size: NotRequired[float]
    r"""Optionally, set the SO_RCVBUF socket option for the UDP socket. This value tells the operating system how many bytes can be buffered in the kernel before events are dropped. Leave blank to use the OS default. Caution: Increasing this value will affect OS memory utilization."""
    varbinds_with_types: NotRequired[bool]
    r"""If enabled, parses varbinds as an array of objects that include OID, value, and type"""
    best_effort_parsing: NotRequired[bool]
    r"""If enabled, the parser will attempt to parse varbind octet strings as UTF-8, first, otherwise will fallback to other methods"""
    description: NotRequired[str]


class InputSnmpSnmp4(BaseModel):
    type: TypeSnmpOption

    pq: PqType

    pq_enabled: Annotated[Optional[bool], pydantic.Field(alias="pqEnabled")] = False
    r"""Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers)."""

    id: Optional[str] = None
    r"""Unique ID for this input"""

    disabled: Optional[bool] = False

    pipeline: Optional[str] = None
    r"""Pipeline to process data from this Source before sending it through the Routes"""

    send_to_routes: Annotated[Optional[bool], pydantic.Field(alias="sendToRoutes")] = (
        True
    )
    r"""Select whether to send data to Routes, or directly to Destinations."""

    environment: Optional[str] = None
    r"""Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere."""

    streamtags: Optional[List[str]] = None
    r"""Tags for filtering and grouping in @{product}"""

    connections: Optional[List[ConnectionsType]] = None
    r"""Direct connections to Destinations, and optionally via a Pipeline or a Pack"""

    host: Optional[str] = "0.0.0.0"
    r"""Address to bind on. For IPv4 (all addresses), use the default '0.0.0.0'. For IPv6, enter '::' (all addresses) or specify an IP address."""

    port: Optional[float] = 162
    r"""UDP port to receive SNMP traps on. Defaults to 162."""

    snmp_v3_auth: Annotated[
        Optional[SNMPv3Authentication4], pydantic.Field(alias="snmpV3Auth")
    ] = None
    r"""Authentication parameters for SNMPv3 trap. Set the log level to debug if you are experiencing authentication or decryption issues."""

    max_buffer_size: Annotated[
        Optional[float], pydantic.Field(alias="maxBufferSize")
    ] = 1000
    r"""Maximum number of events to buffer when downstream is blocking."""

    ip_whitelist_regex: Annotated[
        Optional[str], pydantic.Field(alias="ipWhitelistRegex")
    ] = "/.*/"
    r"""Regex matching IP addresses that are allowed to send data"""

    metadata: Optional[List[Metadata1Type]] = None
    r"""Fields to add to events from this input"""

    udp_socket_rx_buf_size: Annotated[
        Optional[float], pydantic.Field(alias="udpSocketRxBufSize")
    ] = None
    r"""Optionally, set the SO_RCVBUF socket option for the UDP socket. This value tells the operating system how many bytes can be buffered in the kernel before events are dropped. Leave blank to use the OS default. Caution: Increasing this value will affect OS memory utilization."""

    varbinds_with_types: Annotated[
        Optional[bool], pydantic.Field(alias="varbindsWithTypes")
    ] = False
    r"""If enabled, parses varbinds as an array of objects that include OID, value, and type"""

    best_effort_parsing: Annotated[
        Optional[bool], pydantic.Field(alias="bestEffortParsing")
    ] = False
    r"""If enabled, the parser will attempt to parse varbind octet strings as UTF-8, first, otherwise will fallback to other methods"""

    description: Optional[str] = None


class AuthenticationProtocol3(str, Enum, metaclass=utils.OpenEnumMeta):
    # None
    NONE = "none"
    # MD5
    MD5 = "md5"
    # SHA1
    SHA = "sha"
    # SHA224
    SHA224 = "sha224"
    # SHA256
    SHA256 = "sha256"
    # SHA384
    SHA384 = "sha384"
    # SHA512
    SHA512 = "sha512"


class V3User3TypedDict(TypedDict):
    name: str
    auth_protocol: NotRequired[AuthenticationProtocol3]
    auth_key: NotRequired[Any]
    priv_protocol: NotRequired[str]


class V3User3(BaseModel):
    name: str

    auth_protocol: Annotated[
        Annotated[
            Optional[AuthenticationProtocol3], PlainValidator(validate_open_enum(False))
        ],
        pydantic.Field(alias="authProtocol"),
    ] = AuthenticationProtocol3.NONE

    auth_key: Annotated[Optional[Any], pydantic.Field(alias="authKey")] = None

    priv_protocol: Annotated[Optional[str], pydantic.Field(alias="privProtocol")] = (
        "none"
    )

    @field_serializer("auth_protocol")
    def serialize_auth_protocol(self, value):
        if isinstance(value, str):
            try:
                return models.AuthenticationProtocol3(value)
            except ValueError:
                return value
        return value


class SNMPv3Authentication3TypedDict(TypedDict):
    r"""Authentication parameters for SNMPv3 trap. Set the log level to debug if you are experiencing authentication or decryption issues."""

    v3_auth_enabled: NotRequired[bool]
    allow_unmatched_trap: NotRequired[bool]
    r"""Pass through traps that don't match any of the configured users. @{product} will not attempt to decrypt these traps."""
    v3_users: NotRequired[List[V3User3TypedDict]]
    r"""User credentials for receiving v3 traps"""


class SNMPv3Authentication3(BaseModel):
    r"""Authentication parameters for SNMPv3 trap. Set the log level to debug if you are experiencing authentication or decryption issues."""

    v3_auth_enabled: Annotated[
        Optional[bool], pydantic.Field(alias="v3AuthEnabled")
    ] = False

    allow_unmatched_trap: Annotated[
        Optional[bool], pydantic.Field(alias="allowUnmatchedTrap")
    ] = False
    r"""Pass through traps that don't match any of the configured users. @{product} will not attempt to decrypt these traps."""

    v3_users: Annotated[Optional[List[V3User3]], pydantic.Field(alias="v3Users")] = None
    r"""User credentials for receiving v3 traps"""


class InputSnmpSnmp3TypedDict(TypedDict):
    type: TypeSnmpOption
    pq_enabled: NotRequired[bool]
    r"""Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers)."""
    id: NotRequired[str]
    r"""Unique ID for this input"""
    disabled: NotRequired[bool]
    pipeline: NotRequired[str]
    r"""Pipeline to process data from this Source before sending it through the Routes"""
    send_to_routes: NotRequired[bool]
    r"""Select whether to send data to Routes, or directly to Destinations."""
    environment: NotRequired[str]
    r"""Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere."""
    streamtags: NotRequired[List[str]]
    r"""Tags for filtering and grouping in @{product}"""
    connections: NotRequired[List[ConnectionsTypeTypedDict]]
    r"""Direct connections to Destinations, and optionally via a Pipeline or a Pack"""
    pq: NotRequired[PqTypeTypedDict]
    host: NotRequired[str]
    r"""Address to bind on. For IPv4 (all addresses), use the default '0.0.0.0'. For IPv6, enter '::' (all addresses) or specify an IP address."""
    port: NotRequired[float]
    r"""UDP port to receive SNMP traps on. Defaults to 162."""
    snmp_v3_auth: NotRequired[SNMPv3Authentication3TypedDict]
    r"""Authentication parameters for SNMPv3 trap. Set the log level to debug if you are experiencing authentication or decryption issues."""
    max_buffer_size: NotRequired[float]
    r"""Maximum number of events to buffer when downstream is blocking."""
    ip_whitelist_regex: NotRequired[str]
    r"""Regex matching IP addresses that are allowed to send data"""
    metadata: NotRequired[List[Metadata1TypeTypedDict]]
    r"""Fields to add to events from this input"""
    udp_socket_rx_buf_size: NotRequired[float]
    r"""Optionally, set the SO_RCVBUF socket option for the UDP socket. This value tells the operating system how many bytes can be buffered in the kernel before events are dropped. Leave blank to use the OS default. Caution: Increasing this value will affect OS memory utilization."""
    varbinds_with_types: NotRequired[bool]
    r"""If enabled, parses varbinds as an array of objects that include OID, value, and type"""
    best_effort_parsing: NotRequired[bool]
    r"""If enabled, the parser will attempt to parse varbind octet strings as UTF-8, first, otherwise will fallback to other methods"""
    description: NotRequired[str]


class InputSnmpSnmp3(BaseModel):
    type: TypeSnmpOption

    pq_enabled: Annotated[Optional[bool], pydantic.Field(alias="pqEnabled")] = False
    r"""Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers)."""

    id: Optional[str] = None
    r"""Unique ID for this input"""

    disabled: Optional[bool] = False

    pipeline: Optional[str] = None
    r"""Pipeline to process data from this Source before sending it through the Routes"""

    send_to_routes: Annotated[Optional[bool], pydantic.Field(alias="sendToRoutes")] = (
        True
    )
    r"""Select whether to send data to Routes, or directly to Destinations."""

    environment: Optional[str] = None
    r"""Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere."""

    streamtags: Optional[List[str]] = None
    r"""Tags for filtering and grouping in @{product}"""

    connections: Optional[List[ConnectionsType]] = None
    r"""Direct connections to Destinations, and optionally via a Pipeline or a Pack"""

    pq: Optional[PqType] = None

    host: Optional[str] = "0.0.0.0"
    r"""Address to bind on. For IPv4 (all addresses), use the default '0.0.0.0'. For IPv6, enter '::' (all addresses) or specify an IP address."""

    port: Optional[float] = 162
    r"""UDP port to receive SNMP traps on. Defaults to 162."""

    snmp_v3_auth: Annotated[
        Optional[SNMPv3Authentication3], pydantic.Field(alias="snmpV3Auth")
    ] = None
    r"""Authentication parameters for SNMPv3 trap. Set the log level to debug if you are experiencing authentication or decryption issues."""

    max_buffer_size: Annotated[
        Optional[float], pydantic.Field(alias="maxBufferSize")
    ] = 1000
    r"""Maximum number of events to buffer when downstream is blocking."""

    ip_whitelist_regex: Annotated[
        Optional[str], pydantic.Field(alias="ipWhitelistRegex")
    ] = "/.*/"
    r"""Regex matching IP addresses that are allowed to send data"""

    metadata: Optional[List[Metadata1Type]] = None
    r"""Fields to add to events from this input"""

    udp_socket_rx_buf_size: Annotated[
        Optional[float], pydantic.Field(alias="udpSocketRxBufSize")
    ] = None
    r"""Optionally, set the SO_RCVBUF socket option for the UDP socket. This value tells the operating system how many bytes can be buffered in the kernel before events are dropped. Leave blank to use the OS default. Caution: Increasing this value will affect OS memory utilization."""

    varbinds_with_types: Annotated[
        Optional[bool], pydantic.Field(alias="varbindsWithTypes")
    ] = False
    r"""If enabled, parses varbinds as an array of objects that include OID, value, and type"""

    best_effort_parsing: Annotated[
        Optional[bool], pydantic.Field(alias="bestEffortParsing")
    ] = False
    r"""If enabled, the parser will attempt to parse varbind octet strings as UTF-8, first, otherwise will fallback to other methods"""

    description: Optional[str] = None


class AuthenticationProtocol2(str, Enum, metaclass=utils.OpenEnumMeta):
    # None
    NONE = "none"
    # MD5
    MD5 = "md5"
    # SHA1
    SHA = "sha"
    # SHA224
    SHA224 = "sha224"
    # SHA256
    SHA256 = "sha256"
    # SHA384
    SHA384 = "sha384"
    # SHA512
    SHA512 = "sha512"


class V3User2TypedDict(TypedDict):
    name: str
    auth_protocol: NotRequired[AuthenticationProtocol2]
    auth_key: NotRequired[Any]
    priv_protocol: NotRequired[str]


class V3User2(BaseModel):
    name: str

    auth_protocol: Annotated[
        Annotated[
            Optional[AuthenticationProtocol2], PlainValidator(validate_open_enum(False))
        ],
        pydantic.Field(alias="authProtocol"),
    ] = AuthenticationProtocol2.NONE

    auth_key: Annotated[Optional[Any], pydantic.Field(alias="authKey")] = None

    priv_protocol: Annotated[Optional[str], pydantic.Field(alias="privProtocol")] = (
        "none"
    )

    @field_serializer("auth_protocol")
    def serialize_auth_protocol(self, value):
        if isinstance(value, str):
            try:
                return models.AuthenticationProtocol2(value)
            except ValueError:
                return value
        return value


class SNMPv3Authentication2TypedDict(TypedDict):
    r"""Authentication parameters for SNMPv3 trap. Set the log level to debug if you are experiencing authentication or decryption issues."""

    v3_auth_enabled: NotRequired[bool]
    allow_unmatched_trap: NotRequired[bool]
    r"""Pass through traps that don't match any of the configured users. @{product} will not attempt to decrypt these traps."""
    v3_users: NotRequired[List[V3User2TypedDict]]
    r"""User credentials for receiving v3 traps"""


class SNMPv3Authentication2(BaseModel):
    r"""Authentication parameters for SNMPv3 trap. Set the log level to debug if you are experiencing authentication or decryption issues."""

    v3_auth_enabled: Annotated[
        Optional[bool], pydantic.Field(alias="v3AuthEnabled")
    ] = False

    allow_unmatched_trap: Annotated[
        Optional[bool], pydantic.Field(alias="allowUnmatchedTrap")
    ] = False
    r"""Pass through traps that don't match any of the configured users. @{product} will not attempt to decrypt these traps."""

    v3_users: Annotated[Optional[List[V3User2]], pydantic.Field(alias="v3Users")] = None
    r"""User credentials for receiving v3 traps"""


class InputSnmpSnmp2TypedDict(TypedDict):
    type: TypeSnmpOption
    connections: List[ConnectionsTypeTypedDict]
    r"""Direct connections to Destinations, and optionally via a Pipeline or a Pack"""
    send_to_routes: NotRequired[bool]
    r"""Select whether to send data to Routes, or directly to Destinations."""
    id: NotRequired[str]
    r"""Unique ID for this input"""
    disabled: NotRequired[bool]
    pipeline: NotRequired[str]
    r"""Pipeline to process data from this Source before sending it through the Routes"""
    environment: NotRequired[str]
    r"""Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere."""
    pq_enabled: NotRequired[bool]
    r"""Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers)."""
    streamtags: NotRequired[List[str]]
    r"""Tags for filtering and grouping in @{product}"""
    pq: NotRequired[PqTypeTypedDict]
    host: NotRequired[str]
    r"""Address to bind on. For IPv4 (all addresses), use the default '0.0.0.0'. For IPv6, enter '::' (all addresses) or specify an IP address."""
    port: NotRequired[float]
    r"""UDP port to receive SNMP traps on. Defaults to 162."""
    snmp_v3_auth: NotRequired[SNMPv3Authentication2TypedDict]
    r"""Authentication parameters for SNMPv3 trap. Set the log level to debug if you are experiencing authentication or decryption issues."""
    max_buffer_size: NotRequired[float]
    r"""Maximum number of events to buffer when downstream is blocking."""
    ip_whitelist_regex: NotRequired[str]
    r"""Regex matching IP addresses that are allowed to send data"""
    metadata: NotRequired[List[Metadata1TypeTypedDict]]
    r"""Fields to add to events from this input"""
    udp_socket_rx_buf_size: NotRequired[float]
    r"""Optionally, set the SO_RCVBUF socket option for the UDP socket. This value tells the operating system how many bytes can be buffered in the kernel before events are dropped. Leave blank to use the OS default. Caution: Increasing this value will affect OS memory utilization."""
    varbinds_with_types: NotRequired[bool]
    r"""If enabled, parses varbinds as an array of objects that include OID, value, and type"""
    best_effort_parsing: NotRequired[bool]
    r"""If enabled, the parser will attempt to parse varbind octet strings as UTF-8, first, otherwise will fallback to other methods"""
    description: NotRequired[str]


class InputSnmpSnmp2(BaseModel):
    type: TypeSnmpOption

    connections: List[ConnectionsType]
    r"""Direct connections to Destinations, and optionally via a Pipeline or a Pack"""

    send_to_routes: Annotated[Optional[bool], pydantic.Field(alias="sendToRoutes")] = (
        True
    )
    r"""Select whether to send data to Routes, or directly to Destinations."""

    id: Optional[str] = None
    r"""Unique ID for this input"""

    disabled: Optional[bool] = False

    pipeline: Optional[str] = None
    r"""Pipeline to process data from this Source before sending it through the Routes"""

    environment: Optional[str] = None
    r"""Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere."""

    pq_enabled: Annotated[Optional[bool], pydantic.Field(alias="pqEnabled")] = False
    r"""Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers)."""

    streamtags: Optional[List[str]] = None
    r"""Tags for filtering and grouping in @{product}"""

    pq: Optional[PqType] = None

    host: Optional[str] = "0.0.0.0"
    r"""Address to bind on. For IPv4 (all addresses), use the default '0.0.0.0'. For IPv6, enter '::' (all addresses) or specify an IP address."""

    port: Optional[float] = 162
    r"""UDP port to receive SNMP traps on. Defaults to 162."""

    snmp_v3_auth: Annotated[
        Optional[SNMPv3Authentication2], pydantic.Field(alias="snmpV3Auth")
    ] = None
    r"""Authentication parameters for SNMPv3 trap. Set the log level to debug if you are experiencing authentication or decryption issues."""

    max_buffer_size: Annotated[
        Optional[float], pydantic.Field(alias="maxBufferSize")
    ] = 1000
    r"""Maximum number of events to buffer when downstream is blocking."""

    ip_whitelist_regex: Annotated[
        Optional[str], pydantic.Field(alias="ipWhitelistRegex")
    ] = "/.*/"
    r"""Regex matching IP addresses that are allowed to send data"""

    metadata: Optional[List[Metadata1Type]] = None
    r"""Fields to add to events from this input"""

    udp_socket_rx_buf_size: Annotated[
        Optional[float], pydantic.Field(alias="udpSocketRxBufSize")
    ] = None
    r"""Optionally, set the SO_RCVBUF socket option for the UDP socket. This value tells the operating system how many bytes can be buffered in the kernel before events are dropped. Leave blank to use the OS default. Caution: Increasing this value will affect OS memory utilization."""

    varbinds_with_types: Annotated[
        Optional[bool], pydantic.Field(alias="varbindsWithTypes")
    ] = False
    r"""If enabled, parses varbinds as an array of objects that include OID, value, and type"""

    best_effort_parsing: Annotated[
        Optional[bool], pydantic.Field(alias="bestEffortParsing")
    ] = False
    r"""If enabled, the parser will attempt to parse varbind octet strings as UTF-8, first, otherwise will fallback to other methods"""

    description: Optional[str] = None


class AuthenticationProtocol1(str, Enum, metaclass=utils.OpenEnumMeta):
    # None
    NONE = "none"
    # MD5
    MD5 = "md5"
    # SHA1
    SHA = "sha"
    # SHA224
    SHA224 = "sha224"
    # SHA256
    SHA256 = "sha256"
    # SHA384
    SHA384 = "sha384"
    # SHA512
    SHA512 = "sha512"


class V3User1TypedDict(TypedDict):
    name: str
    auth_protocol: NotRequired[AuthenticationProtocol1]
    auth_key: NotRequired[Any]
    priv_protocol: NotRequired[str]


class V3User1(BaseModel):
    name: str

    auth_protocol: Annotated[
        Annotated[
            Optional[AuthenticationProtocol1], PlainValidator(validate_open_enum(False))
        ],
        pydantic.Field(alias="authProtocol"),
    ] = AuthenticationProtocol1.NONE

    auth_key: Annotated[Optional[Any], pydantic.Field(alias="authKey")] = None

    priv_protocol: Annotated[Optional[str], pydantic.Field(alias="privProtocol")] = (
        "none"
    )

    @field_serializer("auth_protocol")
    def serialize_auth_protocol(self, value):
        if isinstance(value, str):
            try:
                return models.AuthenticationProtocol1(value)
            except ValueError:
                return value
        return value


class SNMPv3Authentication1TypedDict(TypedDict):
    r"""Authentication parameters for SNMPv3 trap. Set the log level to debug if you are experiencing authentication or decryption issues."""

    v3_auth_enabled: NotRequired[bool]
    allow_unmatched_trap: NotRequired[bool]
    r"""Pass through traps that don't match any of the configured users. @{product} will not attempt to decrypt these traps."""
    v3_users: NotRequired[List[V3User1TypedDict]]
    r"""User credentials for receiving v3 traps"""


class SNMPv3Authentication1(BaseModel):
    r"""Authentication parameters for SNMPv3 trap. Set the log level to debug if you are experiencing authentication or decryption issues."""

    v3_auth_enabled: Annotated[
        Optional[bool], pydantic.Field(alias="v3AuthEnabled")
    ] = False

    allow_unmatched_trap: Annotated[
        Optional[bool], pydantic.Field(alias="allowUnmatchedTrap")
    ] = False
    r"""Pass through traps that don't match any of the configured users. @{product} will not attempt to decrypt these traps."""

    v3_users: Annotated[Optional[List[V3User1]], pydantic.Field(alias="v3Users")] = None
    r"""User credentials for receiving v3 traps"""


class InputSnmpSnmp1TypedDict(TypedDict):
    type: TypeSnmpOption
    send_to_routes: NotRequired[bool]
    r"""Select whether to send data to Routes, or directly to Destinations."""
    id: NotRequired[str]
    r"""Unique ID for this input"""
    disabled: NotRequired[bool]
    pipeline: NotRequired[str]
    r"""Pipeline to process data from this Source before sending it through the Routes"""
    environment: NotRequired[str]
    r"""Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere."""
    pq_enabled: NotRequired[bool]
    r"""Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers)."""
    streamtags: NotRequired[List[str]]
    r"""Tags for filtering and grouping in @{product}"""
    connections: NotRequired[List[ConnectionsTypeTypedDict]]
    r"""Direct connections to Destinations, and optionally via a Pipeline or a Pack"""
    pq: NotRequired[PqTypeTypedDict]
    host: NotRequired[str]
    r"""Address to bind on. For IPv4 (all addresses), use the default '0.0.0.0'. For IPv6, enter '::' (all addresses) or specify an IP address."""
    port: NotRequired[float]
    r"""UDP port to receive SNMP traps on. Defaults to 162."""
    snmp_v3_auth: NotRequired[SNMPv3Authentication1TypedDict]
    r"""Authentication parameters for SNMPv3 trap. Set the log level to debug if you are experiencing authentication or decryption issues."""
    max_buffer_size: NotRequired[float]
    r"""Maximum number of events to buffer when downstream is blocking."""
    ip_whitelist_regex: NotRequired[str]
    r"""Regex matching IP addresses that are allowed to send data"""
    metadata: NotRequired[List[Metadata1TypeTypedDict]]
    r"""Fields to add to events from this input"""
    udp_socket_rx_buf_size: NotRequired[float]
    r"""Optionally, set the SO_RCVBUF socket option for the UDP socket. This value tells the operating system how many bytes can be buffered in the kernel before events are dropped. Leave blank to use the OS default. Caution: Increasing this value will affect OS memory utilization."""
    varbinds_with_types: NotRequired[bool]
    r"""If enabled, parses varbinds as an array of objects that include OID, value, and type"""
    best_effort_parsing: NotRequired[bool]
    r"""If enabled, the parser will attempt to parse varbind octet strings as UTF-8, first, otherwise will fallback to other methods"""
    description: NotRequired[str]


class InputSnmpSnmp1(BaseModel):
    type: TypeSnmpOption

    send_to_routes: Annotated[Optional[bool], pydantic.Field(alias="sendToRoutes")] = (
        True
    )
    r"""Select whether to send data to Routes, or directly to Destinations."""

    id: Optional[str] = None
    r"""Unique ID for this input"""

    disabled: Optional[bool] = False

    pipeline: Optional[str] = None
    r"""Pipeline to process data from this Source before sending it through the Routes"""

    environment: Optional[str] = None
    r"""Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere."""

    pq_enabled: Annotated[Optional[bool], pydantic.Field(alias="pqEnabled")] = False
    r"""Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers)."""

    streamtags: Optional[List[str]] = None
    r"""Tags for filtering and grouping in @{product}"""

    connections: Optional[List[ConnectionsType]] = None
    r"""Direct connections to Destinations, and optionally via a Pipeline or a Pack"""

    pq: Optional[PqType] = None

    host: Optional[str] = "0.0.0.0"
    r"""Address to bind on. For IPv4 (all addresses), use the default '0.0.0.0'. For IPv6, enter '::' (all addresses) or specify an IP address."""

    port: Optional[float] = 162
    r"""UDP port to receive SNMP traps on. Defaults to 162."""

    snmp_v3_auth: Annotated[
        Optional[SNMPv3Authentication1], pydantic.Field(alias="snmpV3Auth")
    ] = None
    r"""Authentication parameters for SNMPv3 trap. Set the log level to debug if you are experiencing authentication or decryption issues."""

    max_buffer_size: Annotated[
        Optional[float], pydantic.Field(alias="maxBufferSize")
    ] = 1000
    r"""Maximum number of events to buffer when downstream is blocking."""

    ip_whitelist_regex: Annotated[
        Optional[str], pydantic.Field(alias="ipWhitelistRegex")
    ] = "/.*/"
    r"""Regex matching IP addresses that are allowed to send data"""

    metadata: Optional[List[Metadata1Type]] = None
    r"""Fields to add to events from this input"""

    udp_socket_rx_buf_size: Annotated[
        Optional[float], pydantic.Field(alias="udpSocketRxBufSize")
    ] = None
    r"""Optionally, set the SO_RCVBUF socket option for the UDP socket. This value tells the operating system how many bytes can be buffered in the kernel before events are dropped. Leave blank to use the OS default. Caution: Increasing this value will affect OS memory utilization."""

    varbinds_with_types: Annotated[
        Optional[bool], pydantic.Field(alias="varbindsWithTypes")
    ] = False
    r"""If enabled, parses varbinds as an array of objects that include OID, value, and type"""

    best_effort_parsing: Annotated[
        Optional[bool], pydantic.Field(alias="bestEffortParsing")
    ] = False
    r"""If enabled, the parser will attempt to parse varbind octet strings as UTF-8, first, otherwise will fallback to other methods"""

    description: Optional[str] = None


InputSnmpTypedDict = TypeAliasType(
    "InputSnmpTypedDict",
    Union[
        InputSnmpSnmp1TypedDict,
        InputSnmpSnmp2TypedDict,
        InputSnmpSnmp3TypedDict,
        InputSnmpSnmp4TypedDict,
    ],
)


InputSnmp = TypeAliasType(
    "InputSnmp", Union[InputSnmpSnmp1, InputSnmpSnmp2, InputSnmpSnmp3, InputSnmpSnmp4]
)
