"""Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT."""

from __future__ import annotations
from .connectionstype import ConnectionsType, ConnectionsTypeTypedDict
from .metadata1type import Metadata1Type, Metadata1TypeTypedDict
from .persistence1type import Persistence1Type, Persistence1TypeTypedDict
from .pqtype import PqType, PqTypeTypedDict
from .processtype import ProcessType, ProcessTypeTypedDict
from cribl_control_plane import models, utils
from cribl_control_plane.types import BaseModel
from cribl_control_plane.utils import validate_open_enum
from enum import Enum
import pydantic
from pydantic import field_serializer
from pydantic.functional_validators import PlainValidator
from typing import List, Optional, Union
from typing_extensions import Annotated, NotRequired, TypeAliasType, TypedDict


class InputSystemMetricsType4(str, Enum):
    SYSTEM_METRICS = "system_metrics"


class InputSystemMetricsHostMode4(str, Enum, metaclass=utils.OpenEnumMeta):
    r"""Select level of detail for host metrics"""

    # Basic
    BASIC = "basic"
    # All
    ALL = "all"
    # Custom
    CUSTOM = "custom"
    # Disabled
    DISABLED = "disabled"


class InputSystemMetricsSystemMode4(str, Enum, metaclass=utils.OpenEnumMeta):
    r"""Select the level of detail for system metrics"""

    # Basic
    BASIC = "basic"
    # All
    ALL = "all"
    # Custom
    CUSTOM = "custom"
    # Disabled
    DISABLED = "disabled"


class InputSystemMetricsSystem4TypedDict(TypedDict):
    mode: NotRequired[InputSystemMetricsSystemMode4]
    r"""Select the level of detail for system metrics"""
    processes: NotRequired[bool]
    r"""Generate metrics for the numbers of processes in various states"""


class InputSystemMetricsSystem4(BaseModel):
    mode: Annotated[
        Optional[InputSystemMetricsSystemMode4],
        PlainValidator(validate_open_enum(False)),
    ] = InputSystemMetricsSystemMode4.BASIC
    r"""Select the level of detail for system metrics"""

    processes: Optional[bool] = False
    r"""Generate metrics for the numbers of processes in various states"""

    @field_serializer("mode")
    def serialize_mode(self, value):
        if isinstance(value, str):
            try:
                return models.InputSystemMetricsSystemMode4(value)
            except ValueError:
                return value
        return value


class InputSystemMetricsCPUMode4(str, Enum, metaclass=utils.OpenEnumMeta):
    r"""Select the level of detail for CPU metrics"""

    # Basic
    BASIC = "basic"
    # All
    ALL = "all"
    # Custom
    CUSTOM = "custom"
    # Disabled
    DISABLED = "disabled"


class InputSystemMetricsCPU4TypedDict(TypedDict):
    mode: NotRequired[InputSystemMetricsCPUMode4]
    r"""Select the level of detail for CPU metrics"""
    per_cpu: NotRequired[bool]
    r"""Generate metrics for each CPU"""
    detail: NotRequired[bool]
    r"""Generate metrics for all CPU states"""
    time: NotRequired[bool]
    r"""Generate raw, monotonic CPU time counters"""


class InputSystemMetricsCPU4(BaseModel):
    mode: Annotated[
        Optional[InputSystemMetricsCPUMode4], PlainValidator(validate_open_enum(False))
    ] = InputSystemMetricsCPUMode4.BASIC
    r"""Select the level of detail for CPU metrics"""

    per_cpu: Annotated[Optional[bool], pydantic.Field(alias="perCpu")] = False
    r"""Generate metrics for each CPU"""

    detail: Optional[bool] = False
    r"""Generate metrics for all CPU states"""

    time: Optional[bool] = False
    r"""Generate raw, monotonic CPU time counters"""

    @field_serializer("mode")
    def serialize_mode(self, value):
        if isinstance(value, str):
            try:
                return models.InputSystemMetricsCPUMode4(value)
            except ValueError:
                return value
        return value


class InputSystemMetricsMemoryMode4(str, Enum, metaclass=utils.OpenEnumMeta):
    r"""Select the level of detail for memory metrics"""

    # Basic
    BASIC = "basic"
    # All
    ALL = "all"
    # Custom
    CUSTOM = "custom"
    # Disabled
    DISABLED = "disabled"


class InputSystemMetricsMemory4TypedDict(TypedDict):
    mode: NotRequired[InputSystemMetricsMemoryMode4]
    r"""Select the level of detail for memory metrics"""
    detail: NotRequired[bool]
    r"""Generate metrics for all memory states"""


class InputSystemMetricsMemory4(BaseModel):
    mode: Annotated[
        Optional[InputSystemMetricsMemoryMode4],
        PlainValidator(validate_open_enum(False)),
    ] = InputSystemMetricsMemoryMode4.BASIC
    r"""Select the level of detail for memory metrics"""

    detail: Optional[bool] = False
    r"""Generate metrics for all memory states"""

    @field_serializer("mode")
    def serialize_mode(self, value):
        if isinstance(value, str):
            try:
                return models.InputSystemMetricsMemoryMode4(value)
            except ValueError:
                return value
        return value


class InputSystemMetricsNetworkMode4(str, Enum, metaclass=utils.OpenEnumMeta):
    r"""Select the level of detail for network metrics"""

    # Basic
    BASIC = "basic"
    # All
    ALL = "all"
    # Custom
    CUSTOM = "custom"
    # Disabled
    DISABLED = "disabled"


class InputSystemMetricsNetwork4TypedDict(TypedDict):
    mode: NotRequired[InputSystemMetricsNetworkMode4]
    r"""Select the level of detail for network metrics"""
    detail: NotRequired[bool]
    r"""Generate full network metrics"""
    protocols: NotRequired[bool]
    r"""Generate protocol metrics for ICMP, ICMPMsg, IP, TCP, UDP and UDPLite"""
    devices: NotRequired[List[str]]
    r"""Network interfaces to include/exclude. Examples: eth0, !lo. All interfaces are included if this list is empty."""
    per_interface: NotRequired[bool]
    r"""Generate separate metrics for each interface"""


class InputSystemMetricsNetwork4(BaseModel):
    mode: Annotated[
        Optional[InputSystemMetricsNetworkMode4],
        PlainValidator(validate_open_enum(False)),
    ] = InputSystemMetricsNetworkMode4.BASIC
    r"""Select the level of detail for network metrics"""

    detail: Optional[bool] = False
    r"""Generate full network metrics"""

    protocols: Optional[bool] = False
    r"""Generate protocol metrics for ICMP, ICMPMsg, IP, TCP, UDP and UDPLite"""

    devices: Optional[List[str]] = None
    r"""Network interfaces to include/exclude. Examples: eth0, !lo. All interfaces are included if this list is empty."""

    per_interface: Annotated[Optional[bool], pydantic.Field(alias="perInterface")] = (
        False
    )
    r"""Generate separate metrics for each interface"""

    @field_serializer("mode")
    def serialize_mode(self, value):
        if isinstance(value, str):
            try:
                return models.InputSystemMetricsNetworkMode4(value)
            except ValueError:
                return value
        return value


class InputSystemMetricsDiskMode4(str, Enum, metaclass=utils.OpenEnumMeta):
    r"""Select the level of detail for disk metrics"""

    # Basic
    BASIC = "basic"
    # All
    ALL = "all"
    # Custom
    CUSTOM = "custom"
    # Disabled
    DISABLED = "disabled"


class InputSystemMetricsDisk4TypedDict(TypedDict):
    mode: NotRequired[InputSystemMetricsDiskMode4]
    r"""Select the level of detail for disk metrics"""
    detail: NotRequired[bool]
    r"""Generate full disk metrics"""
    inodes: NotRequired[bool]
    r"""Generate filesystem inode metrics"""
    devices: NotRequired[List[str]]
    r"""Block devices to include/exclude. Examples: sda*, !loop*. Wildcards and ! (not) operators are supported. All devices are included if this list is empty."""
    mountpoints: NotRequired[List[str]]
    r"""Filesystem mountpoints to include/exclude. Examples: /, /home, !/proc*, !/tmp. Wildcards and ! (not) operators are supported. All mountpoints are included if this list is empty."""
    fstypes: NotRequired[List[str]]
    r"""Filesystem types to include/exclude. Examples: ext4, !*tmpfs, !squashfs. Wildcards and ! (not) operators are supported. All types are included if this list is empty."""
    per_device: NotRequired[bool]
    r"""Generate separate metrics for each device"""


class InputSystemMetricsDisk4(BaseModel):
    mode: Annotated[
        Optional[InputSystemMetricsDiskMode4], PlainValidator(validate_open_enum(False))
    ] = InputSystemMetricsDiskMode4.BASIC
    r"""Select the level of detail for disk metrics"""

    detail: Optional[bool] = False
    r"""Generate full disk metrics"""

    inodes: Optional[bool] = False
    r"""Generate filesystem inode metrics"""

    devices: Optional[List[str]] = None
    r"""Block devices to include/exclude. Examples: sda*, !loop*. Wildcards and ! (not) operators are supported. All devices are included if this list is empty."""

    mountpoints: Optional[List[str]] = None
    r"""Filesystem mountpoints to include/exclude. Examples: /, /home, !/proc*, !/tmp. Wildcards and ! (not) operators are supported. All mountpoints are included if this list is empty."""

    fstypes: Optional[List[str]] = None
    r"""Filesystem types to include/exclude. Examples: ext4, !*tmpfs, !squashfs. Wildcards and ! (not) operators are supported. All types are included if this list is empty."""

    per_device: Annotated[Optional[bool], pydantic.Field(alias="perDevice")] = False
    r"""Generate separate metrics for each device"""

    @field_serializer("mode")
    def serialize_mode(self, value):
        if isinstance(value, str):
            try:
                return models.InputSystemMetricsDiskMode4(value)
            except ValueError:
                return value
        return value


class InputSystemMetricsCustom4TypedDict(TypedDict):
    system: NotRequired[InputSystemMetricsSystem4TypedDict]
    cpu: NotRequired[InputSystemMetricsCPU4TypedDict]
    memory: NotRequired[InputSystemMetricsMemory4TypedDict]
    network: NotRequired[InputSystemMetricsNetwork4TypedDict]
    disk: NotRequired[InputSystemMetricsDisk4TypedDict]


class InputSystemMetricsCustom4(BaseModel):
    system: Optional[InputSystemMetricsSystem4] = None

    cpu: Optional[InputSystemMetricsCPU4] = None

    memory: Optional[InputSystemMetricsMemory4] = None

    network: Optional[InputSystemMetricsNetwork4] = None

    disk: Optional[InputSystemMetricsDisk4] = None


class InputSystemMetricsHost4TypedDict(TypedDict):
    mode: NotRequired[InputSystemMetricsHostMode4]
    r"""Select level of detail for host metrics"""
    custom: NotRequired[InputSystemMetricsCustom4TypedDict]


class InputSystemMetricsHost4(BaseModel):
    mode: Annotated[
        Optional[InputSystemMetricsHostMode4], PlainValidator(validate_open_enum(False))
    ] = InputSystemMetricsHostMode4.BASIC
    r"""Select level of detail for host metrics"""

    custom: Optional[InputSystemMetricsCustom4] = None

    @field_serializer("mode")
    def serialize_mode(self, value):
        if isinstance(value, str):
            try:
                return models.InputSystemMetricsHostMode4(value)
            except ValueError:
                return value
        return value


class ContainerMode4(str, Enum, metaclass=utils.OpenEnumMeta):
    r"""Select the level of detail for container metrics"""

    # Basic
    BASIC = "basic"
    # All
    ALL = "all"
    # Custom
    CUSTOM = "custom"
    # Disabled
    DISABLED = "disabled"


class InputSystemMetricsFilter4TypedDict(TypedDict):
    expr: str


class InputSystemMetricsFilter4(BaseModel):
    expr: str


class Container4TypedDict(TypedDict):
    mode: NotRequired[ContainerMode4]
    r"""Select the level of detail for container metrics"""
    docker_socket: NotRequired[List[str]]
    r"""Full paths for Docker's UNIX-domain socket"""
    docker_timeout: NotRequired[float]
    r"""Timeout, in seconds, for the Docker API"""
    filters: NotRequired[List[InputSystemMetricsFilter4TypedDict]]
    r"""Containers matching any of these will be included. All are included if no filters are added."""
    all_containers: NotRequired[bool]
    r"""Include stopped and paused containers"""
    per_device: NotRequired[bool]
    r"""Generate separate metrics for each device"""
    detail: NotRequired[bool]
    r"""Generate full container metrics"""


class Container4(BaseModel):
    mode: Annotated[
        Optional[ContainerMode4], PlainValidator(validate_open_enum(False))
    ] = ContainerMode4.BASIC
    r"""Select the level of detail for container metrics"""

    docker_socket: Annotated[
        Optional[List[str]], pydantic.Field(alias="dockerSocket")
    ] = None
    r"""Full paths for Docker's UNIX-domain socket"""

    docker_timeout: Annotated[
        Optional[float], pydantic.Field(alias="dockerTimeout")
    ] = 5
    r"""Timeout, in seconds, for the Docker API"""

    filters: Optional[List[InputSystemMetricsFilter4]] = None
    r"""Containers matching any of these will be included. All are included if no filters are added."""

    all_containers: Annotated[Optional[bool], pydantic.Field(alias="allContainers")] = (
        False
    )
    r"""Include stopped and paused containers"""

    per_device: Annotated[Optional[bool], pydantic.Field(alias="perDevice")] = False
    r"""Generate separate metrics for each device"""

    detail: Optional[bool] = False
    r"""Generate full container metrics"""

    @field_serializer("mode")
    def serialize_mode(self, value):
        if isinstance(value, str):
            try:
                return models.ContainerMode4(value)
            except ValueError:
                return value
        return value


class InputSystemMetricsSystemMetrics4TypedDict(TypedDict):
    type: InputSystemMetricsType4
    pq: PqTypeTypedDict
    pq_enabled: NotRequired[bool]
    r"""Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers)."""
    id: NotRequired[str]
    r"""Unique ID for this input"""
    disabled: NotRequired[bool]
    pipeline: NotRequired[str]
    r"""Pipeline to process data from this Source before sending it through the Routes"""
    send_to_routes: NotRequired[bool]
    r"""Select whether to send data to Routes, or directly to Destinations."""
    environment: NotRequired[str]
    r"""Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere."""
    streamtags: NotRequired[List[str]]
    r"""Tags for filtering and grouping in @{product}"""
    connections: NotRequired[List[ConnectionsTypeTypedDict]]
    r"""Direct connections to Destinations, and optionally via a Pipeline or a Pack"""
    interval: NotRequired[float]
    r"""Time, in seconds, between consecutive metric collections. Default is 10 seconds."""
    host: NotRequired[InputSystemMetricsHost4TypedDict]
    process: NotRequired[ProcessTypeTypedDict]
    container: NotRequired[Container4TypedDict]
    metadata: NotRequired[List[Metadata1TypeTypedDict]]
    r"""Fields to add to events from this input"""
    persistence: NotRequired[Persistence1TypeTypedDict]
    description: NotRequired[str]


class InputSystemMetricsSystemMetrics4(BaseModel):
    type: InputSystemMetricsType4

    pq: PqType

    pq_enabled: Annotated[Optional[bool], pydantic.Field(alias="pqEnabled")] = False
    r"""Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers)."""

    id: Optional[str] = None
    r"""Unique ID for this input"""

    disabled: Optional[bool] = False

    pipeline: Optional[str] = None
    r"""Pipeline to process data from this Source before sending it through the Routes"""

    send_to_routes: Annotated[Optional[bool], pydantic.Field(alias="sendToRoutes")] = (
        True
    )
    r"""Select whether to send data to Routes, or directly to Destinations."""

    environment: Optional[str] = None
    r"""Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere."""

    streamtags: Optional[List[str]] = None
    r"""Tags for filtering and grouping in @{product}"""

    connections: Optional[List[ConnectionsType]] = None
    r"""Direct connections to Destinations, and optionally via a Pipeline or a Pack"""

    interval: Optional[float] = 10
    r"""Time, in seconds, between consecutive metric collections. Default is 10 seconds."""

    host: Optional[InputSystemMetricsHost4] = None

    process: Optional[ProcessType] = None

    container: Optional[Container4] = None

    metadata: Optional[List[Metadata1Type]] = None
    r"""Fields to add to events from this input"""

    persistence: Optional[Persistence1Type] = None

    description: Optional[str] = None


class InputSystemMetricsType3(str, Enum):
    SYSTEM_METRICS = "system_metrics"


class InputSystemMetricsHostMode3(str, Enum, metaclass=utils.OpenEnumMeta):
    r"""Select level of detail for host metrics"""

    # Basic
    BASIC = "basic"
    # All
    ALL = "all"
    # Custom
    CUSTOM = "custom"
    # Disabled
    DISABLED = "disabled"


class InputSystemMetricsSystemMode3(str, Enum, metaclass=utils.OpenEnumMeta):
    r"""Select the level of detail for system metrics"""

    # Basic
    BASIC = "basic"
    # All
    ALL = "all"
    # Custom
    CUSTOM = "custom"
    # Disabled
    DISABLED = "disabled"


class InputSystemMetricsSystem3TypedDict(TypedDict):
    mode: NotRequired[InputSystemMetricsSystemMode3]
    r"""Select the level of detail for system metrics"""
    processes: NotRequired[bool]
    r"""Generate metrics for the numbers of processes in various states"""


class InputSystemMetricsSystem3(BaseModel):
    mode: Annotated[
        Optional[InputSystemMetricsSystemMode3],
        PlainValidator(validate_open_enum(False)),
    ] = InputSystemMetricsSystemMode3.BASIC
    r"""Select the level of detail for system metrics"""

    processes: Optional[bool] = False
    r"""Generate metrics for the numbers of processes in various states"""

    @field_serializer("mode")
    def serialize_mode(self, value):
        if isinstance(value, str):
            try:
                return models.InputSystemMetricsSystemMode3(value)
            except ValueError:
                return value
        return value


class InputSystemMetricsCPUMode3(str, Enum, metaclass=utils.OpenEnumMeta):
    r"""Select the level of detail for CPU metrics"""

    # Basic
    BASIC = "basic"
    # All
    ALL = "all"
    # Custom
    CUSTOM = "custom"
    # Disabled
    DISABLED = "disabled"


class InputSystemMetricsCPU3TypedDict(TypedDict):
    mode: NotRequired[InputSystemMetricsCPUMode3]
    r"""Select the level of detail for CPU metrics"""
    per_cpu: NotRequired[bool]
    r"""Generate metrics for each CPU"""
    detail: NotRequired[bool]
    r"""Generate metrics for all CPU states"""
    time: NotRequired[bool]
    r"""Generate raw, monotonic CPU time counters"""


class InputSystemMetricsCPU3(BaseModel):
    mode: Annotated[
        Optional[InputSystemMetricsCPUMode3], PlainValidator(validate_open_enum(False))
    ] = InputSystemMetricsCPUMode3.BASIC
    r"""Select the level of detail for CPU metrics"""

    per_cpu: Annotated[Optional[bool], pydantic.Field(alias="perCpu")] = False
    r"""Generate metrics for each CPU"""

    detail: Optional[bool] = False
    r"""Generate metrics for all CPU states"""

    time: Optional[bool] = False
    r"""Generate raw, monotonic CPU time counters"""

    @field_serializer("mode")
    def serialize_mode(self, value):
        if isinstance(value, str):
            try:
                return models.InputSystemMetricsCPUMode3(value)
            except ValueError:
                return value
        return value


class InputSystemMetricsMemoryMode3(str, Enum, metaclass=utils.OpenEnumMeta):
    r"""Select the level of detail for memory metrics"""

    # Basic
    BASIC = "basic"
    # All
    ALL = "all"
    # Custom
    CUSTOM = "custom"
    # Disabled
    DISABLED = "disabled"


class InputSystemMetricsMemory3TypedDict(TypedDict):
    mode: NotRequired[InputSystemMetricsMemoryMode3]
    r"""Select the level of detail for memory metrics"""
    detail: NotRequired[bool]
    r"""Generate metrics for all memory states"""


class InputSystemMetricsMemory3(BaseModel):
    mode: Annotated[
        Optional[InputSystemMetricsMemoryMode3],
        PlainValidator(validate_open_enum(False)),
    ] = InputSystemMetricsMemoryMode3.BASIC
    r"""Select the level of detail for memory metrics"""

    detail: Optional[bool] = False
    r"""Generate metrics for all memory states"""

    @field_serializer("mode")
    def serialize_mode(self, value):
        if isinstance(value, str):
            try:
                return models.InputSystemMetricsMemoryMode3(value)
            except ValueError:
                return value
        return value


class InputSystemMetricsNetworkMode3(str, Enum, metaclass=utils.OpenEnumMeta):
    r"""Select the level of detail for network metrics"""

    # Basic
    BASIC = "basic"
    # All
    ALL = "all"
    # Custom
    CUSTOM = "custom"
    # Disabled
    DISABLED = "disabled"


class InputSystemMetricsNetwork3TypedDict(TypedDict):
    mode: NotRequired[InputSystemMetricsNetworkMode3]
    r"""Select the level of detail for network metrics"""
    detail: NotRequired[bool]
    r"""Generate full network metrics"""
    protocols: NotRequired[bool]
    r"""Generate protocol metrics for ICMP, ICMPMsg, IP, TCP, UDP and UDPLite"""
    devices: NotRequired[List[str]]
    r"""Network interfaces to include/exclude. Examples: eth0, !lo. All interfaces are included if this list is empty."""
    per_interface: NotRequired[bool]
    r"""Generate separate metrics for each interface"""


class InputSystemMetricsNetwork3(BaseModel):
    mode: Annotated[
        Optional[InputSystemMetricsNetworkMode3],
        PlainValidator(validate_open_enum(False)),
    ] = InputSystemMetricsNetworkMode3.BASIC
    r"""Select the level of detail for network metrics"""

    detail: Optional[bool] = False
    r"""Generate full network metrics"""

    protocols: Optional[bool] = False
    r"""Generate protocol metrics for ICMP, ICMPMsg, IP, TCP, UDP and UDPLite"""

    devices: Optional[List[str]] = None
    r"""Network interfaces to include/exclude. Examples: eth0, !lo. All interfaces are included if this list is empty."""

    per_interface: Annotated[Optional[bool], pydantic.Field(alias="perInterface")] = (
        False
    )
    r"""Generate separate metrics for each interface"""

    @field_serializer("mode")
    def serialize_mode(self, value):
        if isinstance(value, str):
            try:
                return models.InputSystemMetricsNetworkMode3(value)
            except ValueError:
                return value
        return value


class InputSystemMetricsDiskMode3(str, Enum, metaclass=utils.OpenEnumMeta):
    r"""Select the level of detail for disk metrics"""

    # Basic
    BASIC = "basic"
    # All
    ALL = "all"
    # Custom
    CUSTOM = "custom"
    # Disabled
    DISABLED = "disabled"


class InputSystemMetricsDisk3TypedDict(TypedDict):
    mode: NotRequired[InputSystemMetricsDiskMode3]
    r"""Select the level of detail for disk metrics"""
    detail: NotRequired[bool]
    r"""Generate full disk metrics"""
    inodes: NotRequired[bool]
    r"""Generate filesystem inode metrics"""
    devices: NotRequired[List[str]]
    r"""Block devices to include/exclude. Examples: sda*, !loop*. Wildcards and ! (not) operators are supported. All devices are included if this list is empty."""
    mountpoints: NotRequired[List[str]]
    r"""Filesystem mountpoints to include/exclude. Examples: /, /home, !/proc*, !/tmp. Wildcards and ! (not) operators are supported. All mountpoints are included if this list is empty."""
    fstypes: NotRequired[List[str]]
    r"""Filesystem types to include/exclude. Examples: ext4, !*tmpfs, !squashfs. Wildcards and ! (not) operators are supported. All types are included if this list is empty."""
    per_device: NotRequired[bool]
    r"""Generate separate metrics for each device"""


class InputSystemMetricsDisk3(BaseModel):
    mode: Annotated[
        Optional[InputSystemMetricsDiskMode3], PlainValidator(validate_open_enum(False))
    ] = InputSystemMetricsDiskMode3.BASIC
    r"""Select the level of detail for disk metrics"""

    detail: Optional[bool] = False
    r"""Generate full disk metrics"""

    inodes: Optional[bool] = False
    r"""Generate filesystem inode metrics"""

    devices: Optional[List[str]] = None
    r"""Block devices to include/exclude. Examples: sda*, !loop*. Wildcards and ! (not) operators are supported. All devices are included if this list is empty."""

    mountpoints: Optional[List[str]] = None
    r"""Filesystem mountpoints to include/exclude. Examples: /, /home, !/proc*, !/tmp. Wildcards and ! (not) operators are supported. All mountpoints are included if this list is empty."""

    fstypes: Optional[List[str]] = None
    r"""Filesystem types to include/exclude. Examples: ext4, !*tmpfs, !squashfs. Wildcards and ! (not) operators are supported. All types are included if this list is empty."""

    per_device: Annotated[Optional[bool], pydantic.Field(alias="perDevice")] = False
    r"""Generate separate metrics for each device"""

    @field_serializer("mode")
    def serialize_mode(self, value):
        if isinstance(value, str):
            try:
                return models.InputSystemMetricsDiskMode3(value)
            except ValueError:
                return value
        return value


class InputSystemMetricsCustom3TypedDict(TypedDict):
    system: NotRequired[InputSystemMetricsSystem3TypedDict]
    cpu: NotRequired[InputSystemMetricsCPU3TypedDict]
    memory: NotRequired[InputSystemMetricsMemory3TypedDict]
    network: NotRequired[InputSystemMetricsNetwork3TypedDict]
    disk: NotRequired[InputSystemMetricsDisk3TypedDict]


class InputSystemMetricsCustom3(BaseModel):
    system: Optional[InputSystemMetricsSystem3] = None

    cpu: Optional[InputSystemMetricsCPU3] = None

    memory: Optional[InputSystemMetricsMemory3] = None

    network: Optional[InputSystemMetricsNetwork3] = None

    disk: Optional[InputSystemMetricsDisk3] = None


class InputSystemMetricsHost3TypedDict(TypedDict):
    mode: NotRequired[InputSystemMetricsHostMode3]
    r"""Select level of detail for host metrics"""
    custom: NotRequired[InputSystemMetricsCustom3TypedDict]


class InputSystemMetricsHost3(BaseModel):
    mode: Annotated[
        Optional[InputSystemMetricsHostMode3], PlainValidator(validate_open_enum(False))
    ] = InputSystemMetricsHostMode3.BASIC
    r"""Select level of detail for host metrics"""

    custom: Optional[InputSystemMetricsCustom3] = None

    @field_serializer("mode")
    def serialize_mode(self, value):
        if isinstance(value, str):
            try:
                return models.InputSystemMetricsHostMode3(value)
            except ValueError:
                return value
        return value


class ContainerMode3(str, Enum, metaclass=utils.OpenEnumMeta):
    r"""Select the level of detail for container metrics"""

    # Basic
    BASIC = "basic"
    # All
    ALL = "all"
    # Custom
    CUSTOM = "custom"
    # Disabled
    DISABLED = "disabled"


class InputSystemMetricsFilter3TypedDict(TypedDict):
    expr: str


class InputSystemMetricsFilter3(BaseModel):
    expr: str


class Container3TypedDict(TypedDict):
    mode: NotRequired[ContainerMode3]
    r"""Select the level of detail for container metrics"""
    docker_socket: NotRequired[List[str]]
    r"""Full paths for Docker's UNIX-domain socket"""
    docker_timeout: NotRequired[float]
    r"""Timeout, in seconds, for the Docker API"""
    filters: NotRequired[List[InputSystemMetricsFilter3TypedDict]]
    r"""Containers matching any of these will be included. All are included if no filters are added."""
    all_containers: NotRequired[bool]
    r"""Include stopped and paused containers"""
    per_device: NotRequired[bool]
    r"""Generate separate metrics for each device"""
    detail: NotRequired[bool]
    r"""Generate full container metrics"""


class Container3(BaseModel):
    mode: Annotated[
        Optional[ContainerMode3], PlainValidator(validate_open_enum(False))
    ] = ContainerMode3.BASIC
    r"""Select the level of detail for container metrics"""

    docker_socket: Annotated[
        Optional[List[str]], pydantic.Field(alias="dockerSocket")
    ] = None
    r"""Full paths for Docker's UNIX-domain socket"""

    docker_timeout: Annotated[
        Optional[float], pydantic.Field(alias="dockerTimeout")
    ] = 5
    r"""Timeout, in seconds, for the Docker API"""

    filters: Optional[List[InputSystemMetricsFilter3]] = None
    r"""Containers matching any of these will be included. All are included if no filters are added."""

    all_containers: Annotated[Optional[bool], pydantic.Field(alias="allContainers")] = (
        False
    )
    r"""Include stopped and paused containers"""

    per_device: Annotated[Optional[bool], pydantic.Field(alias="perDevice")] = False
    r"""Generate separate metrics for each device"""

    detail: Optional[bool] = False
    r"""Generate full container metrics"""

    @field_serializer("mode")
    def serialize_mode(self, value):
        if isinstance(value, str):
            try:
                return models.ContainerMode3(value)
            except ValueError:
                return value
        return value


class InputSystemMetricsSystemMetrics3TypedDict(TypedDict):
    type: InputSystemMetricsType3
    pq_enabled: NotRequired[bool]
    r"""Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers)."""
    id: NotRequired[str]
    r"""Unique ID for this input"""
    disabled: NotRequired[bool]
    pipeline: NotRequired[str]
    r"""Pipeline to process data from this Source before sending it through the Routes"""
    send_to_routes: NotRequired[bool]
    r"""Select whether to send data to Routes, or directly to Destinations."""
    environment: NotRequired[str]
    r"""Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere."""
    streamtags: NotRequired[List[str]]
    r"""Tags for filtering and grouping in @{product}"""
    connections: NotRequired[List[ConnectionsTypeTypedDict]]
    r"""Direct connections to Destinations, and optionally via a Pipeline or a Pack"""
    pq: NotRequired[PqTypeTypedDict]
    interval: NotRequired[float]
    r"""Time, in seconds, between consecutive metric collections. Default is 10 seconds."""
    host: NotRequired[InputSystemMetricsHost3TypedDict]
    process: NotRequired[ProcessTypeTypedDict]
    container: NotRequired[Container3TypedDict]
    metadata: NotRequired[List[Metadata1TypeTypedDict]]
    r"""Fields to add to events from this input"""
    persistence: NotRequired[Persistence1TypeTypedDict]
    description: NotRequired[str]


class InputSystemMetricsSystemMetrics3(BaseModel):
    type: InputSystemMetricsType3

    pq_enabled: Annotated[Optional[bool], pydantic.Field(alias="pqEnabled")] = False
    r"""Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers)."""

    id: Optional[str] = None
    r"""Unique ID for this input"""

    disabled: Optional[bool] = False

    pipeline: Optional[str] = None
    r"""Pipeline to process data from this Source before sending it through the Routes"""

    send_to_routes: Annotated[Optional[bool], pydantic.Field(alias="sendToRoutes")] = (
        True
    )
    r"""Select whether to send data to Routes, or directly to Destinations."""

    environment: Optional[str] = None
    r"""Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere."""

    streamtags: Optional[List[str]] = None
    r"""Tags for filtering and grouping in @{product}"""

    connections: Optional[List[ConnectionsType]] = None
    r"""Direct connections to Destinations, and optionally via a Pipeline or a Pack"""

    pq: Optional[PqType] = None

    interval: Optional[float] = 10
    r"""Time, in seconds, between consecutive metric collections. Default is 10 seconds."""

    host: Optional[InputSystemMetricsHost3] = None

    process: Optional[ProcessType] = None

    container: Optional[Container3] = None

    metadata: Optional[List[Metadata1Type]] = None
    r"""Fields to add to events from this input"""

    persistence: Optional[Persistence1Type] = None

    description: Optional[str] = None


class InputSystemMetricsType2(str, Enum):
    SYSTEM_METRICS = "system_metrics"


class InputSystemMetricsHostMode2(str, Enum, metaclass=utils.OpenEnumMeta):
    r"""Select level of detail for host metrics"""

    # Basic
    BASIC = "basic"
    # All
    ALL = "all"
    # Custom
    CUSTOM = "custom"
    # Disabled
    DISABLED = "disabled"


class InputSystemMetricsSystemMode2(str, Enum, metaclass=utils.OpenEnumMeta):
    r"""Select the level of detail for system metrics"""

    # Basic
    BASIC = "basic"
    # All
    ALL = "all"
    # Custom
    CUSTOM = "custom"
    # Disabled
    DISABLED = "disabled"


class InputSystemMetricsSystem2TypedDict(TypedDict):
    mode: NotRequired[InputSystemMetricsSystemMode2]
    r"""Select the level of detail for system metrics"""
    processes: NotRequired[bool]
    r"""Generate metrics for the numbers of processes in various states"""


class InputSystemMetricsSystem2(BaseModel):
    mode: Annotated[
        Optional[InputSystemMetricsSystemMode2],
        PlainValidator(validate_open_enum(False)),
    ] = InputSystemMetricsSystemMode2.BASIC
    r"""Select the level of detail for system metrics"""

    processes: Optional[bool] = False
    r"""Generate metrics for the numbers of processes in various states"""

    @field_serializer("mode")
    def serialize_mode(self, value):
        if isinstance(value, str):
            try:
                return models.InputSystemMetricsSystemMode2(value)
            except ValueError:
                return value
        return value


class InputSystemMetricsCPUMode2(str, Enum, metaclass=utils.OpenEnumMeta):
    r"""Select the level of detail for CPU metrics"""

    # Basic
    BASIC = "basic"
    # All
    ALL = "all"
    # Custom
    CUSTOM = "custom"
    # Disabled
    DISABLED = "disabled"


class InputSystemMetricsCPU2TypedDict(TypedDict):
    mode: NotRequired[InputSystemMetricsCPUMode2]
    r"""Select the level of detail for CPU metrics"""
    per_cpu: NotRequired[bool]
    r"""Generate metrics for each CPU"""
    detail: NotRequired[bool]
    r"""Generate metrics for all CPU states"""
    time: NotRequired[bool]
    r"""Generate raw, monotonic CPU time counters"""


class InputSystemMetricsCPU2(BaseModel):
    mode: Annotated[
        Optional[InputSystemMetricsCPUMode2], PlainValidator(validate_open_enum(False))
    ] = InputSystemMetricsCPUMode2.BASIC
    r"""Select the level of detail for CPU metrics"""

    per_cpu: Annotated[Optional[bool], pydantic.Field(alias="perCpu")] = False
    r"""Generate metrics for each CPU"""

    detail: Optional[bool] = False
    r"""Generate metrics for all CPU states"""

    time: Optional[bool] = False
    r"""Generate raw, monotonic CPU time counters"""

    @field_serializer("mode")
    def serialize_mode(self, value):
        if isinstance(value, str):
            try:
                return models.InputSystemMetricsCPUMode2(value)
            except ValueError:
                return value
        return value


class InputSystemMetricsMemoryMode2(str, Enum, metaclass=utils.OpenEnumMeta):
    r"""Select the level of detail for memory metrics"""

    # Basic
    BASIC = "basic"
    # All
    ALL = "all"
    # Custom
    CUSTOM = "custom"
    # Disabled
    DISABLED = "disabled"


class InputSystemMetricsMemory2TypedDict(TypedDict):
    mode: NotRequired[InputSystemMetricsMemoryMode2]
    r"""Select the level of detail for memory metrics"""
    detail: NotRequired[bool]
    r"""Generate metrics for all memory states"""


class InputSystemMetricsMemory2(BaseModel):
    mode: Annotated[
        Optional[InputSystemMetricsMemoryMode2],
        PlainValidator(validate_open_enum(False)),
    ] = InputSystemMetricsMemoryMode2.BASIC
    r"""Select the level of detail for memory metrics"""

    detail: Optional[bool] = False
    r"""Generate metrics for all memory states"""

    @field_serializer("mode")
    def serialize_mode(self, value):
        if isinstance(value, str):
            try:
                return models.InputSystemMetricsMemoryMode2(value)
            except ValueError:
                return value
        return value


class InputSystemMetricsNetworkMode2(str, Enum, metaclass=utils.OpenEnumMeta):
    r"""Select the level of detail for network metrics"""

    # Basic
    BASIC = "basic"
    # All
    ALL = "all"
    # Custom
    CUSTOM = "custom"
    # Disabled
    DISABLED = "disabled"


class InputSystemMetricsNetwork2TypedDict(TypedDict):
    mode: NotRequired[InputSystemMetricsNetworkMode2]
    r"""Select the level of detail for network metrics"""
    detail: NotRequired[bool]
    r"""Generate full network metrics"""
    protocols: NotRequired[bool]
    r"""Generate protocol metrics for ICMP, ICMPMsg, IP, TCP, UDP and UDPLite"""
    devices: NotRequired[List[str]]
    r"""Network interfaces to include/exclude. Examples: eth0, !lo. All interfaces are included if this list is empty."""
    per_interface: NotRequired[bool]
    r"""Generate separate metrics for each interface"""


class InputSystemMetricsNetwork2(BaseModel):
    mode: Annotated[
        Optional[InputSystemMetricsNetworkMode2],
        PlainValidator(validate_open_enum(False)),
    ] = InputSystemMetricsNetworkMode2.BASIC
    r"""Select the level of detail for network metrics"""

    detail: Optional[bool] = False
    r"""Generate full network metrics"""

    protocols: Optional[bool] = False
    r"""Generate protocol metrics for ICMP, ICMPMsg, IP, TCP, UDP and UDPLite"""

    devices: Optional[List[str]] = None
    r"""Network interfaces to include/exclude. Examples: eth0, !lo. All interfaces are included if this list is empty."""

    per_interface: Annotated[Optional[bool], pydantic.Field(alias="perInterface")] = (
        False
    )
    r"""Generate separate metrics for each interface"""

    @field_serializer("mode")
    def serialize_mode(self, value):
        if isinstance(value, str):
            try:
                return models.InputSystemMetricsNetworkMode2(value)
            except ValueError:
                return value
        return value


class InputSystemMetricsDiskMode2(str, Enum, metaclass=utils.OpenEnumMeta):
    r"""Select the level of detail for disk metrics"""

    # Basic
    BASIC = "basic"
    # All
    ALL = "all"
    # Custom
    CUSTOM = "custom"
    # Disabled
    DISABLED = "disabled"


class InputSystemMetricsDisk2TypedDict(TypedDict):
    mode: NotRequired[InputSystemMetricsDiskMode2]
    r"""Select the level of detail for disk metrics"""
    detail: NotRequired[bool]
    r"""Generate full disk metrics"""
    inodes: NotRequired[bool]
    r"""Generate filesystem inode metrics"""
    devices: NotRequired[List[str]]
    r"""Block devices to include/exclude. Examples: sda*, !loop*. Wildcards and ! (not) operators are supported. All devices are included if this list is empty."""
    mountpoints: NotRequired[List[str]]
    r"""Filesystem mountpoints to include/exclude. Examples: /, /home, !/proc*, !/tmp. Wildcards and ! (not) operators are supported. All mountpoints are included if this list is empty."""
    fstypes: NotRequired[List[str]]
    r"""Filesystem types to include/exclude. Examples: ext4, !*tmpfs, !squashfs. Wildcards and ! (not) operators are supported. All types are included if this list is empty."""
    per_device: NotRequired[bool]
    r"""Generate separate metrics for each device"""


class InputSystemMetricsDisk2(BaseModel):
    mode: Annotated[
        Optional[InputSystemMetricsDiskMode2], PlainValidator(validate_open_enum(False))
    ] = InputSystemMetricsDiskMode2.BASIC
    r"""Select the level of detail for disk metrics"""

    detail: Optional[bool] = False
    r"""Generate full disk metrics"""

    inodes: Optional[bool] = False
    r"""Generate filesystem inode metrics"""

    devices: Optional[List[str]] = None
    r"""Block devices to include/exclude. Examples: sda*, !loop*. Wildcards and ! (not) operators are supported. All devices are included if this list is empty."""

    mountpoints: Optional[List[str]] = None
    r"""Filesystem mountpoints to include/exclude. Examples: /, /home, !/proc*, !/tmp. Wildcards and ! (not) operators are supported. All mountpoints are included if this list is empty."""

    fstypes: Optional[List[str]] = None
    r"""Filesystem types to include/exclude. Examples: ext4, !*tmpfs, !squashfs. Wildcards and ! (not) operators are supported. All types are included if this list is empty."""

    per_device: Annotated[Optional[bool], pydantic.Field(alias="perDevice")] = False
    r"""Generate separate metrics for each device"""

    @field_serializer("mode")
    def serialize_mode(self, value):
        if isinstance(value, str):
            try:
                return models.InputSystemMetricsDiskMode2(value)
            except ValueError:
                return value
        return value


class InputSystemMetricsCustom2TypedDict(TypedDict):
    system: NotRequired[InputSystemMetricsSystem2TypedDict]
    cpu: NotRequired[InputSystemMetricsCPU2TypedDict]
    memory: NotRequired[InputSystemMetricsMemory2TypedDict]
    network: NotRequired[InputSystemMetricsNetwork2TypedDict]
    disk: NotRequired[InputSystemMetricsDisk2TypedDict]


class InputSystemMetricsCustom2(BaseModel):
    system: Optional[InputSystemMetricsSystem2] = None

    cpu: Optional[InputSystemMetricsCPU2] = None

    memory: Optional[InputSystemMetricsMemory2] = None

    network: Optional[InputSystemMetricsNetwork2] = None

    disk: Optional[InputSystemMetricsDisk2] = None


class InputSystemMetricsHost2TypedDict(TypedDict):
    mode: NotRequired[InputSystemMetricsHostMode2]
    r"""Select level of detail for host metrics"""
    custom: NotRequired[InputSystemMetricsCustom2TypedDict]


class InputSystemMetricsHost2(BaseModel):
    mode: Annotated[
        Optional[InputSystemMetricsHostMode2], PlainValidator(validate_open_enum(False))
    ] = InputSystemMetricsHostMode2.BASIC
    r"""Select level of detail for host metrics"""

    custom: Optional[InputSystemMetricsCustom2] = None

    @field_serializer("mode")
    def serialize_mode(self, value):
        if isinstance(value, str):
            try:
                return models.InputSystemMetricsHostMode2(value)
            except ValueError:
                return value
        return value


class ContainerMode2(str, Enum, metaclass=utils.OpenEnumMeta):
    r"""Select the level of detail for container metrics"""

    # Basic
    BASIC = "basic"
    # All
    ALL = "all"
    # Custom
    CUSTOM = "custom"
    # Disabled
    DISABLED = "disabled"


class InputSystemMetricsFilter2TypedDict(TypedDict):
    expr: str


class InputSystemMetricsFilter2(BaseModel):
    expr: str


class Container2TypedDict(TypedDict):
    mode: NotRequired[ContainerMode2]
    r"""Select the level of detail for container metrics"""
    docker_socket: NotRequired[List[str]]
    r"""Full paths for Docker's UNIX-domain socket"""
    docker_timeout: NotRequired[float]
    r"""Timeout, in seconds, for the Docker API"""
    filters: NotRequired[List[InputSystemMetricsFilter2TypedDict]]
    r"""Containers matching any of these will be included. All are included if no filters are added."""
    all_containers: NotRequired[bool]
    r"""Include stopped and paused containers"""
    per_device: NotRequired[bool]
    r"""Generate separate metrics for each device"""
    detail: NotRequired[bool]
    r"""Generate full container metrics"""


class Container2(BaseModel):
    mode: Annotated[
        Optional[ContainerMode2], PlainValidator(validate_open_enum(False))
    ] = ContainerMode2.BASIC
    r"""Select the level of detail for container metrics"""

    docker_socket: Annotated[
        Optional[List[str]], pydantic.Field(alias="dockerSocket")
    ] = None
    r"""Full paths for Docker's UNIX-domain socket"""

    docker_timeout: Annotated[
        Optional[float], pydantic.Field(alias="dockerTimeout")
    ] = 5
    r"""Timeout, in seconds, for the Docker API"""

    filters: Optional[List[InputSystemMetricsFilter2]] = None
    r"""Containers matching any of these will be included. All are included if no filters are added."""

    all_containers: Annotated[Optional[bool], pydantic.Field(alias="allContainers")] = (
        False
    )
    r"""Include stopped and paused containers"""

    per_device: Annotated[Optional[bool], pydantic.Field(alias="perDevice")] = False
    r"""Generate separate metrics for each device"""

    detail: Optional[bool] = False
    r"""Generate full container metrics"""

    @field_serializer("mode")
    def serialize_mode(self, value):
        if isinstance(value, str):
            try:
                return models.ContainerMode2(value)
            except ValueError:
                return value
        return value


class InputSystemMetricsSystemMetrics2TypedDict(TypedDict):
    type: InputSystemMetricsType2
    connections: List[ConnectionsTypeTypedDict]
    r"""Direct connections to Destinations, and optionally via a Pipeline or a Pack"""
    send_to_routes: NotRequired[bool]
    r"""Select whether to send data to Routes, or directly to Destinations."""
    id: NotRequired[str]
    r"""Unique ID for this input"""
    disabled: NotRequired[bool]
    pipeline: NotRequired[str]
    r"""Pipeline to process data from this Source before sending it through the Routes"""
    environment: NotRequired[str]
    r"""Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere."""
    pq_enabled: NotRequired[bool]
    r"""Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers)."""
    streamtags: NotRequired[List[str]]
    r"""Tags for filtering and grouping in @{product}"""
    pq: NotRequired[PqTypeTypedDict]
    interval: NotRequired[float]
    r"""Time, in seconds, between consecutive metric collections. Default is 10 seconds."""
    host: NotRequired[InputSystemMetricsHost2TypedDict]
    process: NotRequired[ProcessTypeTypedDict]
    container: NotRequired[Container2TypedDict]
    metadata: NotRequired[List[Metadata1TypeTypedDict]]
    r"""Fields to add to events from this input"""
    persistence: NotRequired[Persistence1TypeTypedDict]
    description: NotRequired[str]


class InputSystemMetricsSystemMetrics2(BaseModel):
    type: InputSystemMetricsType2

    connections: List[ConnectionsType]
    r"""Direct connections to Destinations, and optionally via a Pipeline or a Pack"""

    send_to_routes: Annotated[Optional[bool], pydantic.Field(alias="sendToRoutes")] = (
        True
    )
    r"""Select whether to send data to Routes, or directly to Destinations."""

    id: Optional[str] = None
    r"""Unique ID for this input"""

    disabled: Optional[bool] = False

    pipeline: Optional[str] = None
    r"""Pipeline to process data from this Source before sending it through the Routes"""

    environment: Optional[str] = None
    r"""Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere."""

    pq_enabled: Annotated[Optional[bool], pydantic.Field(alias="pqEnabled")] = False
    r"""Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers)."""

    streamtags: Optional[List[str]] = None
    r"""Tags for filtering and grouping in @{product}"""

    pq: Optional[PqType] = None

    interval: Optional[float] = 10
    r"""Time, in seconds, between consecutive metric collections. Default is 10 seconds."""

    host: Optional[InputSystemMetricsHost2] = None

    process: Optional[ProcessType] = None

    container: Optional[Container2] = None

    metadata: Optional[List[Metadata1Type]] = None
    r"""Fields to add to events from this input"""

    persistence: Optional[Persistence1Type] = None

    description: Optional[str] = None


class InputSystemMetricsType1(str, Enum):
    SYSTEM_METRICS = "system_metrics"


class InputSystemMetricsHostMode1(str, Enum, metaclass=utils.OpenEnumMeta):
    r"""Select level of detail for host metrics"""

    # Basic
    BASIC = "basic"
    # All
    ALL = "all"
    # Custom
    CUSTOM = "custom"
    # Disabled
    DISABLED = "disabled"


class InputSystemMetricsSystemMode1(str, Enum, metaclass=utils.OpenEnumMeta):
    r"""Select the level of detail for system metrics"""

    # Basic
    BASIC = "basic"
    # All
    ALL = "all"
    # Custom
    CUSTOM = "custom"
    # Disabled
    DISABLED = "disabled"


class InputSystemMetricsSystem1TypedDict(TypedDict):
    mode: NotRequired[InputSystemMetricsSystemMode1]
    r"""Select the level of detail for system metrics"""
    processes: NotRequired[bool]
    r"""Generate metrics for the numbers of processes in various states"""


class InputSystemMetricsSystem1(BaseModel):
    mode: Annotated[
        Optional[InputSystemMetricsSystemMode1],
        PlainValidator(validate_open_enum(False)),
    ] = InputSystemMetricsSystemMode1.BASIC
    r"""Select the level of detail for system metrics"""

    processes: Optional[bool] = False
    r"""Generate metrics for the numbers of processes in various states"""

    @field_serializer("mode")
    def serialize_mode(self, value):
        if isinstance(value, str):
            try:
                return models.InputSystemMetricsSystemMode1(value)
            except ValueError:
                return value
        return value


class InputSystemMetricsCPUMode1(str, Enum, metaclass=utils.OpenEnumMeta):
    r"""Select the level of detail for CPU metrics"""

    # Basic
    BASIC = "basic"
    # All
    ALL = "all"
    # Custom
    CUSTOM = "custom"
    # Disabled
    DISABLED = "disabled"


class InputSystemMetricsCPU1TypedDict(TypedDict):
    mode: NotRequired[InputSystemMetricsCPUMode1]
    r"""Select the level of detail for CPU metrics"""
    per_cpu: NotRequired[bool]
    r"""Generate metrics for each CPU"""
    detail: NotRequired[bool]
    r"""Generate metrics for all CPU states"""
    time: NotRequired[bool]
    r"""Generate raw, monotonic CPU time counters"""


class InputSystemMetricsCPU1(BaseModel):
    mode: Annotated[
        Optional[InputSystemMetricsCPUMode1], PlainValidator(validate_open_enum(False))
    ] = InputSystemMetricsCPUMode1.BASIC
    r"""Select the level of detail for CPU metrics"""

    per_cpu: Annotated[Optional[bool], pydantic.Field(alias="perCpu")] = False
    r"""Generate metrics for each CPU"""

    detail: Optional[bool] = False
    r"""Generate metrics for all CPU states"""

    time: Optional[bool] = False
    r"""Generate raw, monotonic CPU time counters"""

    @field_serializer("mode")
    def serialize_mode(self, value):
        if isinstance(value, str):
            try:
                return models.InputSystemMetricsCPUMode1(value)
            except ValueError:
                return value
        return value


class InputSystemMetricsMemoryMode1(str, Enum, metaclass=utils.OpenEnumMeta):
    r"""Select the level of detail for memory metrics"""

    # Basic
    BASIC = "basic"
    # All
    ALL = "all"
    # Custom
    CUSTOM = "custom"
    # Disabled
    DISABLED = "disabled"


class InputSystemMetricsMemory1TypedDict(TypedDict):
    mode: NotRequired[InputSystemMetricsMemoryMode1]
    r"""Select the level of detail for memory metrics"""
    detail: NotRequired[bool]
    r"""Generate metrics for all memory states"""


class InputSystemMetricsMemory1(BaseModel):
    mode: Annotated[
        Optional[InputSystemMetricsMemoryMode1],
        PlainValidator(validate_open_enum(False)),
    ] = InputSystemMetricsMemoryMode1.BASIC
    r"""Select the level of detail for memory metrics"""

    detail: Optional[bool] = False
    r"""Generate metrics for all memory states"""

    @field_serializer("mode")
    def serialize_mode(self, value):
        if isinstance(value, str):
            try:
                return models.InputSystemMetricsMemoryMode1(value)
            except ValueError:
                return value
        return value


class InputSystemMetricsNetworkMode1(str, Enum, metaclass=utils.OpenEnumMeta):
    r"""Select the level of detail for network metrics"""

    # Basic
    BASIC = "basic"
    # All
    ALL = "all"
    # Custom
    CUSTOM = "custom"
    # Disabled
    DISABLED = "disabled"


class InputSystemMetricsNetwork1TypedDict(TypedDict):
    mode: NotRequired[InputSystemMetricsNetworkMode1]
    r"""Select the level of detail for network metrics"""
    detail: NotRequired[bool]
    r"""Generate full network metrics"""
    protocols: NotRequired[bool]
    r"""Generate protocol metrics for ICMP, ICMPMsg, IP, TCP, UDP and UDPLite"""
    devices: NotRequired[List[str]]
    r"""Network interfaces to include/exclude. Examples: eth0, !lo. All interfaces are included if this list is empty."""
    per_interface: NotRequired[bool]
    r"""Generate separate metrics for each interface"""


class InputSystemMetricsNetwork1(BaseModel):
    mode: Annotated[
        Optional[InputSystemMetricsNetworkMode1],
        PlainValidator(validate_open_enum(False)),
    ] = InputSystemMetricsNetworkMode1.BASIC
    r"""Select the level of detail for network metrics"""

    detail: Optional[bool] = False
    r"""Generate full network metrics"""

    protocols: Optional[bool] = False
    r"""Generate protocol metrics for ICMP, ICMPMsg, IP, TCP, UDP and UDPLite"""

    devices: Optional[List[str]] = None
    r"""Network interfaces to include/exclude. Examples: eth0, !lo. All interfaces are included if this list is empty."""

    per_interface: Annotated[Optional[bool], pydantic.Field(alias="perInterface")] = (
        False
    )
    r"""Generate separate metrics for each interface"""

    @field_serializer("mode")
    def serialize_mode(self, value):
        if isinstance(value, str):
            try:
                return models.InputSystemMetricsNetworkMode1(value)
            except ValueError:
                return value
        return value


class InputSystemMetricsDiskMode1(str, Enum, metaclass=utils.OpenEnumMeta):
    r"""Select the level of detail for disk metrics"""

    # Basic
    BASIC = "basic"
    # All
    ALL = "all"
    # Custom
    CUSTOM = "custom"
    # Disabled
    DISABLED = "disabled"


class InputSystemMetricsDisk1TypedDict(TypedDict):
    mode: NotRequired[InputSystemMetricsDiskMode1]
    r"""Select the level of detail for disk metrics"""
    detail: NotRequired[bool]
    r"""Generate full disk metrics"""
    inodes: NotRequired[bool]
    r"""Generate filesystem inode metrics"""
    devices: NotRequired[List[str]]
    r"""Block devices to include/exclude. Examples: sda*, !loop*. Wildcards and ! (not) operators are supported. All devices are included if this list is empty."""
    mountpoints: NotRequired[List[str]]
    r"""Filesystem mountpoints to include/exclude. Examples: /, /home, !/proc*, !/tmp. Wildcards and ! (not) operators are supported. All mountpoints are included if this list is empty."""
    fstypes: NotRequired[List[str]]
    r"""Filesystem types to include/exclude. Examples: ext4, !*tmpfs, !squashfs. Wildcards and ! (not) operators are supported. All types are included if this list is empty."""
    per_device: NotRequired[bool]
    r"""Generate separate metrics for each device"""


class InputSystemMetricsDisk1(BaseModel):
    mode: Annotated[
        Optional[InputSystemMetricsDiskMode1], PlainValidator(validate_open_enum(False))
    ] = InputSystemMetricsDiskMode1.BASIC
    r"""Select the level of detail for disk metrics"""

    detail: Optional[bool] = False
    r"""Generate full disk metrics"""

    inodes: Optional[bool] = False
    r"""Generate filesystem inode metrics"""

    devices: Optional[List[str]] = None
    r"""Block devices to include/exclude. Examples: sda*, !loop*. Wildcards and ! (not) operators are supported. All devices are included if this list is empty."""

    mountpoints: Optional[List[str]] = None
    r"""Filesystem mountpoints to include/exclude. Examples: /, /home, !/proc*, !/tmp. Wildcards and ! (not) operators are supported. All mountpoints are included if this list is empty."""

    fstypes: Optional[List[str]] = None
    r"""Filesystem types to include/exclude. Examples: ext4, !*tmpfs, !squashfs. Wildcards and ! (not) operators are supported. All types are included if this list is empty."""

    per_device: Annotated[Optional[bool], pydantic.Field(alias="perDevice")] = False
    r"""Generate separate metrics for each device"""

    @field_serializer("mode")
    def serialize_mode(self, value):
        if isinstance(value, str):
            try:
                return models.InputSystemMetricsDiskMode1(value)
            except ValueError:
                return value
        return value


class InputSystemMetricsCustom1TypedDict(TypedDict):
    system: NotRequired[InputSystemMetricsSystem1TypedDict]
    cpu: NotRequired[InputSystemMetricsCPU1TypedDict]
    memory: NotRequired[InputSystemMetricsMemory1TypedDict]
    network: NotRequired[InputSystemMetricsNetwork1TypedDict]
    disk: NotRequired[InputSystemMetricsDisk1TypedDict]


class InputSystemMetricsCustom1(BaseModel):
    system: Optional[InputSystemMetricsSystem1] = None

    cpu: Optional[InputSystemMetricsCPU1] = None

    memory: Optional[InputSystemMetricsMemory1] = None

    network: Optional[InputSystemMetricsNetwork1] = None

    disk: Optional[InputSystemMetricsDisk1] = None


class InputSystemMetricsHost1TypedDict(TypedDict):
    mode: NotRequired[InputSystemMetricsHostMode1]
    r"""Select level of detail for host metrics"""
    custom: NotRequired[InputSystemMetricsCustom1TypedDict]


class InputSystemMetricsHost1(BaseModel):
    mode: Annotated[
        Optional[InputSystemMetricsHostMode1], PlainValidator(validate_open_enum(False))
    ] = InputSystemMetricsHostMode1.BASIC
    r"""Select level of detail for host metrics"""

    custom: Optional[InputSystemMetricsCustom1] = None

    @field_serializer("mode")
    def serialize_mode(self, value):
        if isinstance(value, str):
            try:
                return models.InputSystemMetricsHostMode1(value)
            except ValueError:
                return value
        return value


class ContainerMode1(str, Enum, metaclass=utils.OpenEnumMeta):
    r"""Select the level of detail for container metrics"""

    # Basic
    BASIC = "basic"
    # All
    ALL = "all"
    # Custom
    CUSTOM = "custom"
    # Disabled
    DISABLED = "disabled"


class InputSystemMetricsFilter1TypedDict(TypedDict):
    expr: str


class InputSystemMetricsFilter1(BaseModel):
    expr: str


class Container1TypedDict(TypedDict):
    mode: NotRequired[ContainerMode1]
    r"""Select the level of detail for container metrics"""
    docker_socket: NotRequired[List[str]]
    r"""Full paths for Docker's UNIX-domain socket"""
    docker_timeout: NotRequired[float]
    r"""Timeout, in seconds, for the Docker API"""
    filters: NotRequired[List[InputSystemMetricsFilter1TypedDict]]
    r"""Containers matching any of these will be included. All are included if no filters are added."""
    all_containers: NotRequired[bool]
    r"""Include stopped and paused containers"""
    per_device: NotRequired[bool]
    r"""Generate separate metrics for each device"""
    detail: NotRequired[bool]
    r"""Generate full container metrics"""


class Container1(BaseModel):
    mode: Annotated[
        Optional[ContainerMode1], PlainValidator(validate_open_enum(False))
    ] = ContainerMode1.BASIC
    r"""Select the level of detail for container metrics"""

    docker_socket: Annotated[
        Optional[List[str]], pydantic.Field(alias="dockerSocket")
    ] = None
    r"""Full paths for Docker's UNIX-domain socket"""

    docker_timeout: Annotated[
        Optional[float], pydantic.Field(alias="dockerTimeout")
    ] = 5
    r"""Timeout, in seconds, for the Docker API"""

    filters: Optional[List[InputSystemMetricsFilter1]] = None
    r"""Containers matching any of these will be included. All are included if no filters are added."""

    all_containers: Annotated[Optional[bool], pydantic.Field(alias="allContainers")] = (
        False
    )
    r"""Include stopped and paused containers"""

    per_device: Annotated[Optional[bool], pydantic.Field(alias="perDevice")] = False
    r"""Generate separate metrics for each device"""

    detail: Optional[bool] = False
    r"""Generate full container metrics"""

    @field_serializer("mode")
    def serialize_mode(self, value):
        if isinstance(value, str):
            try:
                return models.ContainerMode1(value)
            except ValueError:
                return value
        return value


class InputSystemMetricsSystemMetrics1TypedDict(TypedDict):
    type: InputSystemMetricsType1
    send_to_routes: NotRequired[bool]
    r"""Select whether to send data to Routes, or directly to Destinations."""
    id: NotRequired[str]
    r"""Unique ID for this input"""
    disabled: NotRequired[bool]
    pipeline: NotRequired[str]
    r"""Pipeline to process data from this Source before sending it through the Routes"""
    environment: NotRequired[str]
    r"""Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere."""
    pq_enabled: NotRequired[bool]
    r"""Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers)."""
    streamtags: NotRequired[List[str]]
    r"""Tags for filtering and grouping in @{product}"""
    connections: NotRequired[List[ConnectionsTypeTypedDict]]
    r"""Direct connections to Destinations, and optionally via a Pipeline or a Pack"""
    pq: NotRequired[PqTypeTypedDict]
    interval: NotRequired[float]
    r"""Time, in seconds, between consecutive metric collections. Default is 10 seconds."""
    host: NotRequired[InputSystemMetricsHost1TypedDict]
    process: NotRequired[ProcessTypeTypedDict]
    container: NotRequired[Container1TypedDict]
    metadata: NotRequired[List[Metadata1TypeTypedDict]]
    r"""Fields to add to events from this input"""
    persistence: NotRequired[Persistence1TypeTypedDict]
    description: NotRequired[str]


class InputSystemMetricsSystemMetrics1(BaseModel):
    type: InputSystemMetricsType1

    send_to_routes: Annotated[Optional[bool], pydantic.Field(alias="sendToRoutes")] = (
        True
    )
    r"""Select whether to send data to Routes, or directly to Destinations."""

    id: Optional[str] = None
    r"""Unique ID for this input"""

    disabled: Optional[bool] = False

    pipeline: Optional[str] = None
    r"""Pipeline to process data from this Source before sending it through the Routes"""

    environment: Optional[str] = None
    r"""Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere."""

    pq_enabled: Annotated[Optional[bool], pydantic.Field(alias="pqEnabled")] = False
    r"""Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers)."""

    streamtags: Optional[List[str]] = None
    r"""Tags for filtering and grouping in @{product}"""

    connections: Optional[List[ConnectionsType]] = None
    r"""Direct connections to Destinations, and optionally via a Pipeline or a Pack"""

    pq: Optional[PqType] = None

    interval: Optional[float] = 10
    r"""Time, in seconds, between consecutive metric collections. Default is 10 seconds."""

    host: Optional[InputSystemMetricsHost1] = None

    process: Optional[ProcessType] = None

    container: Optional[Container1] = None

    metadata: Optional[List[Metadata1Type]] = None
    r"""Fields to add to events from this input"""

    persistence: Optional[Persistence1Type] = None

    description: Optional[str] = None


InputSystemMetricsTypedDict = TypeAliasType(
    "InputSystemMetricsTypedDict",
    Union[
        InputSystemMetricsSystemMetrics1TypedDict,
        InputSystemMetricsSystemMetrics2TypedDict,
        InputSystemMetricsSystemMetrics3TypedDict,
        InputSystemMetricsSystemMetrics4TypedDict,
    ],
)


InputSystemMetrics = TypeAliasType(
    "InputSystemMetrics",
    Union[
        InputSystemMetricsSystemMetrics1,
        InputSystemMetricsSystemMetrics2,
        InputSystemMetricsSystemMetrics3,
        InputSystemMetricsSystemMetrics4,
    ],
)
