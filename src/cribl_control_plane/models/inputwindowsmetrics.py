"""Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT."""

from __future__ import annotations
from .connectionstype import ConnectionsType, ConnectionsTypeTypedDict
from .metadata1type import Metadata1Type, Metadata1TypeTypedDict
from .persistence1type import Persistence1Type, Persistence1TypeTypedDict
from .pqtype import PqType, PqTypeTypedDict
from .processtype import ProcessType, ProcessTypeTypedDict
from cribl_control_plane import models, utils
from cribl_control_plane.types import BaseModel
from cribl_control_plane.utils import validate_open_enum
from enum import Enum
import pydantic
from pydantic import field_serializer
from pydantic.functional_validators import PlainValidator
from typing import List, Optional, Union
from typing_extensions import Annotated, NotRequired, TypeAliasType, TypedDict


class InputWindowsMetricsType4(str, Enum):
    WINDOWS_METRICS = "windows_metrics"


class InputWindowsMetricsMode4(str, Enum, metaclass=utils.OpenEnumMeta):
    r"""Select level of detail for host metrics"""

    # Basic
    BASIC = "basic"
    # All
    ALL = "all"
    # Custom
    CUSTOM = "custom"
    # Disabled
    DISABLED = "disabled"


class InputWindowsMetricsSystemMode4(str, Enum, metaclass=utils.OpenEnumMeta):
    r"""Select the level of details for system metrics"""

    # Basic
    BASIC = "basic"
    # All
    ALL = "all"
    # Custom
    CUSTOM = "custom"
    # Disabled
    DISABLED = "disabled"


class InputWindowsMetricsSystem4TypedDict(TypedDict):
    mode: NotRequired[InputWindowsMetricsSystemMode4]
    r"""Select the level of details for system metrics"""
    detail: NotRequired[bool]
    r"""Generate metrics for all system information"""


class InputWindowsMetricsSystem4(BaseModel):
    mode: Annotated[
        Optional[InputWindowsMetricsSystemMode4],
        PlainValidator(validate_open_enum(False)),
    ] = InputWindowsMetricsSystemMode4.BASIC
    r"""Select the level of details for system metrics"""

    detail: Optional[bool] = False
    r"""Generate metrics for all system information"""

    @field_serializer("mode")
    def serialize_mode(self, value):
        if isinstance(value, str):
            try:
                return models.InputWindowsMetricsSystemMode4(value)
            except ValueError:
                return value
        return value


class InputWindowsMetricsCPUMode4(str, Enum, metaclass=utils.OpenEnumMeta):
    r"""Select the level of details for CPU metrics"""

    # Basic
    BASIC = "basic"
    # All
    ALL = "all"
    # Custom
    CUSTOM = "custom"
    # Disabled
    DISABLED = "disabled"


class InputWindowsMetricsCPU4TypedDict(TypedDict):
    mode: NotRequired[InputWindowsMetricsCPUMode4]
    r"""Select the level of details for CPU metrics"""
    per_cpu: NotRequired[bool]
    r"""Generate metrics for each CPU"""
    detail: NotRequired[bool]
    r"""Generate metrics for all CPU states"""
    time: NotRequired[bool]
    r"""Generate raw, monotonic CPU time counters"""


class InputWindowsMetricsCPU4(BaseModel):
    mode: Annotated[
        Optional[InputWindowsMetricsCPUMode4], PlainValidator(validate_open_enum(False))
    ] = InputWindowsMetricsCPUMode4.BASIC
    r"""Select the level of details for CPU metrics"""

    per_cpu: Annotated[Optional[bool], pydantic.Field(alias="perCpu")] = False
    r"""Generate metrics for each CPU"""

    detail: Optional[bool] = False
    r"""Generate metrics for all CPU states"""

    time: Optional[bool] = False
    r"""Generate raw, monotonic CPU time counters"""

    @field_serializer("mode")
    def serialize_mode(self, value):
        if isinstance(value, str):
            try:
                return models.InputWindowsMetricsCPUMode4(value)
            except ValueError:
                return value
        return value


class InputWindowsMetricsMemoryMode4(str, Enum, metaclass=utils.OpenEnumMeta):
    r"""Select the level of details for memory metrics"""

    # Basic
    BASIC = "basic"
    # All
    ALL = "all"
    # Custom
    CUSTOM = "custom"
    # Disabled
    DISABLED = "disabled"


class InputWindowsMetricsMemory4TypedDict(TypedDict):
    mode: NotRequired[InputWindowsMetricsMemoryMode4]
    r"""Select the level of details for memory metrics"""
    detail: NotRequired[bool]
    r"""Generate metrics for all memory states"""


class InputWindowsMetricsMemory4(BaseModel):
    mode: Annotated[
        Optional[InputWindowsMetricsMemoryMode4],
        PlainValidator(validate_open_enum(False)),
    ] = InputWindowsMetricsMemoryMode4.BASIC
    r"""Select the level of details for memory metrics"""

    detail: Optional[bool] = False
    r"""Generate metrics for all memory states"""

    @field_serializer("mode")
    def serialize_mode(self, value):
        if isinstance(value, str):
            try:
                return models.InputWindowsMetricsMemoryMode4(value)
            except ValueError:
                return value
        return value


class InputWindowsMetricsNetworkMode4(str, Enum, metaclass=utils.OpenEnumMeta):
    r"""Select the level of details for network metrics"""

    # Basic
    BASIC = "basic"
    # All
    ALL = "all"
    # Custom
    CUSTOM = "custom"
    # Disabled
    DISABLED = "disabled"


class InputWindowsMetricsNetwork4TypedDict(TypedDict):
    mode: NotRequired[InputWindowsMetricsNetworkMode4]
    r"""Select the level of details for network metrics"""
    detail: NotRequired[bool]
    r"""Generate full network metrics"""
    protocols: NotRequired[bool]
    r"""Generate protocol metrics for ICMP, ICMPMsg, IP, TCP, UDP and UDPLite"""
    devices: NotRequired[List[str]]
    r"""Network interfaces to include/exclude. All interfaces are included if this list is empty."""
    per_interface: NotRequired[bool]
    r"""Generate separate metrics for each interface"""


class InputWindowsMetricsNetwork4(BaseModel):
    mode: Annotated[
        Optional[InputWindowsMetricsNetworkMode4],
        PlainValidator(validate_open_enum(False)),
    ] = InputWindowsMetricsNetworkMode4.BASIC
    r"""Select the level of details for network metrics"""

    detail: Optional[bool] = False
    r"""Generate full network metrics"""

    protocols: Optional[bool] = False
    r"""Generate protocol metrics for ICMP, ICMPMsg, IP, TCP, UDP and UDPLite"""

    devices: Optional[List[str]] = None
    r"""Network interfaces to include/exclude. All interfaces are included if this list is empty."""

    per_interface: Annotated[Optional[bool], pydantic.Field(alias="perInterface")] = (
        False
    )
    r"""Generate separate metrics for each interface"""

    @field_serializer("mode")
    def serialize_mode(self, value):
        if isinstance(value, str):
            try:
                return models.InputWindowsMetricsNetworkMode4(value)
            except ValueError:
                return value
        return value


class InputWindowsMetricsDiskMode4(str, Enum, metaclass=utils.OpenEnumMeta):
    r"""Select the level of details for disk metrics"""

    # Basic
    BASIC = "basic"
    # All
    ALL = "all"
    # Custom
    CUSTOM = "custom"
    # Disabled
    DISABLED = "disabled"


class InputWindowsMetricsDisk4TypedDict(TypedDict):
    mode: NotRequired[InputWindowsMetricsDiskMode4]
    r"""Select the level of details for disk metrics"""
    per_volume: NotRequired[bool]
    r"""Generate separate metrics for each volume"""
    detail: NotRequired[bool]
    r"""Generate full disk metrics"""
    volumes: NotRequired[List[str]]
    r"""Windows volumes to include/exclude. E.g.: C:, !E:, etc. Wildcards and ! (not) operators are supported. All volumes are included if this list is empty."""


class InputWindowsMetricsDisk4(BaseModel):
    mode: Annotated[
        Optional[InputWindowsMetricsDiskMode4],
        PlainValidator(validate_open_enum(False)),
    ] = InputWindowsMetricsDiskMode4.BASIC
    r"""Select the level of details for disk metrics"""

    per_volume: Annotated[Optional[bool], pydantic.Field(alias="perVolume")] = False
    r"""Generate separate metrics for each volume"""

    detail: Optional[bool] = False
    r"""Generate full disk metrics"""

    volumes: Optional[List[str]] = None
    r"""Windows volumes to include/exclude. E.g.: C:, !E:, etc. Wildcards and ! (not) operators are supported. All volumes are included if this list is empty."""

    @field_serializer("mode")
    def serialize_mode(self, value):
        if isinstance(value, str):
            try:
                return models.InputWindowsMetricsDiskMode4(value)
            except ValueError:
                return value
        return value


class InputWindowsMetricsCustom4TypedDict(TypedDict):
    system: NotRequired[InputWindowsMetricsSystem4TypedDict]
    cpu: NotRequired[InputWindowsMetricsCPU4TypedDict]
    memory: NotRequired[InputWindowsMetricsMemory4TypedDict]
    network: NotRequired[InputWindowsMetricsNetwork4TypedDict]
    disk: NotRequired[InputWindowsMetricsDisk4TypedDict]


class InputWindowsMetricsCustom4(BaseModel):
    system: Optional[InputWindowsMetricsSystem4] = None

    cpu: Optional[InputWindowsMetricsCPU4] = None

    memory: Optional[InputWindowsMetricsMemory4] = None

    network: Optional[InputWindowsMetricsNetwork4] = None

    disk: Optional[InputWindowsMetricsDisk4] = None


class InputWindowsMetricsHost4TypedDict(TypedDict):
    mode: NotRequired[InputWindowsMetricsMode4]
    r"""Select level of detail for host metrics"""
    custom: NotRequired[InputWindowsMetricsCustom4TypedDict]


class InputWindowsMetricsHost4(BaseModel):
    mode: Annotated[
        Optional[InputWindowsMetricsMode4], PlainValidator(validate_open_enum(False))
    ] = InputWindowsMetricsMode4.BASIC
    r"""Select level of detail for host metrics"""

    custom: Optional[InputWindowsMetricsCustom4] = None

    @field_serializer("mode")
    def serialize_mode(self, value):
        if isinstance(value, str):
            try:
                return models.InputWindowsMetricsMode4(value)
            except ValueError:
                return value
        return value


class InputWindowsMetricsWindowsMetrics4TypedDict(TypedDict):
    type: InputWindowsMetricsType4
    pq: PqTypeTypedDict
    pq_enabled: NotRequired[bool]
    r"""Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers)."""
    id: NotRequired[str]
    r"""Unique ID for this input"""
    disabled: NotRequired[bool]
    pipeline: NotRequired[str]
    r"""Pipeline to process data from this Source before sending it through the Routes"""
    send_to_routes: NotRequired[bool]
    r"""Select whether to send data to Routes, or directly to Destinations."""
    environment: NotRequired[str]
    r"""Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere."""
    streamtags: NotRequired[List[str]]
    r"""Tags for filtering and grouping in @{product}"""
    connections: NotRequired[List[ConnectionsTypeTypedDict]]
    r"""Direct connections to Destinations, and optionally via a Pipeline or a Pack"""
    interval: NotRequired[float]
    r"""Time, in seconds, between consecutive metric collections. Default is 10 seconds."""
    host: NotRequired[InputWindowsMetricsHost4TypedDict]
    process: NotRequired[ProcessTypeTypedDict]
    metadata: NotRequired[List[Metadata1TypeTypedDict]]
    r"""Fields to add to events from this input"""
    persistence: NotRequired[Persistence1TypeTypedDict]
    disable_native_module: NotRequired[bool]
    r"""Enable to use built-in tools (PowerShell) to collect metrics instead of native API (default) [Learn more](https://docs.cribl.io/edge/sources-windows-metrics/#advanced-tab)"""
    description: NotRequired[str]


class InputWindowsMetricsWindowsMetrics4(BaseModel):
    type: InputWindowsMetricsType4

    pq: PqType

    pq_enabled: Annotated[Optional[bool], pydantic.Field(alias="pqEnabled")] = False
    r"""Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers)."""

    id: Optional[str] = None
    r"""Unique ID for this input"""

    disabled: Optional[bool] = False

    pipeline: Optional[str] = None
    r"""Pipeline to process data from this Source before sending it through the Routes"""

    send_to_routes: Annotated[Optional[bool], pydantic.Field(alias="sendToRoutes")] = (
        True
    )
    r"""Select whether to send data to Routes, or directly to Destinations."""

    environment: Optional[str] = None
    r"""Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere."""

    streamtags: Optional[List[str]] = None
    r"""Tags for filtering and grouping in @{product}"""

    connections: Optional[List[ConnectionsType]] = None
    r"""Direct connections to Destinations, and optionally via a Pipeline or a Pack"""

    interval: Optional[float] = 10
    r"""Time, in seconds, between consecutive metric collections. Default is 10 seconds."""

    host: Optional[InputWindowsMetricsHost4] = None

    process: Optional[ProcessType] = None

    metadata: Optional[List[Metadata1Type]] = None
    r"""Fields to add to events from this input"""

    persistence: Optional[Persistence1Type] = None

    disable_native_module: Annotated[
        Optional[bool], pydantic.Field(alias="disableNativeModule")
    ] = False
    r"""Enable to use built-in tools (PowerShell) to collect metrics instead of native API (default) [Learn more](https://docs.cribl.io/edge/sources-windows-metrics/#advanced-tab)"""

    description: Optional[str] = None


class InputWindowsMetricsType3(str, Enum):
    WINDOWS_METRICS = "windows_metrics"


class InputWindowsMetricsMode3(str, Enum, metaclass=utils.OpenEnumMeta):
    r"""Select level of detail for host metrics"""

    # Basic
    BASIC = "basic"
    # All
    ALL = "all"
    # Custom
    CUSTOM = "custom"
    # Disabled
    DISABLED = "disabled"


class InputWindowsMetricsSystemMode3(str, Enum, metaclass=utils.OpenEnumMeta):
    r"""Select the level of details for system metrics"""

    # Basic
    BASIC = "basic"
    # All
    ALL = "all"
    # Custom
    CUSTOM = "custom"
    # Disabled
    DISABLED = "disabled"


class InputWindowsMetricsSystem3TypedDict(TypedDict):
    mode: NotRequired[InputWindowsMetricsSystemMode3]
    r"""Select the level of details for system metrics"""
    detail: NotRequired[bool]
    r"""Generate metrics for all system information"""


class InputWindowsMetricsSystem3(BaseModel):
    mode: Annotated[
        Optional[InputWindowsMetricsSystemMode3],
        PlainValidator(validate_open_enum(False)),
    ] = InputWindowsMetricsSystemMode3.BASIC
    r"""Select the level of details for system metrics"""

    detail: Optional[bool] = False
    r"""Generate metrics for all system information"""

    @field_serializer("mode")
    def serialize_mode(self, value):
        if isinstance(value, str):
            try:
                return models.InputWindowsMetricsSystemMode3(value)
            except ValueError:
                return value
        return value


class InputWindowsMetricsCPUMode3(str, Enum, metaclass=utils.OpenEnumMeta):
    r"""Select the level of details for CPU metrics"""

    # Basic
    BASIC = "basic"
    # All
    ALL = "all"
    # Custom
    CUSTOM = "custom"
    # Disabled
    DISABLED = "disabled"


class InputWindowsMetricsCPU3TypedDict(TypedDict):
    mode: NotRequired[InputWindowsMetricsCPUMode3]
    r"""Select the level of details for CPU metrics"""
    per_cpu: NotRequired[bool]
    r"""Generate metrics for each CPU"""
    detail: NotRequired[bool]
    r"""Generate metrics for all CPU states"""
    time: NotRequired[bool]
    r"""Generate raw, monotonic CPU time counters"""


class InputWindowsMetricsCPU3(BaseModel):
    mode: Annotated[
        Optional[InputWindowsMetricsCPUMode3], PlainValidator(validate_open_enum(False))
    ] = InputWindowsMetricsCPUMode3.BASIC
    r"""Select the level of details for CPU metrics"""

    per_cpu: Annotated[Optional[bool], pydantic.Field(alias="perCpu")] = False
    r"""Generate metrics for each CPU"""

    detail: Optional[bool] = False
    r"""Generate metrics for all CPU states"""

    time: Optional[bool] = False
    r"""Generate raw, monotonic CPU time counters"""

    @field_serializer("mode")
    def serialize_mode(self, value):
        if isinstance(value, str):
            try:
                return models.InputWindowsMetricsCPUMode3(value)
            except ValueError:
                return value
        return value


class InputWindowsMetricsMemoryMode3(str, Enum, metaclass=utils.OpenEnumMeta):
    r"""Select the level of details for memory metrics"""

    # Basic
    BASIC = "basic"
    # All
    ALL = "all"
    # Custom
    CUSTOM = "custom"
    # Disabled
    DISABLED = "disabled"


class InputWindowsMetricsMemory3TypedDict(TypedDict):
    mode: NotRequired[InputWindowsMetricsMemoryMode3]
    r"""Select the level of details for memory metrics"""
    detail: NotRequired[bool]
    r"""Generate metrics for all memory states"""


class InputWindowsMetricsMemory3(BaseModel):
    mode: Annotated[
        Optional[InputWindowsMetricsMemoryMode3],
        PlainValidator(validate_open_enum(False)),
    ] = InputWindowsMetricsMemoryMode3.BASIC
    r"""Select the level of details for memory metrics"""

    detail: Optional[bool] = False
    r"""Generate metrics for all memory states"""

    @field_serializer("mode")
    def serialize_mode(self, value):
        if isinstance(value, str):
            try:
                return models.InputWindowsMetricsMemoryMode3(value)
            except ValueError:
                return value
        return value


class InputWindowsMetricsNetworkMode3(str, Enum, metaclass=utils.OpenEnumMeta):
    r"""Select the level of details for network metrics"""

    # Basic
    BASIC = "basic"
    # All
    ALL = "all"
    # Custom
    CUSTOM = "custom"
    # Disabled
    DISABLED = "disabled"


class InputWindowsMetricsNetwork3TypedDict(TypedDict):
    mode: NotRequired[InputWindowsMetricsNetworkMode3]
    r"""Select the level of details for network metrics"""
    detail: NotRequired[bool]
    r"""Generate full network metrics"""
    protocols: NotRequired[bool]
    r"""Generate protocol metrics for ICMP, ICMPMsg, IP, TCP, UDP and UDPLite"""
    devices: NotRequired[List[str]]
    r"""Network interfaces to include/exclude. All interfaces are included if this list is empty."""
    per_interface: NotRequired[bool]
    r"""Generate separate metrics for each interface"""


class InputWindowsMetricsNetwork3(BaseModel):
    mode: Annotated[
        Optional[InputWindowsMetricsNetworkMode3],
        PlainValidator(validate_open_enum(False)),
    ] = InputWindowsMetricsNetworkMode3.BASIC
    r"""Select the level of details for network metrics"""

    detail: Optional[bool] = False
    r"""Generate full network metrics"""

    protocols: Optional[bool] = False
    r"""Generate protocol metrics for ICMP, ICMPMsg, IP, TCP, UDP and UDPLite"""

    devices: Optional[List[str]] = None
    r"""Network interfaces to include/exclude. All interfaces are included if this list is empty."""

    per_interface: Annotated[Optional[bool], pydantic.Field(alias="perInterface")] = (
        False
    )
    r"""Generate separate metrics for each interface"""

    @field_serializer("mode")
    def serialize_mode(self, value):
        if isinstance(value, str):
            try:
                return models.InputWindowsMetricsNetworkMode3(value)
            except ValueError:
                return value
        return value


class InputWindowsMetricsDiskMode3(str, Enum, metaclass=utils.OpenEnumMeta):
    r"""Select the level of details for disk metrics"""

    # Basic
    BASIC = "basic"
    # All
    ALL = "all"
    # Custom
    CUSTOM = "custom"
    # Disabled
    DISABLED = "disabled"


class InputWindowsMetricsDisk3TypedDict(TypedDict):
    mode: NotRequired[InputWindowsMetricsDiskMode3]
    r"""Select the level of details for disk metrics"""
    per_volume: NotRequired[bool]
    r"""Generate separate metrics for each volume"""
    detail: NotRequired[bool]
    r"""Generate full disk metrics"""
    volumes: NotRequired[List[str]]
    r"""Windows volumes to include/exclude. E.g.: C:, !E:, etc. Wildcards and ! (not) operators are supported. All volumes are included if this list is empty."""


class InputWindowsMetricsDisk3(BaseModel):
    mode: Annotated[
        Optional[InputWindowsMetricsDiskMode3],
        PlainValidator(validate_open_enum(False)),
    ] = InputWindowsMetricsDiskMode3.BASIC
    r"""Select the level of details for disk metrics"""

    per_volume: Annotated[Optional[bool], pydantic.Field(alias="perVolume")] = False
    r"""Generate separate metrics for each volume"""

    detail: Optional[bool] = False
    r"""Generate full disk metrics"""

    volumes: Optional[List[str]] = None
    r"""Windows volumes to include/exclude. E.g.: C:, !E:, etc. Wildcards and ! (not) operators are supported. All volumes are included if this list is empty."""

    @field_serializer("mode")
    def serialize_mode(self, value):
        if isinstance(value, str):
            try:
                return models.InputWindowsMetricsDiskMode3(value)
            except ValueError:
                return value
        return value


class InputWindowsMetricsCustom3TypedDict(TypedDict):
    system: NotRequired[InputWindowsMetricsSystem3TypedDict]
    cpu: NotRequired[InputWindowsMetricsCPU3TypedDict]
    memory: NotRequired[InputWindowsMetricsMemory3TypedDict]
    network: NotRequired[InputWindowsMetricsNetwork3TypedDict]
    disk: NotRequired[InputWindowsMetricsDisk3TypedDict]


class InputWindowsMetricsCustom3(BaseModel):
    system: Optional[InputWindowsMetricsSystem3] = None

    cpu: Optional[InputWindowsMetricsCPU3] = None

    memory: Optional[InputWindowsMetricsMemory3] = None

    network: Optional[InputWindowsMetricsNetwork3] = None

    disk: Optional[InputWindowsMetricsDisk3] = None


class InputWindowsMetricsHost3TypedDict(TypedDict):
    mode: NotRequired[InputWindowsMetricsMode3]
    r"""Select level of detail for host metrics"""
    custom: NotRequired[InputWindowsMetricsCustom3TypedDict]


class InputWindowsMetricsHost3(BaseModel):
    mode: Annotated[
        Optional[InputWindowsMetricsMode3], PlainValidator(validate_open_enum(False))
    ] = InputWindowsMetricsMode3.BASIC
    r"""Select level of detail for host metrics"""

    custom: Optional[InputWindowsMetricsCustom3] = None

    @field_serializer("mode")
    def serialize_mode(self, value):
        if isinstance(value, str):
            try:
                return models.InputWindowsMetricsMode3(value)
            except ValueError:
                return value
        return value


class InputWindowsMetricsWindowsMetrics3TypedDict(TypedDict):
    type: InputWindowsMetricsType3
    pq_enabled: NotRequired[bool]
    r"""Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers)."""
    id: NotRequired[str]
    r"""Unique ID for this input"""
    disabled: NotRequired[bool]
    pipeline: NotRequired[str]
    r"""Pipeline to process data from this Source before sending it through the Routes"""
    send_to_routes: NotRequired[bool]
    r"""Select whether to send data to Routes, or directly to Destinations."""
    environment: NotRequired[str]
    r"""Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere."""
    streamtags: NotRequired[List[str]]
    r"""Tags for filtering and grouping in @{product}"""
    connections: NotRequired[List[ConnectionsTypeTypedDict]]
    r"""Direct connections to Destinations, and optionally via a Pipeline or a Pack"""
    pq: NotRequired[PqTypeTypedDict]
    interval: NotRequired[float]
    r"""Time, in seconds, between consecutive metric collections. Default is 10 seconds."""
    host: NotRequired[InputWindowsMetricsHost3TypedDict]
    process: NotRequired[ProcessTypeTypedDict]
    metadata: NotRequired[List[Metadata1TypeTypedDict]]
    r"""Fields to add to events from this input"""
    persistence: NotRequired[Persistence1TypeTypedDict]
    disable_native_module: NotRequired[bool]
    r"""Enable to use built-in tools (PowerShell) to collect metrics instead of native API (default) [Learn more](https://docs.cribl.io/edge/sources-windows-metrics/#advanced-tab)"""
    description: NotRequired[str]


class InputWindowsMetricsWindowsMetrics3(BaseModel):
    type: InputWindowsMetricsType3

    pq_enabled: Annotated[Optional[bool], pydantic.Field(alias="pqEnabled")] = False
    r"""Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers)."""

    id: Optional[str] = None
    r"""Unique ID for this input"""

    disabled: Optional[bool] = False

    pipeline: Optional[str] = None
    r"""Pipeline to process data from this Source before sending it through the Routes"""

    send_to_routes: Annotated[Optional[bool], pydantic.Field(alias="sendToRoutes")] = (
        True
    )
    r"""Select whether to send data to Routes, or directly to Destinations."""

    environment: Optional[str] = None
    r"""Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere."""

    streamtags: Optional[List[str]] = None
    r"""Tags for filtering and grouping in @{product}"""

    connections: Optional[List[ConnectionsType]] = None
    r"""Direct connections to Destinations, and optionally via a Pipeline or a Pack"""

    pq: Optional[PqType] = None

    interval: Optional[float] = 10
    r"""Time, in seconds, between consecutive metric collections. Default is 10 seconds."""

    host: Optional[InputWindowsMetricsHost3] = None

    process: Optional[ProcessType] = None

    metadata: Optional[List[Metadata1Type]] = None
    r"""Fields to add to events from this input"""

    persistence: Optional[Persistence1Type] = None

    disable_native_module: Annotated[
        Optional[bool], pydantic.Field(alias="disableNativeModule")
    ] = False
    r"""Enable to use built-in tools (PowerShell) to collect metrics instead of native API (default) [Learn more](https://docs.cribl.io/edge/sources-windows-metrics/#advanced-tab)"""

    description: Optional[str] = None


class InputWindowsMetricsType2(str, Enum):
    WINDOWS_METRICS = "windows_metrics"


class InputWindowsMetricsMode2(str, Enum, metaclass=utils.OpenEnumMeta):
    r"""Select level of detail for host metrics"""

    # Basic
    BASIC = "basic"
    # All
    ALL = "all"
    # Custom
    CUSTOM = "custom"
    # Disabled
    DISABLED = "disabled"


class InputWindowsMetricsSystemMode2(str, Enum, metaclass=utils.OpenEnumMeta):
    r"""Select the level of details for system metrics"""

    # Basic
    BASIC = "basic"
    # All
    ALL = "all"
    # Custom
    CUSTOM = "custom"
    # Disabled
    DISABLED = "disabled"


class InputWindowsMetricsSystem2TypedDict(TypedDict):
    mode: NotRequired[InputWindowsMetricsSystemMode2]
    r"""Select the level of details for system metrics"""
    detail: NotRequired[bool]
    r"""Generate metrics for all system information"""


class InputWindowsMetricsSystem2(BaseModel):
    mode: Annotated[
        Optional[InputWindowsMetricsSystemMode2],
        PlainValidator(validate_open_enum(False)),
    ] = InputWindowsMetricsSystemMode2.BASIC
    r"""Select the level of details for system metrics"""

    detail: Optional[bool] = False
    r"""Generate metrics for all system information"""

    @field_serializer("mode")
    def serialize_mode(self, value):
        if isinstance(value, str):
            try:
                return models.InputWindowsMetricsSystemMode2(value)
            except ValueError:
                return value
        return value


class InputWindowsMetricsCPUMode2(str, Enum, metaclass=utils.OpenEnumMeta):
    r"""Select the level of details for CPU metrics"""

    # Basic
    BASIC = "basic"
    # All
    ALL = "all"
    # Custom
    CUSTOM = "custom"
    # Disabled
    DISABLED = "disabled"


class InputWindowsMetricsCPU2TypedDict(TypedDict):
    mode: NotRequired[InputWindowsMetricsCPUMode2]
    r"""Select the level of details for CPU metrics"""
    per_cpu: NotRequired[bool]
    r"""Generate metrics for each CPU"""
    detail: NotRequired[bool]
    r"""Generate metrics for all CPU states"""
    time: NotRequired[bool]
    r"""Generate raw, monotonic CPU time counters"""


class InputWindowsMetricsCPU2(BaseModel):
    mode: Annotated[
        Optional[InputWindowsMetricsCPUMode2], PlainValidator(validate_open_enum(False))
    ] = InputWindowsMetricsCPUMode2.BASIC
    r"""Select the level of details for CPU metrics"""

    per_cpu: Annotated[Optional[bool], pydantic.Field(alias="perCpu")] = False
    r"""Generate metrics for each CPU"""

    detail: Optional[bool] = False
    r"""Generate metrics for all CPU states"""

    time: Optional[bool] = False
    r"""Generate raw, monotonic CPU time counters"""

    @field_serializer("mode")
    def serialize_mode(self, value):
        if isinstance(value, str):
            try:
                return models.InputWindowsMetricsCPUMode2(value)
            except ValueError:
                return value
        return value


class InputWindowsMetricsMemoryMode2(str, Enum, metaclass=utils.OpenEnumMeta):
    r"""Select the level of details for memory metrics"""

    # Basic
    BASIC = "basic"
    # All
    ALL = "all"
    # Custom
    CUSTOM = "custom"
    # Disabled
    DISABLED = "disabled"


class InputWindowsMetricsMemory2TypedDict(TypedDict):
    mode: NotRequired[InputWindowsMetricsMemoryMode2]
    r"""Select the level of details for memory metrics"""
    detail: NotRequired[bool]
    r"""Generate metrics for all memory states"""


class InputWindowsMetricsMemory2(BaseModel):
    mode: Annotated[
        Optional[InputWindowsMetricsMemoryMode2],
        PlainValidator(validate_open_enum(False)),
    ] = InputWindowsMetricsMemoryMode2.BASIC
    r"""Select the level of details for memory metrics"""

    detail: Optional[bool] = False
    r"""Generate metrics for all memory states"""

    @field_serializer("mode")
    def serialize_mode(self, value):
        if isinstance(value, str):
            try:
                return models.InputWindowsMetricsMemoryMode2(value)
            except ValueError:
                return value
        return value


class InputWindowsMetricsNetworkMode2(str, Enum, metaclass=utils.OpenEnumMeta):
    r"""Select the level of details for network metrics"""

    # Basic
    BASIC = "basic"
    # All
    ALL = "all"
    # Custom
    CUSTOM = "custom"
    # Disabled
    DISABLED = "disabled"


class InputWindowsMetricsNetwork2TypedDict(TypedDict):
    mode: NotRequired[InputWindowsMetricsNetworkMode2]
    r"""Select the level of details for network metrics"""
    detail: NotRequired[bool]
    r"""Generate full network metrics"""
    protocols: NotRequired[bool]
    r"""Generate protocol metrics for ICMP, ICMPMsg, IP, TCP, UDP and UDPLite"""
    devices: NotRequired[List[str]]
    r"""Network interfaces to include/exclude. All interfaces are included if this list is empty."""
    per_interface: NotRequired[bool]
    r"""Generate separate metrics for each interface"""


class InputWindowsMetricsNetwork2(BaseModel):
    mode: Annotated[
        Optional[InputWindowsMetricsNetworkMode2],
        PlainValidator(validate_open_enum(False)),
    ] = InputWindowsMetricsNetworkMode2.BASIC
    r"""Select the level of details for network metrics"""

    detail: Optional[bool] = False
    r"""Generate full network metrics"""

    protocols: Optional[bool] = False
    r"""Generate protocol metrics for ICMP, ICMPMsg, IP, TCP, UDP and UDPLite"""

    devices: Optional[List[str]] = None
    r"""Network interfaces to include/exclude. All interfaces are included if this list is empty."""

    per_interface: Annotated[Optional[bool], pydantic.Field(alias="perInterface")] = (
        False
    )
    r"""Generate separate metrics for each interface"""

    @field_serializer("mode")
    def serialize_mode(self, value):
        if isinstance(value, str):
            try:
                return models.InputWindowsMetricsNetworkMode2(value)
            except ValueError:
                return value
        return value


class InputWindowsMetricsDiskMode2(str, Enum, metaclass=utils.OpenEnumMeta):
    r"""Select the level of details for disk metrics"""

    # Basic
    BASIC = "basic"
    # All
    ALL = "all"
    # Custom
    CUSTOM = "custom"
    # Disabled
    DISABLED = "disabled"


class InputWindowsMetricsDisk2TypedDict(TypedDict):
    mode: NotRequired[InputWindowsMetricsDiskMode2]
    r"""Select the level of details for disk metrics"""
    per_volume: NotRequired[bool]
    r"""Generate separate metrics for each volume"""
    detail: NotRequired[bool]
    r"""Generate full disk metrics"""
    volumes: NotRequired[List[str]]
    r"""Windows volumes to include/exclude. E.g.: C:, !E:, etc. Wildcards and ! (not) operators are supported. All volumes are included if this list is empty."""


class InputWindowsMetricsDisk2(BaseModel):
    mode: Annotated[
        Optional[InputWindowsMetricsDiskMode2],
        PlainValidator(validate_open_enum(False)),
    ] = InputWindowsMetricsDiskMode2.BASIC
    r"""Select the level of details for disk metrics"""

    per_volume: Annotated[Optional[bool], pydantic.Field(alias="perVolume")] = False
    r"""Generate separate metrics for each volume"""

    detail: Optional[bool] = False
    r"""Generate full disk metrics"""

    volumes: Optional[List[str]] = None
    r"""Windows volumes to include/exclude. E.g.: C:, !E:, etc. Wildcards and ! (not) operators are supported. All volumes are included if this list is empty."""

    @field_serializer("mode")
    def serialize_mode(self, value):
        if isinstance(value, str):
            try:
                return models.InputWindowsMetricsDiskMode2(value)
            except ValueError:
                return value
        return value


class InputWindowsMetricsCustom2TypedDict(TypedDict):
    system: NotRequired[InputWindowsMetricsSystem2TypedDict]
    cpu: NotRequired[InputWindowsMetricsCPU2TypedDict]
    memory: NotRequired[InputWindowsMetricsMemory2TypedDict]
    network: NotRequired[InputWindowsMetricsNetwork2TypedDict]
    disk: NotRequired[InputWindowsMetricsDisk2TypedDict]


class InputWindowsMetricsCustom2(BaseModel):
    system: Optional[InputWindowsMetricsSystem2] = None

    cpu: Optional[InputWindowsMetricsCPU2] = None

    memory: Optional[InputWindowsMetricsMemory2] = None

    network: Optional[InputWindowsMetricsNetwork2] = None

    disk: Optional[InputWindowsMetricsDisk2] = None


class InputWindowsMetricsHost2TypedDict(TypedDict):
    mode: NotRequired[InputWindowsMetricsMode2]
    r"""Select level of detail for host metrics"""
    custom: NotRequired[InputWindowsMetricsCustom2TypedDict]


class InputWindowsMetricsHost2(BaseModel):
    mode: Annotated[
        Optional[InputWindowsMetricsMode2], PlainValidator(validate_open_enum(False))
    ] = InputWindowsMetricsMode2.BASIC
    r"""Select level of detail for host metrics"""

    custom: Optional[InputWindowsMetricsCustom2] = None

    @field_serializer("mode")
    def serialize_mode(self, value):
        if isinstance(value, str):
            try:
                return models.InputWindowsMetricsMode2(value)
            except ValueError:
                return value
        return value


class InputWindowsMetricsWindowsMetrics2TypedDict(TypedDict):
    type: InputWindowsMetricsType2
    connections: List[ConnectionsTypeTypedDict]
    r"""Direct connections to Destinations, and optionally via a Pipeline or a Pack"""
    send_to_routes: NotRequired[bool]
    r"""Select whether to send data to Routes, or directly to Destinations."""
    id: NotRequired[str]
    r"""Unique ID for this input"""
    disabled: NotRequired[bool]
    pipeline: NotRequired[str]
    r"""Pipeline to process data from this Source before sending it through the Routes"""
    environment: NotRequired[str]
    r"""Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere."""
    pq_enabled: NotRequired[bool]
    r"""Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers)."""
    streamtags: NotRequired[List[str]]
    r"""Tags for filtering and grouping in @{product}"""
    pq: NotRequired[PqTypeTypedDict]
    interval: NotRequired[float]
    r"""Time, in seconds, between consecutive metric collections. Default is 10 seconds."""
    host: NotRequired[InputWindowsMetricsHost2TypedDict]
    process: NotRequired[ProcessTypeTypedDict]
    metadata: NotRequired[List[Metadata1TypeTypedDict]]
    r"""Fields to add to events from this input"""
    persistence: NotRequired[Persistence1TypeTypedDict]
    disable_native_module: NotRequired[bool]
    r"""Enable to use built-in tools (PowerShell) to collect metrics instead of native API (default) [Learn more](https://docs.cribl.io/edge/sources-windows-metrics/#advanced-tab)"""
    description: NotRequired[str]


class InputWindowsMetricsWindowsMetrics2(BaseModel):
    type: InputWindowsMetricsType2

    connections: List[ConnectionsType]
    r"""Direct connections to Destinations, and optionally via a Pipeline or a Pack"""

    send_to_routes: Annotated[Optional[bool], pydantic.Field(alias="sendToRoutes")] = (
        True
    )
    r"""Select whether to send data to Routes, or directly to Destinations."""

    id: Optional[str] = None
    r"""Unique ID for this input"""

    disabled: Optional[bool] = False

    pipeline: Optional[str] = None
    r"""Pipeline to process data from this Source before sending it through the Routes"""

    environment: Optional[str] = None
    r"""Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere."""

    pq_enabled: Annotated[Optional[bool], pydantic.Field(alias="pqEnabled")] = False
    r"""Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers)."""

    streamtags: Optional[List[str]] = None
    r"""Tags for filtering and grouping in @{product}"""

    pq: Optional[PqType] = None

    interval: Optional[float] = 10
    r"""Time, in seconds, between consecutive metric collections. Default is 10 seconds."""

    host: Optional[InputWindowsMetricsHost2] = None

    process: Optional[ProcessType] = None

    metadata: Optional[List[Metadata1Type]] = None
    r"""Fields to add to events from this input"""

    persistence: Optional[Persistence1Type] = None

    disable_native_module: Annotated[
        Optional[bool], pydantic.Field(alias="disableNativeModule")
    ] = False
    r"""Enable to use built-in tools (PowerShell) to collect metrics instead of native API (default) [Learn more](https://docs.cribl.io/edge/sources-windows-metrics/#advanced-tab)"""

    description: Optional[str] = None


class InputWindowsMetricsType1(str, Enum):
    WINDOWS_METRICS = "windows_metrics"


class InputWindowsMetricsMode1(str, Enum, metaclass=utils.OpenEnumMeta):
    r"""Select level of detail for host metrics"""

    # Basic
    BASIC = "basic"
    # All
    ALL = "all"
    # Custom
    CUSTOM = "custom"
    # Disabled
    DISABLED = "disabled"


class InputWindowsMetricsSystemMode1(str, Enum, metaclass=utils.OpenEnumMeta):
    r"""Select the level of details for system metrics"""

    # Basic
    BASIC = "basic"
    # All
    ALL = "all"
    # Custom
    CUSTOM = "custom"
    # Disabled
    DISABLED = "disabled"


class InputWindowsMetricsSystem1TypedDict(TypedDict):
    mode: NotRequired[InputWindowsMetricsSystemMode1]
    r"""Select the level of details for system metrics"""
    detail: NotRequired[bool]
    r"""Generate metrics for all system information"""


class InputWindowsMetricsSystem1(BaseModel):
    mode: Annotated[
        Optional[InputWindowsMetricsSystemMode1],
        PlainValidator(validate_open_enum(False)),
    ] = InputWindowsMetricsSystemMode1.BASIC
    r"""Select the level of details for system metrics"""

    detail: Optional[bool] = False
    r"""Generate metrics for all system information"""

    @field_serializer("mode")
    def serialize_mode(self, value):
        if isinstance(value, str):
            try:
                return models.InputWindowsMetricsSystemMode1(value)
            except ValueError:
                return value
        return value


class InputWindowsMetricsCPUMode1(str, Enum, metaclass=utils.OpenEnumMeta):
    r"""Select the level of details for CPU metrics"""

    # Basic
    BASIC = "basic"
    # All
    ALL = "all"
    # Custom
    CUSTOM = "custom"
    # Disabled
    DISABLED = "disabled"


class InputWindowsMetricsCPU1TypedDict(TypedDict):
    mode: NotRequired[InputWindowsMetricsCPUMode1]
    r"""Select the level of details for CPU metrics"""
    per_cpu: NotRequired[bool]
    r"""Generate metrics for each CPU"""
    detail: NotRequired[bool]
    r"""Generate metrics for all CPU states"""
    time: NotRequired[bool]
    r"""Generate raw, monotonic CPU time counters"""


class InputWindowsMetricsCPU1(BaseModel):
    mode: Annotated[
        Optional[InputWindowsMetricsCPUMode1], PlainValidator(validate_open_enum(False))
    ] = InputWindowsMetricsCPUMode1.BASIC
    r"""Select the level of details for CPU metrics"""

    per_cpu: Annotated[Optional[bool], pydantic.Field(alias="perCpu")] = False
    r"""Generate metrics for each CPU"""

    detail: Optional[bool] = False
    r"""Generate metrics for all CPU states"""

    time: Optional[bool] = False
    r"""Generate raw, monotonic CPU time counters"""

    @field_serializer("mode")
    def serialize_mode(self, value):
        if isinstance(value, str):
            try:
                return models.InputWindowsMetricsCPUMode1(value)
            except ValueError:
                return value
        return value


class InputWindowsMetricsMemoryMode1(str, Enum, metaclass=utils.OpenEnumMeta):
    r"""Select the level of details for memory metrics"""

    # Basic
    BASIC = "basic"
    # All
    ALL = "all"
    # Custom
    CUSTOM = "custom"
    # Disabled
    DISABLED = "disabled"


class InputWindowsMetricsMemory1TypedDict(TypedDict):
    mode: NotRequired[InputWindowsMetricsMemoryMode1]
    r"""Select the level of details for memory metrics"""
    detail: NotRequired[bool]
    r"""Generate metrics for all memory states"""


class InputWindowsMetricsMemory1(BaseModel):
    mode: Annotated[
        Optional[InputWindowsMetricsMemoryMode1],
        PlainValidator(validate_open_enum(False)),
    ] = InputWindowsMetricsMemoryMode1.BASIC
    r"""Select the level of details for memory metrics"""

    detail: Optional[bool] = False
    r"""Generate metrics for all memory states"""

    @field_serializer("mode")
    def serialize_mode(self, value):
        if isinstance(value, str):
            try:
                return models.InputWindowsMetricsMemoryMode1(value)
            except ValueError:
                return value
        return value


class InputWindowsMetricsNetworkMode1(str, Enum, metaclass=utils.OpenEnumMeta):
    r"""Select the level of details for network metrics"""

    # Basic
    BASIC = "basic"
    # All
    ALL = "all"
    # Custom
    CUSTOM = "custom"
    # Disabled
    DISABLED = "disabled"


class InputWindowsMetricsNetwork1TypedDict(TypedDict):
    mode: NotRequired[InputWindowsMetricsNetworkMode1]
    r"""Select the level of details for network metrics"""
    detail: NotRequired[bool]
    r"""Generate full network metrics"""
    protocols: NotRequired[bool]
    r"""Generate protocol metrics for ICMP, ICMPMsg, IP, TCP, UDP and UDPLite"""
    devices: NotRequired[List[str]]
    r"""Network interfaces to include/exclude. All interfaces are included if this list is empty."""
    per_interface: NotRequired[bool]
    r"""Generate separate metrics for each interface"""


class InputWindowsMetricsNetwork1(BaseModel):
    mode: Annotated[
        Optional[InputWindowsMetricsNetworkMode1],
        PlainValidator(validate_open_enum(False)),
    ] = InputWindowsMetricsNetworkMode1.BASIC
    r"""Select the level of details for network metrics"""

    detail: Optional[bool] = False
    r"""Generate full network metrics"""

    protocols: Optional[bool] = False
    r"""Generate protocol metrics for ICMP, ICMPMsg, IP, TCP, UDP and UDPLite"""

    devices: Optional[List[str]] = None
    r"""Network interfaces to include/exclude. All interfaces are included if this list is empty."""

    per_interface: Annotated[Optional[bool], pydantic.Field(alias="perInterface")] = (
        False
    )
    r"""Generate separate metrics for each interface"""

    @field_serializer("mode")
    def serialize_mode(self, value):
        if isinstance(value, str):
            try:
                return models.InputWindowsMetricsNetworkMode1(value)
            except ValueError:
                return value
        return value


class InputWindowsMetricsDiskMode1(str, Enum, metaclass=utils.OpenEnumMeta):
    r"""Select the level of details for disk metrics"""

    # Basic
    BASIC = "basic"
    # All
    ALL = "all"
    # Custom
    CUSTOM = "custom"
    # Disabled
    DISABLED = "disabled"


class InputWindowsMetricsDisk1TypedDict(TypedDict):
    mode: NotRequired[InputWindowsMetricsDiskMode1]
    r"""Select the level of details for disk metrics"""
    per_volume: NotRequired[bool]
    r"""Generate separate metrics for each volume"""
    detail: NotRequired[bool]
    r"""Generate full disk metrics"""
    volumes: NotRequired[List[str]]
    r"""Windows volumes to include/exclude. E.g.: C:, !E:, etc. Wildcards and ! (not) operators are supported. All volumes are included if this list is empty."""


class InputWindowsMetricsDisk1(BaseModel):
    mode: Annotated[
        Optional[InputWindowsMetricsDiskMode1],
        PlainValidator(validate_open_enum(False)),
    ] = InputWindowsMetricsDiskMode1.BASIC
    r"""Select the level of details for disk metrics"""

    per_volume: Annotated[Optional[bool], pydantic.Field(alias="perVolume")] = False
    r"""Generate separate metrics for each volume"""

    detail: Optional[bool] = False
    r"""Generate full disk metrics"""

    volumes: Optional[List[str]] = None
    r"""Windows volumes to include/exclude. E.g.: C:, !E:, etc. Wildcards and ! (not) operators are supported. All volumes are included if this list is empty."""

    @field_serializer("mode")
    def serialize_mode(self, value):
        if isinstance(value, str):
            try:
                return models.InputWindowsMetricsDiskMode1(value)
            except ValueError:
                return value
        return value


class InputWindowsMetricsCustom1TypedDict(TypedDict):
    system: NotRequired[InputWindowsMetricsSystem1TypedDict]
    cpu: NotRequired[InputWindowsMetricsCPU1TypedDict]
    memory: NotRequired[InputWindowsMetricsMemory1TypedDict]
    network: NotRequired[InputWindowsMetricsNetwork1TypedDict]
    disk: NotRequired[InputWindowsMetricsDisk1TypedDict]


class InputWindowsMetricsCustom1(BaseModel):
    system: Optional[InputWindowsMetricsSystem1] = None

    cpu: Optional[InputWindowsMetricsCPU1] = None

    memory: Optional[InputWindowsMetricsMemory1] = None

    network: Optional[InputWindowsMetricsNetwork1] = None

    disk: Optional[InputWindowsMetricsDisk1] = None


class InputWindowsMetricsHost1TypedDict(TypedDict):
    mode: NotRequired[InputWindowsMetricsMode1]
    r"""Select level of detail for host metrics"""
    custom: NotRequired[InputWindowsMetricsCustom1TypedDict]


class InputWindowsMetricsHost1(BaseModel):
    mode: Annotated[
        Optional[InputWindowsMetricsMode1], PlainValidator(validate_open_enum(False))
    ] = InputWindowsMetricsMode1.BASIC
    r"""Select level of detail for host metrics"""

    custom: Optional[InputWindowsMetricsCustom1] = None

    @field_serializer("mode")
    def serialize_mode(self, value):
        if isinstance(value, str):
            try:
                return models.InputWindowsMetricsMode1(value)
            except ValueError:
                return value
        return value


class InputWindowsMetricsWindowsMetrics1TypedDict(TypedDict):
    type: InputWindowsMetricsType1
    send_to_routes: NotRequired[bool]
    r"""Select whether to send data to Routes, or directly to Destinations."""
    id: NotRequired[str]
    r"""Unique ID for this input"""
    disabled: NotRequired[bool]
    pipeline: NotRequired[str]
    r"""Pipeline to process data from this Source before sending it through the Routes"""
    environment: NotRequired[str]
    r"""Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere."""
    pq_enabled: NotRequired[bool]
    r"""Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers)."""
    streamtags: NotRequired[List[str]]
    r"""Tags for filtering and grouping in @{product}"""
    connections: NotRequired[List[ConnectionsTypeTypedDict]]
    r"""Direct connections to Destinations, and optionally via a Pipeline or a Pack"""
    pq: NotRequired[PqTypeTypedDict]
    interval: NotRequired[float]
    r"""Time, in seconds, between consecutive metric collections. Default is 10 seconds."""
    host: NotRequired[InputWindowsMetricsHost1TypedDict]
    process: NotRequired[ProcessTypeTypedDict]
    metadata: NotRequired[List[Metadata1TypeTypedDict]]
    r"""Fields to add to events from this input"""
    persistence: NotRequired[Persistence1TypeTypedDict]
    disable_native_module: NotRequired[bool]
    r"""Enable to use built-in tools (PowerShell) to collect metrics instead of native API (default) [Learn more](https://docs.cribl.io/edge/sources-windows-metrics/#advanced-tab)"""
    description: NotRequired[str]


class InputWindowsMetricsWindowsMetrics1(BaseModel):
    type: InputWindowsMetricsType1

    send_to_routes: Annotated[Optional[bool], pydantic.Field(alias="sendToRoutes")] = (
        True
    )
    r"""Select whether to send data to Routes, or directly to Destinations."""

    id: Optional[str] = None
    r"""Unique ID for this input"""

    disabled: Optional[bool] = False

    pipeline: Optional[str] = None
    r"""Pipeline to process data from this Source before sending it through the Routes"""

    environment: Optional[str] = None
    r"""Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere."""

    pq_enabled: Annotated[Optional[bool], pydantic.Field(alias="pqEnabled")] = False
    r"""Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers)."""

    streamtags: Optional[List[str]] = None
    r"""Tags for filtering and grouping in @{product}"""

    connections: Optional[List[ConnectionsType]] = None
    r"""Direct connections to Destinations, and optionally via a Pipeline or a Pack"""

    pq: Optional[PqType] = None

    interval: Optional[float] = 10
    r"""Time, in seconds, between consecutive metric collections. Default is 10 seconds."""

    host: Optional[InputWindowsMetricsHost1] = None

    process: Optional[ProcessType] = None

    metadata: Optional[List[Metadata1Type]] = None
    r"""Fields to add to events from this input"""

    persistence: Optional[Persistence1Type] = None

    disable_native_module: Annotated[
        Optional[bool], pydantic.Field(alias="disableNativeModule")
    ] = False
    r"""Enable to use built-in tools (PowerShell) to collect metrics instead of native API (default) [Learn more](https://docs.cribl.io/edge/sources-windows-metrics/#advanced-tab)"""

    description: Optional[str] = None


InputWindowsMetricsTypedDict = TypeAliasType(
    "InputWindowsMetricsTypedDict",
    Union[
        InputWindowsMetricsWindowsMetrics1TypedDict,
        InputWindowsMetricsWindowsMetrics2TypedDict,
        InputWindowsMetricsWindowsMetrics3TypedDict,
        InputWindowsMetricsWindowsMetrics4TypedDict,
    ],
)


InputWindowsMetrics = TypeAliasType(
    "InputWindowsMetrics",
    Union[
        InputWindowsMetricsWindowsMetrics1,
        InputWindowsMetricsWindowsMetrics2,
        InputWindowsMetricsWindowsMetrics3,
        InputWindowsMetricsWindowsMetrics4,
    ],
)
