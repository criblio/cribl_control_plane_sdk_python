"""Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT."""

from __future__ import annotations
from .authtype1options import AuthType1Options
from .certificatetype import CertificateType, CertificateTypeTypedDict
from .compressionleveloptions import CompressionLevelOptions
from .format1options import Format1Options
from .parquetdatapageversionoptions import ParquetDataPageVersionOptions
from .parquetversionoptions import ParquetVersionOptions
from .pqcompressoptions import PqCompressOptions
from .pqonbackpressureoptions import PqOnBackpressureOptions
from .tagstype import TagsType, TagsTypeTypedDict
from .typeazurebloboption import TypeAzureBlobOption
from cribl_control_plane import models, utils
from cribl_control_plane.types import BaseModel
from cribl_control_plane.utils import validate_open_enum
from enum import Enum
import pydantic
from pydantic import field_serializer
from pydantic.functional_validators import PlainValidator
from typing import List, Optional, Union
from typing_extensions import Annotated, NotRequired, TypeAliasType, TypedDict


class BlobAccessTier10(str, Enum, metaclass=utils.OpenEnumMeta):
    # Default account access tier
    INFERRED = "Inferred"
    # Hot tier
    HOT = "Hot"
    # Cool tier
    COOL = "Cool"
    # Cold tier
    COLD = "Cold"
    # Archive tier
    ARCHIVE = "Archive"


class OutputAzureBlobAzureBlob10TypedDict(TypedDict):
    type: TypeAzureBlobOption
    container_name: str
    r"""The Azure Blob Storage container name. Name can include only lowercase letters, numbers, and hyphens. For dynamic container names, enter a JavaScript expression within quotes or backticks, to be evaluated at initialization. The expression can evaluate to a constant value and can reference Global Variables, such as `myContainer-${C.env[\"CRIBL_WORKER_ID\"]}`."""
    storage_account_name: str
    r"""The name of your Azure storage account"""
    tenant_id: str
    r"""The service principal's tenant ID"""
    client_id: str
    r"""The service principal's client ID"""
    azure_cloud: str
    r"""The Azure cloud to use. Defaults to Azure Public Cloud."""
    endpoint_suffix: str
    r"""Endpoint suffix for the service URL. Takes precedence over the Azure Cloud setting. Defaults to core.windows.net."""
    certificate: CertificateTypeTypedDict
    auth_type: NotRequired[AuthType1Options]
    id: NotRequired[str]
    r"""Unique ID for this output"""
    pipeline: NotRequired[str]
    r"""Pipeline to process data before sending out to this output"""
    system_fields: NotRequired[List[str]]
    r"""Fields to automatically add to events, such as cribl_pipe. Supports wildcards."""
    environment: NotRequired[str]
    r"""Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere."""
    streamtags: NotRequired[List[str]]
    r"""Tags for filtering and grouping in @{product}"""
    create_container: NotRequired[bool]
    r"""Create the configured container in Azure Blob Storage if it does not already exist"""
    dest_path: NotRequired[str]
    r"""Root directory prepended to path before uploading. Value can be a JavaScript expression enclosed in quotes or backticks, to be evaluated at initialization. The expression can evaluate to a constant value and can reference Global Variables, such as `myBlobPrefix-${C.env[\"CRIBL_WORKER_ID\"]}`."""
    stage_path: NotRequired[str]
    r"""Filesystem location in which to buffer files before compressing and moving to final destination. Use performant and stable storage."""
    add_id_to_stage_path: NotRequired[bool]
    r"""Add the Output ID value to staging location"""
    max_concurrent_file_parts: NotRequired[float]
    r"""Maximum number of parts to upload in parallel per file"""
    remove_empty_dirs: NotRequired[bool]
    r"""Remove empty staging directories after moving files"""
    partition_expr: NotRequired[str]
    r"""JavaScript expression defining how files are partitioned and organized. Default is date-based. If blank, Stream will fall back to the event's __partition field value – if present – otherwise to each location's root directory."""
    format_: NotRequired[Format1Options]
    r"""Format of the output data"""
    base_file_name: NotRequired[str]
    r"""JavaScript expression to define the output filename prefix (can be constant)"""
    file_name_suffix: NotRequired[str]
    r"""JavaScript expression to define the output filename suffix (can be constant).  The `__format` variable refers to the value of the `Data format` field (`json` or `raw`).  The `__compression` field refers to the kind of compression being used (`none` or `gzip`)."""
    max_file_size_mb: NotRequired[float]
    r"""Maximum uncompressed output file size. Files of this size will be closed and moved to final output location."""
    max_file_open_time_sec: NotRequired[float]
    r"""Maximum amount of time to write to a file. Files open for longer than this will be closed and moved to final output location."""
    max_file_idle_time_sec: NotRequired[float]
    r"""Maximum amount of time to keep inactive files open. Files open for longer than this will be closed and moved to final output location."""
    max_open_files: NotRequired[float]
    r"""Maximum number of files to keep open concurrently. When exceeded, @{product} will close the oldest open files and move them to the final output location."""
    header_line: NotRequired[str]
    r"""If set, this line will be written to the beginning of each output file"""
    write_high_water_mark: NotRequired[float]
    r"""Buffer size used to write to a file"""
    on_backpressure: NotRequired[PqOnBackpressureOptions]
    r"""How to handle events when the queue is exerting backpressure (full capacity or low disk). 'Block' is the same behavior as non-PQ blocking. 'Drop new data' throws away incoming data, while leaving the contents of the PQ unchanged."""
    deadletter_enabled: NotRequired[bool]
    r"""If a file fails to move to its final destination after the maximum number of retries, move it to a designated directory to prevent further errors"""
    on_disk_full_backpressure: NotRequired[PqOnBackpressureOptions]
    r"""How to handle events when the queue is exerting backpressure (full capacity or low disk). 'Block' is the same behavior as non-PQ blocking. 'Drop new data' throws away incoming data, while leaving the contents of the PQ unchanged."""
    storage_class: NotRequired[BlobAccessTier10]
    description: NotRequired[str]
    compress: NotRequired[PqCompressOptions]
    r"""Codec to use to compress the persisted data"""
    compression_level: NotRequired[CompressionLevelOptions]
    r"""Compression level to apply before moving files to final destination"""
    automatic_schema: NotRequired[bool]
    r"""Automatically calculate the schema based on the events of each Parquet file generated"""
    parquet_schema: NotRequired[str]
    r"""To add a new schema, navigate to Processing > Knowledge > Parquet Schemas"""
    parquet_version: NotRequired[ParquetVersionOptions]
    r"""Determines which data types are supported and how they are represented"""
    parquet_data_page_version: NotRequired[ParquetDataPageVersionOptions]
    r"""Serialization format of data pages. Note that some reader implementations use Data page V2's attributes to work more efficiently, while others ignore it."""
    parquet_row_group_length: NotRequired[float]
    r"""The number of rows that every group will contain. The final group can contain a smaller number of rows."""
    parquet_page_size: NotRequired[str]
    r"""Target memory size for page segments, such as 1MB or 128MB. Generally, lower values improve reading speed, while higher values improve compression."""
    should_log_invalid_rows: NotRequired[bool]
    r"""Log up to 3 rows that @{product} skips due to data mismatch"""
    key_value_metadata: NotRequired[List[TagsTypeTypedDict]]
    r"""The metadata of files the Destination writes will include the properties you add here as key-value pairs. Useful for tagging. Examples: \"key\":\"OCSF Event Class\", \"value\":\"9001\" """
    enable_statistics: NotRequired[bool]
    r"""Statistics profile an entire file in terms of minimum/maximum values within data, numbers of nulls, etc. You can use Parquet tools to view statistics."""
    enable_write_page_index: NotRequired[bool]
    r"""One page index contains statistics for one data page. Parquet readers use statistics to enable page skipping."""
    enable_page_checksum: NotRequired[bool]
    r"""Parquet tools can use the checksum of a Parquet page to verify data integrity"""
    empty_dir_cleanup_sec: NotRequired[float]
    r"""How frequently, in seconds, to clean up empty directories"""
    deadletter_path: NotRequired[str]
    r"""Storage location for files that fail to reach their final destination after maximum retries are exceeded"""
    max_retry_num: NotRequired[float]
    r"""The maximum number of times a file will attempt to move to its final destination before being dead-lettered"""
    connection_string: NotRequired[str]
    r"""Enter your Azure Storage account connection string. If left blank, Stream will fall back to env.AZURE_STORAGE_CONNECTION_STRING."""
    text_secret: NotRequired[str]
    r"""Select or create a stored text secret"""
    client_text_secret: NotRequired[str]
    r"""Select or create a stored text secret"""


class OutputAzureBlobAzureBlob10(BaseModel):
    type: TypeAzureBlobOption

    container_name: Annotated[str, pydantic.Field(alias="containerName")]
    r"""The Azure Blob Storage container name. Name can include only lowercase letters, numbers, and hyphens. For dynamic container names, enter a JavaScript expression within quotes or backticks, to be evaluated at initialization. The expression can evaluate to a constant value and can reference Global Variables, such as `myContainer-${C.env[\"CRIBL_WORKER_ID\"]}`."""

    storage_account_name: Annotated[str, pydantic.Field(alias="storageAccountName")]
    r"""The name of your Azure storage account"""

    tenant_id: Annotated[str, pydantic.Field(alias="tenantId")]
    r"""The service principal's tenant ID"""

    client_id: Annotated[str, pydantic.Field(alias="clientId")]
    r"""The service principal's client ID"""

    azure_cloud: Annotated[str, pydantic.Field(alias="azureCloud")]
    r"""The Azure cloud to use. Defaults to Azure Public Cloud."""

    endpoint_suffix: Annotated[str, pydantic.Field(alias="endpointSuffix")]
    r"""Endpoint suffix for the service URL. Takes precedence over the Azure Cloud setting. Defaults to core.windows.net."""

    certificate: CertificateType

    auth_type: Annotated[
        Annotated[
            Optional[AuthType1Options], PlainValidator(validate_open_enum(False))
        ],
        pydantic.Field(alias="authType"),
    ] = AuthType1Options.MANUAL

    id: Optional[str] = None
    r"""Unique ID for this output"""

    pipeline: Optional[str] = None
    r"""Pipeline to process data before sending out to this output"""

    system_fields: Annotated[
        Optional[List[str]], pydantic.Field(alias="systemFields")
    ] = None
    r"""Fields to automatically add to events, such as cribl_pipe. Supports wildcards."""

    environment: Optional[str] = None
    r"""Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere."""

    streamtags: Optional[List[str]] = None
    r"""Tags for filtering and grouping in @{product}"""

    create_container: Annotated[
        Optional[bool], pydantic.Field(alias="createContainer")
    ] = False
    r"""Create the configured container in Azure Blob Storage if it does not already exist"""

    dest_path: Annotated[Optional[str], pydantic.Field(alias="destPath")] = None
    r"""Root directory prepended to path before uploading. Value can be a JavaScript expression enclosed in quotes or backticks, to be evaluated at initialization. The expression can evaluate to a constant value and can reference Global Variables, such as `myBlobPrefix-${C.env[\"CRIBL_WORKER_ID\"]}`."""

    stage_path: Annotated[Optional[str], pydantic.Field(alias="stagePath")] = (
        "$CRIBL_HOME/state/outputs/staging"
    )
    r"""Filesystem location in which to buffer files before compressing and moving to final destination. Use performant and stable storage."""

    add_id_to_stage_path: Annotated[
        Optional[bool], pydantic.Field(alias="addIdToStagePath")
    ] = True
    r"""Add the Output ID value to staging location"""

    max_concurrent_file_parts: Annotated[
        Optional[float], pydantic.Field(alias="maxConcurrentFileParts")
    ] = 1
    r"""Maximum number of parts to upload in parallel per file"""

    remove_empty_dirs: Annotated[
        Optional[bool], pydantic.Field(alias="removeEmptyDirs")
    ] = True
    r"""Remove empty staging directories after moving files"""

    partition_expr: Annotated[Optional[str], pydantic.Field(alias="partitionExpr")] = (
        "C.Time.strftime(_time ? _time : Date.now()/1000, '%Y/%m/%d')"
    )
    r"""JavaScript expression defining how files are partitioned and organized. Default is date-based. If blank, Stream will fall back to the event's __partition field value – if present – otherwise to each location's root directory."""

    format_: Annotated[
        Annotated[Optional[Format1Options], PlainValidator(validate_open_enum(False))],
        pydantic.Field(alias="format"),
    ] = Format1Options.JSON
    r"""Format of the output data"""

    base_file_name: Annotated[Optional[str], pydantic.Field(alias="baseFileName")] = (
        "`CriblOut`"
    )
    r"""JavaScript expression to define the output filename prefix (can be constant)"""

    file_name_suffix: Annotated[
        Optional[str], pydantic.Field(alias="fileNameSuffix")
    ] = '`.${C.env["CRIBL_WORKER_ID"]}.${__format}${__compression === "gzip" ? ".gz" : ""}`'
    r"""JavaScript expression to define the output filename suffix (can be constant).  The `__format` variable refers to the value of the `Data format` field (`json` or `raw`).  The `__compression` field refers to the kind of compression being used (`none` or `gzip`)."""

    max_file_size_mb: Annotated[
        Optional[float], pydantic.Field(alias="maxFileSizeMB")
    ] = 32
    r"""Maximum uncompressed output file size. Files of this size will be closed and moved to final output location."""

    max_file_open_time_sec: Annotated[
        Optional[float], pydantic.Field(alias="maxFileOpenTimeSec")
    ] = 300
    r"""Maximum amount of time to write to a file. Files open for longer than this will be closed and moved to final output location."""

    max_file_idle_time_sec: Annotated[
        Optional[float], pydantic.Field(alias="maxFileIdleTimeSec")
    ] = 30
    r"""Maximum amount of time to keep inactive files open. Files open for longer than this will be closed and moved to final output location."""

    max_open_files: Annotated[Optional[float], pydantic.Field(alias="maxOpenFiles")] = (
        100
    )
    r"""Maximum number of files to keep open concurrently. When exceeded, @{product} will close the oldest open files and move them to the final output location."""

    header_line: Annotated[Optional[str], pydantic.Field(alias="headerLine")] = ""
    r"""If set, this line will be written to the beginning of each output file"""

    write_high_water_mark: Annotated[
        Optional[float], pydantic.Field(alias="writeHighWaterMark")
    ] = 64
    r"""Buffer size used to write to a file"""

    on_backpressure: Annotated[
        Annotated[
            Optional[PqOnBackpressureOptions], PlainValidator(validate_open_enum(False))
        ],
        pydantic.Field(alias="onBackpressure"),
    ] = PqOnBackpressureOptions.BLOCK
    r"""How to handle events when the queue is exerting backpressure (full capacity or low disk). 'Block' is the same behavior as non-PQ blocking. 'Drop new data' throws away incoming data, while leaving the contents of the PQ unchanged."""

    deadletter_enabled: Annotated[
        Optional[bool], pydantic.Field(alias="deadletterEnabled")
    ] = False
    r"""If a file fails to move to its final destination after the maximum number of retries, move it to a designated directory to prevent further errors"""

    on_disk_full_backpressure: Annotated[
        Annotated[
            Optional[PqOnBackpressureOptions], PlainValidator(validate_open_enum(False))
        ],
        pydantic.Field(alias="onDiskFullBackpressure"),
    ] = PqOnBackpressureOptions.BLOCK
    r"""How to handle events when the queue is exerting backpressure (full capacity or low disk). 'Block' is the same behavior as non-PQ blocking. 'Drop new data' throws away incoming data, while leaving the contents of the PQ unchanged."""

    storage_class: Annotated[
        Annotated[
            Optional[BlobAccessTier10], PlainValidator(validate_open_enum(False))
        ],
        pydantic.Field(alias="storageClass"),
    ] = BlobAccessTier10.INFERRED

    description: Optional[str] = None

    compress: Annotated[
        Optional[PqCompressOptions], PlainValidator(validate_open_enum(False))
    ] = PqCompressOptions.NONE
    r"""Codec to use to compress the persisted data"""

    compression_level: Annotated[
        Annotated[
            Optional[CompressionLevelOptions], PlainValidator(validate_open_enum(False))
        ],
        pydantic.Field(alias="compressionLevel"),
    ] = CompressionLevelOptions.BEST_SPEED
    r"""Compression level to apply before moving files to final destination"""

    automatic_schema: Annotated[
        Optional[bool], pydantic.Field(alias="automaticSchema")
    ] = False
    r"""Automatically calculate the schema based on the events of each Parquet file generated"""

    parquet_schema: Annotated[Optional[str], pydantic.Field(alias="parquetSchema")] = (
        None
    )
    r"""To add a new schema, navigate to Processing > Knowledge > Parquet Schemas"""

    parquet_version: Annotated[
        Annotated[
            Optional[ParquetVersionOptions], PlainValidator(validate_open_enum(False))
        ],
        pydantic.Field(alias="parquetVersion"),
    ] = ParquetVersionOptions.PARQUET_2_6
    r"""Determines which data types are supported and how they are represented"""

    parquet_data_page_version: Annotated[
        Annotated[
            Optional[ParquetDataPageVersionOptions],
            PlainValidator(validate_open_enum(False)),
        ],
        pydantic.Field(alias="parquetDataPageVersion"),
    ] = ParquetDataPageVersionOptions.DATA_PAGE_V2
    r"""Serialization format of data pages. Note that some reader implementations use Data page V2's attributes to work more efficiently, while others ignore it."""

    parquet_row_group_length: Annotated[
        Optional[float], pydantic.Field(alias="parquetRowGroupLength")
    ] = 10000
    r"""The number of rows that every group will contain. The final group can contain a smaller number of rows."""

    parquet_page_size: Annotated[
        Optional[str], pydantic.Field(alias="parquetPageSize")
    ] = "1MB"
    r"""Target memory size for page segments, such as 1MB or 128MB. Generally, lower values improve reading speed, while higher values improve compression."""

    should_log_invalid_rows: Annotated[
        Optional[bool], pydantic.Field(alias="shouldLogInvalidRows")
    ] = None
    r"""Log up to 3 rows that @{product} skips due to data mismatch"""

    key_value_metadata: Annotated[
        Optional[List[TagsType]], pydantic.Field(alias="keyValueMetadata")
    ] = None
    r"""The metadata of files the Destination writes will include the properties you add here as key-value pairs. Useful for tagging. Examples: \"key\":\"OCSF Event Class\", \"value\":\"9001\" """

    enable_statistics: Annotated[
        Optional[bool], pydantic.Field(alias="enableStatistics")
    ] = True
    r"""Statistics profile an entire file in terms of minimum/maximum values within data, numbers of nulls, etc. You can use Parquet tools to view statistics."""

    enable_write_page_index: Annotated[
        Optional[bool], pydantic.Field(alias="enableWritePageIndex")
    ] = True
    r"""One page index contains statistics for one data page. Parquet readers use statistics to enable page skipping."""

    enable_page_checksum: Annotated[
        Optional[bool], pydantic.Field(alias="enablePageChecksum")
    ] = False
    r"""Parquet tools can use the checksum of a Parquet page to verify data integrity"""

    empty_dir_cleanup_sec: Annotated[
        Optional[float], pydantic.Field(alias="emptyDirCleanupSec")
    ] = 300
    r"""How frequently, in seconds, to clean up empty directories"""

    deadletter_path: Annotated[
        Optional[str], pydantic.Field(alias="deadletterPath")
    ] = "$CRIBL_HOME/state/outputs/dead-letter"
    r"""Storage location for files that fail to reach their final destination after maximum retries are exceeded"""

    max_retry_num: Annotated[Optional[float], pydantic.Field(alias="maxRetryNum")] = 20
    r"""The maximum number of times a file will attempt to move to its final destination before being dead-lettered"""

    connection_string: Annotated[
        Optional[str], pydantic.Field(alias="connectionString")
    ] = None
    r"""Enter your Azure Storage account connection string. If left blank, Stream will fall back to env.AZURE_STORAGE_CONNECTION_STRING."""

    text_secret: Annotated[Optional[str], pydantic.Field(alias="textSecret")] = None
    r"""Select or create a stored text secret"""

    client_text_secret: Annotated[
        Optional[str], pydantic.Field(alias="clientTextSecret")
    ] = None
    r"""Select or create a stored text secret"""

    @field_serializer("auth_type")
    def serialize_auth_type(self, value):
        if isinstance(value, str):
            try:
                return models.AuthType1Options(value)
            except ValueError:
                return value
        return value

    @field_serializer("format_")
    def serialize_format_(self, value):
        if isinstance(value, str):
            try:
                return models.Format1Options(value)
            except ValueError:
                return value
        return value

    @field_serializer("on_backpressure")
    def serialize_on_backpressure(self, value):
        if isinstance(value, str):
            try:
                return models.PqOnBackpressureOptions(value)
            except ValueError:
                return value
        return value

    @field_serializer("on_disk_full_backpressure")
    def serialize_on_disk_full_backpressure(self, value):
        if isinstance(value, str):
            try:
                return models.PqOnBackpressureOptions(value)
            except ValueError:
                return value
        return value

    @field_serializer("storage_class")
    def serialize_storage_class(self, value):
        if isinstance(value, str):
            try:
                return models.BlobAccessTier10(value)
            except ValueError:
                return value
        return value

    @field_serializer("compress")
    def serialize_compress(self, value):
        if isinstance(value, str):
            try:
                return models.PqCompressOptions(value)
            except ValueError:
                return value
        return value

    @field_serializer("compression_level")
    def serialize_compression_level(self, value):
        if isinstance(value, str):
            try:
                return models.CompressionLevelOptions(value)
            except ValueError:
                return value
        return value

    @field_serializer("parquet_version")
    def serialize_parquet_version(self, value):
        if isinstance(value, str):
            try:
                return models.ParquetVersionOptions(value)
            except ValueError:
                return value
        return value

    @field_serializer("parquet_data_page_version")
    def serialize_parquet_data_page_version(self, value):
        if isinstance(value, str):
            try:
                return models.ParquetDataPageVersionOptions(value)
            except ValueError:
                return value
        return value


class BlobAccessTier9(str, Enum, metaclass=utils.OpenEnumMeta):
    # Default account access tier
    INFERRED = "Inferred"
    # Hot tier
    HOT = "Hot"
    # Cool tier
    COOL = "Cool"
    # Cold tier
    COLD = "Cold"
    # Archive tier
    ARCHIVE = "Archive"


class OutputAzureBlobAzureBlob9TypedDict(TypedDict):
    type: TypeAzureBlobOption
    container_name: str
    r"""The Azure Blob Storage container name. Name can include only lowercase letters, numbers, and hyphens. For dynamic container names, enter a JavaScript expression within quotes or backticks, to be evaluated at initialization. The expression can evaluate to a constant value and can reference Global Variables, such as `myContainer-${C.env[\"CRIBL_WORKER_ID\"]}`."""
    storage_account_name: str
    r"""The name of your Azure storage account"""
    tenant_id: str
    r"""The service principal's tenant ID"""
    client_id: str
    r"""The service principal's client ID"""
    azure_cloud: str
    r"""The Azure cloud to use. Defaults to Azure Public Cloud."""
    endpoint_suffix: str
    r"""Endpoint suffix for the service URL. Takes precedence over the Azure Cloud setting. Defaults to core.windows.net."""
    client_text_secret: str
    r"""Select or create a stored text secret"""
    auth_type: NotRequired[AuthType1Options]
    id: NotRequired[str]
    r"""Unique ID for this output"""
    pipeline: NotRequired[str]
    r"""Pipeline to process data before sending out to this output"""
    system_fields: NotRequired[List[str]]
    r"""Fields to automatically add to events, such as cribl_pipe. Supports wildcards."""
    environment: NotRequired[str]
    r"""Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere."""
    streamtags: NotRequired[List[str]]
    r"""Tags for filtering and grouping in @{product}"""
    create_container: NotRequired[bool]
    r"""Create the configured container in Azure Blob Storage if it does not already exist"""
    dest_path: NotRequired[str]
    r"""Root directory prepended to path before uploading. Value can be a JavaScript expression enclosed in quotes or backticks, to be evaluated at initialization. The expression can evaluate to a constant value and can reference Global Variables, such as `myBlobPrefix-${C.env[\"CRIBL_WORKER_ID\"]}`."""
    stage_path: NotRequired[str]
    r"""Filesystem location in which to buffer files before compressing and moving to final destination. Use performant and stable storage."""
    add_id_to_stage_path: NotRequired[bool]
    r"""Add the Output ID value to staging location"""
    max_concurrent_file_parts: NotRequired[float]
    r"""Maximum number of parts to upload in parallel per file"""
    remove_empty_dirs: NotRequired[bool]
    r"""Remove empty staging directories after moving files"""
    partition_expr: NotRequired[str]
    r"""JavaScript expression defining how files are partitioned and organized. Default is date-based. If blank, Stream will fall back to the event's __partition field value – if present – otherwise to each location's root directory."""
    format_: NotRequired[Format1Options]
    r"""Format of the output data"""
    base_file_name: NotRequired[str]
    r"""JavaScript expression to define the output filename prefix (can be constant)"""
    file_name_suffix: NotRequired[str]
    r"""JavaScript expression to define the output filename suffix (can be constant).  The `__format` variable refers to the value of the `Data format` field (`json` or `raw`).  The `__compression` field refers to the kind of compression being used (`none` or `gzip`)."""
    max_file_size_mb: NotRequired[float]
    r"""Maximum uncompressed output file size. Files of this size will be closed and moved to final output location."""
    max_file_open_time_sec: NotRequired[float]
    r"""Maximum amount of time to write to a file. Files open for longer than this will be closed and moved to final output location."""
    max_file_idle_time_sec: NotRequired[float]
    r"""Maximum amount of time to keep inactive files open. Files open for longer than this will be closed and moved to final output location."""
    max_open_files: NotRequired[float]
    r"""Maximum number of files to keep open concurrently. When exceeded, @{product} will close the oldest open files and move them to the final output location."""
    header_line: NotRequired[str]
    r"""If set, this line will be written to the beginning of each output file"""
    write_high_water_mark: NotRequired[float]
    r"""Buffer size used to write to a file"""
    on_backpressure: NotRequired[PqOnBackpressureOptions]
    r"""How to handle events when the queue is exerting backpressure (full capacity or low disk). 'Block' is the same behavior as non-PQ blocking. 'Drop new data' throws away incoming data, while leaving the contents of the PQ unchanged."""
    deadletter_enabled: NotRequired[bool]
    r"""If a file fails to move to its final destination after the maximum number of retries, move it to a designated directory to prevent further errors"""
    on_disk_full_backpressure: NotRequired[PqOnBackpressureOptions]
    r"""How to handle events when the queue is exerting backpressure (full capacity or low disk). 'Block' is the same behavior as non-PQ blocking. 'Drop new data' throws away incoming data, while leaving the contents of the PQ unchanged."""
    storage_class: NotRequired[BlobAccessTier9]
    description: NotRequired[str]
    compress: NotRequired[PqCompressOptions]
    r"""Codec to use to compress the persisted data"""
    compression_level: NotRequired[CompressionLevelOptions]
    r"""Compression level to apply before moving files to final destination"""
    automatic_schema: NotRequired[bool]
    r"""Automatically calculate the schema based on the events of each Parquet file generated"""
    parquet_schema: NotRequired[str]
    r"""To add a new schema, navigate to Processing > Knowledge > Parquet Schemas"""
    parquet_version: NotRequired[ParquetVersionOptions]
    r"""Determines which data types are supported and how they are represented"""
    parquet_data_page_version: NotRequired[ParquetDataPageVersionOptions]
    r"""Serialization format of data pages. Note that some reader implementations use Data page V2's attributes to work more efficiently, while others ignore it."""
    parquet_row_group_length: NotRequired[float]
    r"""The number of rows that every group will contain. The final group can contain a smaller number of rows."""
    parquet_page_size: NotRequired[str]
    r"""Target memory size for page segments, such as 1MB or 128MB. Generally, lower values improve reading speed, while higher values improve compression."""
    should_log_invalid_rows: NotRequired[bool]
    r"""Log up to 3 rows that @{product} skips due to data mismatch"""
    key_value_metadata: NotRequired[List[TagsTypeTypedDict]]
    r"""The metadata of files the Destination writes will include the properties you add here as key-value pairs. Useful for tagging. Examples: \"key\":\"OCSF Event Class\", \"value\":\"9001\" """
    enable_statistics: NotRequired[bool]
    r"""Statistics profile an entire file in terms of minimum/maximum values within data, numbers of nulls, etc. You can use Parquet tools to view statistics."""
    enable_write_page_index: NotRequired[bool]
    r"""One page index contains statistics for one data page. Parquet readers use statistics to enable page skipping."""
    enable_page_checksum: NotRequired[bool]
    r"""Parquet tools can use the checksum of a Parquet page to verify data integrity"""
    empty_dir_cleanup_sec: NotRequired[float]
    r"""How frequently, in seconds, to clean up empty directories"""
    deadletter_path: NotRequired[str]
    r"""Storage location for files that fail to reach their final destination after maximum retries are exceeded"""
    max_retry_num: NotRequired[float]
    r"""The maximum number of times a file will attempt to move to its final destination before being dead-lettered"""
    connection_string: NotRequired[str]
    r"""Enter your Azure Storage account connection string. If left blank, Stream will fall back to env.AZURE_STORAGE_CONNECTION_STRING."""
    text_secret: NotRequired[str]
    r"""Select or create a stored text secret"""
    certificate: NotRequired[CertificateTypeTypedDict]


class OutputAzureBlobAzureBlob9(BaseModel):
    type: TypeAzureBlobOption

    container_name: Annotated[str, pydantic.Field(alias="containerName")]
    r"""The Azure Blob Storage container name. Name can include only lowercase letters, numbers, and hyphens. For dynamic container names, enter a JavaScript expression within quotes or backticks, to be evaluated at initialization. The expression can evaluate to a constant value and can reference Global Variables, such as `myContainer-${C.env[\"CRIBL_WORKER_ID\"]}`."""

    storage_account_name: Annotated[str, pydantic.Field(alias="storageAccountName")]
    r"""The name of your Azure storage account"""

    tenant_id: Annotated[str, pydantic.Field(alias="tenantId")]
    r"""The service principal's tenant ID"""

    client_id: Annotated[str, pydantic.Field(alias="clientId")]
    r"""The service principal's client ID"""

    azure_cloud: Annotated[str, pydantic.Field(alias="azureCloud")]
    r"""The Azure cloud to use. Defaults to Azure Public Cloud."""

    endpoint_suffix: Annotated[str, pydantic.Field(alias="endpointSuffix")]
    r"""Endpoint suffix for the service URL. Takes precedence over the Azure Cloud setting. Defaults to core.windows.net."""

    client_text_secret: Annotated[str, pydantic.Field(alias="clientTextSecret")]
    r"""Select or create a stored text secret"""

    auth_type: Annotated[
        Annotated[
            Optional[AuthType1Options], PlainValidator(validate_open_enum(False))
        ],
        pydantic.Field(alias="authType"),
    ] = AuthType1Options.MANUAL

    id: Optional[str] = None
    r"""Unique ID for this output"""

    pipeline: Optional[str] = None
    r"""Pipeline to process data before sending out to this output"""

    system_fields: Annotated[
        Optional[List[str]], pydantic.Field(alias="systemFields")
    ] = None
    r"""Fields to automatically add to events, such as cribl_pipe. Supports wildcards."""

    environment: Optional[str] = None
    r"""Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere."""

    streamtags: Optional[List[str]] = None
    r"""Tags for filtering and grouping in @{product}"""

    create_container: Annotated[
        Optional[bool], pydantic.Field(alias="createContainer")
    ] = False
    r"""Create the configured container in Azure Blob Storage if it does not already exist"""

    dest_path: Annotated[Optional[str], pydantic.Field(alias="destPath")] = None
    r"""Root directory prepended to path before uploading. Value can be a JavaScript expression enclosed in quotes or backticks, to be evaluated at initialization. The expression can evaluate to a constant value and can reference Global Variables, such as `myBlobPrefix-${C.env[\"CRIBL_WORKER_ID\"]}`."""

    stage_path: Annotated[Optional[str], pydantic.Field(alias="stagePath")] = (
        "$CRIBL_HOME/state/outputs/staging"
    )
    r"""Filesystem location in which to buffer files before compressing and moving to final destination. Use performant and stable storage."""

    add_id_to_stage_path: Annotated[
        Optional[bool], pydantic.Field(alias="addIdToStagePath")
    ] = True
    r"""Add the Output ID value to staging location"""

    max_concurrent_file_parts: Annotated[
        Optional[float], pydantic.Field(alias="maxConcurrentFileParts")
    ] = 1
    r"""Maximum number of parts to upload in parallel per file"""

    remove_empty_dirs: Annotated[
        Optional[bool], pydantic.Field(alias="removeEmptyDirs")
    ] = True
    r"""Remove empty staging directories after moving files"""

    partition_expr: Annotated[Optional[str], pydantic.Field(alias="partitionExpr")] = (
        "C.Time.strftime(_time ? _time : Date.now()/1000, '%Y/%m/%d')"
    )
    r"""JavaScript expression defining how files are partitioned and organized. Default is date-based. If blank, Stream will fall back to the event's __partition field value – if present – otherwise to each location's root directory."""

    format_: Annotated[
        Annotated[Optional[Format1Options], PlainValidator(validate_open_enum(False))],
        pydantic.Field(alias="format"),
    ] = Format1Options.JSON
    r"""Format of the output data"""

    base_file_name: Annotated[Optional[str], pydantic.Field(alias="baseFileName")] = (
        "`CriblOut`"
    )
    r"""JavaScript expression to define the output filename prefix (can be constant)"""

    file_name_suffix: Annotated[
        Optional[str], pydantic.Field(alias="fileNameSuffix")
    ] = '`.${C.env["CRIBL_WORKER_ID"]}.${__format}${__compression === "gzip" ? ".gz" : ""}`'
    r"""JavaScript expression to define the output filename suffix (can be constant).  The `__format` variable refers to the value of the `Data format` field (`json` or `raw`).  The `__compression` field refers to the kind of compression being used (`none` or `gzip`)."""

    max_file_size_mb: Annotated[
        Optional[float], pydantic.Field(alias="maxFileSizeMB")
    ] = 32
    r"""Maximum uncompressed output file size. Files of this size will be closed and moved to final output location."""

    max_file_open_time_sec: Annotated[
        Optional[float], pydantic.Field(alias="maxFileOpenTimeSec")
    ] = 300
    r"""Maximum amount of time to write to a file. Files open for longer than this will be closed and moved to final output location."""

    max_file_idle_time_sec: Annotated[
        Optional[float], pydantic.Field(alias="maxFileIdleTimeSec")
    ] = 30
    r"""Maximum amount of time to keep inactive files open. Files open for longer than this will be closed and moved to final output location."""

    max_open_files: Annotated[Optional[float], pydantic.Field(alias="maxOpenFiles")] = (
        100
    )
    r"""Maximum number of files to keep open concurrently. When exceeded, @{product} will close the oldest open files and move them to the final output location."""

    header_line: Annotated[Optional[str], pydantic.Field(alias="headerLine")] = ""
    r"""If set, this line will be written to the beginning of each output file"""

    write_high_water_mark: Annotated[
        Optional[float], pydantic.Field(alias="writeHighWaterMark")
    ] = 64
    r"""Buffer size used to write to a file"""

    on_backpressure: Annotated[
        Annotated[
            Optional[PqOnBackpressureOptions], PlainValidator(validate_open_enum(False))
        ],
        pydantic.Field(alias="onBackpressure"),
    ] = PqOnBackpressureOptions.BLOCK
    r"""How to handle events when the queue is exerting backpressure (full capacity or low disk). 'Block' is the same behavior as non-PQ blocking. 'Drop new data' throws away incoming data, while leaving the contents of the PQ unchanged."""

    deadletter_enabled: Annotated[
        Optional[bool], pydantic.Field(alias="deadletterEnabled")
    ] = False
    r"""If a file fails to move to its final destination after the maximum number of retries, move it to a designated directory to prevent further errors"""

    on_disk_full_backpressure: Annotated[
        Annotated[
            Optional[PqOnBackpressureOptions], PlainValidator(validate_open_enum(False))
        ],
        pydantic.Field(alias="onDiskFullBackpressure"),
    ] = PqOnBackpressureOptions.BLOCK
    r"""How to handle events when the queue is exerting backpressure (full capacity or low disk). 'Block' is the same behavior as non-PQ blocking. 'Drop new data' throws away incoming data, while leaving the contents of the PQ unchanged."""

    storage_class: Annotated[
        Annotated[Optional[BlobAccessTier9], PlainValidator(validate_open_enum(False))],
        pydantic.Field(alias="storageClass"),
    ] = BlobAccessTier9.INFERRED

    description: Optional[str] = None

    compress: Annotated[
        Optional[PqCompressOptions], PlainValidator(validate_open_enum(False))
    ] = PqCompressOptions.NONE
    r"""Codec to use to compress the persisted data"""

    compression_level: Annotated[
        Annotated[
            Optional[CompressionLevelOptions], PlainValidator(validate_open_enum(False))
        ],
        pydantic.Field(alias="compressionLevel"),
    ] = CompressionLevelOptions.BEST_SPEED
    r"""Compression level to apply before moving files to final destination"""

    automatic_schema: Annotated[
        Optional[bool], pydantic.Field(alias="automaticSchema")
    ] = False
    r"""Automatically calculate the schema based on the events of each Parquet file generated"""

    parquet_schema: Annotated[Optional[str], pydantic.Field(alias="parquetSchema")] = (
        None
    )
    r"""To add a new schema, navigate to Processing > Knowledge > Parquet Schemas"""

    parquet_version: Annotated[
        Annotated[
            Optional[ParquetVersionOptions], PlainValidator(validate_open_enum(False))
        ],
        pydantic.Field(alias="parquetVersion"),
    ] = ParquetVersionOptions.PARQUET_2_6
    r"""Determines which data types are supported and how they are represented"""

    parquet_data_page_version: Annotated[
        Annotated[
            Optional[ParquetDataPageVersionOptions],
            PlainValidator(validate_open_enum(False)),
        ],
        pydantic.Field(alias="parquetDataPageVersion"),
    ] = ParquetDataPageVersionOptions.DATA_PAGE_V2
    r"""Serialization format of data pages. Note that some reader implementations use Data page V2's attributes to work more efficiently, while others ignore it."""

    parquet_row_group_length: Annotated[
        Optional[float], pydantic.Field(alias="parquetRowGroupLength")
    ] = 10000
    r"""The number of rows that every group will contain. The final group can contain a smaller number of rows."""

    parquet_page_size: Annotated[
        Optional[str], pydantic.Field(alias="parquetPageSize")
    ] = "1MB"
    r"""Target memory size for page segments, such as 1MB or 128MB. Generally, lower values improve reading speed, while higher values improve compression."""

    should_log_invalid_rows: Annotated[
        Optional[bool], pydantic.Field(alias="shouldLogInvalidRows")
    ] = None
    r"""Log up to 3 rows that @{product} skips due to data mismatch"""

    key_value_metadata: Annotated[
        Optional[List[TagsType]], pydantic.Field(alias="keyValueMetadata")
    ] = None
    r"""The metadata of files the Destination writes will include the properties you add here as key-value pairs. Useful for tagging. Examples: \"key\":\"OCSF Event Class\", \"value\":\"9001\" """

    enable_statistics: Annotated[
        Optional[bool], pydantic.Field(alias="enableStatistics")
    ] = True
    r"""Statistics profile an entire file in terms of minimum/maximum values within data, numbers of nulls, etc. You can use Parquet tools to view statistics."""

    enable_write_page_index: Annotated[
        Optional[bool], pydantic.Field(alias="enableWritePageIndex")
    ] = True
    r"""One page index contains statistics for one data page. Parquet readers use statistics to enable page skipping."""

    enable_page_checksum: Annotated[
        Optional[bool], pydantic.Field(alias="enablePageChecksum")
    ] = False
    r"""Parquet tools can use the checksum of a Parquet page to verify data integrity"""

    empty_dir_cleanup_sec: Annotated[
        Optional[float], pydantic.Field(alias="emptyDirCleanupSec")
    ] = 300
    r"""How frequently, in seconds, to clean up empty directories"""

    deadletter_path: Annotated[
        Optional[str], pydantic.Field(alias="deadletterPath")
    ] = "$CRIBL_HOME/state/outputs/dead-letter"
    r"""Storage location for files that fail to reach their final destination after maximum retries are exceeded"""

    max_retry_num: Annotated[Optional[float], pydantic.Field(alias="maxRetryNum")] = 20
    r"""The maximum number of times a file will attempt to move to its final destination before being dead-lettered"""

    connection_string: Annotated[
        Optional[str], pydantic.Field(alias="connectionString")
    ] = None
    r"""Enter your Azure Storage account connection string. If left blank, Stream will fall back to env.AZURE_STORAGE_CONNECTION_STRING."""

    text_secret: Annotated[Optional[str], pydantic.Field(alias="textSecret")] = None
    r"""Select or create a stored text secret"""

    certificate: Optional[CertificateType] = None

    @field_serializer("auth_type")
    def serialize_auth_type(self, value):
        if isinstance(value, str):
            try:
                return models.AuthType1Options(value)
            except ValueError:
                return value
        return value

    @field_serializer("format_")
    def serialize_format_(self, value):
        if isinstance(value, str):
            try:
                return models.Format1Options(value)
            except ValueError:
                return value
        return value

    @field_serializer("on_backpressure")
    def serialize_on_backpressure(self, value):
        if isinstance(value, str):
            try:
                return models.PqOnBackpressureOptions(value)
            except ValueError:
                return value
        return value

    @field_serializer("on_disk_full_backpressure")
    def serialize_on_disk_full_backpressure(self, value):
        if isinstance(value, str):
            try:
                return models.PqOnBackpressureOptions(value)
            except ValueError:
                return value
        return value

    @field_serializer("storage_class")
    def serialize_storage_class(self, value):
        if isinstance(value, str):
            try:
                return models.BlobAccessTier9(value)
            except ValueError:
                return value
        return value

    @field_serializer("compress")
    def serialize_compress(self, value):
        if isinstance(value, str):
            try:
                return models.PqCompressOptions(value)
            except ValueError:
                return value
        return value

    @field_serializer("compression_level")
    def serialize_compression_level(self, value):
        if isinstance(value, str):
            try:
                return models.CompressionLevelOptions(value)
            except ValueError:
                return value
        return value

    @field_serializer("parquet_version")
    def serialize_parquet_version(self, value):
        if isinstance(value, str):
            try:
                return models.ParquetVersionOptions(value)
            except ValueError:
                return value
        return value

    @field_serializer("parquet_data_page_version")
    def serialize_parquet_data_page_version(self, value):
        if isinstance(value, str):
            try:
                return models.ParquetDataPageVersionOptions(value)
            except ValueError:
                return value
        return value


class BlobAccessTier8(str, Enum, metaclass=utils.OpenEnumMeta):
    # Default account access tier
    INFERRED = "Inferred"
    # Hot tier
    HOT = "Hot"
    # Cool tier
    COOL = "Cool"
    # Cold tier
    COLD = "Cold"
    # Archive tier
    ARCHIVE = "Archive"


class OutputAzureBlobAzureBlob8TypedDict(TypedDict):
    type: TypeAzureBlobOption
    container_name: str
    r"""The Azure Blob Storage container name. Name can include only lowercase letters, numbers, and hyphens. For dynamic container names, enter a JavaScript expression within quotes or backticks, to be evaluated at initialization. The expression can evaluate to a constant value and can reference Global Variables, such as `myContainer-${C.env[\"CRIBL_WORKER_ID\"]}`."""
    text_secret: str
    r"""Select or create a stored text secret"""
    auth_type: NotRequired[AuthType1Options]
    id: NotRequired[str]
    r"""Unique ID for this output"""
    pipeline: NotRequired[str]
    r"""Pipeline to process data before sending out to this output"""
    system_fields: NotRequired[List[str]]
    r"""Fields to automatically add to events, such as cribl_pipe. Supports wildcards."""
    environment: NotRequired[str]
    r"""Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere."""
    streamtags: NotRequired[List[str]]
    r"""Tags for filtering and grouping in @{product}"""
    create_container: NotRequired[bool]
    r"""Create the configured container in Azure Blob Storage if it does not already exist"""
    dest_path: NotRequired[str]
    r"""Root directory prepended to path before uploading. Value can be a JavaScript expression enclosed in quotes or backticks, to be evaluated at initialization. The expression can evaluate to a constant value and can reference Global Variables, such as `myBlobPrefix-${C.env[\"CRIBL_WORKER_ID\"]}`."""
    stage_path: NotRequired[str]
    r"""Filesystem location in which to buffer files before compressing and moving to final destination. Use performant and stable storage."""
    add_id_to_stage_path: NotRequired[bool]
    r"""Add the Output ID value to staging location"""
    max_concurrent_file_parts: NotRequired[float]
    r"""Maximum number of parts to upload in parallel per file"""
    remove_empty_dirs: NotRequired[bool]
    r"""Remove empty staging directories after moving files"""
    partition_expr: NotRequired[str]
    r"""JavaScript expression defining how files are partitioned and organized. Default is date-based. If blank, Stream will fall back to the event's __partition field value – if present – otherwise to each location's root directory."""
    format_: NotRequired[Format1Options]
    r"""Format of the output data"""
    base_file_name: NotRequired[str]
    r"""JavaScript expression to define the output filename prefix (can be constant)"""
    file_name_suffix: NotRequired[str]
    r"""JavaScript expression to define the output filename suffix (can be constant).  The `__format` variable refers to the value of the `Data format` field (`json` or `raw`).  The `__compression` field refers to the kind of compression being used (`none` or `gzip`)."""
    max_file_size_mb: NotRequired[float]
    r"""Maximum uncompressed output file size. Files of this size will be closed and moved to final output location."""
    max_file_open_time_sec: NotRequired[float]
    r"""Maximum amount of time to write to a file. Files open for longer than this will be closed and moved to final output location."""
    max_file_idle_time_sec: NotRequired[float]
    r"""Maximum amount of time to keep inactive files open. Files open for longer than this will be closed and moved to final output location."""
    max_open_files: NotRequired[float]
    r"""Maximum number of files to keep open concurrently. When exceeded, @{product} will close the oldest open files and move them to the final output location."""
    header_line: NotRequired[str]
    r"""If set, this line will be written to the beginning of each output file"""
    write_high_water_mark: NotRequired[float]
    r"""Buffer size used to write to a file"""
    on_backpressure: NotRequired[PqOnBackpressureOptions]
    r"""How to handle events when the queue is exerting backpressure (full capacity or low disk). 'Block' is the same behavior as non-PQ blocking. 'Drop new data' throws away incoming data, while leaving the contents of the PQ unchanged."""
    deadletter_enabled: NotRequired[bool]
    r"""If a file fails to move to its final destination after the maximum number of retries, move it to a designated directory to prevent further errors"""
    on_disk_full_backpressure: NotRequired[PqOnBackpressureOptions]
    r"""How to handle events when the queue is exerting backpressure (full capacity or low disk). 'Block' is the same behavior as non-PQ blocking. 'Drop new data' throws away incoming data, while leaving the contents of the PQ unchanged."""
    storage_class: NotRequired[BlobAccessTier8]
    description: NotRequired[str]
    compress: NotRequired[PqCompressOptions]
    r"""Codec to use to compress the persisted data"""
    compression_level: NotRequired[CompressionLevelOptions]
    r"""Compression level to apply before moving files to final destination"""
    automatic_schema: NotRequired[bool]
    r"""Automatically calculate the schema based on the events of each Parquet file generated"""
    parquet_schema: NotRequired[str]
    r"""To add a new schema, navigate to Processing > Knowledge > Parquet Schemas"""
    parquet_version: NotRequired[ParquetVersionOptions]
    r"""Determines which data types are supported and how they are represented"""
    parquet_data_page_version: NotRequired[ParquetDataPageVersionOptions]
    r"""Serialization format of data pages. Note that some reader implementations use Data page V2's attributes to work more efficiently, while others ignore it."""
    parquet_row_group_length: NotRequired[float]
    r"""The number of rows that every group will contain. The final group can contain a smaller number of rows."""
    parquet_page_size: NotRequired[str]
    r"""Target memory size for page segments, such as 1MB or 128MB. Generally, lower values improve reading speed, while higher values improve compression."""
    should_log_invalid_rows: NotRequired[bool]
    r"""Log up to 3 rows that @{product} skips due to data mismatch"""
    key_value_metadata: NotRequired[List[TagsTypeTypedDict]]
    r"""The metadata of files the Destination writes will include the properties you add here as key-value pairs. Useful for tagging. Examples: \"key\":\"OCSF Event Class\", \"value\":\"9001\" """
    enable_statistics: NotRequired[bool]
    r"""Statistics profile an entire file in terms of minimum/maximum values within data, numbers of nulls, etc. You can use Parquet tools to view statistics."""
    enable_write_page_index: NotRequired[bool]
    r"""One page index contains statistics for one data page. Parquet readers use statistics to enable page skipping."""
    enable_page_checksum: NotRequired[bool]
    r"""Parquet tools can use the checksum of a Parquet page to verify data integrity"""
    empty_dir_cleanup_sec: NotRequired[float]
    r"""How frequently, in seconds, to clean up empty directories"""
    deadletter_path: NotRequired[str]
    r"""Storage location for files that fail to reach their final destination after maximum retries are exceeded"""
    max_retry_num: NotRequired[float]
    r"""The maximum number of times a file will attempt to move to its final destination before being dead-lettered"""
    connection_string: NotRequired[str]
    r"""Enter your Azure Storage account connection string. If left blank, Stream will fall back to env.AZURE_STORAGE_CONNECTION_STRING."""
    storage_account_name: NotRequired[str]
    r"""The name of your Azure storage account"""
    tenant_id: NotRequired[str]
    r"""The service principal's tenant ID"""
    client_id: NotRequired[str]
    r"""The service principal's client ID"""
    azure_cloud: NotRequired[str]
    r"""The Azure cloud to use. Defaults to Azure Public Cloud."""
    endpoint_suffix: NotRequired[str]
    r"""Endpoint suffix for the service URL. Takes precedence over the Azure Cloud setting. Defaults to core.windows.net."""
    client_text_secret: NotRequired[str]
    r"""Select or create a stored text secret"""
    certificate: NotRequired[CertificateTypeTypedDict]


class OutputAzureBlobAzureBlob8(BaseModel):
    type: TypeAzureBlobOption

    container_name: Annotated[str, pydantic.Field(alias="containerName")]
    r"""The Azure Blob Storage container name. Name can include only lowercase letters, numbers, and hyphens. For dynamic container names, enter a JavaScript expression within quotes or backticks, to be evaluated at initialization. The expression can evaluate to a constant value and can reference Global Variables, such as `myContainer-${C.env[\"CRIBL_WORKER_ID\"]}`."""

    text_secret: Annotated[str, pydantic.Field(alias="textSecret")]
    r"""Select or create a stored text secret"""

    auth_type: Annotated[
        Annotated[
            Optional[AuthType1Options], PlainValidator(validate_open_enum(False))
        ],
        pydantic.Field(alias="authType"),
    ] = AuthType1Options.MANUAL

    id: Optional[str] = None
    r"""Unique ID for this output"""

    pipeline: Optional[str] = None
    r"""Pipeline to process data before sending out to this output"""

    system_fields: Annotated[
        Optional[List[str]], pydantic.Field(alias="systemFields")
    ] = None
    r"""Fields to automatically add to events, such as cribl_pipe. Supports wildcards."""

    environment: Optional[str] = None
    r"""Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere."""

    streamtags: Optional[List[str]] = None
    r"""Tags for filtering and grouping in @{product}"""

    create_container: Annotated[
        Optional[bool], pydantic.Field(alias="createContainer")
    ] = False
    r"""Create the configured container in Azure Blob Storage if it does not already exist"""

    dest_path: Annotated[Optional[str], pydantic.Field(alias="destPath")] = None
    r"""Root directory prepended to path before uploading. Value can be a JavaScript expression enclosed in quotes or backticks, to be evaluated at initialization. The expression can evaluate to a constant value and can reference Global Variables, such as `myBlobPrefix-${C.env[\"CRIBL_WORKER_ID\"]}`."""

    stage_path: Annotated[Optional[str], pydantic.Field(alias="stagePath")] = (
        "$CRIBL_HOME/state/outputs/staging"
    )
    r"""Filesystem location in which to buffer files before compressing and moving to final destination. Use performant and stable storage."""

    add_id_to_stage_path: Annotated[
        Optional[bool], pydantic.Field(alias="addIdToStagePath")
    ] = True
    r"""Add the Output ID value to staging location"""

    max_concurrent_file_parts: Annotated[
        Optional[float], pydantic.Field(alias="maxConcurrentFileParts")
    ] = 1
    r"""Maximum number of parts to upload in parallel per file"""

    remove_empty_dirs: Annotated[
        Optional[bool], pydantic.Field(alias="removeEmptyDirs")
    ] = True
    r"""Remove empty staging directories after moving files"""

    partition_expr: Annotated[Optional[str], pydantic.Field(alias="partitionExpr")] = (
        "C.Time.strftime(_time ? _time : Date.now()/1000, '%Y/%m/%d')"
    )
    r"""JavaScript expression defining how files are partitioned and organized. Default is date-based. If blank, Stream will fall back to the event's __partition field value – if present – otherwise to each location's root directory."""

    format_: Annotated[
        Annotated[Optional[Format1Options], PlainValidator(validate_open_enum(False))],
        pydantic.Field(alias="format"),
    ] = Format1Options.JSON
    r"""Format of the output data"""

    base_file_name: Annotated[Optional[str], pydantic.Field(alias="baseFileName")] = (
        "`CriblOut`"
    )
    r"""JavaScript expression to define the output filename prefix (can be constant)"""

    file_name_suffix: Annotated[
        Optional[str], pydantic.Field(alias="fileNameSuffix")
    ] = '`.${C.env["CRIBL_WORKER_ID"]}.${__format}${__compression === "gzip" ? ".gz" : ""}`'
    r"""JavaScript expression to define the output filename suffix (can be constant).  The `__format` variable refers to the value of the `Data format` field (`json` or `raw`).  The `__compression` field refers to the kind of compression being used (`none` or `gzip`)."""

    max_file_size_mb: Annotated[
        Optional[float], pydantic.Field(alias="maxFileSizeMB")
    ] = 32
    r"""Maximum uncompressed output file size. Files of this size will be closed and moved to final output location."""

    max_file_open_time_sec: Annotated[
        Optional[float], pydantic.Field(alias="maxFileOpenTimeSec")
    ] = 300
    r"""Maximum amount of time to write to a file. Files open for longer than this will be closed and moved to final output location."""

    max_file_idle_time_sec: Annotated[
        Optional[float], pydantic.Field(alias="maxFileIdleTimeSec")
    ] = 30
    r"""Maximum amount of time to keep inactive files open. Files open for longer than this will be closed and moved to final output location."""

    max_open_files: Annotated[Optional[float], pydantic.Field(alias="maxOpenFiles")] = (
        100
    )
    r"""Maximum number of files to keep open concurrently. When exceeded, @{product} will close the oldest open files and move them to the final output location."""

    header_line: Annotated[Optional[str], pydantic.Field(alias="headerLine")] = ""
    r"""If set, this line will be written to the beginning of each output file"""

    write_high_water_mark: Annotated[
        Optional[float], pydantic.Field(alias="writeHighWaterMark")
    ] = 64
    r"""Buffer size used to write to a file"""

    on_backpressure: Annotated[
        Annotated[
            Optional[PqOnBackpressureOptions], PlainValidator(validate_open_enum(False))
        ],
        pydantic.Field(alias="onBackpressure"),
    ] = PqOnBackpressureOptions.BLOCK
    r"""How to handle events when the queue is exerting backpressure (full capacity or low disk). 'Block' is the same behavior as non-PQ blocking. 'Drop new data' throws away incoming data, while leaving the contents of the PQ unchanged."""

    deadletter_enabled: Annotated[
        Optional[bool], pydantic.Field(alias="deadletterEnabled")
    ] = False
    r"""If a file fails to move to its final destination after the maximum number of retries, move it to a designated directory to prevent further errors"""

    on_disk_full_backpressure: Annotated[
        Annotated[
            Optional[PqOnBackpressureOptions], PlainValidator(validate_open_enum(False))
        ],
        pydantic.Field(alias="onDiskFullBackpressure"),
    ] = PqOnBackpressureOptions.BLOCK
    r"""How to handle events when the queue is exerting backpressure (full capacity or low disk). 'Block' is the same behavior as non-PQ blocking. 'Drop new data' throws away incoming data, while leaving the contents of the PQ unchanged."""

    storage_class: Annotated[
        Annotated[Optional[BlobAccessTier8], PlainValidator(validate_open_enum(False))],
        pydantic.Field(alias="storageClass"),
    ] = BlobAccessTier8.INFERRED

    description: Optional[str] = None

    compress: Annotated[
        Optional[PqCompressOptions], PlainValidator(validate_open_enum(False))
    ] = PqCompressOptions.NONE
    r"""Codec to use to compress the persisted data"""

    compression_level: Annotated[
        Annotated[
            Optional[CompressionLevelOptions], PlainValidator(validate_open_enum(False))
        ],
        pydantic.Field(alias="compressionLevel"),
    ] = CompressionLevelOptions.BEST_SPEED
    r"""Compression level to apply before moving files to final destination"""

    automatic_schema: Annotated[
        Optional[bool], pydantic.Field(alias="automaticSchema")
    ] = False
    r"""Automatically calculate the schema based on the events of each Parquet file generated"""

    parquet_schema: Annotated[Optional[str], pydantic.Field(alias="parquetSchema")] = (
        None
    )
    r"""To add a new schema, navigate to Processing > Knowledge > Parquet Schemas"""

    parquet_version: Annotated[
        Annotated[
            Optional[ParquetVersionOptions], PlainValidator(validate_open_enum(False))
        ],
        pydantic.Field(alias="parquetVersion"),
    ] = ParquetVersionOptions.PARQUET_2_6
    r"""Determines which data types are supported and how they are represented"""

    parquet_data_page_version: Annotated[
        Annotated[
            Optional[ParquetDataPageVersionOptions],
            PlainValidator(validate_open_enum(False)),
        ],
        pydantic.Field(alias="parquetDataPageVersion"),
    ] = ParquetDataPageVersionOptions.DATA_PAGE_V2
    r"""Serialization format of data pages. Note that some reader implementations use Data page V2's attributes to work more efficiently, while others ignore it."""

    parquet_row_group_length: Annotated[
        Optional[float], pydantic.Field(alias="parquetRowGroupLength")
    ] = 10000
    r"""The number of rows that every group will contain. The final group can contain a smaller number of rows."""

    parquet_page_size: Annotated[
        Optional[str], pydantic.Field(alias="parquetPageSize")
    ] = "1MB"
    r"""Target memory size for page segments, such as 1MB or 128MB. Generally, lower values improve reading speed, while higher values improve compression."""

    should_log_invalid_rows: Annotated[
        Optional[bool], pydantic.Field(alias="shouldLogInvalidRows")
    ] = None
    r"""Log up to 3 rows that @{product} skips due to data mismatch"""

    key_value_metadata: Annotated[
        Optional[List[TagsType]], pydantic.Field(alias="keyValueMetadata")
    ] = None
    r"""The metadata of files the Destination writes will include the properties you add here as key-value pairs. Useful for tagging. Examples: \"key\":\"OCSF Event Class\", \"value\":\"9001\" """

    enable_statistics: Annotated[
        Optional[bool], pydantic.Field(alias="enableStatistics")
    ] = True
    r"""Statistics profile an entire file in terms of minimum/maximum values within data, numbers of nulls, etc. You can use Parquet tools to view statistics."""

    enable_write_page_index: Annotated[
        Optional[bool], pydantic.Field(alias="enableWritePageIndex")
    ] = True
    r"""One page index contains statistics for one data page. Parquet readers use statistics to enable page skipping."""

    enable_page_checksum: Annotated[
        Optional[bool], pydantic.Field(alias="enablePageChecksum")
    ] = False
    r"""Parquet tools can use the checksum of a Parquet page to verify data integrity"""

    empty_dir_cleanup_sec: Annotated[
        Optional[float], pydantic.Field(alias="emptyDirCleanupSec")
    ] = 300
    r"""How frequently, in seconds, to clean up empty directories"""

    deadletter_path: Annotated[
        Optional[str], pydantic.Field(alias="deadletterPath")
    ] = "$CRIBL_HOME/state/outputs/dead-letter"
    r"""Storage location for files that fail to reach their final destination after maximum retries are exceeded"""

    max_retry_num: Annotated[Optional[float], pydantic.Field(alias="maxRetryNum")] = 20
    r"""The maximum number of times a file will attempt to move to its final destination before being dead-lettered"""

    connection_string: Annotated[
        Optional[str], pydantic.Field(alias="connectionString")
    ] = None
    r"""Enter your Azure Storage account connection string. If left blank, Stream will fall back to env.AZURE_STORAGE_CONNECTION_STRING."""

    storage_account_name: Annotated[
        Optional[str], pydantic.Field(alias="storageAccountName")
    ] = None
    r"""The name of your Azure storage account"""

    tenant_id: Annotated[Optional[str], pydantic.Field(alias="tenantId")] = None
    r"""The service principal's tenant ID"""

    client_id: Annotated[Optional[str], pydantic.Field(alias="clientId")] = None
    r"""The service principal's client ID"""

    azure_cloud: Annotated[Optional[str], pydantic.Field(alias="azureCloud")] = None
    r"""The Azure cloud to use. Defaults to Azure Public Cloud."""

    endpoint_suffix: Annotated[
        Optional[str], pydantic.Field(alias="endpointSuffix")
    ] = None
    r"""Endpoint suffix for the service URL. Takes precedence over the Azure Cloud setting. Defaults to core.windows.net."""

    client_text_secret: Annotated[
        Optional[str], pydantic.Field(alias="clientTextSecret")
    ] = None
    r"""Select or create a stored text secret"""

    certificate: Optional[CertificateType] = None

    @field_serializer("auth_type")
    def serialize_auth_type(self, value):
        if isinstance(value, str):
            try:
                return models.AuthType1Options(value)
            except ValueError:
                return value
        return value

    @field_serializer("format_")
    def serialize_format_(self, value):
        if isinstance(value, str):
            try:
                return models.Format1Options(value)
            except ValueError:
                return value
        return value

    @field_serializer("on_backpressure")
    def serialize_on_backpressure(self, value):
        if isinstance(value, str):
            try:
                return models.PqOnBackpressureOptions(value)
            except ValueError:
                return value
        return value

    @field_serializer("on_disk_full_backpressure")
    def serialize_on_disk_full_backpressure(self, value):
        if isinstance(value, str):
            try:
                return models.PqOnBackpressureOptions(value)
            except ValueError:
                return value
        return value

    @field_serializer("storage_class")
    def serialize_storage_class(self, value):
        if isinstance(value, str):
            try:
                return models.BlobAccessTier8(value)
            except ValueError:
                return value
        return value

    @field_serializer("compress")
    def serialize_compress(self, value):
        if isinstance(value, str):
            try:
                return models.PqCompressOptions(value)
            except ValueError:
                return value
        return value

    @field_serializer("compression_level")
    def serialize_compression_level(self, value):
        if isinstance(value, str):
            try:
                return models.CompressionLevelOptions(value)
            except ValueError:
                return value
        return value

    @field_serializer("parquet_version")
    def serialize_parquet_version(self, value):
        if isinstance(value, str):
            try:
                return models.ParquetVersionOptions(value)
            except ValueError:
                return value
        return value

    @field_serializer("parquet_data_page_version")
    def serialize_parquet_data_page_version(self, value):
        if isinstance(value, str):
            try:
                return models.ParquetDataPageVersionOptions(value)
            except ValueError:
                return value
        return value


class BlobAccessTier7(str, Enum, metaclass=utils.OpenEnumMeta):
    # Default account access tier
    INFERRED = "Inferred"
    # Hot tier
    HOT = "Hot"
    # Cool tier
    COOL = "Cool"
    # Cold tier
    COLD = "Cold"
    # Archive tier
    ARCHIVE = "Archive"


class OutputAzureBlobAzureBlob7TypedDict(TypedDict):
    type: TypeAzureBlobOption
    container_name: str
    r"""The Azure Blob Storage container name. Name can include only lowercase letters, numbers, and hyphens. For dynamic container names, enter a JavaScript expression within quotes or backticks, to be evaluated at initialization. The expression can evaluate to a constant value and can reference Global Variables, such as `myContainer-${C.env[\"CRIBL_WORKER_ID\"]}`."""
    connection_string: str
    r"""Enter your Azure Storage account connection string. If left blank, Stream will fall back to env.AZURE_STORAGE_CONNECTION_STRING."""
    auth_type: NotRequired[AuthType1Options]
    id: NotRequired[str]
    r"""Unique ID for this output"""
    pipeline: NotRequired[str]
    r"""Pipeline to process data before sending out to this output"""
    system_fields: NotRequired[List[str]]
    r"""Fields to automatically add to events, such as cribl_pipe. Supports wildcards."""
    environment: NotRequired[str]
    r"""Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere."""
    streamtags: NotRequired[List[str]]
    r"""Tags for filtering and grouping in @{product}"""
    create_container: NotRequired[bool]
    r"""Create the configured container in Azure Blob Storage if it does not already exist"""
    dest_path: NotRequired[str]
    r"""Root directory prepended to path before uploading. Value can be a JavaScript expression enclosed in quotes or backticks, to be evaluated at initialization. The expression can evaluate to a constant value and can reference Global Variables, such as `myBlobPrefix-${C.env[\"CRIBL_WORKER_ID\"]}`."""
    stage_path: NotRequired[str]
    r"""Filesystem location in which to buffer files before compressing and moving to final destination. Use performant and stable storage."""
    add_id_to_stage_path: NotRequired[bool]
    r"""Add the Output ID value to staging location"""
    max_concurrent_file_parts: NotRequired[float]
    r"""Maximum number of parts to upload in parallel per file"""
    remove_empty_dirs: NotRequired[bool]
    r"""Remove empty staging directories after moving files"""
    partition_expr: NotRequired[str]
    r"""JavaScript expression defining how files are partitioned and organized. Default is date-based. If blank, Stream will fall back to the event's __partition field value – if present – otherwise to each location's root directory."""
    format_: NotRequired[Format1Options]
    r"""Format of the output data"""
    base_file_name: NotRequired[str]
    r"""JavaScript expression to define the output filename prefix (can be constant)"""
    file_name_suffix: NotRequired[str]
    r"""JavaScript expression to define the output filename suffix (can be constant).  The `__format` variable refers to the value of the `Data format` field (`json` or `raw`).  The `__compression` field refers to the kind of compression being used (`none` or `gzip`)."""
    max_file_size_mb: NotRequired[float]
    r"""Maximum uncompressed output file size. Files of this size will be closed and moved to final output location."""
    max_file_open_time_sec: NotRequired[float]
    r"""Maximum amount of time to write to a file. Files open for longer than this will be closed and moved to final output location."""
    max_file_idle_time_sec: NotRequired[float]
    r"""Maximum amount of time to keep inactive files open. Files open for longer than this will be closed and moved to final output location."""
    max_open_files: NotRequired[float]
    r"""Maximum number of files to keep open concurrently. When exceeded, @{product} will close the oldest open files and move them to the final output location."""
    header_line: NotRequired[str]
    r"""If set, this line will be written to the beginning of each output file"""
    write_high_water_mark: NotRequired[float]
    r"""Buffer size used to write to a file"""
    on_backpressure: NotRequired[PqOnBackpressureOptions]
    r"""How to handle events when the queue is exerting backpressure (full capacity or low disk). 'Block' is the same behavior as non-PQ blocking. 'Drop new data' throws away incoming data, while leaving the contents of the PQ unchanged."""
    deadletter_enabled: NotRequired[bool]
    r"""If a file fails to move to its final destination after the maximum number of retries, move it to a designated directory to prevent further errors"""
    on_disk_full_backpressure: NotRequired[PqOnBackpressureOptions]
    r"""How to handle events when the queue is exerting backpressure (full capacity or low disk). 'Block' is the same behavior as non-PQ blocking. 'Drop new data' throws away incoming data, while leaving the contents of the PQ unchanged."""
    storage_class: NotRequired[BlobAccessTier7]
    description: NotRequired[str]
    compress: NotRequired[PqCompressOptions]
    r"""Codec to use to compress the persisted data"""
    compression_level: NotRequired[CompressionLevelOptions]
    r"""Compression level to apply before moving files to final destination"""
    automatic_schema: NotRequired[bool]
    r"""Automatically calculate the schema based on the events of each Parquet file generated"""
    parquet_schema: NotRequired[str]
    r"""To add a new schema, navigate to Processing > Knowledge > Parquet Schemas"""
    parquet_version: NotRequired[ParquetVersionOptions]
    r"""Determines which data types are supported and how they are represented"""
    parquet_data_page_version: NotRequired[ParquetDataPageVersionOptions]
    r"""Serialization format of data pages. Note that some reader implementations use Data page V2's attributes to work more efficiently, while others ignore it."""
    parquet_row_group_length: NotRequired[float]
    r"""The number of rows that every group will contain. The final group can contain a smaller number of rows."""
    parquet_page_size: NotRequired[str]
    r"""Target memory size for page segments, such as 1MB or 128MB. Generally, lower values improve reading speed, while higher values improve compression."""
    should_log_invalid_rows: NotRequired[bool]
    r"""Log up to 3 rows that @{product} skips due to data mismatch"""
    key_value_metadata: NotRequired[List[TagsTypeTypedDict]]
    r"""The metadata of files the Destination writes will include the properties you add here as key-value pairs. Useful for tagging. Examples: \"key\":\"OCSF Event Class\", \"value\":\"9001\" """
    enable_statistics: NotRequired[bool]
    r"""Statistics profile an entire file in terms of minimum/maximum values within data, numbers of nulls, etc. You can use Parquet tools to view statistics."""
    enable_write_page_index: NotRequired[bool]
    r"""One page index contains statistics for one data page. Parquet readers use statistics to enable page skipping."""
    enable_page_checksum: NotRequired[bool]
    r"""Parquet tools can use the checksum of a Parquet page to verify data integrity"""
    empty_dir_cleanup_sec: NotRequired[float]
    r"""How frequently, in seconds, to clean up empty directories"""
    deadletter_path: NotRequired[str]
    r"""Storage location for files that fail to reach their final destination after maximum retries are exceeded"""
    max_retry_num: NotRequired[float]
    r"""The maximum number of times a file will attempt to move to its final destination before being dead-lettered"""
    text_secret: NotRequired[str]
    r"""Select or create a stored text secret"""
    storage_account_name: NotRequired[str]
    r"""The name of your Azure storage account"""
    tenant_id: NotRequired[str]
    r"""The service principal's tenant ID"""
    client_id: NotRequired[str]
    r"""The service principal's client ID"""
    azure_cloud: NotRequired[str]
    r"""The Azure cloud to use. Defaults to Azure Public Cloud."""
    endpoint_suffix: NotRequired[str]
    r"""Endpoint suffix for the service URL. Takes precedence over the Azure Cloud setting. Defaults to core.windows.net."""
    client_text_secret: NotRequired[str]
    r"""Select or create a stored text secret"""
    certificate: NotRequired[CertificateTypeTypedDict]


class OutputAzureBlobAzureBlob7(BaseModel):
    type: TypeAzureBlobOption

    container_name: Annotated[str, pydantic.Field(alias="containerName")]
    r"""The Azure Blob Storage container name. Name can include only lowercase letters, numbers, and hyphens. For dynamic container names, enter a JavaScript expression within quotes or backticks, to be evaluated at initialization. The expression can evaluate to a constant value and can reference Global Variables, such as `myContainer-${C.env[\"CRIBL_WORKER_ID\"]}`."""

    connection_string: Annotated[str, pydantic.Field(alias="connectionString")]
    r"""Enter your Azure Storage account connection string. If left blank, Stream will fall back to env.AZURE_STORAGE_CONNECTION_STRING."""

    auth_type: Annotated[
        Annotated[
            Optional[AuthType1Options], PlainValidator(validate_open_enum(False))
        ],
        pydantic.Field(alias="authType"),
    ] = AuthType1Options.MANUAL

    id: Optional[str] = None
    r"""Unique ID for this output"""

    pipeline: Optional[str] = None
    r"""Pipeline to process data before sending out to this output"""

    system_fields: Annotated[
        Optional[List[str]], pydantic.Field(alias="systemFields")
    ] = None
    r"""Fields to automatically add to events, such as cribl_pipe. Supports wildcards."""

    environment: Optional[str] = None
    r"""Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere."""

    streamtags: Optional[List[str]] = None
    r"""Tags for filtering and grouping in @{product}"""

    create_container: Annotated[
        Optional[bool], pydantic.Field(alias="createContainer")
    ] = False
    r"""Create the configured container in Azure Blob Storage if it does not already exist"""

    dest_path: Annotated[Optional[str], pydantic.Field(alias="destPath")] = None
    r"""Root directory prepended to path before uploading. Value can be a JavaScript expression enclosed in quotes or backticks, to be evaluated at initialization. The expression can evaluate to a constant value and can reference Global Variables, such as `myBlobPrefix-${C.env[\"CRIBL_WORKER_ID\"]}`."""

    stage_path: Annotated[Optional[str], pydantic.Field(alias="stagePath")] = (
        "$CRIBL_HOME/state/outputs/staging"
    )
    r"""Filesystem location in which to buffer files before compressing and moving to final destination. Use performant and stable storage."""

    add_id_to_stage_path: Annotated[
        Optional[bool], pydantic.Field(alias="addIdToStagePath")
    ] = True
    r"""Add the Output ID value to staging location"""

    max_concurrent_file_parts: Annotated[
        Optional[float], pydantic.Field(alias="maxConcurrentFileParts")
    ] = 1
    r"""Maximum number of parts to upload in parallel per file"""

    remove_empty_dirs: Annotated[
        Optional[bool], pydantic.Field(alias="removeEmptyDirs")
    ] = True
    r"""Remove empty staging directories after moving files"""

    partition_expr: Annotated[Optional[str], pydantic.Field(alias="partitionExpr")] = (
        "C.Time.strftime(_time ? _time : Date.now()/1000, '%Y/%m/%d')"
    )
    r"""JavaScript expression defining how files are partitioned and organized. Default is date-based. If blank, Stream will fall back to the event's __partition field value – if present – otherwise to each location's root directory."""

    format_: Annotated[
        Annotated[Optional[Format1Options], PlainValidator(validate_open_enum(False))],
        pydantic.Field(alias="format"),
    ] = Format1Options.JSON
    r"""Format of the output data"""

    base_file_name: Annotated[Optional[str], pydantic.Field(alias="baseFileName")] = (
        "`CriblOut`"
    )
    r"""JavaScript expression to define the output filename prefix (can be constant)"""

    file_name_suffix: Annotated[
        Optional[str], pydantic.Field(alias="fileNameSuffix")
    ] = '`.${C.env["CRIBL_WORKER_ID"]}.${__format}${__compression === "gzip" ? ".gz" : ""}`'
    r"""JavaScript expression to define the output filename suffix (can be constant).  The `__format` variable refers to the value of the `Data format` field (`json` or `raw`).  The `__compression` field refers to the kind of compression being used (`none` or `gzip`)."""

    max_file_size_mb: Annotated[
        Optional[float], pydantic.Field(alias="maxFileSizeMB")
    ] = 32
    r"""Maximum uncompressed output file size. Files of this size will be closed and moved to final output location."""

    max_file_open_time_sec: Annotated[
        Optional[float], pydantic.Field(alias="maxFileOpenTimeSec")
    ] = 300
    r"""Maximum amount of time to write to a file. Files open for longer than this will be closed and moved to final output location."""

    max_file_idle_time_sec: Annotated[
        Optional[float], pydantic.Field(alias="maxFileIdleTimeSec")
    ] = 30
    r"""Maximum amount of time to keep inactive files open. Files open for longer than this will be closed and moved to final output location."""

    max_open_files: Annotated[Optional[float], pydantic.Field(alias="maxOpenFiles")] = (
        100
    )
    r"""Maximum number of files to keep open concurrently. When exceeded, @{product} will close the oldest open files and move them to the final output location."""

    header_line: Annotated[Optional[str], pydantic.Field(alias="headerLine")] = ""
    r"""If set, this line will be written to the beginning of each output file"""

    write_high_water_mark: Annotated[
        Optional[float], pydantic.Field(alias="writeHighWaterMark")
    ] = 64
    r"""Buffer size used to write to a file"""

    on_backpressure: Annotated[
        Annotated[
            Optional[PqOnBackpressureOptions], PlainValidator(validate_open_enum(False))
        ],
        pydantic.Field(alias="onBackpressure"),
    ] = PqOnBackpressureOptions.BLOCK
    r"""How to handle events when the queue is exerting backpressure (full capacity or low disk). 'Block' is the same behavior as non-PQ blocking. 'Drop new data' throws away incoming data, while leaving the contents of the PQ unchanged."""

    deadletter_enabled: Annotated[
        Optional[bool], pydantic.Field(alias="deadletterEnabled")
    ] = False
    r"""If a file fails to move to its final destination after the maximum number of retries, move it to a designated directory to prevent further errors"""

    on_disk_full_backpressure: Annotated[
        Annotated[
            Optional[PqOnBackpressureOptions], PlainValidator(validate_open_enum(False))
        ],
        pydantic.Field(alias="onDiskFullBackpressure"),
    ] = PqOnBackpressureOptions.BLOCK
    r"""How to handle events when the queue is exerting backpressure (full capacity or low disk). 'Block' is the same behavior as non-PQ blocking. 'Drop new data' throws away incoming data, while leaving the contents of the PQ unchanged."""

    storage_class: Annotated[
        Annotated[Optional[BlobAccessTier7], PlainValidator(validate_open_enum(False))],
        pydantic.Field(alias="storageClass"),
    ] = BlobAccessTier7.INFERRED

    description: Optional[str] = None

    compress: Annotated[
        Optional[PqCompressOptions], PlainValidator(validate_open_enum(False))
    ] = PqCompressOptions.NONE
    r"""Codec to use to compress the persisted data"""

    compression_level: Annotated[
        Annotated[
            Optional[CompressionLevelOptions], PlainValidator(validate_open_enum(False))
        ],
        pydantic.Field(alias="compressionLevel"),
    ] = CompressionLevelOptions.BEST_SPEED
    r"""Compression level to apply before moving files to final destination"""

    automatic_schema: Annotated[
        Optional[bool], pydantic.Field(alias="automaticSchema")
    ] = False
    r"""Automatically calculate the schema based on the events of each Parquet file generated"""

    parquet_schema: Annotated[Optional[str], pydantic.Field(alias="parquetSchema")] = (
        None
    )
    r"""To add a new schema, navigate to Processing > Knowledge > Parquet Schemas"""

    parquet_version: Annotated[
        Annotated[
            Optional[ParquetVersionOptions], PlainValidator(validate_open_enum(False))
        ],
        pydantic.Field(alias="parquetVersion"),
    ] = ParquetVersionOptions.PARQUET_2_6
    r"""Determines which data types are supported and how they are represented"""

    parquet_data_page_version: Annotated[
        Annotated[
            Optional[ParquetDataPageVersionOptions],
            PlainValidator(validate_open_enum(False)),
        ],
        pydantic.Field(alias="parquetDataPageVersion"),
    ] = ParquetDataPageVersionOptions.DATA_PAGE_V2
    r"""Serialization format of data pages. Note that some reader implementations use Data page V2's attributes to work more efficiently, while others ignore it."""

    parquet_row_group_length: Annotated[
        Optional[float], pydantic.Field(alias="parquetRowGroupLength")
    ] = 10000
    r"""The number of rows that every group will contain. The final group can contain a smaller number of rows."""

    parquet_page_size: Annotated[
        Optional[str], pydantic.Field(alias="parquetPageSize")
    ] = "1MB"
    r"""Target memory size for page segments, such as 1MB or 128MB. Generally, lower values improve reading speed, while higher values improve compression."""

    should_log_invalid_rows: Annotated[
        Optional[bool], pydantic.Field(alias="shouldLogInvalidRows")
    ] = None
    r"""Log up to 3 rows that @{product} skips due to data mismatch"""

    key_value_metadata: Annotated[
        Optional[List[TagsType]], pydantic.Field(alias="keyValueMetadata")
    ] = None
    r"""The metadata of files the Destination writes will include the properties you add here as key-value pairs. Useful for tagging. Examples: \"key\":\"OCSF Event Class\", \"value\":\"9001\" """

    enable_statistics: Annotated[
        Optional[bool], pydantic.Field(alias="enableStatistics")
    ] = True
    r"""Statistics profile an entire file in terms of minimum/maximum values within data, numbers of nulls, etc. You can use Parquet tools to view statistics."""

    enable_write_page_index: Annotated[
        Optional[bool], pydantic.Field(alias="enableWritePageIndex")
    ] = True
    r"""One page index contains statistics for one data page. Parquet readers use statistics to enable page skipping."""

    enable_page_checksum: Annotated[
        Optional[bool], pydantic.Field(alias="enablePageChecksum")
    ] = False
    r"""Parquet tools can use the checksum of a Parquet page to verify data integrity"""

    empty_dir_cleanup_sec: Annotated[
        Optional[float], pydantic.Field(alias="emptyDirCleanupSec")
    ] = 300
    r"""How frequently, in seconds, to clean up empty directories"""

    deadletter_path: Annotated[
        Optional[str], pydantic.Field(alias="deadletterPath")
    ] = "$CRIBL_HOME/state/outputs/dead-letter"
    r"""Storage location for files that fail to reach their final destination after maximum retries are exceeded"""

    max_retry_num: Annotated[Optional[float], pydantic.Field(alias="maxRetryNum")] = 20
    r"""The maximum number of times a file will attempt to move to its final destination before being dead-lettered"""

    text_secret: Annotated[Optional[str], pydantic.Field(alias="textSecret")] = None
    r"""Select or create a stored text secret"""

    storage_account_name: Annotated[
        Optional[str], pydantic.Field(alias="storageAccountName")
    ] = None
    r"""The name of your Azure storage account"""

    tenant_id: Annotated[Optional[str], pydantic.Field(alias="tenantId")] = None
    r"""The service principal's tenant ID"""

    client_id: Annotated[Optional[str], pydantic.Field(alias="clientId")] = None
    r"""The service principal's client ID"""

    azure_cloud: Annotated[Optional[str], pydantic.Field(alias="azureCloud")] = None
    r"""The Azure cloud to use. Defaults to Azure Public Cloud."""

    endpoint_suffix: Annotated[
        Optional[str], pydantic.Field(alias="endpointSuffix")
    ] = None
    r"""Endpoint suffix for the service URL. Takes precedence over the Azure Cloud setting. Defaults to core.windows.net."""

    client_text_secret: Annotated[
        Optional[str], pydantic.Field(alias="clientTextSecret")
    ] = None
    r"""Select or create a stored text secret"""

    certificate: Optional[CertificateType] = None

    @field_serializer("auth_type")
    def serialize_auth_type(self, value):
        if isinstance(value, str):
            try:
                return models.AuthType1Options(value)
            except ValueError:
                return value
        return value

    @field_serializer("format_")
    def serialize_format_(self, value):
        if isinstance(value, str):
            try:
                return models.Format1Options(value)
            except ValueError:
                return value
        return value

    @field_serializer("on_backpressure")
    def serialize_on_backpressure(self, value):
        if isinstance(value, str):
            try:
                return models.PqOnBackpressureOptions(value)
            except ValueError:
                return value
        return value

    @field_serializer("on_disk_full_backpressure")
    def serialize_on_disk_full_backpressure(self, value):
        if isinstance(value, str):
            try:
                return models.PqOnBackpressureOptions(value)
            except ValueError:
                return value
        return value

    @field_serializer("storage_class")
    def serialize_storage_class(self, value):
        if isinstance(value, str):
            try:
                return models.BlobAccessTier7(value)
            except ValueError:
                return value
        return value

    @field_serializer("compress")
    def serialize_compress(self, value):
        if isinstance(value, str):
            try:
                return models.PqCompressOptions(value)
            except ValueError:
                return value
        return value

    @field_serializer("compression_level")
    def serialize_compression_level(self, value):
        if isinstance(value, str):
            try:
                return models.CompressionLevelOptions(value)
            except ValueError:
                return value
        return value

    @field_serializer("parquet_version")
    def serialize_parquet_version(self, value):
        if isinstance(value, str):
            try:
                return models.ParquetVersionOptions(value)
            except ValueError:
                return value
        return value

    @field_serializer("parquet_data_page_version")
    def serialize_parquet_data_page_version(self, value):
        if isinstance(value, str):
            try:
                return models.ParquetDataPageVersionOptions(value)
            except ValueError:
                return value
        return value


class BlobAccessTier6(str, Enum, metaclass=utils.OpenEnumMeta):
    # Default account access tier
    INFERRED = "Inferred"
    # Hot tier
    HOT = "Hot"
    # Cool tier
    COOL = "Cool"
    # Cold tier
    COLD = "Cold"
    # Archive tier
    ARCHIVE = "Archive"


class OutputAzureBlobAzureBlob6TypedDict(TypedDict):
    type: TypeAzureBlobOption
    container_name: str
    r"""The Azure Blob Storage container name. Name can include only lowercase letters, numbers, and hyphens. For dynamic container names, enter a JavaScript expression within quotes or backticks, to be evaluated at initialization. The expression can evaluate to a constant value and can reference Global Variables, such as `myContainer-${C.env[\"CRIBL_WORKER_ID\"]}`."""
    deadletter_enabled: NotRequired[bool]
    r"""If a file fails to move to its final destination after the maximum number of retries, move it to a designated directory to prevent further errors"""
    id: NotRequired[str]
    r"""Unique ID for this output"""
    pipeline: NotRequired[str]
    r"""Pipeline to process data before sending out to this output"""
    system_fields: NotRequired[List[str]]
    r"""Fields to automatically add to events, such as cribl_pipe. Supports wildcards."""
    environment: NotRequired[str]
    r"""Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere."""
    streamtags: NotRequired[List[str]]
    r"""Tags for filtering and grouping in @{product}"""
    create_container: NotRequired[bool]
    r"""Create the configured container in Azure Blob Storage if it does not already exist"""
    dest_path: NotRequired[str]
    r"""Root directory prepended to path before uploading. Value can be a JavaScript expression enclosed in quotes or backticks, to be evaluated at initialization. The expression can evaluate to a constant value and can reference Global Variables, such as `myBlobPrefix-${C.env[\"CRIBL_WORKER_ID\"]}`."""
    stage_path: NotRequired[str]
    r"""Filesystem location in which to buffer files before compressing and moving to final destination. Use performant and stable storage."""
    add_id_to_stage_path: NotRequired[bool]
    r"""Add the Output ID value to staging location"""
    max_concurrent_file_parts: NotRequired[float]
    r"""Maximum number of parts to upload in parallel per file"""
    remove_empty_dirs: NotRequired[bool]
    r"""Remove empty staging directories after moving files"""
    partition_expr: NotRequired[str]
    r"""JavaScript expression defining how files are partitioned and organized. Default is date-based. If blank, Stream will fall back to the event's __partition field value – if present – otherwise to each location's root directory."""
    format_: NotRequired[Format1Options]
    r"""Format of the output data"""
    base_file_name: NotRequired[str]
    r"""JavaScript expression to define the output filename prefix (can be constant)"""
    file_name_suffix: NotRequired[str]
    r"""JavaScript expression to define the output filename suffix (can be constant).  The `__format` variable refers to the value of the `Data format` field (`json` or `raw`).  The `__compression` field refers to the kind of compression being used (`none` or `gzip`)."""
    max_file_size_mb: NotRequired[float]
    r"""Maximum uncompressed output file size. Files of this size will be closed and moved to final output location."""
    max_file_open_time_sec: NotRequired[float]
    r"""Maximum amount of time to write to a file. Files open for longer than this will be closed and moved to final output location."""
    max_file_idle_time_sec: NotRequired[float]
    r"""Maximum amount of time to keep inactive files open. Files open for longer than this will be closed and moved to final output location."""
    max_open_files: NotRequired[float]
    r"""Maximum number of files to keep open concurrently. When exceeded, @{product} will close the oldest open files and move them to the final output location."""
    header_line: NotRequired[str]
    r"""If set, this line will be written to the beginning of each output file"""
    write_high_water_mark: NotRequired[float]
    r"""Buffer size used to write to a file"""
    on_backpressure: NotRequired[PqOnBackpressureOptions]
    r"""How to handle events when the queue is exerting backpressure (full capacity or low disk). 'Block' is the same behavior as non-PQ blocking. 'Drop new data' throws away incoming data, while leaving the contents of the PQ unchanged."""
    on_disk_full_backpressure: NotRequired[PqOnBackpressureOptions]
    r"""How to handle events when the queue is exerting backpressure (full capacity or low disk). 'Block' is the same behavior as non-PQ blocking. 'Drop new data' throws away incoming data, while leaving the contents of the PQ unchanged."""
    auth_type: NotRequired[AuthType1Options]
    storage_class: NotRequired[BlobAccessTier6]
    description: NotRequired[str]
    compress: NotRequired[PqCompressOptions]
    r"""Codec to use to compress the persisted data"""
    compression_level: NotRequired[CompressionLevelOptions]
    r"""Compression level to apply before moving files to final destination"""
    automatic_schema: NotRequired[bool]
    r"""Automatically calculate the schema based on the events of each Parquet file generated"""
    parquet_schema: NotRequired[str]
    r"""To add a new schema, navigate to Processing > Knowledge > Parquet Schemas"""
    parquet_version: NotRequired[ParquetVersionOptions]
    r"""Determines which data types are supported and how they are represented"""
    parquet_data_page_version: NotRequired[ParquetDataPageVersionOptions]
    r"""Serialization format of data pages. Note that some reader implementations use Data page V2's attributes to work more efficiently, while others ignore it."""
    parquet_row_group_length: NotRequired[float]
    r"""The number of rows that every group will contain. The final group can contain a smaller number of rows."""
    parquet_page_size: NotRequired[str]
    r"""Target memory size for page segments, such as 1MB or 128MB. Generally, lower values improve reading speed, while higher values improve compression."""
    should_log_invalid_rows: NotRequired[bool]
    r"""Log up to 3 rows that @{product} skips due to data mismatch"""
    key_value_metadata: NotRequired[List[TagsTypeTypedDict]]
    r"""The metadata of files the Destination writes will include the properties you add here as key-value pairs. Useful for tagging. Examples: \"key\":\"OCSF Event Class\", \"value\":\"9001\" """
    enable_statistics: NotRequired[bool]
    r"""Statistics profile an entire file in terms of minimum/maximum values within data, numbers of nulls, etc. You can use Parquet tools to view statistics."""
    enable_write_page_index: NotRequired[bool]
    r"""One page index contains statistics for one data page. Parquet readers use statistics to enable page skipping."""
    enable_page_checksum: NotRequired[bool]
    r"""Parquet tools can use the checksum of a Parquet page to verify data integrity"""
    empty_dir_cleanup_sec: NotRequired[float]
    r"""How frequently, in seconds, to clean up empty directories"""
    deadletter_path: NotRequired[str]
    r"""Storage location for files that fail to reach their final destination after maximum retries are exceeded"""
    max_retry_num: NotRequired[float]
    r"""The maximum number of times a file will attempt to move to its final destination before being dead-lettered"""
    connection_string: NotRequired[str]
    r"""Enter your Azure Storage account connection string. If left blank, Stream will fall back to env.AZURE_STORAGE_CONNECTION_STRING."""
    text_secret: NotRequired[str]
    r"""Select or create a stored text secret"""
    storage_account_name: NotRequired[str]
    r"""The name of your Azure storage account"""
    tenant_id: NotRequired[str]
    r"""The service principal's tenant ID"""
    client_id: NotRequired[str]
    r"""The service principal's client ID"""
    azure_cloud: NotRequired[str]
    r"""The Azure cloud to use. Defaults to Azure Public Cloud."""
    endpoint_suffix: NotRequired[str]
    r"""Endpoint suffix for the service URL. Takes precedence over the Azure Cloud setting. Defaults to core.windows.net."""
    client_text_secret: NotRequired[str]
    r"""Select or create a stored text secret"""
    certificate: NotRequired[CertificateTypeTypedDict]


class OutputAzureBlobAzureBlob6(BaseModel):
    type: TypeAzureBlobOption

    container_name: Annotated[str, pydantic.Field(alias="containerName")]
    r"""The Azure Blob Storage container name. Name can include only lowercase letters, numbers, and hyphens. For dynamic container names, enter a JavaScript expression within quotes or backticks, to be evaluated at initialization. The expression can evaluate to a constant value and can reference Global Variables, such as `myContainer-${C.env[\"CRIBL_WORKER_ID\"]}`."""

    deadletter_enabled: Annotated[
        Optional[bool], pydantic.Field(alias="deadletterEnabled")
    ] = False
    r"""If a file fails to move to its final destination after the maximum number of retries, move it to a designated directory to prevent further errors"""

    id: Optional[str] = None
    r"""Unique ID for this output"""

    pipeline: Optional[str] = None
    r"""Pipeline to process data before sending out to this output"""

    system_fields: Annotated[
        Optional[List[str]], pydantic.Field(alias="systemFields")
    ] = None
    r"""Fields to automatically add to events, such as cribl_pipe. Supports wildcards."""

    environment: Optional[str] = None
    r"""Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere."""

    streamtags: Optional[List[str]] = None
    r"""Tags for filtering and grouping in @{product}"""

    create_container: Annotated[
        Optional[bool], pydantic.Field(alias="createContainer")
    ] = False
    r"""Create the configured container in Azure Blob Storage if it does not already exist"""

    dest_path: Annotated[Optional[str], pydantic.Field(alias="destPath")] = None
    r"""Root directory prepended to path before uploading. Value can be a JavaScript expression enclosed in quotes or backticks, to be evaluated at initialization. The expression can evaluate to a constant value and can reference Global Variables, such as `myBlobPrefix-${C.env[\"CRIBL_WORKER_ID\"]}`."""

    stage_path: Annotated[Optional[str], pydantic.Field(alias="stagePath")] = (
        "$CRIBL_HOME/state/outputs/staging"
    )
    r"""Filesystem location in which to buffer files before compressing and moving to final destination. Use performant and stable storage."""

    add_id_to_stage_path: Annotated[
        Optional[bool], pydantic.Field(alias="addIdToStagePath")
    ] = True
    r"""Add the Output ID value to staging location"""

    max_concurrent_file_parts: Annotated[
        Optional[float], pydantic.Field(alias="maxConcurrentFileParts")
    ] = 1
    r"""Maximum number of parts to upload in parallel per file"""

    remove_empty_dirs: Annotated[
        Optional[bool], pydantic.Field(alias="removeEmptyDirs")
    ] = True
    r"""Remove empty staging directories after moving files"""

    partition_expr: Annotated[Optional[str], pydantic.Field(alias="partitionExpr")] = (
        "C.Time.strftime(_time ? _time : Date.now()/1000, '%Y/%m/%d')"
    )
    r"""JavaScript expression defining how files are partitioned and organized. Default is date-based. If blank, Stream will fall back to the event's __partition field value – if present – otherwise to each location's root directory."""

    format_: Annotated[
        Annotated[Optional[Format1Options], PlainValidator(validate_open_enum(False))],
        pydantic.Field(alias="format"),
    ] = Format1Options.JSON
    r"""Format of the output data"""

    base_file_name: Annotated[Optional[str], pydantic.Field(alias="baseFileName")] = (
        "`CriblOut`"
    )
    r"""JavaScript expression to define the output filename prefix (can be constant)"""

    file_name_suffix: Annotated[
        Optional[str], pydantic.Field(alias="fileNameSuffix")
    ] = '`.${C.env["CRIBL_WORKER_ID"]}.${__format}${__compression === "gzip" ? ".gz" : ""}`'
    r"""JavaScript expression to define the output filename suffix (can be constant).  The `__format` variable refers to the value of the `Data format` field (`json` or `raw`).  The `__compression` field refers to the kind of compression being used (`none` or `gzip`)."""

    max_file_size_mb: Annotated[
        Optional[float], pydantic.Field(alias="maxFileSizeMB")
    ] = 32
    r"""Maximum uncompressed output file size. Files of this size will be closed and moved to final output location."""

    max_file_open_time_sec: Annotated[
        Optional[float], pydantic.Field(alias="maxFileOpenTimeSec")
    ] = 300
    r"""Maximum amount of time to write to a file. Files open for longer than this will be closed and moved to final output location."""

    max_file_idle_time_sec: Annotated[
        Optional[float], pydantic.Field(alias="maxFileIdleTimeSec")
    ] = 30
    r"""Maximum amount of time to keep inactive files open. Files open for longer than this will be closed and moved to final output location."""

    max_open_files: Annotated[Optional[float], pydantic.Field(alias="maxOpenFiles")] = (
        100
    )
    r"""Maximum number of files to keep open concurrently. When exceeded, @{product} will close the oldest open files and move them to the final output location."""

    header_line: Annotated[Optional[str], pydantic.Field(alias="headerLine")] = ""
    r"""If set, this line will be written to the beginning of each output file"""

    write_high_water_mark: Annotated[
        Optional[float], pydantic.Field(alias="writeHighWaterMark")
    ] = 64
    r"""Buffer size used to write to a file"""

    on_backpressure: Annotated[
        Annotated[
            Optional[PqOnBackpressureOptions], PlainValidator(validate_open_enum(False))
        ],
        pydantic.Field(alias="onBackpressure"),
    ] = PqOnBackpressureOptions.BLOCK
    r"""How to handle events when the queue is exerting backpressure (full capacity or low disk). 'Block' is the same behavior as non-PQ blocking. 'Drop new data' throws away incoming data, while leaving the contents of the PQ unchanged."""

    on_disk_full_backpressure: Annotated[
        Annotated[
            Optional[PqOnBackpressureOptions], PlainValidator(validate_open_enum(False))
        ],
        pydantic.Field(alias="onDiskFullBackpressure"),
    ] = PqOnBackpressureOptions.BLOCK
    r"""How to handle events when the queue is exerting backpressure (full capacity or low disk). 'Block' is the same behavior as non-PQ blocking. 'Drop new data' throws away incoming data, while leaving the contents of the PQ unchanged."""

    auth_type: Annotated[
        Annotated[
            Optional[AuthType1Options], PlainValidator(validate_open_enum(False))
        ],
        pydantic.Field(alias="authType"),
    ] = AuthType1Options.MANUAL

    storage_class: Annotated[
        Annotated[Optional[BlobAccessTier6], PlainValidator(validate_open_enum(False))],
        pydantic.Field(alias="storageClass"),
    ] = BlobAccessTier6.INFERRED

    description: Optional[str] = None

    compress: Annotated[
        Optional[PqCompressOptions], PlainValidator(validate_open_enum(False))
    ] = PqCompressOptions.NONE
    r"""Codec to use to compress the persisted data"""

    compression_level: Annotated[
        Annotated[
            Optional[CompressionLevelOptions], PlainValidator(validate_open_enum(False))
        ],
        pydantic.Field(alias="compressionLevel"),
    ] = CompressionLevelOptions.BEST_SPEED
    r"""Compression level to apply before moving files to final destination"""

    automatic_schema: Annotated[
        Optional[bool], pydantic.Field(alias="automaticSchema")
    ] = False
    r"""Automatically calculate the schema based on the events of each Parquet file generated"""

    parquet_schema: Annotated[Optional[str], pydantic.Field(alias="parquetSchema")] = (
        None
    )
    r"""To add a new schema, navigate to Processing > Knowledge > Parquet Schemas"""

    parquet_version: Annotated[
        Annotated[
            Optional[ParquetVersionOptions], PlainValidator(validate_open_enum(False))
        ],
        pydantic.Field(alias="parquetVersion"),
    ] = ParquetVersionOptions.PARQUET_2_6
    r"""Determines which data types are supported and how they are represented"""

    parquet_data_page_version: Annotated[
        Annotated[
            Optional[ParquetDataPageVersionOptions],
            PlainValidator(validate_open_enum(False)),
        ],
        pydantic.Field(alias="parquetDataPageVersion"),
    ] = ParquetDataPageVersionOptions.DATA_PAGE_V2
    r"""Serialization format of data pages. Note that some reader implementations use Data page V2's attributes to work more efficiently, while others ignore it."""

    parquet_row_group_length: Annotated[
        Optional[float], pydantic.Field(alias="parquetRowGroupLength")
    ] = 10000
    r"""The number of rows that every group will contain. The final group can contain a smaller number of rows."""

    parquet_page_size: Annotated[
        Optional[str], pydantic.Field(alias="parquetPageSize")
    ] = "1MB"
    r"""Target memory size for page segments, such as 1MB or 128MB. Generally, lower values improve reading speed, while higher values improve compression."""

    should_log_invalid_rows: Annotated[
        Optional[bool], pydantic.Field(alias="shouldLogInvalidRows")
    ] = None
    r"""Log up to 3 rows that @{product} skips due to data mismatch"""

    key_value_metadata: Annotated[
        Optional[List[TagsType]], pydantic.Field(alias="keyValueMetadata")
    ] = None
    r"""The metadata of files the Destination writes will include the properties you add here as key-value pairs. Useful for tagging. Examples: \"key\":\"OCSF Event Class\", \"value\":\"9001\" """

    enable_statistics: Annotated[
        Optional[bool], pydantic.Field(alias="enableStatistics")
    ] = True
    r"""Statistics profile an entire file in terms of minimum/maximum values within data, numbers of nulls, etc. You can use Parquet tools to view statistics."""

    enable_write_page_index: Annotated[
        Optional[bool], pydantic.Field(alias="enableWritePageIndex")
    ] = True
    r"""One page index contains statistics for one data page. Parquet readers use statistics to enable page skipping."""

    enable_page_checksum: Annotated[
        Optional[bool], pydantic.Field(alias="enablePageChecksum")
    ] = False
    r"""Parquet tools can use the checksum of a Parquet page to verify data integrity"""

    empty_dir_cleanup_sec: Annotated[
        Optional[float], pydantic.Field(alias="emptyDirCleanupSec")
    ] = 300
    r"""How frequently, in seconds, to clean up empty directories"""

    deadletter_path: Annotated[
        Optional[str], pydantic.Field(alias="deadletterPath")
    ] = "$CRIBL_HOME/state/outputs/dead-letter"
    r"""Storage location for files that fail to reach their final destination after maximum retries are exceeded"""

    max_retry_num: Annotated[Optional[float], pydantic.Field(alias="maxRetryNum")] = 20
    r"""The maximum number of times a file will attempt to move to its final destination before being dead-lettered"""

    connection_string: Annotated[
        Optional[str], pydantic.Field(alias="connectionString")
    ] = None
    r"""Enter your Azure Storage account connection string. If left blank, Stream will fall back to env.AZURE_STORAGE_CONNECTION_STRING."""

    text_secret: Annotated[Optional[str], pydantic.Field(alias="textSecret")] = None
    r"""Select or create a stored text secret"""

    storage_account_name: Annotated[
        Optional[str], pydantic.Field(alias="storageAccountName")
    ] = None
    r"""The name of your Azure storage account"""

    tenant_id: Annotated[Optional[str], pydantic.Field(alias="tenantId")] = None
    r"""The service principal's tenant ID"""

    client_id: Annotated[Optional[str], pydantic.Field(alias="clientId")] = None
    r"""The service principal's client ID"""

    azure_cloud: Annotated[Optional[str], pydantic.Field(alias="azureCloud")] = None
    r"""The Azure cloud to use. Defaults to Azure Public Cloud."""

    endpoint_suffix: Annotated[
        Optional[str], pydantic.Field(alias="endpointSuffix")
    ] = None
    r"""Endpoint suffix for the service URL. Takes precedence over the Azure Cloud setting. Defaults to core.windows.net."""

    client_text_secret: Annotated[
        Optional[str], pydantic.Field(alias="clientTextSecret")
    ] = None
    r"""Select or create a stored text secret"""

    certificate: Optional[CertificateType] = None

    @field_serializer("format_")
    def serialize_format_(self, value):
        if isinstance(value, str):
            try:
                return models.Format1Options(value)
            except ValueError:
                return value
        return value

    @field_serializer("on_backpressure")
    def serialize_on_backpressure(self, value):
        if isinstance(value, str):
            try:
                return models.PqOnBackpressureOptions(value)
            except ValueError:
                return value
        return value

    @field_serializer("on_disk_full_backpressure")
    def serialize_on_disk_full_backpressure(self, value):
        if isinstance(value, str):
            try:
                return models.PqOnBackpressureOptions(value)
            except ValueError:
                return value
        return value

    @field_serializer("auth_type")
    def serialize_auth_type(self, value):
        if isinstance(value, str):
            try:
                return models.AuthType1Options(value)
            except ValueError:
                return value
        return value

    @field_serializer("storage_class")
    def serialize_storage_class(self, value):
        if isinstance(value, str):
            try:
                return models.BlobAccessTier6(value)
            except ValueError:
                return value
        return value

    @field_serializer("compress")
    def serialize_compress(self, value):
        if isinstance(value, str):
            try:
                return models.PqCompressOptions(value)
            except ValueError:
                return value
        return value

    @field_serializer("compression_level")
    def serialize_compression_level(self, value):
        if isinstance(value, str):
            try:
                return models.CompressionLevelOptions(value)
            except ValueError:
                return value
        return value

    @field_serializer("parquet_version")
    def serialize_parquet_version(self, value):
        if isinstance(value, str):
            try:
                return models.ParquetVersionOptions(value)
            except ValueError:
                return value
        return value

    @field_serializer("parquet_data_page_version")
    def serialize_parquet_data_page_version(self, value):
        if isinstance(value, str):
            try:
                return models.ParquetDataPageVersionOptions(value)
            except ValueError:
                return value
        return value


class BlobAccessTier5(str, Enum, metaclass=utils.OpenEnumMeta):
    # Default account access tier
    INFERRED = "Inferred"
    # Hot tier
    HOT = "Hot"
    # Cool tier
    COOL = "Cool"
    # Cold tier
    COLD = "Cold"
    # Archive tier
    ARCHIVE = "Archive"


class OutputAzureBlobAzureBlob5TypedDict(TypedDict):
    type: TypeAzureBlobOption
    container_name: str
    r"""The Azure Blob Storage container name. Name can include only lowercase letters, numbers, and hyphens. For dynamic container names, enter a JavaScript expression within quotes or backticks, to be evaluated at initialization. The expression can evaluate to a constant value and can reference Global Variables, such as `myContainer-${C.env[\"CRIBL_WORKER_ID\"]}`."""
    deadletter_enabled: NotRequired[bool]
    r"""If a file fails to move to its final destination after the maximum number of retries, move it to a designated directory to prevent further errors"""
    id: NotRequired[str]
    r"""Unique ID for this output"""
    pipeline: NotRequired[str]
    r"""Pipeline to process data before sending out to this output"""
    system_fields: NotRequired[List[str]]
    r"""Fields to automatically add to events, such as cribl_pipe. Supports wildcards."""
    environment: NotRequired[str]
    r"""Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere."""
    streamtags: NotRequired[List[str]]
    r"""Tags for filtering and grouping in @{product}"""
    create_container: NotRequired[bool]
    r"""Create the configured container in Azure Blob Storage if it does not already exist"""
    dest_path: NotRequired[str]
    r"""Root directory prepended to path before uploading. Value can be a JavaScript expression enclosed in quotes or backticks, to be evaluated at initialization. The expression can evaluate to a constant value and can reference Global Variables, such as `myBlobPrefix-${C.env[\"CRIBL_WORKER_ID\"]}`."""
    stage_path: NotRequired[str]
    r"""Filesystem location in which to buffer files before compressing and moving to final destination. Use performant and stable storage."""
    add_id_to_stage_path: NotRequired[bool]
    r"""Add the Output ID value to staging location"""
    max_concurrent_file_parts: NotRequired[float]
    r"""Maximum number of parts to upload in parallel per file"""
    remove_empty_dirs: NotRequired[bool]
    r"""Remove empty staging directories after moving files"""
    partition_expr: NotRequired[str]
    r"""JavaScript expression defining how files are partitioned and organized. Default is date-based. If blank, Stream will fall back to the event's __partition field value – if present – otherwise to each location's root directory."""
    format_: NotRequired[Format1Options]
    r"""Format of the output data"""
    base_file_name: NotRequired[str]
    r"""JavaScript expression to define the output filename prefix (can be constant)"""
    file_name_suffix: NotRequired[str]
    r"""JavaScript expression to define the output filename suffix (can be constant).  The `__format` variable refers to the value of the `Data format` field (`json` or `raw`).  The `__compression` field refers to the kind of compression being used (`none` or `gzip`)."""
    max_file_size_mb: NotRequired[float]
    r"""Maximum uncompressed output file size. Files of this size will be closed and moved to final output location."""
    max_file_open_time_sec: NotRequired[float]
    r"""Maximum amount of time to write to a file. Files open for longer than this will be closed and moved to final output location."""
    max_file_idle_time_sec: NotRequired[float]
    r"""Maximum amount of time to keep inactive files open. Files open for longer than this will be closed and moved to final output location."""
    max_open_files: NotRequired[float]
    r"""Maximum number of files to keep open concurrently. When exceeded, @{product} will close the oldest open files and move them to the final output location."""
    header_line: NotRequired[str]
    r"""If set, this line will be written to the beginning of each output file"""
    write_high_water_mark: NotRequired[float]
    r"""Buffer size used to write to a file"""
    on_backpressure: NotRequired[PqOnBackpressureOptions]
    r"""How to handle events when the queue is exerting backpressure (full capacity or low disk). 'Block' is the same behavior as non-PQ blocking. 'Drop new data' throws away incoming data, while leaving the contents of the PQ unchanged."""
    on_disk_full_backpressure: NotRequired[PqOnBackpressureOptions]
    r"""How to handle events when the queue is exerting backpressure (full capacity or low disk). 'Block' is the same behavior as non-PQ blocking. 'Drop new data' throws away incoming data, while leaving the contents of the PQ unchanged."""
    auth_type: NotRequired[AuthType1Options]
    storage_class: NotRequired[BlobAccessTier5]
    description: NotRequired[str]
    compress: NotRequired[PqCompressOptions]
    r"""Codec to use to compress the persisted data"""
    compression_level: NotRequired[CompressionLevelOptions]
    r"""Compression level to apply before moving files to final destination"""
    automatic_schema: NotRequired[bool]
    r"""Automatically calculate the schema based on the events of each Parquet file generated"""
    parquet_schema: NotRequired[str]
    r"""To add a new schema, navigate to Processing > Knowledge > Parquet Schemas"""
    parquet_version: NotRequired[ParquetVersionOptions]
    r"""Determines which data types are supported and how they are represented"""
    parquet_data_page_version: NotRequired[ParquetDataPageVersionOptions]
    r"""Serialization format of data pages. Note that some reader implementations use Data page V2's attributes to work more efficiently, while others ignore it."""
    parquet_row_group_length: NotRequired[float]
    r"""The number of rows that every group will contain. The final group can contain a smaller number of rows."""
    parquet_page_size: NotRequired[str]
    r"""Target memory size for page segments, such as 1MB or 128MB. Generally, lower values improve reading speed, while higher values improve compression."""
    should_log_invalid_rows: NotRequired[bool]
    r"""Log up to 3 rows that @{product} skips due to data mismatch"""
    key_value_metadata: NotRequired[List[TagsTypeTypedDict]]
    r"""The metadata of files the Destination writes will include the properties you add here as key-value pairs. Useful for tagging. Examples: \"key\":\"OCSF Event Class\", \"value\":\"9001\" """
    enable_statistics: NotRequired[bool]
    r"""Statistics profile an entire file in terms of minimum/maximum values within data, numbers of nulls, etc. You can use Parquet tools to view statistics."""
    enable_write_page_index: NotRequired[bool]
    r"""One page index contains statistics for one data page. Parquet readers use statistics to enable page skipping."""
    enable_page_checksum: NotRequired[bool]
    r"""Parquet tools can use the checksum of a Parquet page to verify data integrity"""
    empty_dir_cleanup_sec: NotRequired[float]
    r"""How frequently, in seconds, to clean up empty directories"""
    deadletter_path: NotRequired[str]
    r"""Storage location for files that fail to reach their final destination after maximum retries are exceeded"""
    max_retry_num: NotRequired[float]
    r"""The maximum number of times a file will attempt to move to its final destination before being dead-lettered"""
    connection_string: NotRequired[str]
    r"""Enter your Azure Storage account connection string. If left blank, Stream will fall back to env.AZURE_STORAGE_CONNECTION_STRING."""
    text_secret: NotRequired[str]
    r"""Select or create a stored text secret"""
    storage_account_name: NotRequired[str]
    r"""The name of your Azure storage account"""
    tenant_id: NotRequired[str]
    r"""The service principal's tenant ID"""
    client_id: NotRequired[str]
    r"""The service principal's client ID"""
    azure_cloud: NotRequired[str]
    r"""The Azure cloud to use. Defaults to Azure Public Cloud."""
    endpoint_suffix: NotRequired[str]
    r"""Endpoint suffix for the service URL. Takes precedence over the Azure Cloud setting. Defaults to core.windows.net."""
    client_text_secret: NotRequired[str]
    r"""Select or create a stored text secret"""
    certificate: NotRequired[CertificateTypeTypedDict]


class OutputAzureBlobAzureBlob5(BaseModel):
    type: TypeAzureBlobOption

    container_name: Annotated[str, pydantic.Field(alias="containerName")]
    r"""The Azure Blob Storage container name. Name can include only lowercase letters, numbers, and hyphens. For dynamic container names, enter a JavaScript expression within quotes or backticks, to be evaluated at initialization. The expression can evaluate to a constant value and can reference Global Variables, such as `myContainer-${C.env[\"CRIBL_WORKER_ID\"]}`."""

    deadletter_enabled: Annotated[
        Optional[bool], pydantic.Field(alias="deadletterEnabled")
    ] = False
    r"""If a file fails to move to its final destination after the maximum number of retries, move it to a designated directory to prevent further errors"""

    id: Optional[str] = None
    r"""Unique ID for this output"""

    pipeline: Optional[str] = None
    r"""Pipeline to process data before sending out to this output"""

    system_fields: Annotated[
        Optional[List[str]], pydantic.Field(alias="systemFields")
    ] = None
    r"""Fields to automatically add to events, such as cribl_pipe. Supports wildcards."""

    environment: Optional[str] = None
    r"""Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere."""

    streamtags: Optional[List[str]] = None
    r"""Tags for filtering and grouping in @{product}"""

    create_container: Annotated[
        Optional[bool], pydantic.Field(alias="createContainer")
    ] = False
    r"""Create the configured container in Azure Blob Storage if it does not already exist"""

    dest_path: Annotated[Optional[str], pydantic.Field(alias="destPath")] = None
    r"""Root directory prepended to path before uploading. Value can be a JavaScript expression enclosed in quotes or backticks, to be evaluated at initialization. The expression can evaluate to a constant value and can reference Global Variables, such as `myBlobPrefix-${C.env[\"CRIBL_WORKER_ID\"]}`."""

    stage_path: Annotated[Optional[str], pydantic.Field(alias="stagePath")] = (
        "$CRIBL_HOME/state/outputs/staging"
    )
    r"""Filesystem location in which to buffer files before compressing and moving to final destination. Use performant and stable storage."""

    add_id_to_stage_path: Annotated[
        Optional[bool], pydantic.Field(alias="addIdToStagePath")
    ] = True
    r"""Add the Output ID value to staging location"""

    max_concurrent_file_parts: Annotated[
        Optional[float], pydantic.Field(alias="maxConcurrentFileParts")
    ] = 1
    r"""Maximum number of parts to upload in parallel per file"""

    remove_empty_dirs: Annotated[
        Optional[bool], pydantic.Field(alias="removeEmptyDirs")
    ] = True
    r"""Remove empty staging directories after moving files"""

    partition_expr: Annotated[Optional[str], pydantic.Field(alias="partitionExpr")] = (
        "C.Time.strftime(_time ? _time : Date.now()/1000, '%Y/%m/%d')"
    )
    r"""JavaScript expression defining how files are partitioned and organized. Default is date-based. If blank, Stream will fall back to the event's __partition field value – if present – otherwise to each location's root directory."""

    format_: Annotated[
        Annotated[Optional[Format1Options], PlainValidator(validate_open_enum(False))],
        pydantic.Field(alias="format"),
    ] = Format1Options.JSON
    r"""Format of the output data"""

    base_file_name: Annotated[Optional[str], pydantic.Field(alias="baseFileName")] = (
        "`CriblOut`"
    )
    r"""JavaScript expression to define the output filename prefix (can be constant)"""

    file_name_suffix: Annotated[
        Optional[str], pydantic.Field(alias="fileNameSuffix")
    ] = '`.${C.env["CRIBL_WORKER_ID"]}.${__format}${__compression === "gzip" ? ".gz" : ""}`'
    r"""JavaScript expression to define the output filename suffix (can be constant).  The `__format` variable refers to the value of the `Data format` field (`json` or `raw`).  The `__compression` field refers to the kind of compression being used (`none` or `gzip`)."""

    max_file_size_mb: Annotated[
        Optional[float], pydantic.Field(alias="maxFileSizeMB")
    ] = 32
    r"""Maximum uncompressed output file size. Files of this size will be closed and moved to final output location."""

    max_file_open_time_sec: Annotated[
        Optional[float], pydantic.Field(alias="maxFileOpenTimeSec")
    ] = 300
    r"""Maximum amount of time to write to a file. Files open for longer than this will be closed and moved to final output location."""

    max_file_idle_time_sec: Annotated[
        Optional[float], pydantic.Field(alias="maxFileIdleTimeSec")
    ] = 30
    r"""Maximum amount of time to keep inactive files open. Files open for longer than this will be closed and moved to final output location."""

    max_open_files: Annotated[Optional[float], pydantic.Field(alias="maxOpenFiles")] = (
        100
    )
    r"""Maximum number of files to keep open concurrently. When exceeded, @{product} will close the oldest open files and move them to the final output location."""

    header_line: Annotated[Optional[str], pydantic.Field(alias="headerLine")] = ""
    r"""If set, this line will be written to the beginning of each output file"""

    write_high_water_mark: Annotated[
        Optional[float], pydantic.Field(alias="writeHighWaterMark")
    ] = 64
    r"""Buffer size used to write to a file"""

    on_backpressure: Annotated[
        Annotated[
            Optional[PqOnBackpressureOptions], PlainValidator(validate_open_enum(False))
        ],
        pydantic.Field(alias="onBackpressure"),
    ] = PqOnBackpressureOptions.BLOCK
    r"""How to handle events when the queue is exerting backpressure (full capacity or low disk). 'Block' is the same behavior as non-PQ blocking. 'Drop new data' throws away incoming data, while leaving the contents of the PQ unchanged."""

    on_disk_full_backpressure: Annotated[
        Annotated[
            Optional[PqOnBackpressureOptions], PlainValidator(validate_open_enum(False))
        ],
        pydantic.Field(alias="onDiskFullBackpressure"),
    ] = PqOnBackpressureOptions.BLOCK
    r"""How to handle events when the queue is exerting backpressure (full capacity or low disk). 'Block' is the same behavior as non-PQ blocking. 'Drop new data' throws away incoming data, while leaving the contents of the PQ unchanged."""

    auth_type: Annotated[
        Annotated[
            Optional[AuthType1Options], PlainValidator(validate_open_enum(False))
        ],
        pydantic.Field(alias="authType"),
    ] = AuthType1Options.MANUAL

    storage_class: Annotated[
        Annotated[Optional[BlobAccessTier5], PlainValidator(validate_open_enum(False))],
        pydantic.Field(alias="storageClass"),
    ] = BlobAccessTier5.INFERRED

    description: Optional[str] = None

    compress: Annotated[
        Optional[PqCompressOptions], PlainValidator(validate_open_enum(False))
    ] = PqCompressOptions.NONE
    r"""Codec to use to compress the persisted data"""

    compression_level: Annotated[
        Annotated[
            Optional[CompressionLevelOptions], PlainValidator(validate_open_enum(False))
        ],
        pydantic.Field(alias="compressionLevel"),
    ] = CompressionLevelOptions.BEST_SPEED
    r"""Compression level to apply before moving files to final destination"""

    automatic_schema: Annotated[
        Optional[bool], pydantic.Field(alias="automaticSchema")
    ] = False
    r"""Automatically calculate the schema based on the events of each Parquet file generated"""

    parquet_schema: Annotated[Optional[str], pydantic.Field(alias="parquetSchema")] = (
        None
    )
    r"""To add a new schema, navigate to Processing > Knowledge > Parquet Schemas"""

    parquet_version: Annotated[
        Annotated[
            Optional[ParquetVersionOptions], PlainValidator(validate_open_enum(False))
        ],
        pydantic.Field(alias="parquetVersion"),
    ] = ParquetVersionOptions.PARQUET_2_6
    r"""Determines which data types are supported and how they are represented"""

    parquet_data_page_version: Annotated[
        Annotated[
            Optional[ParquetDataPageVersionOptions],
            PlainValidator(validate_open_enum(False)),
        ],
        pydantic.Field(alias="parquetDataPageVersion"),
    ] = ParquetDataPageVersionOptions.DATA_PAGE_V2
    r"""Serialization format of data pages. Note that some reader implementations use Data page V2's attributes to work more efficiently, while others ignore it."""

    parquet_row_group_length: Annotated[
        Optional[float], pydantic.Field(alias="parquetRowGroupLength")
    ] = 10000
    r"""The number of rows that every group will contain. The final group can contain a smaller number of rows."""

    parquet_page_size: Annotated[
        Optional[str], pydantic.Field(alias="parquetPageSize")
    ] = "1MB"
    r"""Target memory size for page segments, such as 1MB or 128MB. Generally, lower values improve reading speed, while higher values improve compression."""

    should_log_invalid_rows: Annotated[
        Optional[bool], pydantic.Field(alias="shouldLogInvalidRows")
    ] = None
    r"""Log up to 3 rows that @{product} skips due to data mismatch"""

    key_value_metadata: Annotated[
        Optional[List[TagsType]], pydantic.Field(alias="keyValueMetadata")
    ] = None
    r"""The metadata of files the Destination writes will include the properties you add here as key-value pairs. Useful for tagging. Examples: \"key\":\"OCSF Event Class\", \"value\":\"9001\" """

    enable_statistics: Annotated[
        Optional[bool], pydantic.Field(alias="enableStatistics")
    ] = True
    r"""Statistics profile an entire file in terms of minimum/maximum values within data, numbers of nulls, etc. You can use Parquet tools to view statistics."""

    enable_write_page_index: Annotated[
        Optional[bool], pydantic.Field(alias="enableWritePageIndex")
    ] = True
    r"""One page index contains statistics for one data page. Parquet readers use statistics to enable page skipping."""

    enable_page_checksum: Annotated[
        Optional[bool], pydantic.Field(alias="enablePageChecksum")
    ] = False
    r"""Parquet tools can use the checksum of a Parquet page to verify data integrity"""

    empty_dir_cleanup_sec: Annotated[
        Optional[float], pydantic.Field(alias="emptyDirCleanupSec")
    ] = 300
    r"""How frequently, in seconds, to clean up empty directories"""

    deadletter_path: Annotated[
        Optional[str], pydantic.Field(alias="deadletterPath")
    ] = "$CRIBL_HOME/state/outputs/dead-letter"
    r"""Storage location for files that fail to reach their final destination after maximum retries are exceeded"""

    max_retry_num: Annotated[Optional[float], pydantic.Field(alias="maxRetryNum")] = 20
    r"""The maximum number of times a file will attempt to move to its final destination before being dead-lettered"""

    connection_string: Annotated[
        Optional[str], pydantic.Field(alias="connectionString")
    ] = None
    r"""Enter your Azure Storage account connection string. If left blank, Stream will fall back to env.AZURE_STORAGE_CONNECTION_STRING."""

    text_secret: Annotated[Optional[str], pydantic.Field(alias="textSecret")] = None
    r"""Select or create a stored text secret"""

    storage_account_name: Annotated[
        Optional[str], pydantic.Field(alias="storageAccountName")
    ] = None
    r"""The name of your Azure storage account"""

    tenant_id: Annotated[Optional[str], pydantic.Field(alias="tenantId")] = None
    r"""The service principal's tenant ID"""

    client_id: Annotated[Optional[str], pydantic.Field(alias="clientId")] = None
    r"""The service principal's client ID"""

    azure_cloud: Annotated[Optional[str], pydantic.Field(alias="azureCloud")] = None
    r"""The Azure cloud to use. Defaults to Azure Public Cloud."""

    endpoint_suffix: Annotated[
        Optional[str], pydantic.Field(alias="endpointSuffix")
    ] = None
    r"""Endpoint suffix for the service URL. Takes precedence over the Azure Cloud setting. Defaults to core.windows.net."""

    client_text_secret: Annotated[
        Optional[str], pydantic.Field(alias="clientTextSecret")
    ] = None
    r"""Select or create a stored text secret"""

    certificate: Optional[CertificateType] = None

    @field_serializer("format_")
    def serialize_format_(self, value):
        if isinstance(value, str):
            try:
                return models.Format1Options(value)
            except ValueError:
                return value
        return value

    @field_serializer("on_backpressure")
    def serialize_on_backpressure(self, value):
        if isinstance(value, str):
            try:
                return models.PqOnBackpressureOptions(value)
            except ValueError:
                return value
        return value

    @field_serializer("on_disk_full_backpressure")
    def serialize_on_disk_full_backpressure(self, value):
        if isinstance(value, str):
            try:
                return models.PqOnBackpressureOptions(value)
            except ValueError:
                return value
        return value

    @field_serializer("auth_type")
    def serialize_auth_type(self, value):
        if isinstance(value, str):
            try:
                return models.AuthType1Options(value)
            except ValueError:
                return value
        return value

    @field_serializer("storage_class")
    def serialize_storage_class(self, value):
        if isinstance(value, str):
            try:
                return models.BlobAccessTier5(value)
            except ValueError:
                return value
        return value

    @field_serializer("compress")
    def serialize_compress(self, value):
        if isinstance(value, str):
            try:
                return models.PqCompressOptions(value)
            except ValueError:
                return value
        return value

    @field_serializer("compression_level")
    def serialize_compression_level(self, value):
        if isinstance(value, str):
            try:
                return models.CompressionLevelOptions(value)
            except ValueError:
                return value
        return value

    @field_serializer("parquet_version")
    def serialize_parquet_version(self, value):
        if isinstance(value, str):
            try:
                return models.ParquetVersionOptions(value)
            except ValueError:
                return value
        return value

    @field_serializer("parquet_data_page_version")
    def serialize_parquet_data_page_version(self, value):
        if isinstance(value, str):
            try:
                return models.ParquetDataPageVersionOptions(value)
            except ValueError:
                return value
        return value


class BlobAccessTier4(str, Enum, metaclass=utils.OpenEnumMeta):
    # Default account access tier
    INFERRED = "Inferred"
    # Hot tier
    HOT = "Hot"
    # Cool tier
    COOL = "Cool"
    # Cold tier
    COLD = "Cold"
    # Archive tier
    ARCHIVE = "Archive"


class OutputAzureBlobAzureBlob4TypedDict(TypedDict):
    type: TypeAzureBlobOption
    container_name: str
    r"""The Azure Blob Storage container name. Name can include only lowercase letters, numbers, and hyphens. For dynamic container names, enter a JavaScript expression within quotes or backticks, to be evaluated at initialization. The expression can evaluate to a constant value and can reference Global Variables, such as `myContainer-${C.env[\"CRIBL_WORKER_ID\"]}`."""
    remove_empty_dirs: NotRequired[bool]
    r"""Remove empty staging directories after moving files"""
    id: NotRequired[str]
    r"""Unique ID for this output"""
    pipeline: NotRequired[str]
    r"""Pipeline to process data before sending out to this output"""
    system_fields: NotRequired[List[str]]
    r"""Fields to automatically add to events, such as cribl_pipe. Supports wildcards."""
    environment: NotRequired[str]
    r"""Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere."""
    streamtags: NotRequired[List[str]]
    r"""Tags for filtering and grouping in @{product}"""
    create_container: NotRequired[bool]
    r"""Create the configured container in Azure Blob Storage if it does not already exist"""
    dest_path: NotRequired[str]
    r"""Root directory prepended to path before uploading. Value can be a JavaScript expression enclosed in quotes or backticks, to be evaluated at initialization. The expression can evaluate to a constant value and can reference Global Variables, such as `myBlobPrefix-${C.env[\"CRIBL_WORKER_ID\"]}`."""
    stage_path: NotRequired[str]
    r"""Filesystem location in which to buffer files before compressing and moving to final destination. Use performant and stable storage."""
    add_id_to_stage_path: NotRequired[bool]
    r"""Add the Output ID value to staging location"""
    max_concurrent_file_parts: NotRequired[float]
    r"""Maximum number of parts to upload in parallel per file"""
    partition_expr: NotRequired[str]
    r"""JavaScript expression defining how files are partitioned and organized. Default is date-based. If blank, Stream will fall back to the event's __partition field value – if present – otherwise to each location's root directory."""
    format_: NotRequired[Format1Options]
    r"""Format of the output data"""
    base_file_name: NotRequired[str]
    r"""JavaScript expression to define the output filename prefix (can be constant)"""
    file_name_suffix: NotRequired[str]
    r"""JavaScript expression to define the output filename suffix (can be constant).  The `__format` variable refers to the value of the `Data format` field (`json` or `raw`).  The `__compression` field refers to the kind of compression being used (`none` or `gzip`)."""
    max_file_size_mb: NotRequired[float]
    r"""Maximum uncompressed output file size. Files of this size will be closed and moved to final output location."""
    max_file_open_time_sec: NotRequired[float]
    r"""Maximum amount of time to write to a file. Files open for longer than this will be closed and moved to final output location."""
    max_file_idle_time_sec: NotRequired[float]
    r"""Maximum amount of time to keep inactive files open. Files open for longer than this will be closed and moved to final output location."""
    max_open_files: NotRequired[float]
    r"""Maximum number of files to keep open concurrently. When exceeded, @{product} will close the oldest open files and move them to the final output location."""
    header_line: NotRequired[str]
    r"""If set, this line will be written to the beginning of each output file"""
    write_high_water_mark: NotRequired[float]
    r"""Buffer size used to write to a file"""
    on_backpressure: NotRequired[PqOnBackpressureOptions]
    r"""How to handle events when the queue is exerting backpressure (full capacity or low disk). 'Block' is the same behavior as non-PQ blocking. 'Drop new data' throws away incoming data, while leaving the contents of the PQ unchanged."""
    deadletter_enabled: NotRequired[bool]
    r"""If a file fails to move to its final destination after the maximum number of retries, move it to a designated directory to prevent further errors"""
    on_disk_full_backpressure: NotRequired[PqOnBackpressureOptions]
    r"""How to handle events when the queue is exerting backpressure (full capacity or low disk). 'Block' is the same behavior as non-PQ blocking. 'Drop new data' throws away incoming data, while leaving the contents of the PQ unchanged."""
    auth_type: NotRequired[AuthType1Options]
    storage_class: NotRequired[BlobAccessTier4]
    description: NotRequired[str]
    compress: NotRequired[PqCompressOptions]
    r"""Codec to use to compress the persisted data"""
    compression_level: NotRequired[CompressionLevelOptions]
    r"""Compression level to apply before moving files to final destination"""
    automatic_schema: NotRequired[bool]
    r"""Automatically calculate the schema based on the events of each Parquet file generated"""
    parquet_schema: NotRequired[str]
    r"""To add a new schema, navigate to Processing > Knowledge > Parquet Schemas"""
    parquet_version: NotRequired[ParquetVersionOptions]
    r"""Determines which data types are supported and how they are represented"""
    parquet_data_page_version: NotRequired[ParquetDataPageVersionOptions]
    r"""Serialization format of data pages. Note that some reader implementations use Data page V2's attributes to work more efficiently, while others ignore it."""
    parquet_row_group_length: NotRequired[float]
    r"""The number of rows that every group will contain. The final group can contain a smaller number of rows."""
    parquet_page_size: NotRequired[str]
    r"""Target memory size for page segments, such as 1MB or 128MB. Generally, lower values improve reading speed, while higher values improve compression."""
    should_log_invalid_rows: NotRequired[bool]
    r"""Log up to 3 rows that @{product} skips due to data mismatch"""
    key_value_metadata: NotRequired[List[TagsTypeTypedDict]]
    r"""The metadata of files the Destination writes will include the properties you add here as key-value pairs. Useful for tagging. Examples: \"key\":\"OCSF Event Class\", \"value\":\"9001\" """
    enable_statistics: NotRequired[bool]
    r"""Statistics profile an entire file in terms of minimum/maximum values within data, numbers of nulls, etc. You can use Parquet tools to view statistics."""
    enable_write_page_index: NotRequired[bool]
    r"""One page index contains statistics for one data page. Parquet readers use statistics to enable page skipping."""
    enable_page_checksum: NotRequired[bool]
    r"""Parquet tools can use the checksum of a Parquet page to verify data integrity"""
    empty_dir_cleanup_sec: NotRequired[float]
    r"""How frequently, in seconds, to clean up empty directories"""
    deadletter_path: NotRequired[str]
    r"""Storage location for files that fail to reach their final destination after maximum retries are exceeded"""
    max_retry_num: NotRequired[float]
    r"""The maximum number of times a file will attempt to move to its final destination before being dead-lettered"""
    connection_string: NotRequired[str]
    r"""Enter your Azure Storage account connection string. If left blank, Stream will fall back to env.AZURE_STORAGE_CONNECTION_STRING."""
    text_secret: NotRequired[str]
    r"""Select or create a stored text secret"""
    storage_account_name: NotRequired[str]
    r"""The name of your Azure storage account"""
    tenant_id: NotRequired[str]
    r"""The service principal's tenant ID"""
    client_id: NotRequired[str]
    r"""The service principal's client ID"""
    azure_cloud: NotRequired[str]
    r"""The Azure cloud to use. Defaults to Azure Public Cloud."""
    endpoint_suffix: NotRequired[str]
    r"""Endpoint suffix for the service URL. Takes precedence over the Azure Cloud setting. Defaults to core.windows.net."""
    client_text_secret: NotRequired[str]
    r"""Select or create a stored text secret"""
    certificate: NotRequired[CertificateTypeTypedDict]


class OutputAzureBlobAzureBlob4(BaseModel):
    type: TypeAzureBlobOption

    container_name: Annotated[str, pydantic.Field(alias="containerName")]
    r"""The Azure Blob Storage container name. Name can include only lowercase letters, numbers, and hyphens. For dynamic container names, enter a JavaScript expression within quotes or backticks, to be evaluated at initialization. The expression can evaluate to a constant value and can reference Global Variables, such as `myContainer-${C.env[\"CRIBL_WORKER_ID\"]}`."""

    remove_empty_dirs: Annotated[
        Optional[bool], pydantic.Field(alias="removeEmptyDirs")
    ] = True
    r"""Remove empty staging directories after moving files"""

    id: Optional[str] = None
    r"""Unique ID for this output"""

    pipeline: Optional[str] = None
    r"""Pipeline to process data before sending out to this output"""

    system_fields: Annotated[
        Optional[List[str]], pydantic.Field(alias="systemFields")
    ] = None
    r"""Fields to automatically add to events, such as cribl_pipe. Supports wildcards."""

    environment: Optional[str] = None
    r"""Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere."""

    streamtags: Optional[List[str]] = None
    r"""Tags for filtering and grouping in @{product}"""

    create_container: Annotated[
        Optional[bool], pydantic.Field(alias="createContainer")
    ] = False
    r"""Create the configured container in Azure Blob Storage if it does not already exist"""

    dest_path: Annotated[Optional[str], pydantic.Field(alias="destPath")] = None
    r"""Root directory prepended to path before uploading. Value can be a JavaScript expression enclosed in quotes or backticks, to be evaluated at initialization. The expression can evaluate to a constant value and can reference Global Variables, such as `myBlobPrefix-${C.env[\"CRIBL_WORKER_ID\"]}`."""

    stage_path: Annotated[Optional[str], pydantic.Field(alias="stagePath")] = (
        "$CRIBL_HOME/state/outputs/staging"
    )
    r"""Filesystem location in which to buffer files before compressing and moving to final destination. Use performant and stable storage."""

    add_id_to_stage_path: Annotated[
        Optional[bool], pydantic.Field(alias="addIdToStagePath")
    ] = True
    r"""Add the Output ID value to staging location"""

    max_concurrent_file_parts: Annotated[
        Optional[float], pydantic.Field(alias="maxConcurrentFileParts")
    ] = 1
    r"""Maximum number of parts to upload in parallel per file"""

    partition_expr: Annotated[Optional[str], pydantic.Field(alias="partitionExpr")] = (
        "C.Time.strftime(_time ? _time : Date.now()/1000, '%Y/%m/%d')"
    )
    r"""JavaScript expression defining how files are partitioned and organized. Default is date-based. If blank, Stream will fall back to the event's __partition field value – if present – otherwise to each location's root directory."""

    format_: Annotated[
        Annotated[Optional[Format1Options], PlainValidator(validate_open_enum(False))],
        pydantic.Field(alias="format"),
    ] = Format1Options.JSON
    r"""Format of the output data"""

    base_file_name: Annotated[Optional[str], pydantic.Field(alias="baseFileName")] = (
        "`CriblOut`"
    )
    r"""JavaScript expression to define the output filename prefix (can be constant)"""

    file_name_suffix: Annotated[
        Optional[str], pydantic.Field(alias="fileNameSuffix")
    ] = '`.${C.env["CRIBL_WORKER_ID"]}.${__format}${__compression === "gzip" ? ".gz" : ""}`'
    r"""JavaScript expression to define the output filename suffix (can be constant).  The `__format` variable refers to the value of the `Data format` field (`json` or `raw`).  The `__compression` field refers to the kind of compression being used (`none` or `gzip`)."""

    max_file_size_mb: Annotated[
        Optional[float], pydantic.Field(alias="maxFileSizeMB")
    ] = 32
    r"""Maximum uncompressed output file size. Files of this size will be closed and moved to final output location."""

    max_file_open_time_sec: Annotated[
        Optional[float], pydantic.Field(alias="maxFileOpenTimeSec")
    ] = 300
    r"""Maximum amount of time to write to a file. Files open for longer than this will be closed and moved to final output location."""

    max_file_idle_time_sec: Annotated[
        Optional[float], pydantic.Field(alias="maxFileIdleTimeSec")
    ] = 30
    r"""Maximum amount of time to keep inactive files open. Files open for longer than this will be closed and moved to final output location."""

    max_open_files: Annotated[Optional[float], pydantic.Field(alias="maxOpenFiles")] = (
        100
    )
    r"""Maximum number of files to keep open concurrently. When exceeded, @{product} will close the oldest open files and move them to the final output location."""

    header_line: Annotated[Optional[str], pydantic.Field(alias="headerLine")] = ""
    r"""If set, this line will be written to the beginning of each output file"""

    write_high_water_mark: Annotated[
        Optional[float], pydantic.Field(alias="writeHighWaterMark")
    ] = 64
    r"""Buffer size used to write to a file"""

    on_backpressure: Annotated[
        Annotated[
            Optional[PqOnBackpressureOptions], PlainValidator(validate_open_enum(False))
        ],
        pydantic.Field(alias="onBackpressure"),
    ] = PqOnBackpressureOptions.BLOCK
    r"""How to handle events when the queue is exerting backpressure (full capacity or low disk). 'Block' is the same behavior as non-PQ blocking. 'Drop new data' throws away incoming data, while leaving the contents of the PQ unchanged."""

    deadletter_enabled: Annotated[
        Optional[bool], pydantic.Field(alias="deadletterEnabled")
    ] = False
    r"""If a file fails to move to its final destination after the maximum number of retries, move it to a designated directory to prevent further errors"""

    on_disk_full_backpressure: Annotated[
        Annotated[
            Optional[PqOnBackpressureOptions], PlainValidator(validate_open_enum(False))
        ],
        pydantic.Field(alias="onDiskFullBackpressure"),
    ] = PqOnBackpressureOptions.BLOCK
    r"""How to handle events when the queue is exerting backpressure (full capacity or low disk). 'Block' is the same behavior as non-PQ blocking. 'Drop new data' throws away incoming data, while leaving the contents of the PQ unchanged."""

    auth_type: Annotated[
        Annotated[
            Optional[AuthType1Options], PlainValidator(validate_open_enum(False))
        ],
        pydantic.Field(alias="authType"),
    ] = AuthType1Options.MANUAL

    storage_class: Annotated[
        Annotated[Optional[BlobAccessTier4], PlainValidator(validate_open_enum(False))],
        pydantic.Field(alias="storageClass"),
    ] = BlobAccessTier4.INFERRED

    description: Optional[str] = None

    compress: Annotated[
        Optional[PqCompressOptions], PlainValidator(validate_open_enum(False))
    ] = PqCompressOptions.NONE
    r"""Codec to use to compress the persisted data"""

    compression_level: Annotated[
        Annotated[
            Optional[CompressionLevelOptions], PlainValidator(validate_open_enum(False))
        ],
        pydantic.Field(alias="compressionLevel"),
    ] = CompressionLevelOptions.BEST_SPEED
    r"""Compression level to apply before moving files to final destination"""

    automatic_schema: Annotated[
        Optional[bool], pydantic.Field(alias="automaticSchema")
    ] = False
    r"""Automatically calculate the schema based on the events of each Parquet file generated"""

    parquet_schema: Annotated[Optional[str], pydantic.Field(alias="parquetSchema")] = (
        None
    )
    r"""To add a new schema, navigate to Processing > Knowledge > Parquet Schemas"""

    parquet_version: Annotated[
        Annotated[
            Optional[ParquetVersionOptions], PlainValidator(validate_open_enum(False))
        ],
        pydantic.Field(alias="parquetVersion"),
    ] = ParquetVersionOptions.PARQUET_2_6
    r"""Determines which data types are supported and how they are represented"""

    parquet_data_page_version: Annotated[
        Annotated[
            Optional[ParquetDataPageVersionOptions],
            PlainValidator(validate_open_enum(False)),
        ],
        pydantic.Field(alias="parquetDataPageVersion"),
    ] = ParquetDataPageVersionOptions.DATA_PAGE_V2
    r"""Serialization format of data pages. Note that some reader implementations use Data page V2's attributes to work more efficiently, while others ignore it."""

    parquet_row_group_length: Annotated[
        Optional[float], pydantic.Field(alias="parquetRowGroupLength")
    ] = 10000
    r"""The number of rows that every group will contain. The final group can contain a smaller number of rows."""

    parquet_page_size: Annotated[
        Optional[str], pydantic.Field(alias="parquetPageSize")
    ] = "1MB"
    r"""Target memory size for page segments, such as 1MB or 128MB. Generally, lower values improve reading speed, while higher values improve compression."""

    should_log_invalid_rows: Annotated[
        Optional[bool], pydantic.Field(alias="shouldLogInvalidRows")
    ] = None
    r"""Log up to 3 rows that @{product} skips due to data mismatch"""

    key_value_metadata: Annotated[
        Optional[List[TagsType]], pydantic.Field(alias="keyValueMetadata")
    ] = None
    r"""The metadata of files the Destination writes will include the properties you add here as key-value pairs. Useful for tagging. Examples: \"key\":\"OCSF Event Class\", \"value\":\"9001\" """

    enable_statistics: Annotated[
        Optional[bool], pydantic.Field(alias="enableStatistics")
    ] = True
    r"""Statistics profile an entire file in terms of minimum/maximum values within data, numbers of nulls, etc. You can use Parquet tools to view statistics."""

    enable_write_page_index: Annotated[
        Optional[bool], pydantic.Field(alias="enableWritePageIndex")
    ] = True
    r"""One page index contains statistics for one data page. Parquet readers use statistics to enable page skipping."""

    enable_page_checksum: Annotated[
        Optional[bool], pydantic.Field(alias="enablePageChecksum")
    ] = False
    r"""Parquet tools can use the checksum of a Parquet page to verify data integrity"""

    empty_dir_cleanup_sec: Annotated[
        Optional[float], pydantic.Field(alias="emptyDirCleanupSec")
    ] = 300
    r"""How frequently, in seconds, to clean up empty directories"""

    deadletter_path: Annotated[
        Optional[str], pydantic.Field(alias="deadletterPath")
    ] = "$CRIBL_HOME/state/outputs/dead-letter"
    r"""Storage location for files that fail to reach their final destination after maximum retries are exceeded"""

    max_retry_num: Annotated[Optional[float], pydantic.Field(alias="maxRetryNum")] = 20
    r"""The maximum number of times a file will attempt to move to its final destination before being dead-lettered"""

    connection_string: Annotated[
        Optional[str], pydantic.Field(alias="connectionString")
    ] = None
    r"""Enter your Azure Storage account connection string. If left blank, Stream will fall back to env.AZURE_STORAGE_CONNECTION_STRING."""

    text_secret: Annotated[Optional[str], pydantic.Field(alias="textSecret")] = None
    r"""Select or create a stored text secret"""

    storage_account_name: Annotated[
        Optional[str], pydantic.Field(alias="storageAccountName")
    ] = None
    r"""The name of your Azure storage account"""

    tenant_id: Annotated[Optional[str], pydantic.Field(alias="tenantId")] = None
    r"""The service principal's tenant ID"""

    client_id: Annotated[Optional[str], pydantic.Field(alias="clientId")] = None
    r"""The service principal's client ID"""

    azure_cloud: Annotated[Optional[str], pydantic.Field(alias="azureCloud")] = None
    r"""The Azure cloud to use. Defaults to Azure Public Cloud."""

    endpoint_suffix: Annotated[
        Optional[str], pydantic.Field(alias="endpointSuffix")
    ] = None
    r"""Endpoint suffix for the service URL. Takes precedence over the Azure Cloud setting. Defaults to core.windows.net."""

    client_text_secret: Annotated[
        Optional[str], pydantic.Field(alias="clientTextSecret")
    ] = None
    r"""Select or create a stored text secret"""

    certificate: Optional[CertificateType] = None

    @field_serializer("format_")
    def serialize_format_(self, value):
        if isinstance(value, str):
            try:
                return models.Format1Options(value)
            except ValueError:
                return value
        return value

    @field_serializer("on_backpressure")
    def serialize_on_backpressure(self, value):
        if isinstance(value, str):
            try:
                return models.PqOnBackpressureOptions(value)
            except ValueError:
                return value
        return value

    @field_serializer("on_disk_full_backpressure")
    def serialize_on_disk_full_backpressure(self, value):
        if isinstance(value, str):
            try:
                return models.PqOnBackpressureOptions(value)
            except ValueError:
                return value
        return value

    @field_serializer("auth_type")
    def serialize_auth_type(self, value):
        if isinstance(value, str):
            try:
                return models.AuthType1Options(value)
            except ValueError:
                return value
        return value

    @field_serializer("storage_class")
    def serialize_storage_class(self, value):
        if isinstance(value, str):
            try:
                return models.BlobAccessTier4(value)
            except ValueError:
                return value
        return value

    @field_serializer("compress")
    def serialize_compress(self, value):
        if isinstance(value, str):
            try:
                return models.PqCompressOptions(value)
            except ValueError:
                return value
        return value

    @field_serializer("compression_level")
    def serialize_compression_level(self, value):
        if isinstance(value, str):
            try:
                return models.CompressionLevelOptions(value)
            except ValueError:
                return value
        return value

    @field_serializer("parquet_version")
    def serialize_parquet_version(self, value):
        if isinstance(value, str):
            try:
                return models.ParquetVersionOptions(value)
            except ValueError:
                return value
        return value

    @field_serializer("parquet_data_page_version")
    def serialize_parquet_data_page_version(self, value):
        if isinstance(value, str):
            try:
                return models.ParquetDataPageVersionOptions(value)
            except ValueError:
                return value
        return value


class BlobAccessTier3(str, Enum, metaclass=utils.OpenEnumMeta):
    # Default account access tier
    INFERRED = "Inferred"
    # Hot tier
    HOT = "Hot"
    # Cool tier
    COOL = "Cool"
    # Cold tier
    COLD = "Cold"
    # Archive tier
    ARCHIVE = "Archive"


class OutputAzureBlobAzureBlob3TypedDict(TypedDict):
    type: TypeAzureBlobOption
    container_name: str
    r"""The Azure Blob Storage container name. Name can include only lowercase letters, numbers, and hyphens. For dynamic container names, enter a JavaScript expression within quotes or backticks, to be evaluated at initialization. The expression can evaluate to a constant value and can reference Global Variables, such as `myContainer-${C.env[\"CRIBL_WORKER_ID\"]}`."""
    remove_empty_dirs: NotRequired[bool]
    r"""Remove empty staging directories after moving files"""
    id: NotRequired[str]
    r"""Unique ID for this output"""
    pipeline: NotRequired[str]
    r"""Pipeline to process data before sending out to this output"""
    system_fields: NotRequired[List[str]]
    r"""Fields to automatically add to events, such as cribl_pipe. Supports wildcards."""
    environment: NotRequired[str]
    r"""Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere."""
    streamtags: NotRequired[List[str]]
    r"""Tags for filtering and grouping in @{product}"""
    create_container: NotRequired[bool]
    r"""Create the configured container in Azure Blob Storage if it does not already exist"""
    dest_path: NotRequired[str]
    r"""Root directory prepended to path before uploading. Value can be a JavaScript expression enclosed in quotes or backticks, to be evaluated at initialization. The expression can evaluate to a constant value and can reference Global Variables, such as `myBlobPrefix-${C.env[\"CRIBL_WORKER_ID\"]}`."""
    stage_path: NotRequired[str]
    r"""Filesystem location in which to buffer files before compressing and moving to final destination. Use performant and stable storage."""
    add_id_to_stage_path: NotRequired[bool]
    r"""Add the Output ID value to staging location"""
    max_concurrent_file_parts: NotRequired[float]
    r"""Maximum number of parts to upload in parallel per file"""
    partition_expr: NotRequired[str]
    r"""JavaScript expression defining how files are partitioned and organized. Default is date-based. If blank, Stream will fall back to the event's __partition field value – if present – otherwise to each location's root directory."""
    format_: NotRequired[Format1Options]
    r"""Format of the output data"""
    base_file_name: NotRequired[str]
    r"""JavaScript expression to define the output filename prefix (can be constant)"""
    file_name_suffix: NotRequired[str]
    r"""JavaScript expression to define the output filename suffix (can be constant).  The `__format` variable refers to the value of the `Data format` field (`json` or `raw`).  The `__compression` field refers to the kind of compression being used (`none` or `gzip`)."""
    max_file_size_mb: NotRequired[float]
    r"""Maximum uncompressed output file size. Files of this size will be closed and moved to final output location."""
    max_file_open_time_sec: NotRequired[float]
    r"""Maximum amount of time to write to a file. Files open for longer than this will be closed and moved to final output location."""
    max_file_idle_time_sec: NotRequired[float]
    r"""Maximum amount of time to keep inactive files open. Files open for longer than this will be closed and moved to final output location."""
    max_open_files: NotRequired[float]
    r"""Maximum number of files to keep open concurrently. When exceeded, @{product} will close the oldest open files and move them to the final output location."""
    header_line: NotRequired[str]
    r"""If set, this line will be written to the beginning of each output file"""
    write_high_water_mark: NotRequired[float]
    r"""Buffer size used to write to a file"""
    on_backpressure: NotRequired[PqOnBackpressureOptions]
    r"""How to handle events when the queue is exerting backpressure (full capacity or low disk). 'Block' is the same behavior as non-PQ blocking. 'Drop new data' throws away incoming data, while leaving the contents of the PQ unchanged."""
    deadletter_enabled: NotRequired[bool]
    r"""If a file fails to move to its final destination after the maximum number of retries, move it to a designated directory to prevent further errors"""
    on_disk_full_backpressure: NotRequired[PqOnBackpressureOptions]
    r"""How to handle events when the queue is exerting backpressure (full capacity or low disk). 'Block' is the same behavior as non-PQ blocking. 'Drop new data' throws away incoming data, while leaving the contents of the PQ unchanged."""
    auth_type: NotRequired[AuthType1Options]
    storage_class: NotRequired[BlobAccessTier3]
    description: NotRequired[str]
    compress: NotRequired[PqCompressOptions]
    r"""Codec to use to compress the persisted data"""
    compression_level: NotRequired[CompressionLevelOptions]
    r"""Compression level to apply before moving files to final destination"""
    automatic_schema: NotRequired[bool]
    r"""Automatically calculate the schema based on the events of each Parquet file generated"""
    parquet_schema: NotRequired[str]
    r"""To add a new schema, navigate to Processing > Knowledge > Parquet Schemas"""
    parquet_version: NotRequired[ParquetVersionOptions]
    r"""Determines which data types are supported and how they are represented"""
    parquet_data_page_version: NotRequired[ParquetDataPageVersionOptions]
    r"""Serialization format of data pages. Note that some reader implementations use Data page V2's attributes to work more efficiently, while others ignore it."""
    parquet_row_group_length: NotRequired[float]
    r"""The number of rows that every group will contain. The final group can contain a smaller number of rows."""
    parquet_page_size: NotRequired[str]
    r"""Target memory size for page segments, such as 1MB or 128MB. Generally, lower values improve reading speed, while higher values improve compression."""
    should_log_invalid_rows: NotRequired[bool]
    r"""Log up to 3 rows that @{product} skips due to data mismatch"""
    key_value_metadata: NotRequired[List[TagsTypeTypedDict]]
    r"""The metadata of files the Destination writes will include the properties you add here as key-value pairs. Useful for tagging. Examples: \"key\":\"OCSF Event Class\", \"value\":\"9001\" """
    enable_statistics: NotRequired[bool]
    r"""Statistics profile an entire file in terms of minimum/maximum values within data, numbers of nulls, etc. You can use Parquet tools to view statistics."""
    enable_write_page_index: NotRequired[bool]
    r"""One page index contains statistics for one data page. Parquet readers use statistics to enable page skipping."""
    enable_page_checksum: NotRequired[bool]
    r"""Parquet tools can use the checksum of a Parquet page to verify data integrity"""
    empty_dir_cleanup_sec: NotRequired[float]
    r"""How frequently, in seconds, to clean up empty directories"""
    deadletter_path: NotRequired[str]
    r"""Storage location for files that fail to reach their final destination after maximum retries are exceeded"""
    max_retry_num: NotRequired[float]
    r"""The maximum number of times a file will attempt to move to its final destination before being dead-lettered"""
    connection_string: NotRequired[str]
    r"""Enter your Azure Storage account connection string. If left blank, Stream will fall back to env.AZURE_STORAGE_CONNECTION_STRING."""
    text_secret: NotRequired[str]
    r"""Select or create a stored text secret"""
    storage_account_name: NotRequired[str]
    r"""The name of your Azure storage account"""
    tenant_id: NotRequired[str]
    r"""The service principal's tenant ID"""
    client_id: NotRequired[str]
    r"""The service principal's client ID"""
    azure_cloud: NotRequired[str]
    r"""The Azure cloud to use. Defaults to Azure Public Cloud."""
    endpoint_suffix: NotRequired[str]
    r"""Endpoint suffix for the service URL. Takes precedence over the Azure Cloud setting. Defaults to core.windows.net."""
    client_text_secret: NotRequired[str]
    r"""Select or create a stored text secret"""
    certificate: NotRequired[CertificateTypeTypedDict]


class OutputAzureBlobAzureBlob3(BaseModel):
    type: TypeAzureBlobOption

    container_name: Annotated[str, pydantic.Field(alias="containerName")]
    r"""The Azure Blob Storage container name. Name can include only lowercase letters, numbers, and hyphens. For dynamic container names, enter a JavaScript expression within quotes or backticks, to be evaluated at initialization. The expression can evaluate to a constant value and can reference Global Variables, such as `myContainer-${C.env[\"CRIBL_WORKER_ID\"]}`."""

    remove_empty_dirs: Annotated[
        Optional[bool], pydantic.Field(alias="removeEmptyDirs")
    ] = True
    r"""Remove empty staging directories after moving files"""

    id: Optional[str] = None
    r"""Unique ID for this output"""

    pipeline: Optional[str] = None
    r"""Pipeline to process data before sending out to this output"""

    system_fields: Annotated[
        Optional[List[str]], pydantic.Field(alias="systemFields")
    ] = None
    r"""Fields to automatically add to events, such as cribl_pipe. Supports wildcards."""

    environment: Optional[str] = None
    r"""Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere."""

    streamtags: Optional[List[str]] = None
    r"""Tags for filtering and grouping in @{product}"""

    create_container: Annotated[
        Optional[bool], pydantic.Field(alias="createContainer")
    ] = False
    r"""Create the configured container in Azure Blob Storage if it does not already exist"""

    dest_path: Annotated[Optional[str], pydantic.Field(alias="destPath")] = None
    r"""Root directory prepended to path before uploading. Value can be a JavaScript expression enclosed in quotes or backticks, to be evaluated at initialization. The expression can evaluate to a constant value and can reference Global Variables, such as `myBlobPrefix-${C.env[\"CRIBL_WORKER_ID\"]}`."""

    stage_path: Annotated[Optional[str], pydantic.Field(alias="stagePath")] = (
        "$CRIBL_HOME/state/outputs/staging"
    )
    r"""Filesystem location in which to buffer files before compressing and moving to final destination. Use performant and stable storage."""

    add_id_to_stage_path: Annotated[
        Optional[bool], pydantic.Field(alias="addIdToStagePath")
    ] = True
    r"""Add the Output ID value to staging location"""

    max_concurrent_file_parts: Annotated[
        Optional[float], pydantic.Field(alias="maxConcurrentFileParts")
    ] = 1
    r"""Maximum number of parts to upload in parallel per file"""

    partition_expr: Annotated[Optional[str], pydantic.Field(alias="partitionExpr")] = (
        "C.Time.strftime(_time ? _time : Date.now()/1000, '%Y/%m/%d')"
    )
    r"""JavaScript expression defining how files are partitioned and organized. Default is date-based. If blank, Stream will fall back to the event's __partition field value – if present – otherwise to each location's root directory."""

    format_: Annotated[
        Annotated[Optional[Format1Options], PlainValidator(validate_open_enum(False))],
        pydantic.Field(alias="format"),
    ] = Format1Options.JSON
    r"""Format of the output data"""

    base_file_name: Annotated[Optional[str], pydantic.Field(alias="baseFileName")] = (
        "`CriblOut`"
    )
    r"""JavaScript expression to define the output filename prefix (can be constant)"""

    file_name_suffix: Annotated[
        Optional[str], pydantic.Field(alias="fileNameSuffix")
    ] = '`.${C.env["CRIBL_WORKER_ID"]}.${__format}${__compression === "gzip" ? ".gz" : ""}`'
    r"""JavaScript expression to define the output filename suffix (can be constant).  The `__format` variable refers to the value of the `Data format` field (`json` or `raw`).  The `__compression` field refers to the kind of compression being used (`none` or `gzip`)."""

    max_file_size_mb: Annotated[
        Optional[float], pydantic.Field(alias="maxFileSizeMB")
    ] = 32
    r"""Maximum uncompressed output file size. Files of this size will be closed and moved to final output location."""

    max_file_open_time_sec: Annotated[
        Optional[float], pydantic.Field(alias="maxFileOpenTimeSec")
    ] = 300
    r"""Maximum amount of time to write to a file. Files open for longer than this will be closed and moved to final output location."""

    max_file_idle_time_sec: Annotated[
        Optional[float], pydantic.Field(alias="maxFileIdleTimeSec")
    ] = 30
    r"""Maximum amount of time to keep inactive files open. Files open for longer than this will be closed and moved to final output location."""

    max_open_files: Annotated[Optional[float], pydantic.Field(alias="maxOpenFiles")] = (
        100
    )
    r"""Maximum number of files to keep open concurrently. When exceeded, @{product} will close the oldest open files and move them to the final output location."""

    header_line: Annotated[Optional[str], pydantic.Field(alias="headerLine")] = ""
    r"""If set, this line will be written to the beginning of each output file"""

    write_high_water_mark: Annotated[
        Optional[float], pydantic.Field(alias="writeHighWaterMark")
    ] = 64
    r"""Buffer size used to write to a file"""

    on_backpressure: Annotated[
        Annotated[
            Optional[PqOnBackpressureOptions], PlainValidator(validate_open_enum(False))
        ],
        pydantic.Field(alias="onBackpressure"),
    ] = PqOnBackpressureOptions.BLOCK
    r"""How to handle events when the queue is exerting backpressure (full capacity or low disk). 'Block' is the same behavior as non-PQ blocking. 'Drop new data' throws away incoming data, while leaving the contents of the PQ unchanged."""

    deadletter_enabled: Annotated[
        Optional[bool], pydantic.Field(alias="deadletterEnabled")
    ] = False
    r"""If a file fails to move to its final destination after the maximum number of retries, move it to a designated directory to prevent further errors"""

    on_disk_full_backpressure: Annotated[
        Annotated[
            Optional[PqOnBackpressureOptions], PlainValidator(validate_open_enum(False))
        ],
        pydantic.Field(alias="onDiskFullBackpressure"),
    ] = PqOnBackpressureOptions.BLOCK
    r"""How to handle events when the queue is exerting backpressure (full capacity or low disk). 'Block' is the same behavior as non-PQ blocking. 'Drop new data' throws away incoming data, while leaving the contents of the PQ unchanged."""

    auth_type: Annotated[
        Annotated[
            Optional[AuthType1Options], PlainValidator(validate_open_enum(False))
        ],
        pydantic.Field(alias="authType"),
    ] = AuthType1Options.MANUAL

    storage_class: Annotated[
        Annotated[Optional[BlobAccessTier3], PlainValidator(validate_open_enum(False))],
        pydantic.Field(alias="storageClass"),
    ] = BlobAccessTier3.INFERRED

    description: Optional[str] = None

    compress: Annotated[
        Optional[PqCompressOptions], PlainValidator(validate_open_enum(False))
    ] = PqCompressOptions.NONE
    r"""Codec to use to compress the persisted data"""

    compression_level: Annotated[
        Annotated[
            Optional[CompressionLevelOptions], PlainValidator(validate_open_enum(False))
        ],
        pydantic.Field(alias="compressionLevel"),
    ] = CompressionLevelOptions.BEST_SPEED
    r"""Compression level to apply before moving files to final destination"""

    automatic_schema: Annotated[
        Optional[bool], pydantic.Field(alias="automaticSchema")
    ] = False
    r"""Automatically calculate the schema based on the events of each Parquet file generated"""

    parquet_schema: Annotated[Optional[str], pydantic.Field(alias="parquetSchema")] = (
        None
    )
    r"""To add a new schema, navigate to Processing > Knowledge > Parquet Schemas"""

    parquet_version: Annotated[
        Annotated[
            Optional[ParquetVersionOptions], PlainValidator(validate_open_enum(False))
        ],
        pydantic.Field(alias="parquetVersion"),
    ] = ParquetVersionOptions.PARQUET_2_6
    r"""Determines which data types are supported and how they are represented"""

    parquet_data_page_version: Annotated[
        Annotated[
            Optional[ParquetDataPageVersionOptions],
            PlainValidator(validate_open_enum(False)),
        ],
        pydantic.Field(alias="parquetDataPageVersion"),
    ] = ParquetDataPageVersionOptions.DATA_PAGE_V2
    r"""Serialization format of data pages. Note that some reader implementations use Data page V2's attributes to work more efficiently, while others ignore it."""

    parquet_row_group_length: Annotated[
        Optional[float], pydantic.Field(alias="parquetRowGroupLength")
    ] = 10000
    r"""The number of rows that every group will contain. The final group can contain a smaller number of rows."""

    parquet_page_size: Annotated[
        Optional[str], pydantic.Field(alias="parquetPageSize")
    ] = "1MB"
    r"""Target memory size for page segments, such as 1MB or 128MB. Generally, lower values improve reading speed, while higher values improve compression."""

    should_log_invalid_rows: Annotated[
        Optional[bool], pydantic.Field(alias="shouldLogInvalidRows")
    ] = None
    r"""Log up to 3 rows that @{product} skips due to data mismatch"""

    key_value_metadata: Annotated[
        Optional[List[TagsType]], pydantic.Field(alias="keyValueMetadata")
    ] = None
    r"""The metadata of files the Destination writes will include the properties you add here as key-value pairs. Useful for tagging. Examples: \"key\":\"OCSF Event Class\", \"value\":\"9001\" """

    enable_statistics: Annotated[
        Optional[bool], pydantic.Field(alias="enableStatistics")
    ] = True
    r"""Statistics profile an entire file in terms of minimum/maximum values within data, numbers of nulls, etc. You can use Parquet tools to view statistics."""

    enable_write_page_index: Annotated[
        Optional[bool], pydantic.Field(alias="enableWritePageIndex")
    ] = True
    r"""One page index contains statistics for one data page. Parquet readers use statistics to enable page skipping."""

    enable_page_checksum: Annotated[
        Optional[bool], pydantic.Field(alias="enablePageChecksum")
    ] = False
    r"""Parquet tools can use the checksum of a Parquet page to verify data integrity"""

    empty_dir_cleanup_sec: Annotated[
        Optional[float], pydantic.Field(alias="emptyDirCleanupSec")
    ] = 300
    r"""How frequently, in seconds, to clean up empty directories"""

    deadletter_path: Annotated[
        Optional[str], pydantic.Field(alias="deadletterPath")
    ] = "$CRIBL_HOME/state/outputs/dead-letter"
    r"""Storage location for files that fail to reach their final destination after maximum retries are exceeded"""

    max_retry_num: Annotated[Optional[float], pydantic.Field(alias="maxRetryNum")] = 20
    r"""The maximum number of times a file will attempt to move to its final destination before being dead-lettered"""

    connection_string: Annotated[
        Optional[str], pydantic.Field(alias="connectionString")
    ] = None
    r"""Enter your Azure Storage account connection string. If left blank, Stream will fall back to env.AZURE_STORAGE_CONNECTION_STRING."""

    text_secret: Annotated[Optional[str], pydantic.Field(alias="textSecret")] = None
    r"""Select or create a stored text secret"""

    storage_account_name: Annotated[
        Optional[str], pydantic.Field(alias="storageAccountName")
    ] = None
    r"""The name of your Azure storage account"""

    tenant_id: Annotated[Optional[str], pydantic.Field(alias="tenantId")] = None
    r"""The service principal's tenant ID"""

    client_id: Annotated[Optional[str], pydantic.Field(alias="clientId")] = None
    r"""The service principal's client ID"""

    azure_cloud: Annotated[Optional[str], pydantic.Field(alias="azureCloud")] = None
    r"""The Azure cloud to use. Defaults to Azure Public Cloud."""

    endpoint_suffix: Annotated[
        Optional[str], pydantic.Field(alias="endpointSuffix")
    ] = None
    r"""Endpoint suffix for the service URL. Takes precedence over the Azure Cloud setting. Defaults to core.windows.net."""

    client_text_secret: Annotated[
        Optional[str], pydantic.Field(alias="clientTextSecret")
    ] = None
    r"""Select or create a stored text secret"""

    certificate: Optional[CertificateType] = None

    @field_serializer("format_")
    def serialize_format_(self, value):
        if isinstance(value, str):
            try:
                return models.Format1Options(value)
            except ValueError:
                return value
        return value

    @field_serializer("on_backpressure")
    def serialize_on_backpressure(self, value):
        if isinstance(value, str):
            try:
                return models.PqOnBackpressureOptions(value)
            except ValueError:
                return value
        return value

    @field_serializer("on_disk_full_backpressure")
    def serialize_on_disk_full_backpressure(self, value):
        if isinstance(value, str):
            try:
                return models.PqOnBackpressureOptions(value)
            except ValueError:
                return value
        return value

    @field_serializer("auth_type")
    def serialize_auth_type(self, value):
        if isinstance(value, str):
            try:
                return models.AuthType1Options(value)
            except ValueError:
                return value
        return value

    @field_serializer("storage_class")
    def serialize_storage_class(self, value):
        if isinstance(value, str):
            try:
                return models.BlobAccessTier3(value)
            except ValueError:
                return value
        return value

    @field_serializer("compress")
    def serialize_compress(self, value):
        if isinstance(value, str):
            try:
                return models.PqCompressOptions(value)
            except ValueError:
                return value
        return value

    @field_serializer("compression_level")
    def serialize_compression_level(self, value):
        if isinstance(value, str):
            try:
                return models.CompressionLevelOptions(value)
            except ValueError:
                return value
        return value

    @field_serializer("parquet_version")
    def serialize_parquet_version(self, value):
        if isinstance(value, str):
            try:
                return models.ParquetVersionOptions(value)
            except ValueError:
                return value
        return value

    @field_serializer("parquet_data_page_version")
    def serialize_parquet_data_page_version(self, value):
        if isinstance(value, str):
            try:
                return models.ParquetDataPageVersionOptions(value)
            except ValueError:
                return value
        return value


class BlobAccessTier2(str, Enum, metaclass=utils.OpenEnumMeta):
    # Default account access tier
    INFERRED = "Inferred"
    # Hot tier
    HOT = "Hot"
    # Cool tier
    COOL = "Cool"
    # Cold tier
    COLD = "Cold"
    # Archive tier
    ARCHIVE = "Archive"


class OutputAzureBlobAzureBlob2TypedDict(TypedDict):
    type: TypeAzureBlobOption
    container_name: str
    r"""The Azure Blob Storage container name. Name can include only lowercase letters, numbers, and hyphens. For dynamic container names, enter a JavaScript expression within quotes or backticks, to be evaluated at initialization. The expression can evaluate to a constant value and can reference Global Variables, such as `myContainer-${C.env[\"CRIBL_WORKER_ID\"]}`."""
    should_log_invalid_rows: bool
    r"""Log up to 3 rows that @{product} skips due to data mismatch"""
    key_value_metadata: List[TagsTypeTypedDict]
    r"""The metadata of files the Destination writes will include the properties you add here as key-value pairs. Useful for tagging. Examples: \"key\":\"OCSF Event Class\", \"value\":\"9001\" """
    format_: NotRequired[Format1Options]
    r"""Format of the output data"""
    id: NotRequired[str]
    r"""Unique ID for this output"""
    pipeline: NotRequired[str]
    r"""Pipeline to process data before sending out to this output"""
    system_fields: NotRequired[List[str]]
    r"""Fields to automatically add to events, such as cribl_pipe. Supports wildcards."""
    environment: NotRequired[str]
    r"""Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere."""
    streamtags: NotRequired[List[str]]
    r"""Tags for filtering and grouping in @{product}"""
    create_container: NotRequired[bool]
    r"""Create the configured container in Azure Blob Storage if it does not already exist"""
    dest_path: NotRequired[str]
    r"""Root directory prepended to path before uploading. Value can be a JavaScript expression enclosed in quotes or backticks, to be evaluated at initialization. The expression can evaluate to a constant value and can reference Global Variables, such as `myBlobPrefix-${C.env[\"CRIBL_WORKER_ID\"]}`."""
    stage_path: NotRequired[str]
    r"""Filesystem location in which to buffer files before compressing and moving to final destination. Use performant and stable storage."""
    add_id_to_stage_path: NotRequired[bool]
    r"""Add the Output ID value to staging location"""
    max_concurrent_file_parts: NotRequired[float]
    r"""Maximum number of parts to upload in parallel per file"""
    remove_empty_dirs: NotRequired[bool]
    r"""Remove empty staging directories after moving files"""
    partition_expr: NotRequired[str]
    r"""JavaScript expression defining how files are partitioned and organized. Default is date-based. If blank, Stream will fall back to the event's __partition field value – if present – otherwise to each location's root directory."""
    base_file_name: NotRequired[str]
    r"""JavaScript expression to define the output filename prefix (can be constant)"""
    file_name_suffix: NotRequired[str]
    r"""JavaScript expression to define the output filename suffix (can be constant).  The `__format` variable refers to the value of the `Data format` field (`json` or `raw`).  The `__compression` field refers to the kind of compression being used (`none` or `gzip`)."""
    max_file_size_mb: NotRequired[float]
    r"""Maximum uncompressed output file size. Files of this size will be closed and moved to final output location."""
    max_file_open_time_sec: NotRequired[float]
    r"""Maximum amount of time to write to a file. Files open for longer than this will be closed and moved to final output location."""
    max_file_idle_time_sec: NotRequired[float]
    r"""Maximum amount of time to keep inactive files open. Files open for longer than this will be closed and moved to final output location."""
    max_open_files: NotRequired[float]
    r"""Maximum number of files to keep open concurrently. When exceeded, @{product} will close the oldest open files and move them to the final output location."""
    header_line: NotRequired[str]
    r"""If set, this line will be written to the beginning of each output file"""
    write_high_water_mark: NotRequired[float]
    r"""Buffer size used to write to a file"""
    on_backpressure: NotRequired[PqOnBackpressureOptions]
    r"""How to handle events when the queue is exerting backpressure (full capacity or low disk). 'Block' is the same behavior as non-PQ blocking. 'Drop new data' throws away incoming data, while leaving the contents of the PQ unchanged."""
    deadletter_enabled: NotRequired[bool]
    r"""If a file fails to move to its final destination after the maximum number of retries, move it to a designated directory to prevent further errors"""
    on_disk_full_backpressure: NotRequired[PqOnBackpressureOptions]
    r"""How to handle events when the queue is exerting backpressure (full capacity or low disk). 'Block' is the same behavior as non-PQ blocking. 'Drop new data' throws away incoming data, while leaving the contents of the PQ unchanged."""
    auth_type: NotRequired[AuthType1Options]
    storage_class: NotRequired[BlobAccessTier2]
    description: NotRequired[str]
    compress: NotRequired[PqCompressOptions]
    r"""Codec to use to compress the persisted data"""
    compression_level: NotRequired[CompressionLevelOptions]
    r"""Compression level to apply before moving files to final destination"""
    automatic_schema: NotRequired[bool]
    r"""Automatically calculate the schema based on the events of each Parquet file generated"""
    parquet_schema: NotRequired[str]
    r"""To add a new schema, navigate to Processing > Knowledge > Parquet Schemas"""
    parquet_version: NotRequired[ParquetVersionOptions]
    r"""Determines which data types are supported and how they are represented"""
    parquet_data_page_version: NotRequired[ParquetDataPageVersionOptions]
    r"""Serialization format of data pages. Note that some reader implementations use Data page V2's attributes to work more efficiently, while others ignore it."""
    parquet_row_group_length: NotRequired[float]
    r"""The number of rows that every group will contain. The final group can contain a smaller number of rows."""
    parquet_page_size: NotRequired[str]
    r"""Target memory size for page segments, such as 1MB or 128MB. Generally, lower values improve reading speed, while higher values improve compression."""
    enable_statistics: NotRequired[bool]
    r"""Statistics profile an entire file in terms of minimum/maximum values within data, numbers of nulls, etc. You can use Parquet tools to view statistics."""
    enable_write_page_index: NotRequired[bool]
    r"""One page index contains statistics for one data page. Parquet readers use statistics to enable page skipping."""
    enable_page_checksum: NotRequired[bool]
    r"""Parquet tools can use the checksum of a Parquet page to verify data integrity"""
    empty_dir_cleanup_sec: NotRequired[float]
    r"""How frequently, in seconds, to clean up empty directories"""
    deadletter_path: NotRequired[str]
    r"""Storage location for files that fail to reach their final destination after maximum retries are exceeded"""
    max_retry_num: NotRequired[float]
    r"""The maximum number of times a file will attempt to move to its final destination before being dead-lettered"""
    connection_string: NotRequired[str]
    r"""Enter your Azure Storage account connection string. If left blank, Stream will fall back to env.AZURE_STORAGE_CONNECTION_STRING."""
    text_secret: NotRequired[str]
    r"""Select or create a stored text secret"""
    storage_account_name: NotRequired[str]
    r"""The name of your Azure storage account"""
    tenant_id: NotRequired[str]
    r"""The service principal's tenant ID"""
    client_id: NotRequired[str]
    r"""The service principal's client ID"""
    azure_cloud: NotRequired[str]
    r"""The Azure cloud to use. Defaults to Azure Public Cloud."""
    endpoint_suffix: NotRequired[str]
    r"""Endpoint suffix for the service URL. Takes precedence over the Azure Cloud setting. Defaults to core.windows.net."""
    client_text_secret: NotRequired[str]
    r"""Select or create a stored text secret"""
    certificate: NotRequired[CertificateTypeTypedDict]


class OutputAzureBlobAzureBlob2(BaseModel):
    type: TypeAzureBlobOption

    container_name: Annotated[str, pydantic.Field(alias="containerName")]
    r"""The Azure Blob Storage container name. Name can include only lowercase letters, numbers, and hyphens. For dynamic container names, enter a JavaScript expression within quotes or backticks, to be evaluated at initialization. The expression can evaluate to a constant value and can reference Global Variables, such as `myContainer-${C.env[\"CRIBL_WORKER_ID\"]}`."""

    should_log_invalid_rows: Annotated[
        bool, pydantic.Field(alias="shouldLogInvalidRows")
    ]
    r"""Log up to 3 rows that @{product} skips due to data mismatch"""

    key_value_metadata: Annotated[
        List[TagsType], pydantic.Field(alias="keyValueMetadata")
    ]
    r"""The metadata of files the Destination writes will include the properties you add here as key-value pairs. Useful for tagging. Examples: \"key\":\"OCSF Event Class\", \"value\":\"9001\" """

    format_: Annotated[
        Annotated[Optional[Format1Options], PlainValidator(validate_open_enum(False))],
        pydantic.Field(alias="format"),
    ] = Format1Options.JSON
    r"""Format of the output data"""

    id: Optional[str] = None
    r"""Unique ID for this output"""

    pipeline: Optional[str] = None
    r"""Pipeline to process data before sending out to this output"""

    system_fields: Annotated[
        Optional[List[str]], pydantic.Field(alias="systemFields")
    ] = None
    r"""Fields to automatically add to events, such as cribl_pipe. Supports wildcards."""

    environment: Optional[str] = None
    r"""Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere."""

    streamtags: Optional[List[str]] = None
    r"""Tags for filtering and grouping in @{product}"""

    create_container: Annotated[
        Optional[bool], pydantic.Field(alias="createContainer")
    ] = False
    r"""Create the configured container in Azure Blob Storage if it does not already exist"""

    dest_path: Annotated[Optional[str], pydantic.Field(alias="destPath")] = None
    r"""Root directory prepended to path before uploading. Value can be a JavaScript expression enclosed in quotes or backticks, to be evaluated at initialization. The expression can evaluate to a constant value and can reference Global Variables, such as `myBlobPrefix-${C.env[\"CRIBL_WORKER_ID\"]}`."""

    stage_path: Annotated[Optional[str], pydantic.Field(alias="stagePath")] = (
        "$CRIBL_HOME/state/outputs/staging"
    )
    r"""Filesystem location in which to buffer files before compressing and moving to final destination. Use performant and stable storage."""

    add_id_to_stage_path: Annotated[
        Optional[bool], pydantic.Field(alias="addIdToStagePath")
    ] = True
    r"""Add the Output ID value to staging location"""

    max_concurrent_file_parts: Annotated[
        Optional[float], pydantic.Field(alias="maxConcurrentFileParts")
    ] = 1
    r"""Maximum number of parts to upload in parallel per file"""

    remove_empty_dirs: Annotated[
        Optional[bool], pydantic.Field(alias="removeEmptyDirs")
    ] = True
    r"""Remove empty staging directories after moving files"""

    partition_expr: Annotated[Optional[str], pydantic.Field(alias="partitionExpr")] = (
        "C.Time.strftime(_time ? _time : Date.now()/1000, '%Y/%m/%d')"
    )
    r"""JavaScript expression defining how files are partitioned and organized. Default is date-based. If blank, Stream will fall back to the event's __partition field value – if present – otherwise to each location's root directory."""

    base_file_name: Annotated[Optional[str], pydantic.Field(alias="baseFileName")] = (
        "`CriblOut`"
    )
    r"""JavaScript expression to define the output filename prefix (can be constant)"""

    file_name_suffix: Annotated[
        Optional[str], pydantic.Field(alias="fileNameSuffix")
    ] = '`.${C.env["CRIBL_WORKER_ID"]}.${__format}${__compression === "gzip" ? ".gz" : ""}`'
    r"""JavaScript expression to define the output filename suffix (can be constant).  The `__format` variable refers to the value of the `Data format` field (`json` or `raw`).  The `__compression` field refers to the kind of compression being used (`none` or `gzip`)."""

    max_file_size_mb: Annotated[
        Optional[float], pydantic.Field(alias="maxFileSizeMB")
    ] = 32
    r"""Maximum uncompressed output file size. Files of this size will be closed and moved to final output location."""

    max_file_open_time_sec: Annotated[
        Optional[float], pydantic.Field(alias="maxFileOpenTimeSec")
    ] = 300
    r"""Maximum amount of time to write to a file. Files open for longer than this will be closed and moved to final output location."""

    max_file_idle_time_sec: Annotated[
        Optional[float], pydantic.Field(alias="maxFileIdleTimeSec")
    ] = 30
    r"""Maximum amount of time to keep inactive files open. Files open for longer than this will be closed and moved to final output location."""

    max_open_files: Annotated[Optional[float], pydantic.Field(alias="maxOpenFiles")] = (
        100
    )
    r"""Maximum number of files to keep open concurrently. When exceeded, @{product} will close the oldest open files and move them to the final output location."""

    header_line: Annotated[Optional[str], pydantic.Field(alias="headerLine")] = ""
    r"""If set, this line will be written to the beginning of each output file"""

    write_high_water_mark: Annotated[
        Optional[float], pydantic.Field(alias="writeHighWaterMark")
    ] = 64
    r"""Buffer size used to write to a file"""

    on_backpressure: Annotated[
        Annotated[
            Optional[PqOnBackpressureOptions], PlainValidator(validate_open_enum(False))
        ],
        pydantic.Field(alias="onBackpressure"),
    ] = PqOnBackpressureOptions.BLOCK
    r"""How to handle events when the queue is exerting backpressure (full capacity or low disk). 'Block' is the same behavior as non-PQ blocking. 'Drop new data' throws away incoming data, while leaving the contents of the PQ unchanged."""

    deadletter_enabled: Annotated[
        Optional[bool], pydantic.Field(alias="deadletterEnabled")
    ] = False
    r"""If a file fails to move to its final destination after the maximum number of retries, move it to a designated directory to prevent further errors"""

    on_disk_full_backpressure: Annotated[
        Annotated[
            Optional[PqOnBackpressureOptions], PlainValidator(validate_open_enum(False))
        ],
        pydantic.Field(alias="onDiskFullBackpressure"),
    ] = PqOnBackpressureOptions.BLOCK
    r"""How to handle events when the queue is exerting backpressure (full capacity or low disk). 'Block' is the same behavior as non-PQ blocking. 'Drop new data' throws away incoming data, while leaving the contents of the PQ unchanged."""

    auth_type: Annotated[
        Annotated[
            Optional[AuthType1Options], PlainValidator(validate_open_enum(False))
        ],
        pydantic.Field(alias="authType"),
    ] = AuthType1Options.MANUAL

    storage_class: Annotated[
        Annotated[Optional[BlobAccessTier2], PlainValidator(validate_open_enum(False))],
        pydantic.Field(alias="storageClass"),
    ] = BlobAccessTier2.INFERRED

    description: Optional[str] = None

    compress: Annotated[
        Optional[PqCompressOptions], PlainValidator(validate_open_enum(False))
    ] = PqCompressOptions.NONE
    r"""Codec to use to compress the persisted data"""

    compression_level: Annotated[
        Annotated[
            Optional[CompressionLevelOptions], PlainValidator(validate_open_enum(False))
        ],
        pydantic.Field(alias="compressionLevel"),
    ] = CompressionLevelOptions.BEST_SPEED
    r"""Compression level to apply before moving files to final destination"""

    automatic_schema: Annotated[
        Optional[bool], pydantic.Field(alias="automaticSchema")
    ] = False
    r"""Automatically calculate the schema based on the events of each Parquet file generated"""

    parquet_schema: Annotated[Optional[str], pydantic.Field(alias="parquetSchema")] = (
        None
    )
    r"""To add a new schema, navigate to Processing > Knowledge > Parquet Schemas"""

    parquet_version: Annotated[
        Annotated[
            Optional[ParquetVersionOptions], PlainValidator(validate_open_enum(False))
        ],
        pydantic.Field(alias="parquetVersion"),
    ] = ParquetVersionOptions.PARQUET_2_6
    r"""Determines which data types are supported and how they are represented"""

    parquet_data_page_version: Annotated[
        Annotated[
            Optional[ParquetDataPageVersionOptions],
            PlainValidator(validate_open_enum(False)),
        ],
        pydantic.Field(alias="parquetDataPageVersion"),
    ] = ParquetDataPageVersionOptions.DATA_PAGE_V2
    r"""Serialization format of data pages. Note that some reader implementations use Data page V2's attributes to work more efficiently, while others ignore it."""

    parquet_row_group_length: Annotated[
        Optional[float], pydantic.Field(alias="parquetRowGroupLength")
    ] = 10000
    r"""The number of rows that every group will contain. The final group can contain a smaller number of rows."""

    parquet_page_size: Annotated[
        Optional[str], pydantic.Field(alias="parquetPageSize")
    ] = "1MB"
    r"""Target memory size for page segments, such as 1MB or 128MB. Generally, lower values improve reading speed, while higher values improve compression."""

    enable_statistics: Annotated[
        Optional[bool], pydantic.Field(alias="enableStatistics")
    ] = True
    r"""Statistics profile an entire file in terms of minimum/maximum values within data, numbers of nulls, etc. You can use Parquet tools to view statistics."""

    enable_write_page_index: Annotated[
        Optional[bool], pydantic.Field(alias="enableWritePageIndex")
    ] = True
    r"""One page index contains statistics for one data page. Parquet readers use statistics to enable page skipping."""

    enable_page_checksum: Annotated[
        Optional[bool], pydantic.Field(alias="enablePageChecksum")
    ] = False
    r"""Parquet tools can use the checksum of a Parquet page to verify data integrity"""

    empty_dir_cleanup_sec: Annotated[
        Optional[float], pydantic.Field(alias="emptyDirCleanupSec")
    ] = 300
    r"""How frequently, in seconds, to clean up empty directories"""

    deadletter_path: Annotated[
        Optional[str], pydantic.Field(alias="deadletterPath")
    ] = "$CRIBL_HOME/state/outputs/dead-letter"
    r"""Storage location for files that fail to reach their final destination after maximum retries are exceeded"""

    max_retry_num: Annotated[Optional[float], pydantic.Field(alias="maxRetryNum")] = 20
    r"""The maximum number of times a file will attempt to move to its final destination before being dead-lettered"""

    connection_string: Annotated[
        Optional[str], pydantic.Field(alias="connectionString")
    ] = None
    r"""Enter your Azure Storage account connection string. If left blank, Stream will fall back to env.AZURE_STORAGE_CONNECTION_STRING."""

    text_secret: Annotated[Optional[str], pydantic.Field(alias="textSecret")] = None
    r"""Select or create a stored text secret"""

    storage_account_name: Annotated[
        Optional[str], pydantic.Field(alias="storageAccountName")
    ] = None
    r"""The name of your Azure storage account"""

    tenant_id: Annotated[Optional[str], pydantic.Field(alias="tenantId")] = None
    r"""The service principal's tenant ID"""

    client_id: Annotated[Optional[str], pydantic.Field(alias="clientId")] = None
    r"""The service principal's client ID"""

    azure_cloud: Annotated[Optional[str], pydantic.Field(alias="azureCloud")] = None
    r"""The Azure cloud to use. Defaults to Azure Public Cloud."""

    endpoint_suffix: Annotated[
        Optional[str], pydantic.Field(alias="endpointSuffix")
    ] = None
    r"""Endpoint suffix for the service URL. Takes precedence over the Azure Cloud setting. Defaults to core.windows.net."""

    client_text_secret: Annotated[
        Optional[str], pydantic.Field(alias="clientTextSecret")
    ] = None
    r"""Select or create a stored text secret"""

    certificate: Optional[CertificateType] = None

    @field_serializer("format_")
    def serialize_format_(self, value):
        if isinstance(value, str):
            try:
                return models.Format1Options(value)
            except ValueError:
                return value
        return value

    @field_serializer("on_backpressure")
    def serialize_on_backpressure(self, value):
        if isinstance(value, str):
            try:
                return models.PqOnBackpressureOptions(value)
            except ValueError:
                return value
        return value

    @field_serializer("on_disk_full_backpressure")
    def serialize_on_disk_full_backpressure(self, value):
        if isinstance(value, str):
            try:
                return models.PqOnBackpressureOptions(value)
            except ValueError:
                return value
        return value

    @field_serializer("auth_type")
    def serialize_auth_type(self, value):
        if isinstance(value, str):
            try:
                return models.AuthType1Options(value)
            except ValueError:
                return value
        return value

    @field_serializer("storage_class")
    def serialize_storage_class(self, value):
        if isinstance(value, str):
            try:
                return models.BlobAccessTier2(value)
            except ValueError:
                return value
        return value

    @field_serializer("compress")
    def serialize_compress(self, value):
        if isinstance(value, str):
            try:
                return models.PqCompressOptions(value)
            except ValueError:
                return value
        return value

    @field_serializer("compression_level")
    def serialize_compression_level(self, value):
        if isinstance(value, str):
            try:
                return models.CompressionLevelOptions(value)
            except ValueError:
                return value
        return value

    @field_serializer("parquet_version")
    def serialize_parquet_version(self, value):
        if isinstance(value, str):
            try:
                return models.ParquetVersionOptions(value)
            except ValueError:
                return value
        return value

    @field_serializer("parquet_data_page_version")
    def serialize_parquet_data_page_version(self, value):
        if isinstance(value, str):
            try:
                return models.ParquetDataPageVersionOptions(value)
            except ValueError:
                return value
        return value


class BlobAccessTier1(str, Enum, metaclass=utils.OpenEnumMeta):
    # Default account access tier
    INFERRED = "Inferred"
    # Hot tier
    HOT = "Hot"
    # Cool tier
    COOL = "Cool"
    # Cold tier
    COLD = "Cold"
    # Archive tier
    ARCHIVE = "Archive"


class OutputAzureBlobAzureBlob1TypedDict(TypedDict):
    type: TypeAzureBlobOption
    container_name: str
    r"""The Azure Blob Storage container name. Name can include only lowercase letters, numbers, and hyphens. For dynamic container names, enter a JavaScript expression within quotes or backticks, to be evaluated at initialization. The expression can evaluate to a constant value and can reference Global Variables, such as `myContainer-${C.env[\"CRIBL_WORKER_ID\"]}`."""
    format_: NotRequired[Format1Options]
    r"""Format of the output data"""
    id: NotRequired[str]
    r"""Unique ID for this output"""
    pipeline: NotRequired[str]
    r"""Pipeline to process data before sending out to this output"""
    system_fields: NotRequired[List[str]]
    r"""Fields to automatically add to events, such as cribl_pipe. Supports wildcards."""
    environment: NotRequired[str]
    r"""Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere."""
    streamtags: NotRequired[List[str]]
    r"""Tags for filtering and grouping in @{product}"""
    create_container: NotRequired[bool]
    r"""Create the configured container in Azure Blob Storage if it does not already exist"""
    dest_path: NotRequired[str]
    r"""Root directory prepended to path before uploading. Value can be a JavaScript expression enclosed in quotes or backticks, to be evaluated at initialization. The expression can evaluate to a constant value and can reference Global Variables, such as `myBlobPrefix-${C.env[\"CRIBL_WORKER_ID\"]}`."""
    stage_path: NotRequired[str]
    r"""Filesystem location in which to buffer files before compressing and moving to final destination. Use performant and stable storage."""
    add_id_to_stage_path: NotRequired[bool]
    r"""Add the Output ID value to staging location"""
    max_concurrent_file_parts: NotRequired[float]
    r"""Maximum number of parts to upload in parallel per file"""
    remove_empty_dirs: NotRequired[bool]
    r"""Remove empty staging directories after moving files"""
    partition_expr: NotRequired[str]
    r"""JavaScript expression defining how files are partitioned and organized. Default is date-based. If blank, Stream will fall back to the event's __partition field value – if present – otherwise to each location's root directory."""
    base_file_name: NotRequired[str]
    r"""JavaScript expression to define the output filename prefix (can be constant)"""
    file_name_suffix: NotRequired[str]
    r"""JavaScript expression to define the output filename suffix (can be constant).  The `__format` variable refers to the value of the `Data format` field (`json` or `raw`).  The `__compression` field refers to the kind of compression being used (`none` or `gzip`)."""
    max_file_size_mb: NotRequired[float]
    r"""Maximum uncompressed output file size. Files of this size will be closed and moved to final output location."""
    max_file_open_time_sec: NotRequired[float]
    r"""Maximum amount of time to write to a file. Files open for longer than this will be closed and moved to final output location."""
    max_file_idle_time_sec: NotRequired[float]
    r"""Maximum amount of time to keep inactive files open. Files open for longer than this will be closed and moved to final output location."""
    max_open_files: NotRequired[float]
    r"""Maximum number of files to keep open concurrently. When exceeded, @{product} will close the oldest open files and move them to the final output location."""
    header_line: NotRequired[str]
    r"""If set, this line will be written to the beginning of each output file"""
    write_high_water_mark: NotRequired[float]
    r"""Buffer size used to write to a file"""
    on_backpressure: NotRequired[PqOnBackpressureOptions]
    r"""How to handle events when the queue is exerting backpressure (full capacity or low disk). 'Block' is the same behavior as non-PQ blocking. 'Drop new data' throws away incoming data, while leaving the contents of the PQ unchanged."""
    deadletter_enabled: NotRequired[bool]
    r"""If a file fails to move to its final destination after the maximum number of retries, move it to a designated directory to prevent further errors"""
    on_disk_full_backpressure: NotRequired[PqOnBackpressureOptions]
    r"""How to handle events when the queue is exerting backpressure (full capacity or low disk). 'Block' is the same behavior as non-PQ blocking. 'Drop new data' throws away incoming data, while leaving the contents of the PQ unchanged."""
    auth_type: NotRequired[AuthType1Options]
    storage_class: NotRequired[BlobAccessTier1]
    description: NotRequired[str]
    compress: NotRequired[PqCompressOptions]
    r"""Codec to use to compress the persisted data"""
    compression_level: NotRequired[CompressionLevelOptions]
    r"""Compression level to apply before moving files to final destination"""
    automatic_schema: NotRequired[bool]
    r"""Automatically calculate the schema based on the events of each Parquet file generated"""
    parquet_schema: NotRequired[str]
    r"""To add a new schema, navigate to Processing > Knowledge > Parquet Schemas"""
    parquet_version: NotRequired[ParquetVersionOptions]
    r"""Determines which data types are supported and how they are represented"""
    parquet_data_page_version: NotRequired[ParquetDataPageVersionOptions]
    r"""Serialization format of data pages. Note that some reader implementations use Data page V2's attributes to work more efficiently, while others ignore it."""
    parquet_row_group_length: NotRequired[float]
    r"""The number of rows that every group will contain. The final group can contain a smaller number of rows."""
    parquet_page_size: NotRequired[str]
    r"""Target memory size for page segments, such as 1MB or 128MB. Generally, lower values improve reading speed, while higher values improve compression."""
    should_log_invalid_rows: NotRequired[bool]
    r"""Log up to 3 rows that @{product} skips due to data mismatch"""
    key_value_metadata: NotRequired[List[TagsTypeTypedDict]]
    r"""The metadata of files the Destination writes will include the properties you add here as key-value pairs. Useful for tagging. Examples: \"key\":\"OCSF Event Class\", \"value\":\"9001\" """
    enable_statistics: NotRequired[bool]
    r"""Statistics profile an entire file in terms of minimum/maximum values within data, numbers of nulls, etc. You can use Parquet tools to view statistics."""
    enable_write_page_index: NotRequired[bool]
    r"""One page index contains statistics for one data page. Parquet readers use statistics to enable page skipping."""
    enable_page_checksum: NotRequired[bool]
    r"""Parquet tools can use the checksum of a Parquet page to verify data integrity"""
    empty_dir_cleanup_sec: NotRequired[float]
    r"""How frequently, in seconds, to clean up empty directories"""
    deadletter_path: NotRequired[str]
    r"""Storage location for files that fail to reach their final destination after maximum retries are exceeded"""
    max_retry_num: NotRequired[float]
    r"""The maximum number of times a file will attempt to move to its final destination before being dead-lettered"""
    connection_string: NotRequired[str]
    r"""Enter your Azure Storage account connection string. If left blank, Stream will fall back to env.AZURE_STORAGE_CONNECTION_STRING."""
    text_secret: NotRequired[str]
    r"""Select or create a stored text secret"""
    storage_account_name: NotRequired[str]
    r"""The name of your Azure storage account"""
    tenant_id: NotRequired[str]
    r"""The service principal's tenant ID"""
    client_id: NotRequired[str]
    r"""The service principal's client ID"""
    azure_cloud: NotRequired[str]
    r"""The Azure cloud to use. Defaults to Azure Public Cloud."""
    endpoint_suffix: NotRequired[str]
    r"""Endpoint suffix for the service URL. Takes precedence over the Azure Cloud setting. Defaults to core.windows.net."""
    client_text_secret: NotRequired[str]
    r"""Select or create a stored text secret"""
    certificate: NotRequired[CertificateTypeTypedDict]


class OutputAzureBlobAzureBlob1(BaseModel):
    type: TypeAzureBlobOption

    container_name: Annotated[str, pydantic.Field(alias="containerName")]
    r"""The Azure Blob Storage container name. Name can include only lowercase letters, numbers, and hyphens. For dynamic container names, enter a JavaScript expression within quotes or backticks, to be evaluated at initialization. The expression can evaluate to a constant value and can reference Global Variables, such as `myContainer-${C.env[\"CRIBL_WORKER_ID\"]}`."""

    format_: Annotated[
        Annotated[Optional[Format1Options], PlainValidator(validate_open_enum(False))],
        pydantic.Field(alias="format"),
    ] = Format1Options.JSON
    r"""Format of the output data"""

    id: Optional[str] = None
    r"""Unique ID for this output"""

    pipeline: Optional[str] = None
    r"""Pipeline to process data before sending out to this output"""

    system_fields: Annotated[
        Optional[List[str]], pydantic.Field(alias="systemFields")
    ] = None
    r"""Fields to automatically add to events, such as cribl_pipe. Supports wildcards."""

    environment: Optional[str] = None
    r"""Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere."""

    streamtags: Optional[List[str]] = None
    r"""Tags for filtering and grouping in @{product}"""

    create_container: Annotated[
        Optional[bool], pydantic.Field(alias="createContainer")
    ] = False
    r"""Create the configured container in Azure Blob Storage if it does not already exist"""

    dest_path: Annotated[Optional[str], pydantic.Field(alias="destPath")] = None
    r"""Root directory prepended to path before uploading. Value can be a JavaScript expression enclosed in quotes or backticks, to be evaluated at initialization. The expression can evaluate to a constant value and can reference Global Variables, such as `myBlobPrefix-${C.env[\"CRIBL_WORKER_ID\"]}`."""

    stage_path: Annotated[Optional[str], pydantic.Field(alias="stagePath")] = (
        "$CRIBL_HOME/state/outputs/staging"
    )
    r"""Filesystem location in which to buffer files before compressing and moving to final destination. Use performant and stable storage."""

    add_id_to_stage_path: Annotated[
        Optional[bool], pydantic.Field(alias="addIdToStagePath")
    ] = True
    r"""Add the Output ID value to staging location"""

    max_concurrent_file_parts: Annotated[
        Optional[float], pydantic.Field(alias="maxConcurrentFileParts")
    ] = 1
    r"""Maximum number of parts to upload in parallel per file"""

    remove_empty_dirs: Annotated[
        Optional[bool], pydantic.Field(alias="removeEmptyDirs")
    ] = True
    r"""Remove empty staging directories after moving files"""

    partition_expr: Annotated[Optional[str], pydantic.Field(alias="partitionExpr")] = (
        "C.Time.strftime(_time ? _time : Date.now()/1000, '%Y/%m/%d')"
    )
    r"""JavaScript expression defining how files are partitioned and organized. Default is date-based. If blank, Stream will fall back to the event's __partition field value – if present – otherwise to each location's root directory."""

    base_file_name: Annotated[Optional[str], pydantic.Field(alias="baseFileName")] = (
        "`CriblOut`"
    )
    r"""JavaScript expression to define the output filename prefix (can be constant)"""

    file_name_suffix: Annotated[
        Optional[str], pydantic.Field(alias="fileNameSuffix")
    ] = '`.${C.env["CRIBL_WORKER_ID"]}.${__format}${__compression === "gzip" ? ".gz" : ""}`'
    r"""JavaScript expression to define the output filename suffix (can be constant).  The `__format` variable refers to the value of the `Data format` field (`json` or `raw`).  The `__compression` field refers to the kind of compression being used (`none` or `gzip`)."""

    max_file_size_mb: Annotated[
        Optional[float], pydantic.Field(alias="maxFileSizeMB")
    ] = 32
    r"""Maximum uncompressed output file size. Files of this size will be closed and moved to final output location."""

    max_file_open_time_sec: Annotated[
        Optional[float], pydantic.Field(alias="maxFileOpenTimeSec")
    ] = 300
    r"""Maximum amount of time to write to a file. Files open for longer than this will be closed and moved to final output location."""

    max_file_idle_time_sec: Annotated[
        Optional[float], pydantic.Field(alias="maxFileIdleTimeSec")
    ] = 30
    r"""Maximum amount of time to keep inactive files open. Files open for longer than this will be closed and moved to final output location."""

    max_open_files: Annotated[Optional[float], pydantic.Field(alias="maxOpenFiles")] = (
        100
    )
    r"""Maximum number of files to keep open concurrently. When exceeded, @{product} will close the oldest open files and move them to the final output location."""

    header_line: Annotated[Optional[str], pydantic.Field(alias="headerLine")] = ""
    r"""If set, this line will be written to the beginning of each output file"""

    write_high_water_mark: Annotated[
        Optional[float], pydantic.Field(alias="writeHighWaterMark")
    ] = 64
    r"""Buffer size used to write to a file"""

    on_backpressure: Annotated[
        Annotated[
            Optional[PqOnBackpressureOptions], PlainValidator(validate_open_enum(False))
        ],
        pydantic.Field(alias="onBackpressure"),
    ] = PqOnBackpressureOptions.BLOCK
    r"""How to handle events when the queue is exerting backpressure (full capacity or low disk). 'Block' is the same behavior as non-PQ blocking. 'Drop new data' throws away incoming data, while leaving the contents of the PQ unchanged."""

    deadletter_enabled: Annotated[
        Optional[bool], pydantic.Field(alias="deadletterEnabled")
    ] = False
    r"""If a file fails to move to its final destination after the maximum number of retries, move it to a designated directory to prevent further errors"""

    on_disk_full_backpressure: Annotated[
        Annotated[
            Optional[PqOnBackpressureOptions], PlainValidator(validate_open_enum(False))
        ],
        pydantic.Field(alias="onDiskFullBackpressure"),
    ] = PqOnBackpressureOptions.BLOCK
    r"""How to handle events when the queue is exerting backpressure (full capacity or low disk). 'Block' is the same behavior as non-PQ blocking. 'Drop new data' throws away incoming data, while leaving the contents of the PQ unchanged."""

    auth_type: Annotated[
        Annotated[
            Optional[AuthType1Options], PlainValidator(validate_open_enum(False))
        ],
        pydantic.Field(alias="authType"),
    ] = AuthType1Options.MANUAL

    storage_class: Annotated[
        Annotated[Optional[BlobAccessTier1], PlainValidator(validate_open_enum(False))],
        pydantic.Field(alias="storageClass"),
    ] = BlobAccessTier1.INFERRED

    description: Optional[str] = None

    compress: Annotated[
        Optional[PqCompressOptions], PlainValidator(validate_open_enum(False))
    ] = PqCompressOptions.NONE
    r"""Codec to use to compress the persisted data"""

    compression_level: Annotated[
        Annotated[
            Optional[CompressionLevelOptions], PlainValidator(validate_open_enum(False))
        ],
        pydantic.Field(alias="compressionLevel"),
    ] = CompressionLevelOptions.BEST_SPEED
    r"""Compression level to apply before moving files to final destination"""

    automatic_schema: Annotated[
        Optional[bool], pydantic.Field(alias="automaticSchema")
    ] = False
    r"""Automatically calculate the schema based on the events of each Parquet file generated"""

    parquet_schema: Annotated[Optional[str], pydantic.Field(alias="parquetSchema")] = (
        None
    )
    r"""To add a new schema, navigate to Processing > Knowledge > Parquet Schemas"""

    parquet_version: Annotated[
        Annotated[
            Optional[ParquetVersionOptions], PlainValidator(validate_open_enum(False))
        ],
        pydantic.Field(alias="parquetVersion"),
    ] = ParquetVersionOptions.PARQUET_2_6
    r"""Determines which data types are supported and how they are represented"""

    parquet_data_page_version: Annotated[
        Annotated[
            Optional[ParquetDataPageVersionOptions],
            PlainValidator(validate_open_enum(False)),
        ],
        pydantic.Field(alias="parquetDataPageVersion"),
    ] = ParquetDataPageVersionOptions.DATA_PAGE_V2
    r"""Serialization format of data pages. Note that some reader implementations use Data page V2's attributes to work more efficiently, while others ignore it."""

    parquet_row_group_length: Annotated[
        Optional[float], pydantic.Field(alias="parquetRowGroupLength")
    ] = 10000
    r"""The number of rows that every group will contain. The final group can contain a smaller number of rows."""

    parquet_page_size: Annotated[
        Optional[str], pydantic.Field(alias="parquetPageSize")
    ] = "1MB"
    r"""Target memory size for page segments, such as 1MB or 128MB. Generally, lower values improve reading speed, while higher values improve compression."""

    should_log_invalid_rows: Annotated[
        Optional[bool], pydantic.Field(alias="shouldLogInvalidRows")
    ] = None
    r"""Log up to 3 rows that @{product} skips due to data mismatch"""

    key_value_metadata: Annotated[
        Optional[List[TagsType]], pydantic.Field(alias="keyValueMetadata")
    ] = None
    r"""The metadata of files the Destination writes will include the properties you add here as key-value pairs. Useful for tagging. Examples: \"key\":\"OCSF Event Class\", \"value\":\"9001\" """

    enable_statistics: Annotated[
        Optional[bool], pydantic.Field(alias="enableStatistics")
    ] = True
    r"""Statistics profile an entire file in terms of minimum/maximum values within data, numbers of nulls, etc. You can use Parquet tools to view statistics."""

    enable_write_page_index: Annotated[
        Optional[bool], pydantic.Field(alias="enableWritePageIndex")
    ] = True
    r"""One page index contains statistics for one data page. Parquet readers use statistics to enable page skipping."""

    enable_page_checksum: Annotated[
        Optional[bool], pydantic.Field(alias="enablePageChecksum")
    ] = False
    r"""Parquet tools can use the checksum of a Parquet page to verify data integrity"""

    empty_dir_cleanup_sec: Annotated[
        Optional[float], pydantic.Field(alias="emptyDirCleanupSec")
    ] = 300
    r"""How frequently, in seconds, to clean up empty directories"""

    deadletter_path: Annotated[
        Optional[str], pydantic.Field(alias="deadletterPath")
    ] = "$CRIBL_HOME/state/outputs/dead-letter"
    r"""Storage location for files that fail to reach their final destination after maximum retries are exceeded"""

    max_retry_num: Annotated[Optional[float], pydantic.Field(alias="maxRetryNum")] = 20
    r"""The maximum number of times a file will attempt to move to its final destination before being dead-lettered"""

    connection_string: Annotated[
        Optional[str], pydantic.Field(alias="connectionString")
    ] = None
    r"""Enter your Azure Storage account connection string. If left blank, Stream will fall back to env.AZURE_STORAGE_CONNECTION_STRING."""

    text_secret: Annotated[Optional[str], pydantic.Field(alias="textSecret")] = None
    r"""Select or create a stored text secret"""

    storage_account_name: Annotated[
        Optional[str], pydantic.Field(alias="storageAccountName")
    ] = None
    r"""The name of your Azure storage account"""

    tenant_id: Annotated[Optional[str], pydantic.Field(alias="tenantId")] = None
    r"""The service principal's tenant ID"""

    client_id: Annotated[Optional[str], pydantic.Field(alias="clientId")] = None
    r"""The service principal's client ID"""

    azure_cloud: Annotated[Optional[str], pydantic.Field(alias="azureCloud")] = None
    r"""The Azure cloud to use. Defaults to Azure Public Cloud."""

    endpoint_suffix: Annotated[
        Optional[str], pydantic.Field(alias="endpointSuffix")
    ] = None
    r"""Endpoint suffix for the service URL. Takes precedence over the Azure Cloud setting. Defaults to core.windows.net."""

    client_text_secret: Annotated[
        Optional[str], pydantic.Field(alias="clientTextSecret")
    ] = None
    r"""Select or create a stored text secret"""

    certificate: Optional[CertificateType] = None

    @field_serializer("format_")
    def serialize_format_(self, value):
        if isinstance(value, str):
            try:
                return models.Format1Options(value)
            except ValueError:
                return value
        return value

    @field_serializer("on_backpressure")
    def serialize_on_backpressure(self, value):
        if isinstance(value, str):
            try:
                return models.PqOnBackpressureOptions(value)
            except ValueError:
                return value
        return value

    @field_serializer("on_disk_full_backpressure")
    def serialize_on_disk_full_backpressure(self, value):
        if isinstance(value, str):
            try:
                return models.PqOnBackpressureOptions(value)
            except ValueError:
                return value
        return value

    @field_serializer("auth_type")
    def serialize_auth_type(self, value):
        if isinstance(value, str):
            try:
                return models.AuthType1Options(value)
            except ValueError:
                return value
        return value

    @field_serializer("storage_class")
    def serialize_storage_class(self, value):
        if isinstance(value, str):
            try:
                return models.BlobAccessTier1(value)
            except ValueError:
                return value
        return value

    @field_serializer("compress")
    def serialize_compress(self, value):
        if isinstance(value, str):
            try:
                return models.PqCompressOptions(value)
            except ValueError:
                return value
        return value

    @field_serializer("compression_level")
    def serialize_compression_level(self, value):
        if isinstance(value, str):
            try:
                return models.CompressionLevelOptions(value)
            except ValueError:
                return value
        return value

    @field_serializer("parquet_version")
    def serialize_parquet_version(self, value):
        if isinstance(value, str):
            try:
                return models.ParquetVersionOptions(value)
            except ValueError:
                return value
        return value

    @field_serializer("parquet_data_page_version")
    def serialize_parquet_data_page_version(self, value):
        if isinstance(value, str):
            try:
                return models.ParquetDataPageVersionOptions(value)
            except ValueError:
                return value
        return value


OutputAzureBlobTypedDict = TypeAliasType(
    "OutputAzureBlobTypedDict",
    Union[
        OutputAzureBlobAzureBlob1TypedDict,
        OutputAzureBlobAzureBlob2TypedDict,
        OutputAzureBlobAzureBlob3TypedDict,
        OutputAzureBlobAzureBlob4TypedDict,
        OutputAzureBlobAzureBlob5TypedDict,
        OutputAzureBlobAzureBlob6TypedDict,
        OutputAzureBlobAzureBlob7TypedDict,
        OutputAzureBlobAzureBlob8TypedDict,
        OutputAzureBlobAzureBlob9TypedDict,
        OutputAzureBlobAzureBlob10TypedDict,
    ],
)


OutputAzureBlob = TypeAliasType(
    "OutputAzureBlob",
    Union[
        OutputAzureBlobAzureBlob1,
        OutputAzureBlobAzureBlob2,
        OutputAzureBlobAzureBlob3,
        OutputAzureBlobAzureBlob4,
        OutputAzureBlobAzureBlob5,
        OutputAzureBlobAzureBlob6,
        OutputAzureBlobAzureBlob7,
        OutputAzureBlobAzureBlob8,
        OutputAzureBlobAzureBlob9,
        OutputAzureBlobAzureBlob10,
    ],
)
