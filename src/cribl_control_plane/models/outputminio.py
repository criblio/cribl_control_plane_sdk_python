"""Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT."""

from __future__ import annotations
from .awsauthenticationmethodoptions import AwsAuthenticationMethodOptions
from .compressionleveloptions import CompressionLevelOptions
from .format1options import Format1Options
from .objectacloptions import ObjectACLOptions
from .parquetdatapageversionoptions import ParquetDataPageVersionOptions
from .parquetversionoptions import ParquetVersionOptions
from .pqcompressoptions import PqCompressOptions
from .pqonbackpressureoptions import PqOnBackpressureOptions
from .signatureversionoptions import SignatureVersionOptions
from .tagstype import TagsType, TagsTypeTypedDict
from cribl_control_plane import models, utils
from cribl_control_plane.types import BaseModel
from cribl_control_plane.utils import validate_open_enum
from enum import Enum
import pydantic
from pydantic import field_serializer
from pydantic.functional_validators import PlainValidator
from typing import List, Optional, Union
from typing_extensions import Annotated, NotRequired, TypeAliasType, TypedDict


class OutputMinioType9(str, Enum):
    MINIO = "minio"


class StorageClass9(str, Enum, metaclass=utils.OpenEnumMeta):
    r"""Storage class to select for uploaded objects"""

    # Standard
    STANDARD = "STANDARD"
    # Reduced Redundancy Storage
    REDUCED_REDUNDANCY = "REDUCED_REDUNDANCY"


class ServerSideEncryption9(str, Enum, metaclass=utils.OpenEnumMeta):
    r"""Server-side encryption for uploaded objects"""

    # Amazon S3 Managed Key
    AES256 = "AES256"


class OutputMinioMinio9TypedDict(TypedDict):
    type: OutputMinioType9
    endpoint: str
    r"""MinIO service url (e.g. http://minioHost:9000)"""
    bucket: str
    r"""Name of the destination MinIO bucket. This value can be a constant or a JavaScript expression that can only be evaluated at init time. Example referencing a Global Variable: `myBucket-${C.vars.myVar}`"""
    deadletter_enabled: NotRequired[bool]
    r"""If a file fails to move to its final destination after the maximum number of retries, move it to a designated directory to prevent further errors"""
    id: NotRequired[str]
    r"""Unique ID for this output"""
    pipeline: NotRequired[str]
    r"""Pipeline to process data before sending out to this output"""
    system_fields: NotRequired[List[str]]
    r"""Fields to automatically add to events, such as cribl_pipe. Supports wildcards."""
    environment: NotRequired[str]
    r"""Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere."""
    streamtags: NotRequired[List[str]]
    r"""Tags for filtering and grouping in @{product}"""
    aws_authentication_method: NotRequired[AwsAuthenticationMethodOptions]
    r"""AWS authentication method. Choose Auto to use IAM roles."""
    aws_secret_key: NotRequired[str]
    r"""Secret key. This value can be a constant or a JavaScript expression, such as `${C.env.SOME_SECRET}`)."""
    region: NotRequired[str]
    r"""Region where the MinIO service/cluster is located"""
    stage_path: NotRequired[str]
    r"""Filesystem location in which to buffer files, before compressing and moving to final destination. Use performant stable storage."""
    add_id_to_stage_path: NotRequired[bool]
    r"""Add the Output ID value to staging location"""
    dest_path: NotRequired[str]
    r"""Root directory to prepend to path before uploading. Enter a constant, or a JavaScript expression enclosed in quotes or backticks."""
    signature_version: NotRequired[SignatureVersionOptions]
    r"""Signature version to use for signing MSK cluster requests"""
    object_acl: NotRequired[ObjectACLOptions]
    r"""Object ACL to assign to uploaded objects"""
    storage_class: NotRequired[StorageClass9]
    r"""Storage class to select for uploaded objects"""
    server_side_encryption: NotRequired[ServerSideEncryption9]
    r"""Server-side encryption for uploaded objects"""
    reuse_connections: NotRequired[bool]
    r"""Reuse connections between requests, which can improve performance"""
    reject_unauthorized: NotRequired[bool]
    r"""Reject certificates that cannot be verified against a valid CA, such as self-signed certificates)"""
    verify_permissions: NotRequired[bool]
    r"""Disable if you can access files within the bucket but not the bucket itself"""
    remove_empty_dirs: NotRequired[bool]
    r"""Remove empty staging directories after moving files"""
    partition_expr: NotRequired[str]
    r"""JavaScript expression defining how files are partitioned and organized. Default is date-based. If blank, Stream will fall back to the event's __partition field value – if present – otherwise to each location's root directory."""
    format_: NotRequired[Format1Options]
    r"""Format of the output data"""
    base_file_name: NotRequired[str]
    r"""JavaScript expression to define the output filename prefix (can be constant)"""
    file_name_suffix: NotRequired[str]
    r"""JavaScript expression to define the output filename suffix (can be constant).  The `__format` variable refers to the value of the `Data format` field (`json` or `raw`).  The `__compression` field refers to the kind of compression being used (`none` or `gzip`)."""
    max_file_size_mb: NotRequired[float]
    r"""Maximum uncompressed output file size. Files of this size will be closed and moved to final output location."""
    max_open_files: NotRequired[float]
    r"""Maximum number of files to keep open concurrently. When exceeded, @{product} will close the oldest open files and move them to the final output location."""
    header_line: NotRequired[str]
    r"""If set, this line will be written to the beginning of each output file"""
    write_high_water_mark: NotRequired[float]
    r"""Buffer size used to write to a file"""
    on_backpressure: NotRequired[PqOnBackpressureOptions]
    r"""How to handle events when the queue is exerting backpressure (full capacity or low disk). 'Block' is the same behavior as non-PQ blocking. 'Drop new data' throws away incoming data, while leaving the contents of the PQ unchanged."""
    on_disk_full_backpressure: NotRequired[PqOnBackpressureOptions]
    r"""How to handle events when the queue is exerting backpressure (full capacity or low disk). 'Block' is the same behavior as non-PQ blocking. 'Drop new data' throws away incoming data, while leaving the contents of the PQ unchanged."""
    max_file_open_time_sec: NotRequired[float]
    r"""Maximum amount of time to write to a file. Files open for longer than this will be closed and moved to final output location."""
    max_file_idle_time_sec: NotRequired[float]
    r"""Maximum amount of time to keep inactive files open. Files open for longer than this will be closed and moved to final output location."""
    max_concurrent_file_parts: NotRequired[float]
    r"""Maximum number of parts to upload in parallel per file. Minimum part size is 5MB."""
    description: NotRequired[str]
    aws_api_key: NotRequired[str]
    r"""This value can be a constant or a JavaScript expression (`${C.env.SOME_ACCESS_KEY}`)"""
    aws_secret: NotRequired[str]
    r"""Select or create a stored secret that references your access key and secret key"""
    compress: NotRequired[PqCompressOptions]
    r"""Codec to use to compress the persisted data"""
    compression_level: NotRequired[CompressionLevelOptions]
    r"""Compression level to apply before moving files to final destination"""
    automatic_schema: NotRequired[bool]
    r"""Automatically calculate the schema based on the events of each Parquet file generated"""
    parquet_schema: NotRequired[str]
    r"""To add a new schema, navigate to Processing > Knowledge > Parquet Schemas"""
    parquet_version: NotRequired[ParquetVersionOptions]
    r"""Determines which data types are supported and how they are represented"""
    parquet_data_page_version: NotRequired[ParquetDataPageVersionOptions]
    r"""Serialization format of data pages. Note that some reader implementations use Data page V2's attributes to work more efficiently, while others ignore it."""
    parquet_row_group_length: NotRequired[float]
    r"""The number of rows that every group will contain. The final group can contain a smaller number of rows."""
    parquet_page_size: NotRequired[str]
    r"""Target memory size for page segments, such as 1MB or 128MB. Generally, lower values improve reading speed, while higher values improve compression."""
    should_log_invalid_rows: NotRequired[bool]
    r"""Log up to 3 rows that @{product} skips due to data mismatch"""
    key_value_metadata: NotRequired[List[TagsTypeTypedDict]]
    r"""The metadata of files the Destination writes will include the properties you add here as key-value pairs. Useful for tagging. Examples: \"key\":\"OCSF Event Class\", \"value\":\"9001\" """
    enable_statistics: NotRequired[bool]
    r"""Statistics profile an entire file in terms of minimum/maximum values within data, numbers of nulls, etc. You can use Parquet tools to view statistics."""
    enable_write_page_index: NotRequired[bool]
    r"""One page index contains statistics for one data page. Parquet readers use statistics to enable page skipping."""
    enable_page_checksum: NotRequired[bool]
    r"""Parquet tools can use the checksum of a Parquet page to verify data integrity"""
    empty_dir_cleanup_sec: NotRequired[float]
    r"""How frequently, in seconds, to clean up empty directories"""
    deadletter_path: NotRequired[str]
    r"""Storage location for files that fail to reach their final destination after maximum retries are exceeded"""
    max_retry_num: NotRequired[float]
    r"""The maximum number of times a file will attempt to move to its final destination before being dead-lettered"""


class OutputMinioMinio9(BaseModel):
    type: OutputMinioType9

    endpoint: str
    r"""MinIO service url (e.g. http://minioHost:9000)"""

    bucket: str
    r"""Name of the destination MinIO bucket. This value can be a constant or a JavaScript expression that can only be evaluated at init time. Example referencing a Global Variable: `myBucket-${C.vars.myVar}`"""

    deadletter_enabled: Annotated[
        Optional[bool], pydantic.Field(alias="deadletterEnabled")
    ] = False
    r"""If a file fails to move to its final destination after the maximum number of retries, move it to a designated directory to prevent further errors"""

    id: Optional[str] = None
    r"""Unique ID for this output"""

    pipeline: Optional[str] = None
    r"""Pipeline to process data before sending out to this output"""

    system_fields: Annotated[
        Optional[List[str]], pydantic.Field(alias="systemFields")
    ] = None
    r"""Fields to automatically add to events, such as cribl_pipe. Supports wildcards."""

    environment: Optional[str] = None
    r"""Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere."""

    streamtags: Optional[List[str]] = None
    r"""Tags for filtering and grouping in @{product}"""

    aws_authentication_method: Annotated[
        Annotated[
            Optional[AwsAuthenticationMethodOptions],
            PlainValidator(validate_open_enum(False)),
        ],
        pydantic.Field(alias="awsAuthenticationMethod"),
    ] = AwsAuthenticationMethodOptions.AUTO
    r"""AWS authentication method. Choose Auto to use IAM roles."""

    aws_secret_key: Annotated[Optional[str], pydantic.Field(alias="awsSecretKey")] = (
        None
    )
    r"""Secret key. This value can be a constant or a JavaScript expression, such as `${C.env.SOME_SECRET}`)."""

    region: Optional[str] = None
    r"""Region where the MinIO service/cluster is located"""

    stage_path: Annotated[Optional[str], pydantic.Field(alias="stagePath")] = (
        "$CRIBL_HOME/state/outputs/staging"
    )
    r"""Filesystem location in which to buffer files, before compressing and moving to final destination. Use performant stable storage."""

    add_id_to_stage_path: Annotated[
        Optional[bool], pydantic.Field(alias="addIdToStagePath")
    ] = True
    r"""Add the Output ID value to staging location"""

    dest_path: Annotated[Optional[str], pydantic.Field(alias="destPath")] = None
    r"""Root directory to prepend to path before uploading. Enter a constant, or a JavaScript expression enclosed in quotes or backticks."""

    signature_version: Annotated[
        Annotated[
            Optional[SignatureVersionOptions], PlainValidator(validate_open_enum(False))
        ],
        pydantic.Field(alias="signatureVersion"),
    ] = SignatureVersionOptions.V4
    r"""Signature version to use for signing MSK cluster requests"""

    object_acl: Annotated[
        Annotated[
            Optional[ObjectACLOptions], PlainValidator(validate_open_enum(False))
        ],
        pydantic.Field(alias="objectACL"),
    ] = ObjectACLOptions.PRIVATE
    r"""Object ACL to assign to uploaded objects"""

    storage_class: Annotated[
        Annotated[Optional[StorageClass9], PlainValidator(validate_open_enum(False))],
        pydantic.Field(alias="storageClass"),
    ] = None
    r"""Storage class to select for uploaded objects"""

    server_side_encryption: Annotated[
        Annotated[
            Optional[ServerSideEncryption9], PlainValidator(validate_open_enum(False))
        ],
        pydantic.Field(alias="serverSideEncryption"),
    ] = None
    r"""Server-side encryption for uploaded objects"""

    reuse_connections: Annotated[
        Optional[bool], pydantic.Field(alias="reuseConnections")
    ] = True
    r"""Reuse connections between requests, which can improve performance"""

    reject_unauthorized: Annotated[
        Optional[bool], pydantic.Field(alias="rejectUnauthorized")
    ] = True
    r"""Reject certificates that cannot be verified against a valid CA, such as self-signed certificates)"""

    verify_permissions: Annotated[
        Optional[bool], pydantic.Field(alias="verifyPermissions")
    ] = True
    r"""Disable if you can access files within the bucket but not the bucket itself"""

    remove_empty_dirs: Annotated[
        Optional[bool], pydantic.Field(alias="removeEmptyDirs")
    ] = True
    r"""Remove empty staging directories after moving files"""

    partition_expr: Annotated[Optional[str], pydantic.Field(alias="partitionExpr")] = (
        "C.Time.strftime(_time ? _time : Date.now()/1000, '%Y/%m/%d')"
    )
    r"""JavaScript expression defining how files are partitioned and organized. Default is date-based. If blank, Stream will fall back to the event's __partition field value – if present – otherwise to each location's root directory."""

    format_: Annotated[
        Annotated[Optional[Format1Options], PlainValidator(validate_open_enum(False))],
        pydantic.Field(alias="format"),
    ] = Format1Options.JSON
    r"""Format of the output data"""

    base_file_name: Annotated[Optional[str], pydantic.Field(alias="baseFileName")] = (
        "`CriblOut`"
    )
    r"""JavaScript expression to define the output filename prefix (can be constant)"""

    file_name_suffix: Annotated[
        Optional[str], pydantic.Field(alias="fileNameSuffix")
    ] = '`.${C.env["CRIBL_WORKER_ID"]}.${__format}${__compression === "gzip" ? ".gz" : ""}`'
    r"""JavaScript expression to define the output filename suffix (can be constant).  The `__format` variable refers to the value of the `Data format` field (`json` or `raw`).  The `__compression` field refers to the kind of compression being used (`none` or `gzip`)."""

    max_file_size_mb: Annotated[
        Optional[float], pydantic.Field(alias="maxFileSizeMB")
    ] = 32
    r"""Maximum uncompressed output file size. Files of this size will be closed and moved to final output location."""

    max_open_files: Annotated[Optional[float], pydantic.Field(alias="maxOpenFiles")] = (
        100
    )
    r"""Maximum number of files to keep open concurrently. When exceeded, @{product} will close the oldest open files and move them to the final output location."""

    header_line: Annotated[Optional[str], pydantic.Field(alias="headerLine")] = ""
    r"""If set, this line will be written to the beginning of each output file"""

    write_high_water_mark: Annotated[
        Optional[float], pydantic.Field(alias="writeHighWaterMark")
    ] = 64
    r"""Buffer size used to write to a file"""

    on_backpressure: Annotated[
        Annotated[
            Optional[PqOnBackpressureOptions], PlainValidator(validate_open_enum(False))
        ],
        pydantic.Field(alias="onBackpressure"),
    ] = PqOnBackpressureOptions.BLOCK
    r"""How to handle events when the queue is exerting backpressure (full capacity or low disk). 'Block' is the same behavior as non-PQ blocking. 'Drop new data' throws away incoming data, while leaving the contents of the PQ unchanged."""

    on_disk_full_backpressure: Annotated[
        Annotated[
            Optional[PqOnBackpressureOptions], PlainValidator(validate_open_enum(False))
        ],
        pydantic.Field(alias="onDiskFullBackpressure"),
    ] = PqOnBackpressureOptions.BLOCK
    r"""How to handle events when the queue is exerting backpressure (full capacity or low disk). 'Block' is the same behavior as non-PQ blocking. 'Drop new data' throws away incoming data, while leaving the contents of the PQ unchanged."""

    max_file_open_time_sec: Annotated[
        Optional[float], pydantic.Field(alias="maxFileOpenTimeSec")
    ] = 300
    r"""Maximum amount of time to write to a file. Files open for longer than this will be closed and moved to final output location."""

    max_file_idle_time_sec: Annotated[
        Optional[float], pydantic.Field(alias="maxFileIdleTimeSec")
    ] = 30
    r"""Maximum amount of time to keep inactive files open. Files open for longer than this will be closed and moved to final output location."""

    max_concurrent_file_parts: Annotated[
        Optional[float], pydantic.Field(alias="maxConcurrentFileParts")
    ] = 4
    r"""Maximum number of parts to upload in parallel per file. Minimum part size is 5MB."""

    description: Optional[str] = None

    aws_api_key: Annotated[Optional[str], pydantic.Field(alias="awsApiKey")] = None
    r"""This value can be a constant or a JavaScript expression (`${C.env.SOME_ACCESS_KEY}`)"""

    aws_secret: Annotated[Optional[str], pydantic.Field(alias="awsSecret")] = None
    r"""Select or create a stored secret that references your access key and secret key"""

    compress: Annotated[
        Optional[PqCompressOptions], PlainValidator(validate_open_enum(False))
    ] = PqCompressOptions.NONE
    r"""Codec to use to compress the persisted data"""

    compression_level: Annotated[
        Annotated[
            Optional[CompressionLevelOptions], PlainValidator(validate_open_enum(False))
        ],
        pydantic.Field(alias="compressionLevel"),
    ] = CompressionLevelOptions.BEST_SPEED
    r"""Compression level to apply before moving files to final destination"""

    automatic_schema: Annotated[
        Optional[bool], pydantic.Field(alias="automaticSchema")
    ] = False
    r"""Automatically calculate the schema based on the events of each Parquet file generated"""

    parquet_schema: Annotated[Optional[str], pydantic.Field(alias="parquetSchema")] = (
        None
    )
    r"""To add a new schema, navigate to Processing > Knowledge > Parquet Schemas"""

    parquet_version: Annotated[
        Annotated[
            Optional[ParquetVersionOptions], PlainValidator(validate_open_enum(False))
        ],
        pydantic.Field(alias="parquetVersion"),
    ] = ParquetVersionOptions.PARQUET_2_6
    r"""Determines which data types are supported and how they are represented"""

    parquet_data_page_version: Annotated[
        Annotated[
            Optional[ParquetDataPageVersionOptions],
            PlainValidator(validate_open_enum(False)),
        ],
        pydantic.Field(alias="parquetDataPageVersion"),
    ] = ParquetDataPageVersionOptions.DATA_PAGE_V2
    r"""Serialization format of data pages. Note that some reader implementations use Data page V2's attributes to work more efficiently, while others ignore it."""

    parquet_row_group_length: Annotated[
        Optional[float], pydantic.Field(alias="parquetRowGroupLength")
    ] = 10000
    r"""The number of rows that every group will contain. The final group can contain a smaller number of rows."""

    parquet_page_size: Annotated[
        Optional[str], pydantic.Field(alias="parquetPageSize")
    ] = "1MB"
    r"""Target memory size for page segments, such as 1MB or 128MB. Generally, lower values improve reading speed, while higher values improve compression."""

    should_log_invalid_rows: Annotated[
        Optional[bool], pydantic.Field(alias="shouldLogInvalidRows")
    ] = None
    r"""Log up to 3 rows that @{product} skips due to data mismatch"""

    key_value_metadata: Annotated[
        Optional[List[TagsType]], pydantic.Field(alias="keyValueMetadata")
    ] = None
    r"""The metadata of files the Destination writes will include the properties you add here as key-value pairs. Useful for tagging. Examples: \"key\":\"OCSF Event Class\", \"value\":\"9001\" """

    enable_statistics: Annotated[
        Optional[bool], pydantic.Field(alias="enableStatistics")
    ] = True
    r"""Statistics profile an entire file in terms of minimum/maximum values within data, numbers of nulls, etc. You can use Parquet tools to view statistics."""

    enable_write_page_index: Annotated[
        Optional[bool], pydantic.Field(alias="enableWritePageIndex")
    ] = True
    r"""One page index contains statistics for one data page. Parquet readers use statistics to enable page skipping."""

    enable_page_checksum: Annotated[
        Optional[bool], pydantic.Field(alias="enablePageChecksum")
    ] = False
    r"""Parquet tools can use the checksum of a Parquet page to verify data integrity"""

    empty_dir_cleanup_sec: Annotated[
        Optional[float], pydantic.Field(alias="emptyDirCleanupSec")
    ] = 300
    r"""How frequently, in seconds, to clean up empty directories"""

    deadletter_path: Annotated[
        Optional[str], pydantic.Field(alias="deadletterPath")
    ] = "$CRIBL_HOME/state/outputs/dead-letter"
    r"""Storage location for files that fail to reach their final destination after maximum retries are exceeded"""

    max_retry_num: Annotated[Optional[float], pydantic.Field(alias="maxRetryNum")] = 20
    r"""The maximum number of times a file will attempt to move to its final destination before being dead-lettered"""

    @field_serializer("aws_authentication_method")
    def serialize_aws_authentication_method(self, value):
        if isinstance(value, str):
            try:
                return models.AwsAuthenticationMethodOptions(value)
            except ValueError:
                return value
        return value

    @field_serializer("signature_version")
    def serialize_signature_version(self, value):
        if isinstance(value, str):
            try:
                return models.SignatureVersionOptions(value)
            except ValueError:
                return value
        return value

    @field_serializer("object_acl")
    def serialize_object_acl(self, value):
        if isinstance(value, str):
            try:
                return models.ObjectACLOptions(value)
            except ValueError:
                return value
        return value

    @field_serializer("storage_class")
    def serialize_storage_class(self, value):
        if isinstance(value, str):
            try:
                return models.StorageClass9(value)
            except ValueError:
                return value
        return value

    @field_serializer("server_side_encryption")
    def serialize_server_side_encryption(self, value):
        if isinstance(value, str):
            try:
                return models.ServerSideEncryption9(value)
            except ValueError:
                return value
        return value

    @field_serializer("format_")
    def serialize_format_(self, value):
        if isinstance(value, str):
            try:
                return models.Format1Options(value)
            except ValueError:
                return value
        return value

    @field_serializer("on_backpressure")
    def serialize_on_backpressure(self, value):
        if isinstance(value, str):
            try:
                return models.PqOnBackpressureOptions(value)
            except ValueError:
                return value
        return value

    @field_serializer("on_disk_full_backpressure")
    def serialize_on_disk_full_backpressure(self, value):
        if isinstance(value, str):
            try:
                return models.PqOnBackpressureOptions(value)
            except ValueError:
                return value
        return value

    @field_serializer("compress")
    def serialize_compress(self, value):
        if isinstance(value, str):
            try:
                return models.PqCompressOptions(value)
            except ValueError:
                return value
        return value

    @field_serializer("compression_level")
    def serialize_compression_level(self, value):
        if isinstance(value, str):
            try:
                return models.CompressionLevelOptions(value)
            except ValueError:
                return value
        return value

    @field_serializer("parquet_version")
    def serialize_parquet_version(self, value):
        if isinstance(value, str):
            try:
                return models.ParquetVersionOptions(value)
            except ValueError:
                return value
        return value

    @field_serializer("parquet_data_page_version")
    def serialize_parquet_data_page_version(self, value):
        if isinstance(value, str):
            try:
                return models.ParquetDataPageVersionOptions(value)
            except ValueError:
                return value
        return value


class OutputMinioType8(str, Enum):
    MINIO = "minio"


class StorageClass8(str, Enum, metaclass=utils.OpenEnumMeta):
    r"""Storage class to select for uploaded objects"""

    # Standard
    STANDARD = "STANDARD"
    # Reduced Redundancy Storage
    REDUCED_REDUNDANCY = "REDUCED_REDUNDANCY"


class ServerSideEncryption8(str, Enum, metaclass=utils.OpenEnumMeta):
    r"""Server-side encryption for uploaded objects"""

    # Amazon S3 Managed Key
    AES256 = "AES256"


class OutputMinioMinio8TypedDict(TypedDict):
    type: OutputMinioType8
    endpoint: str
    r"""MinIO service url (e.g. http://minioHost:9000)"""
    bucket: str
    r"""Name of the destination MinIO bucket. This value can be a constant or a JavaScript expression that can only be evaluated at init time. Example referencing a Global Variable: `myBucket-${C.vars.myVar}`"""
    deadletter_enabled: NotRequired[bool]
    r"""If a file fails to move to its final destination after the maximum number of retries, move it to a designated directory to prevent further errors"""
    id: NotRequired[str]
    r"""Unique ID for this output"""
    pipeline: NotRequired[str]
    r"""Pipeline to process data before sending out to this output"""
    system_fields: NotRequired[List[str]]
    r"""Fields to automatically add to events, such as cribl_pipe. Supports wildcards."""
    environment: NotRequired[str]
    r"""Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere."""
    streamtags: NotRequired[List[str]]
    r"""Tags for filtering and grouping in @{product}"""
    aws_authentication_method: NotRequired[AwsAuthenticationMethodOptions]
    r"""AWS authentication method. Choose Auto to use IAM roles."""
    aws_secret_key: NotRequired[str]
    r"""Secret key. This value can be a constant or a JavaScript expression, such as `${C.env.SOME_SECRET}`)."""
    region: NotRequired[str]
    r"""Region where the MinIO service/cluster is located"""
    stage_path: NotRequired[str]
    r"""Filesystem location in which to buffer files, before compressing and moving to final destination. Use performant stable storage."""
    add_id_to_stage_path: NotRequired[bool]
    r"""Add the Output ID value to staging location"""
    dest_path: NotRequired[str]
    r"""Root directory to prepend to path before uploading. Enter a constant, or a JavaScript expression enclosed in quotes or backticks."""
    signature_version: NotRequired[SignatureVersionOptions]
    r"""Signature version to use for signing MSK cluster requests"""
    object_acl: NotRequired[ObjectACLOptions]
    r"""Object ACL to assign to uploaded objects"""
    storage_class: NotRequired[StorageClass8]
    r"""Storage class to select for uploaded objects"""
    server_side_encryption: NotRequired[ServerSideEncryption8]
    r"""Server-side encryption for uploaded objects"""
    reuse_connections: NotRequired[bool]
    r"""Reuse connections between requests, which can improve performance"""
    reject_unauthorized: NotRequired[bool]
    r"""Reject certificates that cannot be verified against a valid CA, such as self-signed certificates)"""
    verify_permissions: NotRequired[bool]
    r"""Disable if you can access files within the bucket but not the bucket itself"""
    remove_empty_dirs: NotRequired[bool]
    r"""Remove empty staging directories after moving files"""
    partition_expr: NotRequired[str]
    r"""JavaScript expression defining how files are partitioned and organized. Default is date-based. If blank, Stream will fall back to the event's __partition field value – if present – otherwise to each location's root directory."""
    format_: NotRequired[Format1Options]
    r"""Format of the output data"""
    base_file_name: NotRequired[str]
    r"""JavaScript expression to define the output filename prefix (can be constant)"""
    file_name_suffix: NotRequired[str]
    r"""JavaScript expression to define the output filename suffix (can be constant).  The `__format` variable refers to the value of the `Data format` field (`json` or `raw`).  The `__compression` field refers to the kind of compression being used (`none` or `gzip`)."""
    max_file_size_mb: NotRequired[float]
    r"""Maximum uncompressed output file size. Files of this size will be closed and moved to final output location."""
    max_open_files: NotRequired[float]
    r"""Maximum number of files to keep open concurrently. When exceeded, @{product} will close the oldest open files and move them to the final output location."""
    header_line: NotRequired[str]
    r"""If set, this line will be written to the beginning of each output file"""
    write_high_water_mark: NotRequired[float]
    r"""Buffer size used to write to a file"""
    on_backpressure: NotRequired[PqOnBackpressureOptions]
    r"""How to handle events when the queue is exerting backpressure (full capacity or low disk). 'Block' is the same behavior as non-PQ blocking. 'Drop new data' throws away incoming data, while leaving the contents of the PQ unchanged."""
    on_disk_full_backpressure: NotRequired[PqOnBackpressureOptions]
    r"""How to handle events when the queue is exerting backpressure (full capacity or low disk). 'Block' is the same behavior as non-PQ blocking. 'Drop new data' throws away incoming data, while leaving the contents of the PQ unchanged."""
    max_file_open_time_sec: NotRequired[float]
    r"""Maximum amount of time to write to a file. Files open for longer than this will be closed and moved to final output location."""
    max_file_idle_time_sec: NotRequired[float]
    r"""Maximum amount of time to keep inactive files open. Files open for longer than this will be closed and moved to final output location."""
    max_concurrent_file_parts: NotRequired[float]
    r"""Maximum number of parts to upload in parallel per file. Minimum part size is 5MB."""
    description: NotRequired[str]
    aws_api_key: NotRequired[str]
    r"""This value can be a constant or a JavaScript expression (`${C.env.SOME_ACCESS_KEY}`)"""
    aws_secret: NotRequired[str]
    r"""Select or create a stored secret that references your access key and secret key"""
    compress: NotRequired[PqCompressOptions]
    r"""Codec to use to compress the persisted data"""
    compression_level: NotRequired[CompressionLevelOptions]
    r"""Compression level to apply before moving files to final destination"""
    automatic_schema: NotRequired[bool]
    r"""Automatically calculate the schema based on the events of each Parquet file generated"""
    parquet_schema: NotRequired[str]
    r"""To add a new schema, navigate to Processing > Knowledge > Parquet Schemas"""
    parquet_version: NotRequired[ParquetVersionOptions]
    r"""Determines which data types are supported and how they are represented"""
    parquet_data_page_version: NotRequired[ParquetDataPageVersionOptions]
    r"""Serialization format of data pages. Note that some reader implementations use Data page V2's attributes to work more efficiently, while others ignore it."""
    parquet_row_group_length: NotRequired[float]
    r"""The number of rows that every group will contain. The final group can contain a smaller number of rows."""
    parquet_page_size: NotRequired[str]
    r"""Target memory size for page segments, such as 1MB or 128MB. Generally, lower values improve reading speed, while higher values improve compression."""
    should_log_invalid_rows: NotRequired[bool]
    r"""Log up to 3 rows that @{product} skips due to data mismatch"""
    key_value_metadata: NotRequired[List[TagsTypeTypedDict]]
    r"""The metadata of files the Destination writes will include the properties you add here as key-value pairs. Useful for tagging. Examples: \"key\":\"OCSF Event Class\", \"value\":\"9001\" """
    enable_statistics: NotRequired[bool]
    r"""Statistics profile an entire file in terms of minimum/maximum values within data, numbers of nulls, etc. You can use Parquet tools to view statistics."""
    enable_write_page_index: NotRequired[bool]
    r"""One page index contains statistics for one data page. Parquet readers use statistics to enable page skipping."""
    enable_page_checksum: NotRequired[bool]
    r"""Parquet tools can use the checksum of a Parquet page to verify data integrity"""
    empty_dir_cleanup_sec: NotRequired[float]
    r"""How frequently, in seconds, to clean up empty directories"""
    deadletter_path: NotRequired[str]
    r"""Storage location for files that fail to reach their final destination after maximum retries are exceeded"""
    max_retry_num: NotRequired[float]
    r"""The maximum number of times a file will attempt to move to its final destination before being dead-lettered"""


class OutputMinioMinio8(BaseModel):
    type: OutputMinioType8

    endpoint: str
    r"""MinIO service url (e.g. http://minioHost:9000)"""

    bucket: str
    r"""Name of the destination MinIO bucket. This value can be a constant or a JavaScript expression that can only be evaluated at init time. Example referencing a Global Variable: `myBucket-${C.vars.myVar}`"""

    deadletter_enabled: Annotated[
        Optional[bool], pydantic.Field(alias="deadletterEnabled")
    ] = False
    r"""If a file fails to move to its final destination after the maximum number of retries, move it to a designated directory to prevent further errors"""

    id: Optional[str] = None
    r"""Unique ID for this output"""

    pipeline: Optional[str] = None
    r"""Pipeline to process data before sending out to this output"""

    system_fields: Annotated[
        Optional[List[str]], pydantic.Field(alias="systemFields")
    ] = None
    r"""Fields to automatically add to events, such as cribl_pipe. Supports wildcards."""

    environment: Optional[str] = None
    r"""Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere."""

    streamtags: Optional[List[str]] = None
    r"""Tags for filtering and grouping in @{product}"""

    aws_authentication_method: Annotated[
        Annotated[
            Optional[AwsAuthenticationMethodOptions],
            PlainValidator(validate_open_enum(False)),
        ],
        pydantic.Field(alias="awsAuthenticationMethod"),
    ] = AwsAuthenticationMethodOptions.AUTO
    r"""AWS authentication method. Choose Auto to use IAM roles."""

    aws_secret_key: Annotated[Optional[str], pydantic.Field(alias="awsSecretKey")] = (
        None
    )
    r"""Secret key. This value can be a constant or a JavaScript expression, such as `${C.env.SOME_SECRET}`)."""

    region: Optional[str] = None
    r"""Region where the MinIO service/cluster is located"""

    stage_path: Annotated[Optional[str], pydantic.Field(alias="stagePath")] = (
        "$CRIBL_HOME/state/outputs/staging"
    )
    r"""Filesystem location in which to buffer files, before compressing and moving to final destination. Use performant stable storage."""

    add_id_to_stage_path: Annotated[
        Optional[bool], pydantic.Field(alias="addIdToStagePath")
    ] = True
    r"""Add the Output ID value to staging location"""

    dest_path: Annotated[Optional[str], pydantic.Field(alias="destPath")] = None
    r"""Root directory to prepend to path before uploading. Enter a constant, or a JavaScript expression enclosed in quotes or backticks."""

    signature_version: Annotated[
        Annotated[
            Optional[SignatureVersionOptions], PlainValidator(validate_open_enum(False))
        ],
        pydantic.Field(alias="signatureVersion"),
    ] = SignatureVersionOptions.V4
    r"""Signature version to use for signing MSK cluster requests"""

    object_acl: Annotated[
        Annotated[
            Optional[ObjectACLOptions], PlainValidator(validate_open_enum(False))
        ],
        pydantic.Field(alias="objectACL"),
    ] = ObjectACLOptions.PRIVATE
    r"""Object ACL to assign to uploaded objects"""

    storage_class: Annotated[
        Annotated[Optional[StorageClass8], PlainValidator(validate_open_enum(False))],
        pydantic.Field(alias="storageClass"),
    ] = None
    r"""Storage class to select for uploaded objects"""

    server_side_encryption: Annotated[
        Annotated[
            Optional[ServerSideEncryption8], PlainValidator(validate_open_enum(False))
        ],
        pydantic.Field(alias="serverSideEncryption"),
    ] = None
    r"""Server-side encryption for uploaded objects"""

    reuse_connections: Annotated[
        Optional[bool], pydantic.Field(alias="reuseConnections")
    ] = True
    r"""Reuse connections between requests, which can improve performance"""

    reject_unauthorized: Annotated[
        Optional[bool], pydantic.Field(alias="rejectUnauthorized")
    ] = True
    r"""Reject certificates that cannot be verified against a valid CA, such as self-signed certificates)"""

    verify_permissions: Annotated[
        Optional[bool], pydantic.Field(alias="verifyPermissions")
    ] = True
    r"""Disable if you can access files within the bucket but not the bucket itself"""

    remove_empty_dirs: Annotated[
        Optional[bool], pydantic.Field(alias="removeEmptyDirs")
    ] = True
    r"""Remove empty staging directories after moving files"""

    partition_expr: Annotated[Optional[str], pydantic.Field(alias="partitionExpr")] = (
        "C.Time.strftime(_time ? _time : Date.now()/1000, '%Y/%m/%d')"
    )
    r"""JavaScript expression defining how files are partitioned and organized. Default is date-based. If blank, Stream will fall back to the event's __partition field value – if present – otherwise to each location's root directory."""

    format_: Annotated[
        Annotated[Optional[Format1Options], PlainValidator(validate_open_enum(False))],
        pydantic.Field(alias="format"),
    ] = Format1Options.JSON
    r"""Format of the output data"""

    base_file_name: Annotated[Optional[str], pydantic.Field(alias="baseFileName")] = (
        "`CriblOut`"
    )
    r"""JavaScript expression to define the output filename prefix (can be constant)"""

    file_name_suffix: Annotated[
        Optional[str], pydantic.Field(alias="fileNameSuffix")
    ] = '`.${C.env["CRIBL_WORKER_ID"]}.${__format}${__compression === "gzip" ? ".gz" : ""}`'
    r"""JavaScript expression to define the output filename suffix (can be constant).  The `__format` variable refers to the value of the `Data format` field (`json` or `raw`).  The `__compression` field refers to the kind of compression being used (`none` or `gzip`)."""

    max_file_size_mb: Annotated[
        Optional[float], pydantic.Field(alias="maxFileSizeMB")
    ] = 32
    r"""Maximum uncompressed output file size. Files of this size will be closed and moved to final output location."""

    max_open_files: Annotated[Optional[float], pydantic.Field(alias="maxOpenFiles")] = (
        100
    )
    r"""Maximum number of files to keep open concurrently. When exceeded, @{product} will close the oldest open files and move them to the final output location."""

    header_line: Annotated[Optional[str], pydantic.Field(alias="headerLine")] = ""
    r"""If set, this line will be written to the beginning of each output file"""

    write_high_water_mark: Annotated[
        Optional[float], pydantic.Field(alias="writeHighWaterMark")
    ] = 64
    r"""Buffer size used to write to a file"""

    on_backpressure: Annotated[
        Annotated[
            Optional[PqOnBackpressureOptions], PlainValidator(validate_open_enum(False))
        ],
        pydantic.Field(alias="onBackpressure"),
    ] = PqOnBackpressureOptions.BLOCK
    r"""How to handle events when the queue is exerting backpressure (full capacity or low disk). 'Block' is the same behavior as non-PQ blocking. 'Drop new data' throws away incoming data, while leaving the contents of the PQ unchanged."""

    on_disk_full_backpressure: Annotated[
        Annotated[
            Optional[PqOnBackpressureOptions], PlainValidator(validate_open_enum(False))
        ],
        pydantic.Field(alias="onDiskFullBackpressure"),
    ] = PqOnBackpressureOptions.BLOCK
    r"""How to handle events when the queue is exerting backpressure (full capacity or low disk). 'Block' is the same behavior as non-PQ blocking. 'Drop new data' throws away incoming data, while leaving the contents of the PQ unchanged."""

    max_file_open_time_sec: Annotated[
        Optional[float], pydantic.Field(alias="maxFileOpenTimeSec")
    ] = 300
    r"""Maximum amount of time to write to a file. Files open for longer than this will be closed and moved to final output location."""

    max_file_idle_time_sec: Annotated[
        Optional[float], pydantic.Field(alias="maxFileIdleTimeSec")
    ] = 30
    r"""Maximum amount of time to keep inactive files open. Files open for longer than this will be closed and moved to final output location."""

    max_concurrent_file_parts: Annotated[
        Optional[float], pydantic.Field(alias="maxConcurrentFileParts")
    ] = 4
    r"""Maximum number of parts to upload in parallel per file. Minimum part size is 5MB."""

    description: Optional[str] = None

    aws_api_key: Annotated[Optional[str], pydantic.Field(alias="awsApiKey")] = None
    r"""This value can be a constant or a JavaScript expression (`${C.env.SOME_ACCESS_KEY}`)"""

    aws_secret: Annotated[Optional[str], pydantic.Field(alias="awsSecret")] = None
    r"""Select or create a stored secret that references your access key and secret key"""

    compress: Annotated[
        Optional[PqCompressOptions], PlainValidator(validate_open_enum(False))
    ] = PqCompressOptions.NONE
    r"""Codec to use to compress the persisted data"""

    compression_level: Annotated[
        Annotated[
            Optional[CompressionLevelOptions], PlainValidator(validate_open_enum(False))
        ],
        pydantic.Field(alias="compressionLevel"),
    ] = CompressionLevelOptions.BEST_SPEED
    r"""Compression level to apply before moving files to final destination"""

    automatic_schema: Annotated[
        Optional[bool], pydantic.Field(alias="automaticSchema")
    ] = False
    r"""Automatically calculate the schema based on the events of each Parquet file generated"""

    parquet_schema: Annotated[Optional[str], pydantic.Field(alias="parquetSchema")] = (
        None
    )
    r"""To add a new schema, navigate to Processing > Knowledge > Parquet Schemas"""

    parquet_version: Annotated[
        Annotated[
            Optional[ParquetVersionOptions], PlainValidator(validate_open_enum(False))
        ],
        pydantic.Field(alias="parquetVersion"),
    ] = ParquetVersionOptions.PARQUET_2_6
    r"""Determines which data types are supported and how they are represented"""

    parquet_data_page_version: Annotated[
        Annotated[
            Optional[ParquetDataPageVersionOptions],
            PlainValidator(validate_open_enum(False)),
        ],
        pydantic.Field(alias="parquetDataPageVersion"),
    ] = ParquetDataPageVersionOptions.DATA_PAGE_V2
    r"""Serialization format of data pages. Note that some reader implementations use Data page V2's attributes to work more efficiently, while others ignore it."""

    parquet_row_group_length: Annotated[
        Optional[float], pydantic.Field(alias="parquetRowGroupLength")
    ] = 10000
    r"""The number of rows that every group will contain. The final group can contain a smaller number of rows."""

    parquet_page_size: Annotated[
        Optional[str], pydantic.Field(alias="parquetPageSize")
    ] = "1MB"
    r"""Target memory size for page segments, such as 1MB or 128MB. Generally, lower values improve reading speed, while higher values improve compression."""

    should_log_invalid_rows: Annotated[
        Optional[bool], pydantic.Field(alias="shouldLogInvalidRows")
    ] = None
    r"""Log up to 3 rows that @{product} skips due to data mismatch"""

    key_value_metadata: Annotated[
        Optional[List[TagsType]], pydantic.Field(alias="keyValueMetadata")
    ] = None
    r"""The metadata of files the Destination writes will include the properties you add here as key-value pairs. Useful for tagging. Examples: \"key\":\"OCSF Event Class\", \"value\":\"9001\" """

    enable_statistics: Annotated[
        Optional[bool], pydantic.Field(alias="enableStatistics")
    ] = True
    r"""Statistics profile an entire file in terms of minimum/maximum values within data, numbers of nulls, etc. You can use Parquet tools to view statistics."""

    enable_write_page_index: Annotated[
        Optional[bool], pydantic.Field(alias="enableWritePageIndex")
    ] = True
    r"""One page index contains statistics for one data page. Parquet readers use statistics to enable page skipping."""

    enable_page_checksum: Annotated[
        Optional[bool], pydantic.Field(alias="enablePageChecksum")
    ] = False
    r"""Parquet tools can use the checksum of a Parquet page to verify data integrity"""

    empty_dir_cleanup_sec: Annotated[
        Optional[float], pydantic.Field(alias="emptyDirCleanupSec")
    ] = 300
    r"""How frequently, in seconds, to clean up empty directories"""

    deadletter_path: Annotated[
        Optional[str], pydantic.Field(alias="deadletterPath")
    ] = "$CRIBL_HOME/state/outputs/dead-letter"
    r"""Storage location for files that fail to reach their final destination after maximum retries are exceeded"""

    max_retry_num: Annotated[Optional[float], pydantic.Field(alias="maxRetryNum")] = 20
    r"""The maximum number of times a file will attempt to move to its final destination before being dead-lettered"""

    @field_serializer("aws_authentication_method")
    def serialize_aws_authentication_method(self, value):
        if isinstance(value, str):
            try:
                return models.AwsAuthenticationMethodOptions(value)
            except ValueError:
                return value
        return value

    @field_serializer("signature_version")
    def serialize_signature_version(self, value):
        if isinstance(value, str):
            try:
                return models.SignatureVersionOptions(value)
            except ValueError:
                return value
        return value

    @field_serializer("object_acl")
    def serialize_object_acl(self, value):
        if isinstance(value, str):
            try:
                return models.ObjectACLOptions(value)
            except ValueError:
                return value
        return value

    @field_serializer("storage_class")
    def serialize_storage_class(self, value):
        if isinstance(value, str):
            try:
                return models.StorageClass8(value)
            except ValueError:
                return value
        return value

    @field_serializer("server_side_encryption")
    def serialize_server_side_encryption(self, value):
        if isinstance(value, str):
            try:
                return models.ServerSideEncryption8(value)
            except ValueError:
                return value
        return value

    @field_serializer("format_")
    def serialize_format_(self, value):
        if isinstance(value, str):
            try:
                return models.Format1Options(value)
            except ValueError:
                return value
        return value

    @field_serializer("on_backpressure")
    def serialize_on_backpressure(self, value):
        if isinstance(value, str):
            try:
                return models.PqOnBackpressureOptions(value)
            except ValueError:
                return value
        return value

    @field_serializer("on_disk_full_backpressure")
    def serialize_on_disk_full_backpressure(self, value):
        if isinstance(value, str):
            try:
                return models.PqOnBackpressureOptions(value)
            except ValueError:
                return value
        return value

    @field_serializer("compress")
    def serialize_compress(self, value):
        if isinstance(value, str):
            try:
                return models.PqCompressOptions(value)
            except ValueError:
                return value
        return value

    @field_serializer("compression_level")
    def serialize_compression_level(self, value):
        if isinstance(value, str):
            try:
                return models.CompressionLevelOptions(value)
            except ValueError:
                return value
        return value

    @field_serializer("parquet_version")
    def serialize_parquet_version(self, value):
        if isinstance(value, str):
            try:
                return models.ParquetVersionOptions(value)
            except ValueError:
                return value
        return value

    @field_serializer("parquet_data_page_version")
    def serialize_parquet_data_page_version(self, value):
        if isinstance(value, str):
            try:
                return models.ParquetDataPageVersionOptions(value)
            except ValueError:
                return value
        return value


class OutputMinioType7(str, Enum):
    MINIO = "minio"


class StorageClass7(str, Enum, metaclass=utils.OpenEnumMeta):
    r"""Storage class to select for uploaded objects"""

    # Standard
    STANDARD = "STANDARD"
    # Reduced Redundancy Storage
    REDUCED_REDUNDANCY = "REDUCED_REDUNDANCY"


class ServerSideEncryption7(str, Enum, metaclass=utils.OpenEnumMeta):
    r"""Server-side encryption for uploaded objects"""

    # Amazon S3 Managed Key
    AES256 = "AES256"


class OutputMinioMinio7TypedDict(TypedDict):
    type: OutputMinioType7
    endpoint: str
    r"""MinIO service url (e.g. http://minioHost:9000)"""
    bucket: str
    r"""Name of the destination MinIO bucket. This value can be a constant or a JavaScript expression that can only be evaluated at init time. Example referencing a Global Variable: `myBucket-${C.vars.myVar}`"""
    remove_empty_dirs: NotRequired[bool]
    r"""Remove empty staging directories after moving files"""
    id: NotRequired[str]
    r"""Unique ID for this output"""
    pipeline: NotRequired[str]
    r"""Pipeline to process data before sending out to this output"""
    system_fields: NotRequired[List[str]]
    r"""Fields to automatically add to events, such as cribl_pipe. Supports wildcards."""
    environment: NotRequired[str]
    r"""Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere."""
    streamtags: NotRequired[List[str]]
    r"""Tags for filtering and grouping in @{product}"""
    aws_authentication_method: NotRequired[AwsAuthenticationMethodOptions]
    r"""AWS authentication method. Choose Auto to use IAM roles."""
    aws_secret_key: NotRequired[str]
    r"""Secret key. This value can be a constant or a JavaScript expression, such as `${C.env.SOME_SECRET}`)."""
    region: NotRequired[str]
    r"""Region where the MinIO service/cluster is located"""
    stage_path: NotRequired[str]
    r"""Filesystem location in which to buffer files, before compressing and moving to final destination. Use performant stable storage."""
    add_id_to_stage_path: NotRequired[bool]
    r"""Add the Output ID value to staging location"""
    dest_path: NotRequired[str]
    r"""Root directory to prepend to path before uploading. Enter a constant, or a JavaScript expression enclosed in quotes or backticks."""
    signature_version: NotRequired[SignatureVersionOptions]
    r"""Signature version to use for signing MSK cluster requests"""
    object_acl: NotRequired[ObjectACLOptions]
    r"""Object ACL to assign to uploaded objects"""
    storage_class: NotRequired[StorageClass7]
    r"""Storage class to select for uploaded objects"""
    server_side_encryption: NotRequired[ServerSideEncryption7]
    r"""Server-side encryption for uploaded objects"""
    reuse_connections: NotRequired[bool]
    r"""Reuse connections between requests, which can improve performance"""
    reject_unauthorized: NotRequired[bool]
    r"""Reject certificates that cannot be verified against a valid CA, such as self-signed certificates)"""
    verify_permissions: NotRequired[bool]
    r"""Disable if you can access files within the bucket but not the bucket itself"""
    partition_expr: NotRequired[str]
    r"""JavaScript expression defining how files are partitioned and organized. Default is date-based. If blank, Stream will fall back to the event's __partition field value – if present – otherwise to each location's root directory."""
    format_: NotRequired[Format1Options]
    r"""Format of the output data"""
    base_file_name: NotRequired[str]
    r"""JavaScript expression to define the output filename prefix (can be constant)"""
    file_name_suffix: NotRequired[str]
    r"""JavaScript expression to define the output filename suffix (can be constant).  The `__format` variable refers to the value of the `Data format` field (`json` or `raw`).  The `__compression` field refers to the kind of compression being used (`none` or `gzip`)."""
    max_file_size_mb: NotRequired[float]
    r"""Maximum uncompressed output file size. Files of this size will be closed and moved to final output location."""
    max_open_files: NotRequired[float]
    r"""Maximum number of files to keep open concurrently. When exceeded, @{product} will close the oldest open files and move them to the final output location."""
    header_line: NotRequired[str]
    r"""If set, this line will be written to the beginning of each output file"""
    write_high_water_mark: NotRequired[float]
    r"""Buffer size used to write to a file"""
    on_backpressure: NotRequired[PqOnBackpressureOptions]
    r"""How to handle events when the queue is exerting backpressure (full capacity or low disk). 'Block' is the same behavior as non-PQ blocking. 'Drop new data' throws away incoming data, while leaving the contents of the PQ unchanged."""
    deadletter_enabled: NotRequired[bool]
    r"""If a file fails to move to its final destination after the maximum number of retries, move it to a designated directory to prevent further errors"""
    on_disk_full_backpressure: NotRequired[PqOnBackpressureOptions]
    r"""How to handle events when the queue is exerting backpressure (full capacity or low disk). 'Block' is the same behavior as non-PQ blocking. 'Drop new data' throws away incoming data, while leaving the contents of the PQ unchanged."""
    max_file_open_time_sec: NotRequired[float]
    r"""Maximum amount of time to write to a file. Files open for longer than this will be closed and moved to final output location."""
    max_file_idle_time_sec: NotRequired[float]
    r"""Maximum amount of time to keep inactive files open. Files open for longer than this will be closed and moved to final output location."""
    max_concurrent_file_parts: NotRequired[float]
    r"""Maximum number of parts to upload in parallel per file. Minimum part size is 5MB."""
    description: NotRequired[str]
    aws_api_key: NotRequired[str]
    r"""This value can be a constant or a JavaScript expression (`${C.env.SOME_ACCESS_KEY}`)"""
    aws_secret: NotRequired[str]
    r"""Select or create a stored secret that references your access key and secret key"""
    compress: NotRequired[PqCompressOptions]
    r"""Codec to use to compress the persisted data"""
    compression_level: NotRequired[CompressionLevelOptions]
    r"""Compression level to apply before moving files to final destination"""
    automatic_schema: NotRequired[bool]
    r"""Automatically calculate the schema based on the events of each Parquet file generated"""
    parquet_schema: NotRequired[str]
    r"""To add a new schema, navigate to Processing > Knowledge > Parquet Schemas"""
    parquet_version: NotRequired[ParquetVersionOptions]
    r"""Determines which data types are supported and how they are represented"""
    parquet_data_page_version: NotRequired[ParquetDataPageVersionOptions]
    r"""Serialization format of data pages. Note that some reader implementations use Data page V2's attributes to work more efficiently, while others ignore it."""
    parquet_row_group_length: NotRequired[float]
    r"""The number of rows that every group will contain. The final group can contain a smaller number of rows."""
    parquet_page_size: NotRequired[str]
    r"""Target memory size for page segments, such as 1MB or 128MB. Generally, lower values improve reading speed, while higher values improve compression."""
    should_log_invalid_rows: NotRequired[bool]
    r"""Log up to 3 rows that @{product} skips due to data mismatch"""
    key_value_metadata: NotRequired[List[TagsTypeTypedDict]]
    r"""The metadata of files the Destination writes will include the properties you add here as key-value pairs. Useful for tagging. Examples: \"key\":\"OCSF Event Class\", \"value\":\"9001\" """
    enable_statistics: NotRequired[bool]
    r"""Statistics profile an entire file in terms of minimum/maximum values within data, numbers of nulls, etc. You can use Parquet tools to view statistics."""
    enable_write_page_index: NotRequired[bool]
    r"""One page index contains statistics for one data page. Parquet readers use statistics to enable page skipping."""
    enable_page_checksum: NotRequired[bool]
    r"""Parquet tools can use the checksum of a Parquet page to verify data integrity"""
    empty_dir_cleanup_sec: NotRequired[float]
    r"""How frequently, in seconds, to clean up empty directories"""
    deadletter_path: NotRequired[str]
    r"""Storage location for files that fail to reach their final destination after maximum retries are exceeded"""
    max_retry_num: NotRequired[float]
    r"""The maximum number of times a file will attempt to move to its final destination before being dead-lettered"""


class OutputMinioMinio7(BaseModel):
    type: OutputMinioType7

    endpoint: str
    r"""MinIO service url (e.g. http://minioHost:9000)"""

    bucket: str
    r"""Name of the destination MinIO bucket. This value can be a constant or a JavaScript expression that can only be evaluated at init time. Example referencing a Global Variable: `myBucket-${C.vars.myVar}`"""

    remove_empty_dirs: Annotated[
        Optional[bool], pydantic.Field(alias="removeEmptyDirs")
    ] = True
    r"""Remove empty staging directories after moving files"""

    id: Optional[str] = None
    r"""Unique ID for this output"""

    pipeline: Optional[str] = None
    r"""Pipeline to process data before sending out to this output"""

    system_fields: Annotated[
        Optional[List[str]], pydantic.Field(alias="systemFields")
    ] = None
    r"""Fields to automatically add to events, such as cribl_pipe. Supports wildcards."""

    environment: Optional[str] = None
    r"""Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere."""

    streamtags: Optional[List[str]] = None
    r"""Tags for filtering and grouping in @{product}"""

    aws_authentication_method: Annotated[
        Annotated[
            Optional[AwsAuthenticationMethodOptions],
            PlainValidator(validate_open_enum(False)),
        ],
        pydantic.Field(alias="awsAuthenticationMethod"),
    ] = AwsAuthenticationMethodOptions.AUTO
    r"""AWS authentication method. Choose Auto to use IAM roles."""

    aws_secret_key: Annotated[Optional[str], pydantic.Field(alias="awsSecretKey")] = (
        None
    )
    r"""Secret key. This value can be a constant or a JavaScript expression, such as `${C.env.SOME_SECRET}`)."""

    region: Optional[str] = None
    r"""Region where the MinIO service/cluster is located"""

    stage_path: Annotated[Optional[str], pydantic.Field(alias="stagePath")] = (
        "$CRIBL_HOME/state/outputs/staging"
    )
    r"""Filesystem location in which to buffer files, before compressing and moving to final destination. Use performant stable storage."""

    add_id_to_stage_path: Annotated[
        Optional[bool], pydantic.Field(alias="addIdToStagePath")
    ] = True
    r"""Add the Output ID value to staging location"""

    dest_path: Annotated[Optional[str], pydantic.Field(alias="destPath")] = None
    r"""Root directory to prepend to path before uploading. Enter a constant, or a JavaScript expression enclosed in quotes or backticks."""

    signature_version: Annotated[
        Annotated[
            Optional[SignatureVersionOptions], PlainValidator(validate_open_enum(False))
        ],
        pydantic.Field(alias="signatureVersion"),
    ] = SignatureVersionOptions.V4
    r"""Signature version to use for signing MSK cluster requests"""

    object_acl: Annotated[
        Annotated[
            Optional[ObjectACLOptions], PlainValidator(validate_open_enum(False))
        ],
        pydantic.Field(alias="objectACL"),
    ] = ObjectACLOptions.PRIVATE
    r"""Object ACL to assign to uploaded objects"""

    storage_class: Annotated[
        Annotated[Optional[StorageClass7], PlainValidator(validate_open_enum(False))],
        pydantic.Field(alias="storageClass"),
    ] = None
    r"""Storage class to select for uploaded objects"""

    server_side_encryption: Annotated[
        Annotated[
            Optional[ServerSideEncryption7], PlainValidator(validate_open_enum(False))
        ],
        pydantic.Field(alias="serverSideEncryption"),
    ] = None
    r"""Server-side encryption for uploaded objects"""

    reuse_connections: Annotated[
        Optional[bool], pydantic.Field(alias="reuseConnections")
    ] = True
    r"""Reuse connections between requests, which can improve performance"""

    reject_unauthorized: Annotated[
        Optional[bool], pydantic.Field(alias="rejectUnauthorized")
    ] = True
    r"""Reject certificates that cannot be verified against a valid CA, such as self-signed certificates)"""

    verify_permissions: Annotated[
        Optional[bool], pydantic.Field(alias="verifyPermissions")
    ] = True
    r"""Disable if you can access files within the bucket but not the bucket itself"""

    partition_expr: Annotated[Optional[str], pydantic.Field(alias="partitionExpr")] = (
        "C.Time.strftime(_time ? _time : Date.now()/1000, '%Y/%m/%d')"
    )
    r"""JavaScript expression defining how files are partitioned and organized. Default is date-based. If blank, Stream will fall back to the event's __partition field value – if present – otherwise to each location's root directory."""

    format_: Annotated[
        Annotated[Optional[Format1Options], PlainValidator(validate_open_enum(False))],
        pydantic.Field(alias="format"),
    ] = Format1Options.JSON
    r"""Format of the output data"""

    base_file_name: Annotated[Optional[str], pydantic.Field(alias="baseFileName")] = (
        "`CriblOut`"
    )
    r"""JavaScript expression to define the output filename prefix (can be constant)"""

    file_name_suffix: Annotated[
        Optional[str], pydantic.Field(alias="fileNameSuffix")
    ] = '`.${C.env["CRIBL_WORKER_ID"]}.${__format}${__compression === "gzip" ? ".gz" : ""}`'
    r"""JavaScript expression to define the output filename suffix (can be constant).  The `__format` variable refers to the value of the `Data format` field (`json` or `raw`).  The `__compression` field refers to the kind of compression being used (`none` or `gzip`)."""

    max_file_size_mb: Annotated[
        Optional[float], pydantic.Field(alias="maxFileSizeMB")
    ] = 32
    r"""Maximum uncompressed output file size. Files of this size will be closed and moved to final output location."""

    max_open_files: Annotated[Optional[float], pydantic.Field(alias="maxOpenFiles")] = (
        100
    )
    r"""Maximum number of files to keep open concurrently. When exceeded, @{product} will close the oldest open files and move them to the final output location."""

    header_line: Annotated[Optional[str], pydantic.Field(alias="headerLine")] = ""
    r"""If set, this line will be written to the beginning of each output file"""

    write_high_water_mark: Annotated[
        Optional[float], pydantic.Field(alias="writeHighWaterMark")
    ] = 64
    r"""Buffer size used to write to a file"""

    on_backpressure: Annotated[
        Annotated[
            Optional[PqOnBackpressureOptions], PlainValidator(validate_open_enum(False))
        ],
        pydantic.Field(alias="onBackpressure"),
    ] = PqOnBackpressureOptions.BLOCK
    r"""How to handle events when the queue is exerting backpressure (full capacity or low disk). 'Block' is the same behavior as non-PQ blocking. 'Drop new data' throws away incoming data, while leaving the contents of the PQ unchanged."""

    deadletter_enabled: Annotated[
        Optional[bool], pydantic.Field(alias="deadletterEnabled")
    ] = False
    r"""If a file fails to move to its final destination after the maximum number of retries, move it to a designated directory to prevent further errors"""

    on_disk_full_backpressure: Annotated[
        Annotated[
            Optional[PqOnBackpressureOptions], PlainValidator(validate_open_enum(False))
        ],
        pydantic.Field(alias="onDiskFullBackpressure"),
    ] = PqOnBackpressureOptions.BLOCK
    r"""How to handle events when the queue is exerting backpressure (full capacity or low disk). 'Block' is the same behavior as non-PQ blocking. 'Drop new data' throws away incoming data, while leaving the contents of the PQ unchanged."""

    max_file_open_time_sec: Annotated[
        Optional[float], pydantic.Field(alias="maxFileOpenTimeSec")
    ] = 300
    r"""Maximum amount of time to write to a file. Files open for longer than this will be closed and moved to final output location."""

    max_file_idle_time_sec: Annotated[
        Optional[float], pydantic.Field(alias="maxFileIdleTimeSec")
    ] = 30
    r"""Maximum amount of time to keep inactive files open. Files open for longer than this will be closed and moved to final output location."""

    max_concurrent_file_parts: Annotated[
        Optional[float], pydantic.Field(alias="maxConcurrentFileParts")
    ] = 4
    r"""Maximum number of parts to upload in parallel per file. Minimum part size is 5MB."""

    description: Optional[str] = None

    aws_api_key: Annotated[Optional[str], pydantic.Field(alias="awsApiKey")] = None
    r"""This value can be a constant or a JavaScript expression (`${C.env.SOME_ACCESS_KEY}`)"""

    aws_secret: Annotated[Optional[str], pydantic.Field(alias="awsSecret")] = None
    r"""Select or create a stored secret that references your access key and secret key"""

    compress: Annotated[
        Optional[PqCompressOptions], PlainValidator(validate_open_enum(False))
    ] = PqCompressOptions.NONE
    r"""Codec to use to compress the persisted data"""

    compression_level: Annotated[
        Annotated[
            Optional[CompressionLevelOptions], PlainValidator(validate_open_enum(False))
        ],
        pydantic.Field(alias="compressionLevel"),
    ] = CompressionLevelOptions.BEST_SPEED
    r"""Compression level to apply before moving files to final destination"""

    automatic_schema: Annotated[
        Optional[bool], pydantic.Field(alias="automaticSchema")
    ] = False
    r"""Automatically calculate the schema based on the events of each Parquet file generated"""

    parquet_schema: Annotated[Optional[str], pydantic.Field(alias="parquetSchema")] = (
        None
    )
    r"""To add a new schema, navigate to Processing > Knowledge > Parquet Schemas"""

    parquet_version: Annotated[
        Annotated[
            Optional[ParquetVersionOptions], PlainValidator(validate_open_enum(False))
        ],
        pydantic.Field(alias="parquetVersion"),
    ] = ParquetVersionOptions.PARQUET_2_6
    r"""Determines which data types are supported and how they are represented"""

    parquet_data_page_version: Annotated[
        Annotated[
            Optional[ParquetDataPageVersionOptions],
            PlainValidator(validate_open_enum(False)),
        ],
        pydantic.Field(alias="parquetDataPageVersion"),
    ] = ParquetDataPageVersionOptions.DATA_PAGE_V2
    r"""Serialization format of data pages. Note that some reader implementations use Data page V2's attributes to work more efficiently, while others ignore it."""

    parquet_row_group_length: Annotated[
        Optional[float], pydantic.Field(alias="parquetRowGroupLength")
    ] = 10000
    r"""The number of rows that every group will contain. The final group can contain a smaller number of rows."""

    parquet_page_size: Annotated[
        Optional[str], pydantic.Field(alias="parquetPageSize")
    ] = "1MB"
    r"""Target memory size for page segments, such as 1MB or 128MB. Generally, lower values improve reading speed, while higher values improve compression."""

    should_log_invalid_rows: Annotated[
        Optional[bool], pydantic.Field(alias="shouldLogInvalidRows")
    ] = None
    r"""Log up to 3 rows that @{product} skips due to data mismatch"""

    key_value_metadata: Annotated[
        Optional[List[TagsType]], pydantic.Field(alias="keyValueMetadata")
    ] = None
    r"""The metadata of files the Destination writes will include the properties you add here as key-value pairs. Useful for tagging. Examples: \"key\":\"OCSF Event Class\", \"value\":\"9001\" """

    enable_statistics: Annotated[
        Optional[bool], pydantic.Field(alias="enableStatistics")
    ] = True
    r"""Statistics profile an entire file in terms of minimum/maximum values within data, numbers of nulls, etc. You can use Parquet tools to view statistics."""

    enable_write_page_index: Annotated[
        Optional[bool], pydantic.Field(alias="enableWritePageIndex")
    ] = True
    r"""One page index contains statistics for one data page. Parquet readers use statistics to enable page skipping."""

    enable_page_checksum: Annotated[
        Optional[bool], pydantic.Field(alias="enablePageChecksum")
    ] = False
    r"""Parquet tools can use the checksum of a Parquet page to verify data integrity"""

    empty_dir_cleanup_sec: Annotated[
        Optional[float], pydantic.Field(alias="emptyDirCleanupSec")
    ] = 300
    r"""How frequently, in seconds, to clean up empty directories"""

    deadletter_path: Annotated[
        Optional[str], pydantic.Field(alias="deadletterPath")
    ] = "$CRIBL_HOME/state/outputs/dead-letter"
    r"""Storage location for files that fail to reach their final destination after maximum retries are exceeded"""

    max_retry_num: Annotated[Optional[float], pydantic.Field(alias="maxRetryNum")] = 20
    r"""The maximum number of times a file will attempt to move to its final destination before being dead-lettered"""

    @field_serializer("aws_authentication_method")
    def serialize_aws_authentication_method(self, value):
        if isinstance(value, str):
            try:
                return models.AwsAuthenticationMethodOptions(value)
            except ValueError:
                return value
        return value

    @field_serializer("signature_version")
    def serialize_signature_version(self, value):
        if isinstance(value, str):
            try:
                return models.SignatureVersionOptions(value)
            except ValueError:
                return value
        return value

    @field_serializer("object_acl")
    def serialize_object_acl(self, value):
        if isinstance(value, str):
            try:
                return models.ObjectACLOptions(value)
            except ValueError:
                return value
        return value

    @field_serializer("storage_class")
    def serialize_storage_class(self, value):
        if isinstance(value, str):
            try:
                return models.StorageClass7(value)
            except ValueError:
                return value
        return value

    @field_serializer("server_side_encryption")
    def serialize_server_side_encryption(self, value):
        if isinstance(value, str):
            try:
                return models.ServerSideEncryption7(value)
            except ValueError:
                return value
        return value

    @field_serializer("format_")
    def serialize_format_(self, value):
        if isinstance(value, str):
            try:
                return models.Format1Options(value)
            except ValueError:
                return value
        return value

    @field_serializer("on_backpressure")
    def serialize_on_backpressure(self, value):
        if isinstance(value, str):
            try:
                return models.PqOnBackpressureOptions(value)
            except ValueError:
                return value
        return value

    @field_serializer("on_disk_full_backpressure")
    def serialize_on_disk_full_backpressure(self, value):
        if isinstance(value, str):
            try:
                return models.PqOnBackpressureOptions(value)
            except ValueError:
                return value
        return value

    @field_serializer("compress")
    def serialize_compress(self, value):
        if isinstance(value, str):
            try:
                return models.PqCompressOptions(value)
            except ValueError:
                return value
        return value

    @field_serializer("compression_level")
    def serialize_compression_level(self, value):
        if isinstance(value, str):
            try:
                return models.CompressionLevelOptions(value)
            except ValueError:
                return value
        return value

    @field_serializer("parquet_version")
    def serialize_parquet_version(self, value):
        if isinstance(value, str):
            try:
                return models.ParquetVersionOptions(value)
            except ValueError:
                return value
        return value

    @field_serializer("parquet_data_page_version")
    def serialize_parquet_data_page_version(self, value):
        if isinstance(value, str):
            try:
                return models.ParquetDataPageVersionOptions(value)
            except ValueError:
                return value
        return value


class OutputMinioType6(str, Enum):
    MINIO = "minio"


class StorageClass6(str, Enum, metaclass=utils.OpenEnumMeta):
    r"""Storage class to select for uploaded objects"""

    # Standard
    STANDARD = "STANDARD"
    # Reduced Redundancy Storage
    REDUCED_REDUNDANCY = "REDUCED_REDUNDANCY"


class ServerSideEncryption6(str, Enum, metaclass=utils.OpenEnumMeta):
    r"""Server-side encryption for uploaded objects"""

    # Amazon S3 Managed Key
    AES256 = "AES256"


class OutputMinioMinio6TypedDict(TypedDict):
    type: OutputMinioType6
    endpoint: str
    r"""MinIO service url (e.g. http://minioHost:9000)"""
    bucket: str
    r"""Name of the destination MinIO bucket. This value can be a constant or a JavaScript expression that can only be evaluated at init time. Example referencing a Global Variable: `myBucket-${C.vars.myVar}`"""
    remove_empty_dirs: NotRequired[bool]
    r"""Remove empty staging directories after moving files"""
    id: NotRequired[str]
    r"""Unique ID for this output"""
    pipeline: NotRequired[str]
    r"""Pipeline to process data before sending out to this output"""
    system_fields: NotRequired[List[str]]
    r"""Fields to automatically add to events, such as cribl_pipe. Supports wildcards."""
    environment: NotRequired[str]
    r"""Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere."""
    streamtags: NotRequired[List[str]]
    r"""Tags for filtering and grouping in @{product}"""
    aws_authentication_method: NotRequired[AwsAuthenticationMethodOptions]
    r"""AWS authentication method. Choose Auto to use IAM roles."""
    aws_secret_key: NotRequired[str]
    r"""Secret key. This value can be a constant or a JavaScript expression, such as `${C.env.SOME_SECRET}`)."""
    region: NotRequired[str]
    r"""Region where the MinIO service/cluster is located"""
    stage_path: NotRequired[str]
    r"""Filesystem location in which to buffer files, before compressing and moving to final destination. Use performant stable storage."""
    add_id_to_stage_path: NotRequired[bool]
    r"""Add the Output ID value to staging location"""
    dest_path: NotRequired[str]
    r"""Root directory to prepend to path before uploading. Enter a constant, or a JavaScript expression enclosed in quotes or backticks."""
    signature_version: NotRequired[SignatureVersionOptions]
    r"""Signature version to use for signing MSK cluster requests"""
    object_acl: NotRequired[ObjectACLOptions]
    r"""Object ACL to assign to uploaded objects"""
    storage_class: NotRequired[StorageClass6]
    r"""Storage class to select for uploaded objects"""
    server_side_encryption: NotRequired[ServerSideEncryption6]
    r"""Server-side encryption for uploaded objects"""
    reuse_connections: NotRequired[bool]
    r"""Reuse connections between requests, which can improve performance"""
    reject_unauthorized: NotRequired[bool]
    r"""Reject certificates that cannot be verified against a valid CA, such as self-signed certificates)"""
    verify_permissions: NotRequired[bool]
    r"""Disable if you can access files within the bucket but not the bucket itself"""
    partition_expr: NotRequired[str]
    r"""JavaScript expression defining how files are partitioned and organized. Default is date-based. If blank, Stream will fall back to the event's __partition field value – if present – otherwise to each location's root directory."""
    format_: NotRequired[Format1Options]
    r"""Format of the output data"""
    base_file_name: NotRequired[str]
    r"""JavaScript expression to define the output filename prefix (can be constant)"""
    file_name_suffix: NotRequired[str]
    r"""JavaScript expression to define the output filename suffix (can be constant).  The `__format` variable refers to the value of the `Data format` field (`json` or `raw`).  The `__compression` field refers to the kind of compression being used (`none` or `gzip`)."""
    max_file_size_mb: NotRequired[float]
    r"""Maximum uncompressed output file size. Files of this size will be closed and moved to final output location."""
    max_open_files: NotRequired[float]
    r"""Maximum number of files to keep open concurrently. When exceeded, @{product} will close the oldest open files and move them to the final output location."""
    header_line: NotRequired[str]
    r"""If set, this line will be written to the beginning of each output file"""
    write_high_water_mark: NotRequired[float]
    r"""Buffer size used to write to a file"""
    on_backpressure: NotRequired[PqOnBackpressureOptions]
    r"""How to handle events when the queue is exerting backpressure (full capacity or low disk). 'Block' is the same behavior as non-PQ blocking. 'Drop new data' throws away incoming data, while leaving the contents of the PQ unchanged."""
    deadletter_enabled: NotRequired[bool]
    r"""If a file fails to move to its final destination after the maximum number of retries, move it to a designated directory to prevent further errors"""
    on_disk_full_backpressure: NotRequired[PqOnBackpressureOptions]
    r"""How to handle events when the queue is exerting backpressure (full capacity or low disk). 'Block' is the same behavior as non-PQ blocking. 'Drop new data' throws away incoming data, while leaving the contents of the PQ unchanged."""
    max_file_open_time_sec: NotRequired[float]
    r"""Maximum amount of time to write to a file. Files open for longer than this will be closed and moved to final output location."""
    max_file_idle_time_sec: NotRequired[float]
    r"""Maximum amount of time to keep inactive files open. Files open for longer than this will be closed and moved to final output location."""
    max_concurrent_file_parts: NotRequired[float]
    r"""Maximum number of parts to upload in parallel per file. Minimum part size is 5MB."""
    description: NotRequired[str]
    aws_api_key: NotRequired[str]
    r"""This value can be a constant or a JavaScript expression (`${C.env.SOME_ACCESS_KEY}`)"""
    aws_secret: NotRequired[str]
    r"""Select or create a stored secret that references your access key and secret key"""
    compress: NotRequired[PqCompressOptions]
    r"""Codec to use to compress the persisted data"""
    compression_level: NotRequired[CompressionLevelOptions]
    r"""Compression level to apply before moving files to final destination"""
    automatic_schema: NotRequired[bool]
    r"""Automatically calculate the schema based on the events of each Parquet file generated"""
    parquet_schema: NotRequired[str]
    r"""To add a new schema, navigate to Processing > Knowledge > Parquet Schemas"""
    parquet_version: NotRequired[ParquetVersionOptions]
    r"""Determines which data types are supported and how they are represented"""
    parquet_data_page_version: NotRequired[ParquetDataPageVersionOptions]
    r"""Serialization format of data pages. Note that some reader implementations use Data page V2's attributes to work more efficiently, while others ignore it."""
    parquet_row_group_length: NotRequired[float]
    r"""The number of rows that every group will contain. The final group can contain a smaller number of rows."""
    parquet_page_size: NotRequired[str]
    r"""Target memory size for page segments, such as 1MB or 128MB. Generally, lower values improve reading speed, while higher values improve compression."""
    should_log_invalid_rows: NotRequired[bool]
    r"""Log up to 3 rows that @{product} skips due to data mismatch"""
    key_value_metadata: NotRequired[List[TagsTypeTypedDict]]
    r"""The metadata of files the Destination writes will include the properties you add here as key-value pairs. Useful for tagging. Examples: \"key\":\"OCSF Event Class\", \"value\":\"9001\" """
    enable_statistics: NotRequired[bool]
    r"""Statistics profile an entire file in terms of minimum/maximum values within data, numbers of nulls, etc. You can use Parquet tools to view statistics."""
    enable_write_page_index: NotRequired[bool]
    r"""One page index contains statistics for one data page. Parquet readers use statistics to enable page skipping."""
    enable_page_checksum: NotRequired[bool]
    r"""Parquet tools can use the checksum of a Parquet page to verify data integrity"""
    empty_dir_cleanup_sec: NotRequired[float]
    r"""How frequently, in seconds, to clean up empty directories"""
    deadletter_path: NotRequired[str]
    r"""Storage location for files that fail to reach their final destination after maximum retries are exceeded"""
    max_retry_num: NotRequired[float]
    r"""The maximum number of times a file will attempt to move to its final destination before being dead-lettered"""


class OutputMinioMinio6(BaseModel):
    type: OutputMinioType6

    endpoint: str
    r"""MinIO service url (e.g. http://minioHost:9000)"""

    bucket: str
    r"""Name of the destination MinIO bucket. This value can be a constant or a JavaScript expression that can only be evaluated at init time. Example referencing a Global Variable: `myBucket-${C.vars.myVar}`"""

    remove_empty_dirs: Annotated[
        Optional[bool], pydantic.Field(alias="removeEmptyDirs")
    ] = True
    r"""Remove empty staging directories after moving files"""

    id: Optional[str] = None
    r"""Unique ID for this output"""

    pipeline: Optional[str] = None
    r"""Pipeline to process data before sending out to this output"""

    system_fields: Annotated[
        Optional[List[str]], pydantic.Field(alias="systemFields")
    ] = None
    r"""Fields to automatically add to events, such as cribl_pipe. Supports wildcards."""

    environment: Optional[str] = None
    r"""Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere."""

    streamtags: Optional[List[str]] = None
    r"""Tags for filtering and grouping in @{product}"""

    aws_authentication_method: Annotated[
        Annotated[
            Optional[AwsAuthenticationMethodOptions],
            PlainValidator(validate_open_enum(False)),
        ],
        pydantic.Field(alias="awsAuthenticationMethod"),
    ] = AwsAuthenticationMethodOptions.AUTO
    r"""AWS authentication method. Choose Auto to use IAM roles."""

    aws_secret_key: Annotated[Optional[str], pydantic.Field(alias="awsSecretKey")] = (
        None
    )
    r"""Secret key. This value can be a constant or a JavaScript expression, such as `${C.env.SOME_SECRET}`)."""

    region: Optional[str] = None
    r"""Region where the MinIO service/cluster is located"""

    stage_path: Annotated[Optional[str], pydantic.Field(alias="stagePath")] = (
        "$CRIBL_HOME/state/outputs/staging"
    )
    r"""Filesystem location in which to buffer files, before compressing and moving to final destination. Use performant stable storage."""

    add_id_to_stage_path: Annotated[
        Optional[bool], pydantic.Field(alias="addIdToStagePath")
    ] = True
    r"""Add the Output ID value to staging location"""

    dest_path: Annotated[Optional[str], pydantic.Field(alias="destPath")] = None
    r"""Root directory to prepend to path before uploading. Enter a constant, or a JavaScript expression enclosed in quotes or backticks."""

    signature_version: Annotated[
        Annotated[
            Optional[SignatureVersionOptions], PlainValidator(validate_open_enum(False))
        ],
        pydantic.Field(alias="signatureVersion"),
    ] = SignatureVersionOptions.V4
    r"""Signature version to use for signing MSK cluster requests"""

    object_acl: Annotated[
        Annotated[
            Optional[ObjectACLOptions], PlainValidator(validate_open_enum(False))
        ],
        pydantic.Field(alias="objectACL"),
    ] = ObjectACLOptions.PRIVATE
    r"""Object ACL to assign to uploaded objects"""

    storage_class: Annotated[
        Annotated[Optional[StorageClass6], PlainValidator(validate_open_enum(False))],
        pydantic.Field(alias="storageClass"),
    ] = None
    r"""Storage class to select for uploaded objects"""

    server_side_encryption: Annotated[
        Annotated[
            Optional[ServerSideEncryption6], PlainValidator(validate_open_enum(False))
        ],
        pydantic.Field(alias="serverSideEncryption"),
    ] = None
    r"""Server-side encryption for uploaded objects"""

    reuse_connections: Annotated[
        Optional[bool], pydantic.Field(alias="reuseConnections")
    ] = True
    r"""Reuse connections between requests, which can improve performance"""

    reject_unauthorized: Annotated[
        Optional[bool], pydantic.Field(alias="rejectUnauthorized")
    ] = True
    r"""Reject certificates that cannot be verified against a valid CA, such as self-signed certificates)"""

    verify_permissions: Annotated[
        Optional[bool], pydantic.Field(alias="verifyPermissions")
    ] = True
    r"""Disable if you can access files within the bucket but not the bucket itself"""

    partition_expr: Annotated[Optional[str], pydantic.Field(alias="partitionExpr")] = (
        "C.Time.strftime(_time ? _time : Date.now()/1000, '%Y/%m/%d')"
    )
    r"""JavaScript expression defining how files are partitioned and organized. Default is date-based. If blank, Stream will fall back to the event's __partition field value – if present – otherwise to each location's root directory."""

    format_: Annotated[
        Annotated[Optional[Format1Options], PlainValidator(validate_open_enum(False))],
        pydantic.Field(alias="format"),
    ] = Format1Options.JSON
    r"""Format of the output data"""

    base_file_name: Annotated[Optional[str], pydantic.Field(alias="baseFileName")] = (
        "`CriblOut`"
    )
    r"""JavaScript expression to define the output filename prefix (can be constant)"""

    file_name_suffix: Annotated[
        Optional[str], pydantic.Field(alias="fileNameSuffix")
    ] = '`.${C.env["CRIBL_WORKER_ID"]}.${__format}${__compression === "gzip" ? ".gz" : ""}`'
    r"""JavaScript expression to define the output filename suffix (can be constant).  The `__format` variable refers to the value of the `Data format` field (`json` or `raw`).  The `__compression` field refers to the kind of compression being used (`none` or `gzip`)."""

    max_file_size_mb: Annotated[
        Optional[float], pydantic.Field(alias="maxFileSizeMB")
    ] = 32
    r"""Maximum uncompressed output file size. Files of this size will be closed and moved to final output location."""

    max_open_files: Annotated[Optional[float], pydantic.Field(alias="maxOpenFiles")] = (
        100
    )
    r"""Maximum number of files to keep open concurrently. When exceeded, @{product} will close the oldest open files and move them to the final output location."""

    header_line: Annotated[Optional[str], pydantic.Field(alias="headerLine")] = ""
    r"""If set, this line will be written to the beginning of each output file"""

    write_high_water_mark: Annotated[
        Optional[float], pydantic.Field(alias="writeHighWaterMark")
    ] = 64
    r"""Buffer size used to write to a file"""

    on_backpressure: Annotated[
        Annotated[
            Optional[PqOnBackpressureOptions], PlainValidator(validate_open_enum(False))
        ],
        pydantic.Field(alias="onBackpressure"),
    ] = PqOnBackpressureOptions.BLOCK
    r"""How to handle events when the queue is exerting backpressure (full capacity or low disk). 'Block' is the same behavior as non-PQ blocking. 'Drop new data' throws away incoming data, while leaving the contents of the PQ unchanged."""

    deadletter_enabled: Annotated[
        Optional[bool], pydantic.Field(alias="deadletterEnabled")
    ] = False
    r"""If a file fails to move to its final destination after the maximum number of retries, move it to a designated directory to prevent further errors"""

    on_disk_full_backpressure: Annotated[
        Annotated[
            Optional[PqOnBackpressureOptions], PlainValidator(validate_open_enum(False))
        ],
        pydantic.Field(alias="onDiskFullBackpressure"),
    ] = PqOnBackpressureOptions.BLOCK
    r"""How to handle events when the queue is exerting backpressure (full capacity or low disk). 'Block' is the same behavior as non-PQ blocking. 'Drop new data' throws away incoming data, while leaving the contents of the PQ unchanged."""

    max_file_open_time_sec: Annotated[
        Optional[float], pydantic.Field(alias="maxFileOpenTimeSec")
    ] = 300
    r"""Maximum amount of time to write to a file. Files open for longer than this will be closed and moved to final output location."""

    max_file_idle_time_sec: Annotated[
        Optional[float], pydantic.Field(alias="maxFileIdleTimeSec")
    ] = 30
    r"""Maximum amount of time to keep inactive files open. Files open for longer than this will be closed and moved to final output location."""

    max_concurrent_file_parts: Annotated[
        Optional[float], pydantic.Field(alias="maxConcurrentFileParts")
    ] = 4
    r"""Maximum number of parts to upload in parallel per file. Minimum part size is 5MB."""

    description: Optional[str] = None

    aws_api_key: Annotated[Optional[str], pydantic.Field(alias="awsApiKey")] = None
    r"""This value can be a constant or a JavaScript expression (`${C.env.SOME_ACCESS_KEY}`)"""

    aws_secret: Annotated[Optional[str], pydantic.Field(alias="awsSecret")] = None
    r"""Select or create a stored secret that references your access key and secret key"""

    compress: Annotated[
        Optional[PqCompressOptions], PlainValidator(validate_open_enum(False))
    ] = PqCompressOptions.NONE
    r"""Codec to use to compress the persisted data"""

    compression_level: Annotated[
        Annotated[
            Optional[CompressionLevelOptions], PlainValidator(validate_open_enum(False))
        ],
        pydantic.Field(alias="compressionLevel"),
    ] = CompressionLevelOptions.BEST_SPEED
    r"""Compression level to apply before moving files to final destination"""

    automatic_schema: Annotated[
        Optional[bool], pydantic.Field(alias="automaticSchema")
    ] = False
    r"""Automatically calculate the schema based on the events of each Parquet file generated"""

    parquet_schema: Annotated[Optional[str], pydantic.Field(alias="parquetSchema")] = (
        None
    )
    r"""To add a new schema, navigate to Processing > Knowledge > Parquet Schemas"""

    parquet_version: Annotated[
        Annotated[
            Optional[ParquetVersionOptions], PlainValidator(validate_open_enum(False))
        ],
        pydantic.Field(alias="parquetVersion"),
    ] = ParquetVersionOptions.PARQUET_2_6
    r"""Determines which data types are supported and how they are represented"""

    parquet_data_page_version: Annotated[
        Annotated[
            Optional[ParquetDataPageVersionOptions],
            PlainValidator(validate_open_enum(False)),
        ],
        pydantic.Field(alias="parquetDataPageVersion"),
    ] = ParquetDataPageVersionOptions.DATA_PAGE_V2
    r"""Serialization format of data pages. Note that some reader implementations use Data page V2's attributes to work more efficiently, while others ignore it."""

    parquet_row_group_length: Annotated[
        Optional[float], pydantic.Field(alias="parquetRowGroupLength")
    ] = 10000
    r"""The number of rows that every group will contain. The final group can contain a smaller number of rows."""

    parquet_page_size: Annotated[
        Optional[str], pydantic.Field(alias="parquetPageSize")
    ] = "1MB"
    r"""Target memory size for page segments, such as 1MB or 128MB. Generally, lower values improve reading speed, while higher values improve compression."""

    should_log_invalid_rows: Annotated[
        Optional[bool], pydantic.Field(alias="shouldLogInvalidRows")
    ] = None
    r"""Log up to 3 rows that @{product} skips due to data mismatch"""

    key_value_metadata: Annotated[
        Optional[List[TagsType]], pydantic.Field(alias="keyValueMetadata")
    ] = None
    r"""The metadata of files the Destination writes will include the properties you add here as key-value pairs. Useful for tagging. Examples: \"key\":\"OCSF Event Class\", \"value\":\"9001\" """

    enable_statistics: Annotated[
        Optional[bool], pydantic.Field(alias="enableStatistics")
    ] = True
    r"""Statistics profile an entire file in terms of minimum/maximum values within data, numbers of nulls, etc. You can use Parquet tools to view statistics."""

    enable_write_page_index: Annotated[
        Optional[bool], pydantic.Field(alias="enableWritePageIndex")
    ] = True
    r"""One page index contains statistics for one data page. Parquet readers use statistics to enable page skipping."""

    enable_page_checksum: Annotated[
        Optional[bool], pydantic.Field(alias="enablePageChecksum")
    ] = False
    r"""Parquet tools can use the checksum of a Parquet page to verify data integrity"""

    empty_dir_cleanup_sec: Annotated[
        Optional[float], pydantic.Field(alias="emptyDirCleanupSec")
    ] = 300
    r"""How frequently, in seconds, to clean up empty directories"""

    deadletter_path: Annotated[
        Optional[str], pydantic.Field(alias="deadletterPath")
    ] = "$CRIBL_HOME/state/outputs/dead-letter"
    r"""Storage location for files that fail to reach their final destination after maximum retries are exceeded"""

    max_retry_num: Annotated[Optional[float], pydantic.Field(alias="maxRetryNum")] = 20
    r"""The maximum number of times a file will attempt to move to its final destination before being dead-lettered"""

    @field_serializer("aws_authentication_method")
    def serialize_aws_authentication_method(self, value):
        if isinstance(value, str):
            try:
                return models.AwsAuthenticationMethodOptions(value)
            except ValueError:
                return value
        return value

    @field_serializer("signature_version")
    def serialize_signature_version(self, value):
        if isinstance(value, str):
            try:
                return models.SignatureVersionOptions(value)
            except ValueError:
                return value
        return value

    @field_serializer("object_acl")
    def serialize_object_acl(self, value):
        if isinstance(value, str):
            try:
                return models.ObjectACLOptions(value)
            except ValueError:
                return value
        return value

    @field_serializer("storage_class")
    def serialize_storage_class(self, value):
        if isinstance(value, str):
            try:
                return models.StorageClass6(value)
            except ValueError:
                return value
        return value

    @field_serializer("server_side_encryption")
    def serialize_server_side_encryption(self, value):
        if isinstance(value, str):
            try:
                return models.ServerSideEncryption6(value)
            except ValueError:
                return value
        return value

    @field_serializer("format_")
    def serialize_format_(self, value):
        if isinstance(value, str):
            try:
                return models.Format1Options(value)
            except ValueError:
                return value
        return value

    @field_serializer("on_backpressure")
    def serialize_on_backpressure(self, value):
        if isinstance(value, str):
            try:
                return models.PqOnBackpressureOptions(value)
            except ValueError:
                return value
        return value

    @field_serializer("on_disk_full_backpressure")
    def serialize_on_disk_full_backpressure(self, value):
        if isinstance(value, str):
            try:
                return models.PqOnBackpressureOptions(value)
            except ValueError:
                return value
        return value

    @field_serializer("compress")
    def serialize_compress(self, value):
        if isinstance(value, str):
            try:
                return models.PqCompressOptions(value)
            except ValueError:
                return value
        return value

    @field_serializer("compression_level")
    def serialize_compression_level(self, value):
        if isinstance(value, str):
            try:
                return models.CompressionLevelOptions(value)
            except ValueError:
                return value
        return value

    @field_serializer("parquet_version")
    def serialize_parquet_version(self, value):
        if isinstance(value, str):
            try:
                return models.ParquetVersionOptions(value)
            except ValueError:
                return value
        return value

    @field_serializer("parquet_data_page_version")
    def serialize_parquet_data_page_version(self, value):
        if isinstance(value, str):
            try:
                return models.ParquetDataPageVersionOptions(value)
            except ValueError:
                return value
        return value


class OutputMinioType5(str, Enum):
    MINIO = "minio"


class StorageClass5(str, Enum, metaclass=utils.OpenEnumMeta):
    r"""Storage class to select for uploaded objects"""

    # Standard
    STANDARD = "STANDARD"
    # Reduced Redundancy Storage
    REDUCED_REDUNDANCY = "REDUCED_REDUNDANCY"


class ServerSideEncryption5(str, Enum, metaclass=utils.OpenEnumMeta):
    r"""Server-side encryption for uploaded objects"""

    # Amazon S3 Managed Key
    AES256 = "AES256"


class OutputMinioMinio5TypedDict(TypedDict):
    type: OutputMinioType5
    endpoint: str
    r"""MinIO service url (e.g. http://minioHost:9000)"""
    bucket: str
    r"""Name of the destination MinIO bucket. This value can be a constant or a JavaScript expression that can only be evaluated at init time. Example referencing a Global Variable: `myBucket-${C.vars.myVar}`"""
    should_log_invalid_rows: bool
    r"""Log up to 3 rows that @{product} skips due to data mismatch"""
    key_value_metadata: List[TagsTypeTypedDict]
    r"""The metadata of files the Destination writes will include the properties you add here as key-value pairs. Useful for tagging. Examples: \"key\":\"OCSF Event Class\", \"value\":\"9001\" """
    format_: NotRequired[Format1Options]
    r"""Format of the output data"""
    id: NotRequired[str]
    r"""Unique ID for this output"""
    pipeline: NotRequired[str]
    r"""Pipeline to process data before sending out to this output"""
    system_fields: NotRequired[List[str]]
    r"""Fields to automatically add to events, such as cribl_pipe. Supports wildcards."""
    environment: NotRequired[str]
    r"""Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere."""
    streamtags: NotRequired[List[str]]
    r"""Tags for filtering and grouping in @{product}"""
    aws_authentication_method: NotRequired[AwsAuthenticationMethodOptions]
    r"""AWS authentication method. Choose Auto to use IAM roles."""
    aws_secret_key: NotRequired[str]
    r"""Secret key. This value can be a constant or a JavaScript expression, such as `${C.env.SOME_SECRET}`)."""
    region: NotRequired[str]
    r"""Region where the MinIO service/cluster is located"""
    stage_path: NotRequired[str]
    r"""Filesystem location in which to buffer files, before compressing and moving to final destination. Use performant stable storage."""
    add_id_to_stage_path: NotRequired[bool]
    r"""Add the Output ID value to staging location"""
    dest_path: NotRequired[str]
    r"""Root directory to prepend to path before uploading. Enter a constant, or a JavaScript expression enclosed in quotes or backticks."""
    signature_version: NotRequired[SignatureVersionOptions]
    r"""Signature version to use for signing MSK cluster requests"""
    object_acl: NotRequired[ObjectACLOptions]
    r"""Object ACL to assign to uploaded objects"""
    storage_class: NotRequired[StorageClass5]
    r"""Storage class to select for uploaded objects"""
    server_side_encryption: NotRequired[ServerSideEncryption5]
    r"""Server-side encryption for uploaded objects"""
    reuse_connections: NotRequired[bool]
    r"""Reuse connections between requests, which can improve performance"""
    reject_unauthorized: NotRequired[bool]
    r"""Reject certificates that cannot be verified against a valid CA, such as self-signed certificates)"""
    verify_permissions: NotRequired[bool]
    r"""Disable if you can access files within the bucket but not the bucket itself"""
    remove_empty_dirs: NotRequired[bool]
    r"""Remove empty staging directories after moving files"""
    partition_expr: NotRequired[str]
    r"""JavaScript expression defining how files are partitioned and organized. Default is date-based. If blank, Stream will fall back to the event's __partition field value – if present – otherwise to each location's root directory."""
    base_file_name: NotRequired[str]
    r"""JavaScript expression to define the output filename prefix (can be constant)"""
    file_name_suffix: NotRequired[str]
    r"""JavaScript expression to define the output filename suffix (can be constant).  The `__format` variable refers to the value of the `Data format` field (`json` or `raw`).  The `__compression` field refers to the kind of compression being used (`none` or `gzip`)."""
    max_file_size_mb: NotRequired[float]
    r"""Maximum uncompressed output file size. Files of this size will be closed and moved to final output location."""
    max_open_files: NotRequired[float]
    r"""Maximum number of files to keep open concurrently. When exceeded, @{product} will close the oldest open files and move them to the final output location."""
    header_line: NotRequired[str]
    r"""If set, this line will be written to the beginning of each output file"""
    write_high_water_mark: NotRequired[float]
    r"""Buffer size used to write to a file"""
    on_backpressure: NotRequired[PqOnBackpressureOptions]
    r"""How to handle events when the queue is exerting backpressure (full capacity or low disk). 'Block' is the same behavior as non-PQ blocking. 'Drop new data' throws away incoming data, while leaving the contents of the PQ unchanged."""
    deadletter_enabled: NotRequired[bool]
    r"""If a file fails to move to its final destination after the maximum number of retries, move it to a designated directory to prevent further errors"""
    on_disk_full_backpressure: NotRequired[PqOnBackpressureOptions]
    r"""How to handle events when the queue is exerting backpressure (full capacity or low disk). 'Block' is the same behavior as non-PQ blocking. 'Drop new data' throws away incoming data, while leaving the contents of the PQ unchanged."""
    max_file_open_time_sec: NotRequired[float]
    r"""Maximum amount of time to write to a file. Files open for longer than this will be closed and moved to final output location."""
    max_file_idle_time_sec: NotRequired[float]
    r"""Maximum amount of time to keep inactive files open. Files open for longer than this will be closed and moved to final output location."""
    max_concurrent_file_parts: NotRequired[float]
    r"""Maximum number of parts to upload in parallel per file. Minimum part size is 5MB."""
    description: NotRequired[str]
    aws_api_key: NotRequired[str]
    r"""This value can be a constant or a JavaScript expression (`${C.env.SOME_ACCESS_KEY}`)"""
    aws_secret: NotRequired[str]
    r"""Select or create a stored secret that references your access key and secret key"""
    compress: NotRequired[PqCompressOptions]
    r"""Codec to use to compress the persisted data"""
    compression_level: NotRequired[CompressionLevelOptions]
    r"""Compression level to apply before moving files to final destination"""
    automatic_schema: NotRequired[bool]
    r"""Automatically calculate the schema based on the events of each Parquet file generated"""
    parquet_schema: NotRequired[str]
    r"""To add a new schema, navigate to Processing > Knowledge > Parquet Schemas"""
    parquet_version: NotRequired[ParquetVersionOptions]
    r"""Determines which data types are supported and how they are represented"""
    parquet_data_page_version: NotRequired[ParquetDataPageVersionOptions]
    r"""Serialization format of data pages. Note that some reader implementations use Data page V2's attributes to work more efficiently, while others ignore it."""
    parquet_row_group_length: NotRequired[float]
    r"""The number of rows that every group will contain. The final group can contain a smaller number of rows."""
    parquet_page_size: NotRequired[str]
    r"""Target memory size for page segments, such as 1MB or 128MB. Generally, lower values improve reading speed, while higher values improve compression."""
    enable_statistics: NotRequired[bool]
    r"""Statistics profile an entire file in terms of minimum/maximum values within data, numbers of nulls, etc. You can use Parquet tools to view statistics."""
    enable_write_page_index: NotRequired[bool]
    r"""One page index contains statistics for one data page. Parquet readers use statistics to enable page skipping."""
    enable_page_checksum: NotRequired[bool]
    r"""Parquet tools can use the checksum of a Parquet page to verify data integrity"""
    empty_dir_cleanup_sec: NotRequired[float]
    r"""How frequently, in seconds, to clean up empty directories"""
    deadletter_path: NotRequired[str]
    r"""Storage location for files that fail to reach their final destination after maximum retries are exceeded"""
    max_retry_num: NotRequired[float]
    r"""The maximum number of times a file will attempt to move to its final destination before being dead-lettered"""


class OutputMinioMinio5(BaseModel):
    type: OutputMinioType5

    endpoint: str
    r"""MinIO service url (e.g. http://minioHost:9000)"""

    bucket: str
    r"""Name of the destination MinIO bucket. This value can be a constant or a JavaScript expression that can only be evaluated at init time. Example referencing a Global Variable: `myBucket-${C.vars.myVar}`"""

    should_log_invalid_rows: Annotated[
        bool, pydantic.Field(alias="shouldLogInvalidRows")
    ]
    r"""Log up to 3 rows that @{product} skips due to data mismatch"""

    key_value_metadata: Annotated[
        List[TagsType], pydantic.Field(alias="keyValueMetadata")
    ]
    r"""The metadata of files the Destination writes will include the properties you add here as key-value pairs. Useful for tagging. Examples: \"key\":\"OCSF Event Class\", \"value\":\"9001\" """

    format_: Annotated[
        Annotated[Optional[Format1Options], PlainValidator(validate_open_enum(False))],
        pydantic.Field(alias="format"),
    ] = Format1Options.JSON
    r"""Format of the output data"""

    id: Optional[str] = None
    r"""Unique ID for this output"""

    pipeline: Optional[str] = None
    r"""Pipeline to process data before sending out to this output"""

    system_fields: Annotated[
        Optional[List[str]], pydantic.Field(alias="systemFields")
    ] = None
    r"""Fields to automatically add to events, such as cribl_pipe. Supports wildcards."""

    environment: Optional[str] = None
    r"""Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere."""

    streamtags: Optional[List[str]] = None
    r"""Tags for filtering and grouping in @{product}"""

    aws_authentication_method: Annotated[
        Annotated[
            Optional[AwsAuthenticationMethodOptions],
            PlainValidator(validate_open_enum(False)),
        ],
        pydantic.Field(alias="awsAuthenticationMethod"),
    ] = AwsAuthenticationMethodOptions.AUTO
    r"""AWS authentication method. Choose Auto to use IAM roles."""

    aws_secret_key: Annotated[Optional[str], pydantic.Field(alias="awsSecretKey")] = (
        None
    )
    r"""Secret key. This value can be a constant or a JavaScript expression, such as `${C.env.SOME_SECRET}`)."""

    region: Optional[str] = None
    r"""Region where the MinIO service/cluster is located"""

    stage_path: Annotated[Optional[str], pydantic.Field(alias="stagePath")] = (
        "$CRIBL_HOME/state/outputs/staging"
    )
    r"""Filesystem location in which to buffer files, before compressing and moving to final destination. Use performant stable storage."""

    add_id_to_stage_path: Annotated[
        Optional[bool], pydantic.Field(alias="addIdToStagePath")
    ] = True
    r"""Add the Output ID value to staging location"""

    dest_path: Annotated[Optional[str], pydantic.Field(alias="destPath")] = None
    r"""Root directory to prepend to path before uploading. Enter a constant, or a JavaScript expression enclosed in quotes or backticks."""

    signature_version: Annotated[
        Annotated[
            Optional[SignatureVersionOptions], PlainValidator(validate_open_enum(False))
        ],
        pydantic.Field(alias="signatureVersion"),
    ] = SignatureVersionOptions.V4
    r"""Signature version to use for signing MSK cluster requests"""

    object_acl: Annotated[
        Annotated[
            Optional[ObjectACLOptions], PlainValidator(validate_open_enum(False))
        ],
        pydantic.Field(alias="objectACL"),
    ] = ObjectACLOptions.PRIVATE
    r"""Object ACL to assign to uploaded objects"""

    storage_class: Annotated[
        Annotated[Optional[StorageClass5], PlainValidator(validate_open_enum(False))],
        pydantic.Field(alias="storageClass"),
    ] = None
    r"""Storage class to select for uploaded objects"""

    server_side_encryption: Annotated[
        Annotated[
            Optional[ServerSideEncryption5], PlainValidator(validate_open_enum(False))
        ],
        pydantic.Field(alias="serverSideEncryption"),
    ] = None
    r"""Server-side encryption for uploaded objects"""

    reuse_connections: Annotated[
        Optional[bool], pydantic.Field(alias="reuseConnections")
    ] = True
    r"""Reuse connections between requests, which can improve performance"""

    reject_unauthorized: Annotated[
        Optional[bool], pydantic.Field(alias="rejectUnauthorized")
    ] = True
    r"""Reject certificates that cannot be verified against a valid CA, such as self-signed certificates)"""

    verify_permissions: Annotated[
        Optional[bool], pydantic.Field(alias="verifyPermissions")
    ] = True
    r"""Disable if you can access files within the bucket but not the bucket itself"""

    remove_empty_dirs: Annotated[
        Optional[bool], pydantic.Field(alias="removeEmptyDirs")
    ] = True
    r"""Remove empty staging directories after moving files"""

    partition_expr: Annotated[Optional[str], pydantic.Field(alias="partitionExpr")] = (
        "C.Time.strftime(_time ? _time : Date.now()/1000, '%Y/%m/%d')"
    )
    r"""JavaScript expression defining how files are partitioned and organized. Default is date-based. If blank, Stream will fall back to the event's __partition field value – if present – otherwise to each location's root directory."""

    base_file_name: Annotated[Optional[str], pydantic.Field(alias="baseFileName")] = (
        "`CriblOut`"
    )
    r"""JavaScript expression to define the output filename prefix (can be constant)"""

    file_name_suffix: Annotated[
        Optional[str], pydantic.Field(alias="fileNameSuffix")
    ] = '`.${C.env["CRIBL_WORKER_ID"]}.${__format}${__compression === "gzip" ? ".gz" : ""}`'
    r"""JavaScript expression to define the output filename suffix (can be constant).  The `__format` variable refers to the value of the `Data format` field (`json` or `raw`).  The `__compression` field refers to the kind of compression being used (`none` or `gzip`)."""

    max_file_size_mb: Annotated[
        Optional[float], pydantic.Field(alias="maxFileSizeMB")
    ] = 32
    r"""Maximum uncompressed output file size. Files of this size will be closed and moved to final output location."""

    max_open_files: Annotated[Optional[float], pydantic.Field(alias="maxOpenFiles")] = (
        100
    )
    r"""Maximum number of files to keep open concurrently. When exceeded, @{product} will close the oldest open files and move them to the final output location."""

    header_line: Annotated[Optional[str], pydantic.Field(alias="headerLine")] = ""
    r"""If set, this line will be written to the beginning of each output file"""

    write_high_water_mark: Annotated[
        Optional[float], pydantic.Field(alias="writeHighWaterMark")
    ] = 64
    r"""Buffer size used to write to a file"""

    on_backpressure: Annotated[
        Annotated[
            Optional[PqOnBackpressureOptions], PlainValidator(validate_open_enum(False))
        ],
        pydantic.Field(alias="onBackpressure"),
    ] = PqOnBackpressureOptions.BLOCK
    r"""How to handle events when the queue is exerting backpressure (full capacity or low disk). 'Block' is the same behavior as non-PQ blocking. 'Drop new data' throws away incoming data, while leaving the contents of the PQ unchanged."""

    deadletter_enabled: Annotated[
        Optional[bool], pydantic.Field(alias="deadletterEnabled")
    ] = False
    r"""If a file fails to move to its final destination after the maximum number of retries, move it to a designated directory to prevent further errors"""

    on_disk_full_backpressure: Annotated[
        Annotated[
            Optional[PqOnBackpressureOptions], PlainValidator(validate_open_enum(False))
        ],
        pydantic.Field(alias="onDiskFullBackpressure"),
    ] = PqOnBackpressureOptions.BLOCK
    r"""How to handle events when the queue is exerting backpressure (full capacity or low disk). 'Block' is the same behavior as non-PQ blocking. 'Drop new data' throws away incoming data, while leaving the contents of the PQ unchanged."""

    max_file_open_time_sec: Annotated[
        Optional[float], pydantic.Field(alias="maxFileOpenTimeSec")
    ] = 300
    r"""Maximum amount of time to write to a file. Files open for longer than this will be closed and moved to final output location."""

    max_file_idle_time_sec: Annotated[
        Optional[float], pydantic.Field(alias="maxFileIdleTimeSec")
    ] = 30
    r"""Maximum amount of time to keep inactive files open. Files open for longer than this will be closed and moved to final output location."""

    max_concurrent_file_parts: Annotated[
        Optional[float], pydantic.Field(alias="maxConcurrentFileParts")
    ] = 4
    r"""Maximum number of parts to upload in parallel per file. Minimum part size is 5MB."""

    description: Optional[str] = None

    aws_api_key: Annotated[Optional[str], pydantic.Field(alias="awsApiKey")] = None
    r"""This value can be a constant or a JavaScript expression (`${C.env.SOME_ACCESS_KEY}`)"""

    aws_secret: Annotated[Optional[str], pydantic.Field(alias="awsSecret")] = None
    r"""Select or create a stored secret that references your access key and secret key"""

    compress: Annotated[
        Optional[PqCompressOptions], PlainValidator(validate_open_enum(False))
    ] = PqCompressOptions.NONE
    r"""Codec to use to compress the persisted data"""

    compression_level: Annotated[
        Annotated[
            Optional[CompressionLevelOptions], PlainValidator(validate_open_enum(False))
        ],
        pydantic.Field(alias="compressionLevel"),
    ] = CompressionLevelOptions.BEST_SPEED
    r"""Compression level to apply before moving files to final destination"""

    automatic_schema: Annotated[
        Optional[bool], pydantic.Field(alias="automaticSchema")
    ] = False
    r"""Automatically calculate the schema based on the events of each Parquet file generated"""

    parquet_schema: Annotated[Optional[str], pydantic.Field(alias="parquetSchema")] = (
        None
    )
    r"""To add a new schema, navigate to Processing > Knowledge > Parquet Schemas"""

    parquet_version: Annotated[
        Annotated[
            Optional[ParquetVersionOptions], PlainValidator(validate_open_enum(False))
        ],
        pydantic.Field(alias="parquetVersion"),
    ] = ParquetVersionOptions.PARQUET_2_6
    r"""Determines which data types are supported and how they are represented"""

    parquet_data_page_version: Annotated[
        Annotated[
            Optional[ParquetDataPageVersionOptions],
            PlainValidator(validate_open_enum(False)),
        ],
        pydantic.Field(alias="parquetDataPageVersion"),
    ] = ParquetDataPageVersionOptions.DATA_PAGE_V2
    r"""Serialization format of data pages. Note that some reader implementations use Data page V2's attributes to work more efficiently, while others ignore it."""

    parquet_row_group_length: Annotated[
        Optional[float], pydantic.Field(alias="parquetRowGroupLength")
    ] = 10000
    r"""The number of rows that every group will contain. The final group can contain a smaller number of rows."""

    parquet_page_size: Annotated[
        Optional[str], pydantic.Field(alias="parquetPageSize")
    ] = "1MB"
    r"""Target memory size for page segments, such as 1MB or 128MB. Generally, lower values improve reading speed, while higher values improve compression."""

    enable_statistics: Annotated[
        Optional[bool], pydantic.Field(alias="enableStatistics")
    ] = True
    r"""Statistics profile an entire file in terms of minimum/maximum values within data, numbers of nulls, etc. You can use Parquet tools to view statistics."""

    enable_write_page_index: Annotated[
        Optional[bool], pydantic.Field(alias="enableWritePageIndex")
    ] = True
    r"""One page index contains statistics for one data page. Parquet readers use statistics to enable page skipping."""

    enable_page_checksum: Annotated[
        Optional[bool], pydantic.Field(alias="enablePageChecksum")
    ] = False
    r"""Parquet tools can use the checksum of a Parquet page to verify data integrity"""

    empty_dir_cleanup_sec: Annotated[
        Optional[float], pydantic.Field(alias="emptyDirCleanupSec")
    ] = 300
    r"""How frequently, in seconds, to clean up empty directories"""

    deadletter_path: Annotated[
        Optional[str], pydantic.Field(alias="deadletterPath")
    ] = "$CRIBL_HOME/state/outputs/dead-letter"
    r"""Storage location for files that fail to reach their final destination after maximum retries are exceeded"""

    max_retry_num: Annotated[Optional[float], pydantic.Field(alias="maxRetryNum")] = 20
    r"""The maximum number of times a file will attempt to move to its final destination before being dead-lettered"""

    @field_serializer("format_")
    def serialize_format_(self, value):
        if isinstance(value, str):
            try:
                return models.Format1Options(value)
            except ValueError:
                return value
        return value

    @field_serializer("aws_authentication_method")
    def serialize_aws_authentication_method(self, value):
        if isinstance(value, str):
            try:
                return models.AwsAuthenticationMethodOptions(value)
            except ValueError:
                return value
        return value

    @field_serializer("signature_version")
    def serialize_signature_version(self, value):
        if isinstance(value, str):
            try:
                return models.SignatureVersionOptions(value)
            except ValueError:
                return value
        return value

    @field_serializer("object_acl")
    def serialize_object_acl(self, value):
        if isinstance(value, str):
            try:
                return models.ObjectACLOptions(value)
            except ValueError:
                return value
        return value

    @field_serializer("storage_class")
    def serialize_storage_class(self, value):
        if isinstance(value, str):
            try:
                return models.StorageClass5(value)
            except ValueError:
                return value
        return value

    @field_serializer("server_side_encryption")
    def serialize_server_side_encryption(self, value):
        if isinstance(value, str):
            try:
                return models.ServerSideEncryption5(value)
            except ValueError:
                return value
        return value

    @field_serializer("on_backpressure")
    def serialize_on_backpressure(self, value):
        if isinstance(value, str):
            try:
                return models.PqOnBackpressureOptions(value)
            except ValueError:
                return value
        return value

    @field_serializer("on_disk_full_backpressure")
    def serialize_on_disk_full_backpressure(self, value):
        if isinstance(value, str):
            try:
                return models.PqOnBackpressureOptions(value)
            except ValueError:
                return value
        return value

    @field_serializer("compress")
    def serialize_compress(self, value):
        if isinstance(value, str):
            try:
                return models.PqCompressOptions(value)
            except ValueError:
                return value
        return value

    @field_serializer("compression_level")
    def serialize_compression_level(self, value):
        if isinstance(value, str):
            try:
                return models.CompressionLevelOptions(value)
            except ValueError:
                return value
        return value

    @field_serializer("parquet_version")
    def serialize_parquet_version(self, value):
        if isinstance(value, str):
            try:
                return models.ParquetVersionOptions(value)
            except ValueError:
                return value
        return value

    @field_serializer("parquet_data_page_version")
    def serialize_parquet_data_page_version(self, value):
        if isinstance(value, str):
            try:
                return models.ParquetDataPageVersionOptions(value)
            except ValueError:
                return value
        return value


class OutputMinioType4(str, Enum):
    MINIO = "minio"


class StorageClass4(str, Enum, metaclass=utils.OpenEnumMeta):
    r"""Storage class to select for uploaded objects"""

    # Standard
    STANDARD = "STANDARD"
    # Reduced Redundancy Storage
    REDUCED_REDUNDANCY = "REDUCED_REDUNDANCY"


class ServerSideEncryption4(str, Enum, metaclass=utils.OpenEnumMeta):
    r"""Server-side encryption for uploaded objects"""

    # Amazon S3 Managed Key
    AES256 = "AES256"


class OutputMinioMinio4TypedDict(TypedDict):
    type: OutputMinioType4
    endpoint: str
    r"""MinIO service url (e.g. http://minioHost:9000)"""
    bucket: str
    r"""Name of the destination MinIO bucket. This value can be a constant or a JavaScript expression that can only be evaluated at init time. Example referencing a Global Variable: `myBucket-${C.vars.myVar}`"""
    format_: NotRequired[Format1Options]
    r"""Format of the output data"""
    id: NotRequired[str]
    r"""Unique ID for this output"""
    pipeline: NotRequired[str]
    r"""Pipeline to process data before sending out to this output"""
    system_fields: NotRequired[List[str]]
    r"""Fields to automatically add to events, such as cribl_pipe. Supports wildcards."""
    environment: NotRequired[str]
    r"""Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere."""
    streamtags: NotRequired[List[str]]
    r"""Tags for filtering and grouping in @{product}"""
    aws_authentication_method: NotRequired[AwsAuthenticationMethodOptions]
    r"""AWS authentication method. Choose Auto to use IAM roles."""
    aws_secret_key: NotRequired[str]
    r"""Secret key. This value can be a constant or a JavaScript expression, such as `${C.env.SOME_SECRET}`)."""
    region: NotRequired[str]
    r"""Region where the MinIO service/cluster is located"""
    stage_path: NotRequired[str]
    r"""Filesystem location in which to buffer files, before compressing and moving to final destination. Use performant stable storage."""
    add_id_to_stage_path: NotRequired[bool]
    r"""Add the Output ID value to staging location"""
    dest_path: NotRequired[str]
    r"""Root directory to prepend to path before uploading. Enter a constant, or a JavaScript expression enclosed in quotes or backticks."""
    signature_version: NotRequired[SignatureVersionOptions]
    r"""Signature version to use for signing MSK cluster requests"""
    object_acl: NotRequired[ObjectACLOptions]
    r"""Object ACL to assign to uploaded objects"""
    storage_class: NotRequired[StorageClass4]
    r"""Storage class to select for uploaded objects"""
    server_side_encryption: NotRequired[ServerSideEncryption4]
    r"""Server-side encryption for uploaded objects"""
    reuse_connections: NotRequired[bool]
    r"""Reuse connections between requests, which can improve performance"""
    reject_unauthorized: NotRequired[bool]
    r"""Reject certificates that cannot be verified against a valid CA, such as self-signed certificates)"""
    verify_permissions: NotRequired[bool]
    r"""Disable if you can access files within the bucket but not the bucket itself"""
    remove_empty_dirs: NotRequired[bool]
    r"""Remove empty staging directories after moving files"""
    partition_expr: NotRequired[str]
    r"""JavaScript expression defining how files are partitioned and organized. Default is date-based. If blank, Stream will fall back to the event's __partition field value – if present – otherwise to each location's root directory."""
    base_file_name: NotRequired[str]
    r"""JavaScript expression to define the output filename prefix (can be constant)"""
    file_name_suffix: NotRequired[str]
    r"""JavaScript expression to define the output filename suffix (can be constant).  The `__format` variable refers to the value of the `Data format` field (`json` or `raw`).  The `__compression` field refers to the kind of compression being used (`none` or `gzip`)."""
    max_file_size_mb: NotRequired[float]
    r"""Maximum uncompressed output file size. Files of this size will be closed and moved to final output location."""
    max_open_files: NotRequired[float]
    r"""Maximum number of files to keep open concurrently. When exceeded, @{product} will close the oldest open files and move them to the final output location."""
    header_line: NotRequired[str]
    r"""If set, this line will be written to the beginning of each output file"""
    write_high_water_mark: NotRequired[float]
    r"""Buffer size used to write to a file"""
    on_backpressure: NotRequired[PqOnBackpressureOptions]
    r"""How to handle events when the queue is exerting backpressure (full capacity or low disk). 'Block' is the same behavior as non-PQ blocking. 'Drop new data' throws away incoming data, while leaving the contents of the PQ unchanged."""
    deadletter_enabled: NotRequired[bool]
    r"""If a file fails to move to its final destination after the maximum number of retries, move it to a designated directory to prevent further errors"""
    on_disk_full_backpressure: NotRequired[PqOnBackpressureOptions]
    r"""How to handle events when the queue is exerting backpressure (full capacity or low disk). 'Block' is the same behavior as non-PQ blocking. 'Drop new data' throws away incoming data, while leaving the contents of the PQ unchanged."""
    max_file_open_time_sec: NotRequired[float]
    r"""Maximum amount of time to write to a file. Files open for longer than this will be closed and moved to final output location."""
    max_file_idle_time_sec: NotRequired[float]
    r"""Maximum amount of time to keep inactive files open. Files open for longer than this will be closed and moved to final output location."""
    max_concurrent_file_parts: NotRequired[float]
    r"""Maximum number of parts to upload in parallel per file. Minimum part size is 5MB."""
    description: NotRequired[str]
    aws_api_key: NotRequired[str]
    r"""This value can be a constant or a JavaScript expression (`${C.env.SOME_ACCESS_KEY}`)"""
    aws_secret: NotRequired[str]
    r"""Select or create a stored secret that references your access key and secret key"""
    compress: NotRequired[PqCompressOptions]
    r"""Codec to use to compress the persisted data"""
    compression_level: NotRequired[CompressionLevelOptions]
    r"""Compression level to apply before moving files to final destination"""
    automatic_schema: NotRequired[bool]
    r"""Automatically calculate the schema based on the events of each Parquet file generated"""
    parquet_schema: NotRequired[str]
    r"""To add a new schema, navigate to Processing > Knowledge > Parquet Schemas"""
    parquet_version: NotRequired[ParquetVersionOptions]
    r"""Determines which data types are supported and how they are represented"""
    parquet_data_page_version: NotRequired[ParquetDataPageVersionOptions]
    r"""Serialization format of data pages. Note that some reader implementations use Data page V2's attributes to work more efficiently, while others ignore it."""
    parquet_row_group_length: NotRequired[float]
    r"""The number of rows that every group will contain. The final group can contain a smaller number of rows."""
    parquet_page_size: NotRequired[str]
    r"""Target memory size for page segments, such as 1MB or 128MB. Generally, lower values improve reading speed, while higher values improve compression."""
    should_log_invalid_rows: NotRequired[bool]
    r"""Log up to 3 rows that @{product} skips due to data mismatch"""
    key_value_metadata: NotRequired[List[TagsTypeTypedDict]]
    r"""The metadata of files the Destination writes will include the properties you add here as key-value pairs. Useful for tagging. Examples: \"key\":\"OCSF Event Class\", \"value\":\"9001\" """
    enable_statistics: NotRequired[bool]
    r"""Statistics profile an entire file in terms of minimum/maximum values within data, numbers of nulls, etc. You can use Parquet tools to view statistics."""
    enable_write_page_index: NotRequired[bool]
    r"""One page index contains statistics for one data page. Parquet readers use statistics to enable page skipping."""
    enable_page_checksum: NotRequired[bool]
    r"""Parquet tools can use the checksum of a Parquet page to verify data integrity"""
    empty_dir_cleanup_sec: NotRequired[float]
    r"""How frequently, in seconds, to clean up empty directories"""
    deadletter_path: NotRequired[str]
    r"""Storage location for files that fail to reach their final destination after maximum retries are exceeded"""
    max_retry_num: NotRequired[float]
    r"""The maximum number of times a file will attempt to move to its final destination before being dead-lettered"""


class OutputMinioMinio4(BaseModel):
    type: OutputMinioType4

    endpoint: str
    r"""MinIO service url (e.g. http://minioHost:9000)"""

    bucket: str
    r"""Name of the destination MinIO bucket. This value can be a constant or a JavaScript expression that can only be evaluated at init time. Example referencing a Global Variable: `myBucket-${C.vars.myVar}`"""

    format_: Annotated[
        Annotated[Optional[Format1Options], PlainValidator(validate_open_enum(False))],
        pydantic.Field(alias="format"),
    ] = Format1Options.JSON
    r"""Format of the output data"""

    id: Optional[str] = None
    r"""Unique ID for this output"""

    pipeline: Optional[str] = None
    r"""Pipeline to process data before sending out to this output"""

    system_fields: Annotated[
        Optional[List[str]], pydantic.Field(alias="systemFields")
    ] = None
    r"""Fields to automatically add to events, such as cribl_pipe. Supports wildcards."""

    environment: Optional[str] = None
    r"""Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere."""

    streamtags: Optional[List[str]] = None
    r"""Tags for filtering and grouping in @{product}"""

    aws_authentication_method: Annotated[
        Annotated[
            Optional[AwsAuthenticationMethodOptions],
            PlainValidator(validate_open_enum(False)),
        ],
        pydantic.Field(alias="awsAuthenticationMethod"),
    ] = AwsAuthenticationMethodOptions.AUTO
    r"""AWS authentication method. Choose Auto to use IAM roles."""

    aws_secret_key: Annotated[Optional[str], pydantic.Field(alias="awsSecretKey")] = (
        None
    )
    r"""Secret key. This value can be a constant or a JavaScript expression, such as `${C.env.SOME_SECRET}`)."""

    region: Optional[str] = None
    r"""Region where the MinIO service/cluster is located"""

    stage_path: Annotated[Optional[str], pydantic.Field(alias="stagePath")] = (
        "$CRIBL_HOME/state/outputs/staging"
    )
    r"""Filesystem location in which to buffer files, before compressing and moving to final destination. Use performant stable storage."""

    add_id_to_stage_path: Annotated[
        Optional[bool], pydantic.Field(alias="addIdToStagePath")
    ] = True
    r"""Add the Output ID value to staging location"""

    dest_path: Annotated[Optional[str], pydantic.Field(alias="destPath")] = None
    r"""Root directory to prepend to path before uploading. Enter a constant, or a JavaScript expression enclosed in quotes or backticks."""

    signature_version: Annotated[
        Annotated[
            Optional[SignatureVersionOptions], PlainValidator(validate_open_enum(False))
        ],
        pydantic.Field(alias="signatureVersion"),
    ] = SignatureVersionOptions.V4
    r"""Signature version to use for signing MSK cluster requests"""

    object_acl: Annotated[
        Annotated[
            Optional[ObjectACLOptions], PlainValidator(validate_open_enum(False))
        ],
        pydantic.Field(alias="objectACL"),
    ] = ObjectACLOptions.PRIVATE
    r"""Object ACL to assign to uploaded objects"""

    storage_class: Annotated[
        Annotated[Optional[StorageClass4], PlainValidator(validate_open_enum(False))],
        pydantic.Field(alias="storageClass"),
    ] = None
    r"""Storage class to select for uploaded objects"""

    server_side_encryption: Annotated[
        Annotated[
            Optional[ServerSideEncryption4], PlainValidator(validate_open_enum(False))
        ],
        pydantic.Field(alias="serverSideEncryption"),
    ] = None
    r"""Server-side encryption for uploaded objects"""

    reuse_connections: Annotated[
        Optional[bool], pydantic.Field(alias="reuseConnections")
    ] = True
    r"""Reuse connections between requests, which can improve performance"""

    reject_unauthorized: Annotated[
        Optional[bool], pydantic.Field(alias="rejectUnauthorized")
    ] = True
    r"""Reject certificates that cannot be verified against a valid CA, such as self-signed certificates)"""

    verify_permissions: Annotated[
        Optional[bool], pydantic.Field(alias="verifyPermissions")
    ] = True
    r"""Disable if you can access files within the bucket but not the bucket itself"""

    remove_empty_dirs: Annotated[
        Optional[bool], pydantic.Field(alias="removeEmptyDirs")
    ] = True
    r"""Remove empty staging directories after moving files"""

    partition_expr: Annotated[Optional[str], pydantic.Field(alias="partitionExpr")] = (
        "C.Time.strftime(_time ? _time : Date.now()/1000, '%Y/%m/%d')"
    )
    r"""JavaScript expression defining how files are partitioned and organized. Default is date-based. If blank, Stream will fall back to the event's __partition field value – if present – otherwise to each location's root directory."""

    base_file_name: Annotated[Optional[str], pydantic.Field(alias="baseFileName")] = (
        "`CriblOut`"
    )
    r"""JavaScript expression to define the output filename prefix (can be constant)"""

    file_name_suffix: Annotated[
        Optional[str], pydantic.Field(alias="fileNameSuffix")
    ] = '`.${C.env["CRIBL_WORKER_ID"]}.${__format}${__compression === "gzip" ? ".gz" : ""}`'
    r"""JavaScript expression to define the output filename suffix (can be constant).  The `__format` variable refers to the value of the `Data format` field (`json` or `raw`).  The `__compression` field refers to the kind of compression being used (`none` or `gzip`)."""

    max_file_size_mb: Annotated[
        Optional[float], pydantic.Field(alias="maxFileSizeMB")
    ] = 32
    r"""Maximum uncompressed output file size. Files of this size will be closed and moved to final output location."""

    max_open_files: Annotated[Optional[float], pydantic.Field(alias="maxOpenFiles")] = (
        100
    )
    r"""Maximum number of files to keep open concurrently. When exceeded, @{product} will close the oldest open files and move them to the final output location."""

    header_line: Annotated[Optional[str], pydantic.Field(alias="headerLine")] = ""
    r"""If set, this line will be written to the beginning of each output file"""

    write_high_water_mark: Annotated[
        Optional[float], pydantic.Field(alias="writeHighWaterMark")
    ] = 64
    r"""Buffer size used to write to a file"""

    on_backpressure: Annotated[
        Annotated[
            Optional[PqOnBackpressureOptions], PlainValidator(validate_open_enum(False))
        ],
        pydantic.Field(alias="onBackpressure"),
    ] = PqOnBackpressureOptions.BLOCK
    r"""How to handle events when the queue is exerting backpressure (full capacity or low disk). 'Block' is the same behavior as non-PQ blocking. 'Drop new data' throws away incoming data, while leaving the contents of the PQ unchanged."""

    deadletter_enabled: Annotated[
        Optional[bool], pydantic.Field(alias="deadletterEnabled")
    ] = False
    r"""If a file fails to move to its final destination after the maximum number of retries, move it to a designated directory to prevent further errors"""

    on_disk_full_backpressure: Annotated[
        Annotated[
            Optional[PqOnBackpressureOptions], PlainValidator(validate_open_enum(False))
        ],
        pydantic.Field(alias="onDiskFullBackpressure"),
    ] = PqOnBackpressureOptions.BLOCK
    r"""How to handle events when the queue is exerting backpressure (full capacity or low disk). 'Block' is the same behavior as non-PQ blocking. 'Drop new data' throws away incoming data, while leaving the contents of the PQ unchanged."""

    max_file_open_time_sec: Annotated[
        Optional[float], pydantic.Field(alias="maxFileOpenTimeSec")
    ] = 300
    r"""Maximum amount of time to write to a file. Files open for longer than this will be closed and moved to final output location."""

    max_file_idle_time_sec: Annotated[
        Optional[float], pydantic.Field(alias="maxFileIdleTimeSec")
    ] = 30
    r"""Maximum amount of time to keep inactive files open. Files open for longer than this will be closed and moved to final output location."""

    max_concurrent_file_parts: Annotated[
        Optional[float], pydantic.Field(alias="maxConcurrentFileParts")
    ] = 4
    r"""Maximum number of parts to upload in parallel per file. Minimum part size is 5MB."""

    description: Optional[str] = None

    aws_api_key: Annotated[Optional[str], pydantic.Field(alias="awsApiKey")] = None
    r"""This value can be a constant or a JavaScript expression (`${C.env.SOME_ACCESS_KEY}`)"""

    aws_secret: Annotated[Optional[str], pydantic.Field(alias="awsSecret")] = None
    r"""Select or create a stored secret that references your access key and secret key"""

    compress: Annotated[
        Optional[PqCompressOptions], PlainValidator(validate_open_enum(False))
    ] = PqCompressOptions.NONE
    r"""Codec to use to compress the persisted data"""

    compression_level: Annotated[
        Annotated[
            Optional[CompressionLevelOptions], PlainValidator(validate_open_enum(False))
        ],
        pydantic.Field(alias="compressionLevel"),
    ] = CompressionLevelOptions.BEST_SPEED
    r"""Compression level to apply before moving files to final destination"""

    automatic_schema: Annotated[
        Optional[bool], pydantic.Field(alias="automaticSchema")
    ] = False
    r"""Automatically calculate the schema based on the events of each Parquet file generated"""

    parquet_schema: Annotated[Optional[str], pydantic.Field(alias="parquetSchema")] = (
        None
    )
    r"""To add a new schema, navigate to Processing > Knowledge > Parquet Schemas"""

    parquet_version: Annotated[
        Annotated[
            Optional[ParquetVersionOptions], PlainValidator(validate_open_enum(False))
        ],
        pydantic.Field(alias="parquetVersion"),
    ] = ParquetVersionOptions.PARQUET_2_6
    r"""Determines which data types are supported and how they are represented"""

    parquet_data_page_version: Annotated[
        Annotated[
            Optional[ParquetDataPageVersionOptions],
            PlainValidator(validate_open_enum(False)),
        ],
        pydantic.Field(alias="parquetDataPageVersion"),
    ] = ParquetDataPageVersionOptions.DATA_PAGE_V2
    r"""Serialization format of data pages. Note that some reader implementations use Data page V2's attributes to work more efficiently, while others ignore it."""

    parquet_row_group_length: Annotated[
        Optional[float], pydantic.Field(alias="parquetRowGroupLength")
    ] = 10000
    r"""The number of rows that every group will contain. The final group can contain a smaller number of rows."""

    parquet_page_size: Annotated[
        Optional[str], pydantic.Field(alias="parquetPageSize")
    ] = "1MB"
    r"""Target memory size for page segments, such as 1MB or 128MB. Generally, lower values improve reading speed, while higher values improve compression."""

    should_log_invalid_rows: Annotated[
        Optional[bool], pydantic.Field(alias="shouldLogInvalidRows")
    ] = None
    r"""Log up to 3 rows that @{product} skips due to data mismatch"""

    key_value_metadata: Annotated[
        Optional[List[TagsType]], pydantic.Field(alias="keyValueMetadata")
    ] = None
    r"""The metadata of files the Destination writes will include the properties you add here as key-value pairs. Useful for tagging. Examples: \"key\":\"OCSF Event Class\", \"value\":\"9001\" """

    enable_statistics: Annotated[
        Optional[bool], pydantic.Field(alias="enableStatistics")
    ] = True
    r"""Statistics profile an entire file in terms of minimum/maximum values within data, numbers of nulls, etc. You can use Parquet tools to view statistics."""

    enable_write_page_index: Annotated[
        Optional[bool], pydantic.Field(alias="enableWritePageIndex")
    ] = True
    r"""One page index contains statistics for one data page. Parquet readers use statistics to enable page skipping."""

    enable_page_checksum: Annotated[
        Optional[bool], pydantic.Field(alias="enablePageChecksum")
    ] = False
    r"""Parquet tools can use the checksum of a Parquet page to verify data integrity"""

    empty_dir_cleanup_sec: Annotated[
        Optional[float], pydantic.Field(alias="emptyDirCleanupSec")
    ] = 300
    r"""How frequently, in seconds, to clean up empty directories"""

    deadletter_path: Annotated[
        Optional[str], pydantic.Field(alias="deadletterPath")
    ] = "$CRIBL_HOME/state/outputs/dead-letter"
    r"""Storage location for files that fail to reach their final destination after maximum retries are exceeded"""

    max_retry_num: Annotated[Optional[float], pydantic.Field(alias="maxRetryNum")] = 20
    r"""The maximum number of times a file will attempt to move to its final destination before being dead-lettered"""

    @field_serializer("format_")
    def serialize_format_(self, value):
        if isinstance(value, str):
            try:
                return models.Format1Options(value)
            except ValueError:
                return value
        return value

    @field_serializer("aws_authentication_method")
    def serialize_aws_authentication_method(self, value):
        if isinstance(value, str):
            try:
                return models.AwsAuthenticationMethodOptions(value)
            except ValueError:
                return value
        return value

    @field_serializer("signature_version")
    def serialize_signature_version(self, value):
        if isinstance(value, str):
            try:
                return models.SignatureVersionOptions(value)
            except ValueError:
                return value
        return value

    @field_serializer("object_acl")
    def serialize_object_acl(self, value):
        if isinstance(value, str):
            try:
                return models.ObjectACLOptions(value)
            except ValueError:
                return value
        return value

    @field_serializer("storage_class")
    def serialize_storage_class(self, value):
        if isinstance(value, str):
            try:
                return models.StorageClass4(value)
            except ValueError:
                return value
        return value

    @field_serializer("server_side_encryption")
    def serialize_server_side_encryption(self, value):
        if isinstance(value, str):
            try:
                return models.ServerSideEncryption4(value)
            except ValueError:
                return value
        return value

    @field_serializer("on_backpressure")
    def serialize_on_backpressure(self, value):
        if isinstance(value, str):
            try:
                return models.PqOnBackpressureOptions(value)
            except ValueError:
                return value
        return value

    @field_serializer("on_disk_full_backpressure")
    def serialize_on_disk_full_backpressure(self, value):
        if isinstance(value, str):
            try:
                return models.PqOnBackpressureOptions(value)
            except ValueError:
                return value
        return value

    @field_serializer("compress")
    def serialize_compress(self, value):
        if isinstance(value, str):
            try:
                return models.PqCompressOptions(value)
            except ValueError:
                return value
        return value

    @field_serializer("compression_level")
    def serialize_compression_level(self, value):
        if isinstance(value, str):
            try:
                return models.CompressionLevelOptions(value)
            except ValueError:
                return value
        return value

    @field_serializer("parquet_version")
    def serialize_parquet_version(self, value):
        if isinstance(value, str):
            try:
                return models.ParquetVersionOptions(value)
            except ValueError:
                return value
        return value

    @field_serializer("parquet_data_page_version")
    def serialize_parquet_data_page_version(self, value):
        if isinstance(value, str):
            try:
                return models.ParquetDataPageVersionOptions(value)
            except ValueError:
                return value
        return value


class OutputMinioType3(str, Enum):
    MINIO = "minio"


class StorageClass3(str, Enum, metaclass=utils.OpenEnumMeta):
    r"""Storage class to select for uploaded objects"""

    # Standard
    STANDARD = "STANDARD"
    # Reduced Redundancy Storage
    REDUCED_REDUNDANCY = "REDUCED_REDUNDANCY"


class ServerSideEncryption3(str, Enum, metaclass=utils.OpenEnumMeta):
    r"""Server-side encryption for uploaded objects"""

    # Amazon S3 Managed Key
    AES256 = "AES256"


class OutputMinioMinio3TypedDict(TypedDict):
    type: OutputMinioType3
    endpoint: str
    r"""MinIO service url (e.g. http://minioHost:9000)"""
    bucket: str
    r"""Name of the destination MinIO bucket. This value can be a constant or a JavaScript expression that can only be evaluated at init time. Example referencing a Global Variable: `myBucket-${C.vars.myVar}`"""
    aws_secret: str
    r"""Select or create a stored secret that references your access key and secret key"""
    aws_authentication_method: NotRequired[AwsAuthenticationMethodOptions]
    r"""AWS authentication method. Choose Auto to use IAM roles."""
    id: NotRequired[str]
    r"""Unique ID for this output"""
    pipeline: NotRequired[str]
    r"""Pipeline to process data before sending out to this output"""
    system_fields: NotRequired[List[str]]
    r"""Fields to automatically add to events, such as cribl_pipe. Supports wildcards."""
    environment: NotRequired[str]
    r"""Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere."""
    streamtags: NotRequired[List[str]]
    r"""Tags for filtering and grouping in @{product}"""
    aws_secret_key: NotRequired[str]
    r"""Secret key. This value can be a constant or a JavaScript expression, such as `${C.env.SOME_SECRET}`)."""
    region: NotRequired[str]
    r"""Region where the MinIO service/cluster is located"""
    stage_path: NotRequired[str]
    r"""Filesystem location in which to buffer files, before compressing and moving to final destination. Use performant stable storage."""
    add_id_to_stage_path: NotRequired[bool]
    r"""Add the Output ID value to staging location"""
    dest_path: NotRequired[str]
    r"""Root directory to prepend to path before uploading. Enter a constant, or a JavaScript expression enclosed in quotes or backticks."""
    signature_version: NotRequired[SignatureVersionOptions]
    r"""Signature version to use for signing MSK cluster requests"""
    object_acl: NotRequired[ObjectACLOptions]
    r"""Object ACL to assign to uploaded objects"""
    storage_class: NotRequired[StorageClass3]
    r"""Storage class to select for uploaded objects"""
    server_side_encryption: NotRequired[ServerSideEncryption3]
    r"""Server-side encryption for uploaded objects"""
    reuse_connections: NotRequired[bool]
    r"""Reuse connections between requests, which can improve performance"""
    reject_unauthorized: NotRequired[bool]
    r"""Reject certificates that cannot be verified against a valid CA, such as self-signed certificates)"""
    verify_permissions: NotRequired[bool]
    r"""Disable if you can access files within the bucket but not the bucket itself"""
    remove_empty_dirs: NotRequired[bool]
    r"""Remove empty staging directories after moving files"""
    partition_expr: NotRequired[str]
    r"""JavaScript expression defining how files are partitioned and organized. Default is date-based. If blank, Stream will fall back to the event's __partition field value – if present – otherwise to each location's root directory."""
    format_: NotRequired[Format1Options]
    r"""Format of the output data"""
    base_file_name: NotRequired[str]
    r"""JavaScript expression to define the output filename prefix (can be constant)"""
    file_name_suffix: NotRequired[str]
    r"""JavaScript expression to define the output filename suffix (can be constant).  The `__format` variable refers to the value of the `Data format` field (`json` or `raw`).  The `__compression` field refers to the kind of compression being used (`none` or `gzip`)."""
    max_file_size_mb: NotRequired[float]
    r"""Maximum uncompressed output file size. Files of this size will be closed and moved to final output location."""
    max_open_files: NotRequired[float]
    r"""Maximum number of files to keep open concurrently. When exceeded, @{product} will close the oldest open files and move them to the final output location."""
    header_line: NotRequired[str]
    r"""If set, this line will be written to the beginning of each output file"""
    write_high_water_mark: NotRequired[float]
    r"""Buffer size used to write to a file"""
    on_backpressure: NotRequired[PqOnBackpressureOptions]
    r"""How to handle events when the queue is exerting backpressure (full capacity or low disk). 'Block' is the same behavior as non-PQ blocking. 'Drop new data' throws away incoming data, while leaving the contents of the PQ unchanged."""
    deadletter_enabled: NotRequired[bool]
    r"""If a file fails to move to its final destination after the maximum number of retries, move it to a designated directory to prevent further errors"""
    on_disk_full_backpressure: NotRequired[PqOnBackpressureOptions]
    r"""How to handle events when the queue is exerting backpressure (full capacity or low disk). 'Block' is the same behavior as non-PQ blocking. 'Drop new data' throws away incoming data, while leaving the contents of the PQ unchanged."""
    max_file_open_time_sec: NotRequired[float]
    r"""Maximum amount of time to write to a file. Files open for longer than this will be closed and moved to final output location."""
    max_file_idle_time_sec: NotRequired[float]
    r"""Maximum amount of time to keep inactive files open. Files open for longer than this will be closed and moved to final output location."""
    max_concurrent_file_parts: NotRequired[float]
    r"""Maximum number of parts to upload in parallel per file. Minimum part size is 5MB."""
    description: NotRequired[str]
    aws_api_key: NotRequired[str]
    r"""This value can be a constant or a JavaScript expression (`${C.env.SOME_ACCESS_KEY}`)"""
    compress: NotRequired[PqCompressOptions]
    r"""Codec to use to compress the persisted data"""
    compression_level: NotRequired[CompressionLevelOptions]
    r"""Compression level to apply before moving files to final destination"""
    automatic_schema: NotRequired[bool]
    r"""Automatically calculate the schema based on the events of each Parquet file generated"""
    parquet_schema: NotRequired[str]
    r"""To add a new schema, navigate to Processing > Knowledge > Parquet Schemas"""
    parquet_version: NotRequired[ParquetVersionOptions]
    r"""Determines which data types are supported and how they are represented"""
    parquet_data_page_version: NotRequired[ParquetDataPageVersionOptions]
    r"""Serialization format of data pages. Note that some reader implementations use Data page V2's attributes to work more efficiently, while others ignore it."""
    parquet_row_group_length: NotRequired[float]
    r"""The number of rows that every group will contain. The final group can contain a smaller number of rows."""
    parquet_page_size: NotRequired[str]
    r"""Target memory size for page segments, such as 1MB or 128MB. Generally, lower values improve reading speed, while higher values improve compression."""
    should_log_invalid_rows: NotRequired[bool]
    r"""Log up to 3 rows that @{product} skips due to data mismatch"""
    key_value_metadata: NotRequired[List[TagsTypeTypedDict]]
    r"""The metadata of files the Destination writes will include the properties you add here as key-value pairs. Useful for tagging. Examples: \"key\":\"OCSF Event Class\", \"value\":\"9001\" """
    enable_statistics: NotRequired[bool]
    r"""Statistics profile an entire file in terms of minimum/maximum values within data, numbers of nulls, etc. You can use Parquet tools to view statistics."""
    enable_write_page_index: NotRequired[bool]
    r"""One page index contains statistics for one data page. Parquet readers use statistics to enable page skipping."""
    enable_page_checksum: NotRequired[bool]
    r"""Parquet tools can use the checksum of a Parquet page to verify data integrity"""
    empty_dir_cleanup_sec: NotRequired[float]
    r"""How frequently, in seconds, to clean up empty directories"""
    deadletter_path: NotRequired[str]
    r"""Storage location for files that fail to reach their final destination after maximum retries are exceeded"""
    max_retry_num: NotRequired[float]
    r"""The maximum number of times a file will attempt to move to its final destination before being dead-lettered"""


class OutputMinioMinio3(BaseModel):
    type: OutputMinioType3

    endpoint: str
    r"""MinIO service url (e.g. http://minioHost:9000)"""

    bucket: str
    r"""Name of the destination MinIO bucket. This value can be a constant or a JavaScript expression that can only be evaluated at init time. Example referencing a Global Variable: `myBucket-${C.vars.myVar}`"""

    aws_secret: Annotated[str, pydantic.Field(alias="awsSecret")]
    r"""Select or create a stored secret that references your access key and secret key"""

    aws_authentication_method: Annotated[
        Annotated[
            Optional[AwsAuthenticationMethodOptions],
            PlainValidator(validate_open_enum(False)),
        ],
        pydantic.Field(alias="awsAuthenticationMethod"),
    ] = AwsAuthenticationMethodOptions.AUTO
    r"""AWS authentication method. Choose Auto to use IAM roles."""

    id: Optional[str] = None
    r"""Unique ID for this output"""

    pipeline: Optional[str] = None
    r"""Pipeline to process data before sending out to this output"""

    system_fields: Annotated[
        Optional[List[str]], pydantic.Field(alias="systemFields")
    ] = None
    r"""Fields to automatically add to events, such as cribl_pipe. Supports wildcards."""

    environment: Optional[str] = None
    r"""Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere."""

    streamtags: Optional[List[str]] = None
    r"""Tags for filtering and grouping in @{product}"""

    aws_secret_key: Annotated[Optional[str], pydantic.Field(alias="awsSecretKey")] = (
        None
    )
    r"""Secret key. This value can be a constant or a JavaScript expression, such as `${C.env.SOME_SECRET}`)."""

    region: Optional[str] = None
    r"""Region where the MinIO service/cluster is located"""

    stage_path: Annotated[Optional[str], pydantic.Field(alias="stagePath")] = (
        "$CRIBL_HOME/state/outputs/staging"
    )
    r"""Filesystem location in which to buffer files, before compressing and moving to final destination. Use performant stable storage."""

    add_id_to_stage_path: Annotated[
        Optional[bool], pydantic.Field(alias="addIdToStagePath")
    ] = True
    r"""Add the Output ID value to staging location"""

    dest_path: Annotated[Optional[str], pydantic.Field(alias="destPath")] = None
    r"""Root directory to prepend to path before uploading. Enter a constant, or a JavaScript expression enclosed in quotes or backticks."""

    signature_version: Annotated[
        Annotated[
            Optional[SignatureVersionOptions], PlainValidator(validate_open_enum(False))
        ],
        pydantic.Field(alias="signatureVersion"),
    ] = SignatureVersionOptions.V4
    r"""Signature version to use for signing MSK cluster requests"""

    object_acl: Annotated[
        Annotated[
            Optional[ObjectACLOptions], PlainValidator(validate_open_enum(False))
        ],
        pydantic.Field(alias="objectACL"),
    ] = ObjectACLOptions.PRIVATE
    r"""Object ACL to assign to uploaded objects"""

    storage_class: Annotated[
        Annotated[Optional[StorageClass3], PlainValidator(validate_open_enum(False))],
        pydantic.Field(alias="storageClass"),
    ] = None
    r"""Storage class to select for uploaded objects"""

    server_side_encryption: Annotated[
        Annotated[
            Optional[ServerSideEncryption3], PlainValidator(validate_open_enum(False))
        ],
        pydantic.Field(alias="serverSideEncryption"),
    ] = None
    r"""Server-side encryption for uploaded objects"""

    reuse_connections: Annotated[
        Optional[bool], pydantic.Field(alias="reuseConnections")
    ] = True
    r"""Reuse connections between requests, which can improve performance"""

    reject_unauthorized: Annotated[
        Optional[bool], pydantic.Field(alias="rejectUnauthorized")
    ] = True
    r"""Reject certificates that cannot be verified against a valid CA, such as self-signed certificates)"""

    verify_permissions: Annotated[
        Optional[bool], pydantic.Field(alias="verifyPermissions")
    ] = True
    r"""Disable if you can access files within the bucket but not the bucket itself"""

    remove_empty_dirs: Annotated[
        Optional[bool], pydantic.Field(alias="removeEmptyDirs")
    ] = True
    r"""Remove empty staging directories after moving files"""

    partition_expr: Annotated[Optional[str], pydantic.Field(alias="partitionExpr")] = (
        "C.Time.strftime(_time ? _time : Date.now()/1000, '%Y/%m/%d')"
    )
    r"""JavaScript expression defining how files are partitioned and organized. Default is date-based. If blank, Stream will fall back to the event's __partition field value – if present – otherwise to each location's root directory."""

    format_: Annotated[
        Annotated[Optional[Format1Options], PlainValidator(validate_open_enum(False))],
        pydantic.Field(alias="format"),
    ] = Format1Options.JSON
    r"""Format of the output data"""

    base_file_name: Annotated[Optional[str], pydantic.Field(alias="baseFileName")] = (
        "`CriblOut`"
    )
    r"""JavaScript expression to define the output filename prefix (can be constant)"""

    file_name_suffix: Annotated[
        Optional[str], pydantic.Field(alias="fileNameSuffix")
    ] = '`.${C.env["CRIBL_WORKER_ID"]}.${__format}${__compression === "gzip" ? ".gz" : ""}`'
    r"""JavaScript expression to define the output filename suffix (can be constant).  The `__format` variable refers to the value of the `Data format` field (`json` or `raw`).  The `__compression` field refers to the kind of compression being used (`none` or `gzip`)."""

    max_file_size_mb: Annotated[
        Optional[float], pydantic.Field(alias="maxFileSizeMB")
    ] = 32
    r"""Maximum uncompressed output file size. Files of this size will be closed and moved to final output location."""

    max_open_files: Annotated[Optional[float], pydantic.Field(alias="maxOpenFiles")] = (
        100
    )
    r"""Maximum number of files to keep open concurrently. When exceeded, @{product} will close the oldest open files and move them to the final output location."""

    header_line: Annotated[Optional[str], pydantic.Field(alias="headerLine")] = ""
    r"""If set, this line will be written to the beginning of each output file"""

    write_high_water_mark: Annotated[
        Optional[float], pydantic.Field(alias="writeHighWaterMark")
    ] = 64
    r"""Buffer size used to write to a file"""

    on_backpressure: Annotated[
        Annotated[
            Optional[PqOnBackpressureOptions], PlainValidator(validate_open_enum(False))
        ],
        pydantic.Field(alias="onBackpressure"),
    ] = PqOnBackpressureOptions.BLOCK
    r"""How to handle events when the queue is exerting backpressure (full capacity or low disk). 'Block' is the same behavior as non-PQ blocking. 'Drop new data' throws away incoming data, while leaving the contents of the PQ unchanged."""

    deadletter_enabled: Annotated[
        Optional[bool], pydantic.Field(alias="deadletterEnabled")
    ] = False
    r"""If a file fails to move to its final destination after the maximum number of retries, move it to a designated directory to prevent further errors"""

    on_disk_full_backpressure: Annotated[
        Annotated[
            Optional[PqOnBackpressureOptions], PlainValidator(validate_open_enum(False))
        ],
        pydantic.Field(alias="onDiskFullBackpressure"),
    ] = PqOnBackpressureOptions.BLOCK
    r"""How to handle events when the queue is exerting backpressure (full capacity or low disk). 'Block' is the same behavior as non-PQ blocking. 'Drop new data' throws away incoming data, while leaving the contents of the PQ unchanged."""

    max_file_open_time_sec: Annotated[
        Optional[float], pydantic.Field(alias="maxFileOpenTimeSec")
    ] = 300
    r"""Maximum amount of time to write to a file. Files open for longer than this will be closed and moved to final output location."""

    max_file_idle_time_sec: Annotated[
        Optional[float], pydantic.Field(alias="maxFileIdleTimeSec")
    ] = 30
    r"""Maximum amount of time to keep inactive files open. Files open for longer than this will be closed and moved to final output location."""

    max_concurrent_file_parts: Annotated[
        Optional[float], pydantic.Field(alias="maxConcurrentFileParts")
    ] = 4
    r"""Maximum number of parts to upload in parallel per file. Minimum part size is 5MB."""

    description: Optional[str] = None

    aws_api_key: Annotated[Optional[str], pydantic.Field(alias="awsApiKey")] = None
    r"""This value can be a constant or a JavaScript expression (`${C.env.SOME_ACCESS_KEY}`)"""

    compress: Annotated[
        Optional[PqCompressOptions], PlainValidator(validate_open_enum(False))
    ] = PqCompressOptions.NONE
    r"""Codec to use to compress the persisted data"""

    compression_level: Annotated[
        Annotated[
            Optional[CompressionLevelOptions], PlainValidator(validate_open_enum(False))
        ],
        pydantic.Field(alias="compressionLevel"),
    ] = CompressionLevelOptions.BEST_SPEED
    r"""Compression level to apply before moving files to final destination"""

    automatic_schema: Annotated[
        Optional[bool], pydantic.Field(alias="automaticSchema")
    ] = False
    r"""Automatically calculate the schema based on the events of each Parquet file generated"""

    parquet_schema: Annotated[Optional[str], pydantic.Field(alias="parquetSchema")] = (
        None
    )
    r"""To add a new schema, navigate to Processing > Knowledge > Parquet Schemas"""

    parquet_version: Annotated[
        Annotated[
            Optional[ParquetVersionOptions], PlainValidator(validate_open_enum(False))
        ],
        pydantic.Field(alias="parquetVersion"),
    ] = ParquetVersionOptions.PARQUET_2_6
    r"""Determines which data types are supported and how they are represented"""

    parquet_data_page_version: Annotated[
        Annotated[
            Optional[ParquetDataPageVersionOptions],
            PlainValidator(validate_open_enum(False)),
        ],
        pydantic.Field(alias="parquetDataPageVersion"),
    ] = ParquetDataPageVersionOptions.DATA_PAGE_V2
    r"""Serialization format of data pages. Note that some reader implementations use Data page V2's attributes to work more efficiently, while others ignore it."""

    parquet_row_group_length: Annotated[
        Optional[float], pydantic.Field(alias="parquetRowGroupLength")
    ] = 10000
    r"""The number of rows that every group will contain. The final group can contain a smaller number of rows."""

    parquet_page_size: Annotated[
        Optional[str], pydantic.Field(alias="parquetPageSize")
    ] = "1MB"
    r"""Target memory size for page segments, such as 1MB or 128MB. Generally, lower values improve reading speed, while higher values improve compression."""

    should_log_invalid_rows: Annotated[
        Optional[bool], pydantic.Field(alias="shouldLogInvalidRows")
    ] = None
    r"""Log up to 3 rows that @{product} skips due to data mismatch"""

    key_value_metadata: Annotated[
        Optional[List[TagsType]], pydantic.Field(alias="keyValueMetadata")
    ] = None
    r"""The metadata of files the Destination writes will include the properties you add here as key-value pairs. Useful for tagging. Examples: \"key\":\"OCSF Event Class\", \"value\":\"9001\" """

    enable_statistics: Annotated[
        Optional[bool], pydantic.Field(alias="enableStatistics")
    ] = True
    r"""Statistics profile an entire file in terms of minimum/maximum values within data, numbers of nulls, etc. You can use Parquet tools to view statistics."""

    enable_write_page_index: Annotated[
        Optional[bool], pydantic.Field(alias="enableWritePageIndex")
    ] = True
    r"""One page index contains statistics for one data page. Parquet readers use statistics to enable page skipping."""

    enable_page_checksum: Annotated[
        Optional[bool], pydantic.Field(alias="enablePageChecksum")
    ] = False
    r"""Parquet tools can use the checksum of a Parquet page to verify data integrity"""

    empty_dir_cleanup_sec: Annotated[
        Optional[float], pydantic.Field(alias="emptyDirCleanupSec")
    ] = 300
    r"""How frequently, in seconds, to clean up empty directories"""

    deadletter_path: Annotated[
        Optional[str], pydantic.Field(alias="deadletterPath")
    ] = "$CRIBL_HOME/state/outputs/dead-letter"
    r"""Storage location for files that fail to reach their final destination after maximum retries are exceeded"""

    max_retry_num: Annotated[Optional[float], pydantic.Field(alias="maxRetryNum")] = 20
    r"""The maximum number of times a file will attempt to move to its final destination before being dead-lettered"""

    @field_serializer("aws_authentication_method")
    def serialize_aws_authentication_method(self, value):
        if isinstance(value, str):
            try:
                return models.AwsAuthenticationMethodOptions(value)
            except ValueError:
                return value
        return value

    @field_serializer("signature_version")
    def serialize_signature_version(self, value):
        if isinstance(value, str):
            try:
                return models.SignatureVersionOptions(value)
            except ValueError:
                return value
        return value

    @field_serializer("object_acl")
    def serialize_object_acl(self, value):
        if isinstance(value, str):
            try:
                return models.ObjectACLOptions(value)
            except ValueError:
                return value
        return value

    @field_serializer("storage_class")
    def serialize_storage_class(self, value):
        if isinstance(value, str):
            try:
                return models.StorageClass3(value)
            except ValueError:
                return value
        return value

    @field_serializer("server_side_encryption")
    def serialize_server_side_encryption(self, value):
        if isinstance(value, str):
            try:
                return models.ServerSideEncryption3(value)
            except ValueError:
                return value
        return value

    @field_serializer("format_")
    def serialize_format_(self, value):
        if isinstance(value, str):
            try:
                return models.Format1Options(value)
            except ValueError:
                return value
        return value

    @field_serializer("on_backpressure")
    def serialize_on_backpressure(self, value):
        if isinstance(value, str):
            try:
                return models.PqOnBackpressureOptions(value)
            except ValueError:
                return value
        return value

    @field_serializer("on_disk_full_backpressure")
    def serialize_on_disk_full_backpressure(self, value):
        if isinstance(value, str):
            try:
                return models.PqOnBackpressureOptions(value)
            except ValueError:
                return value
        return value

    @field_serializer("compress")
    def serialize_compress(self, value):
        if isinstance(value, str):
            try:
                return models.PqCompressOptions(value)
            except ValueError:
                return value
        return value

    @field_serializer("compression_level")
    def serialize_compression_level(self, value):
        if isinstance(value, str):
            try:
                return models.CompressionLevelOptions(value)
            except ValueError:
                return value
        return value

    @field_serializer("parquet_version")
    def serialize_parquet_version(self, value):
        if isinstance(value, str):
            try:
                return models.ParquetVersionOptions(value)
            except ValueError:
                return value
        return value

    @field_serializer("parquet_data_page_version")
    def serialize_parquet_data_page_version(self, value):
        if isinstance(value, str):
            try:
                return models.ParquetDataPageVersionOptions(value)
            except ValueError:
                return value
        return value


class OutputMinioType2(str, Enum):
    MINIO = "minio"


class StorageClass2(str, Enum, metaclass=utils.OpenEnumMeta):
    r"""Storage class to select for uploaded objects"""

    # Standard
    STANDARD = "STANDARD"
    # Reduced Redundancy Storage
    REDUCED_REDUNDANCY = "REDUCED_REDUNDANCY"


class ServerSideEncryption2(str, Enum, metaclass=utils.OpenEnumMeta):
    r"""Server-side encryption for uploaded objects"""

    # Amazon S3 Managed Key
    AES256 = "AES256"


class OutputMinioMinio2TypedDict(TypedDict):
    type: OutputMinioType2
    endpoint: str
    r"""MinIO service url (e.g. http://minioHost:9000)"""
    bucket: str
    r"""Name of the destination MinIO bucket. This value can be a constant or a JavaScript expression that can only be evaluated at init time. Example referencing a Global Variable: `myBucket-${C.vars.myVar}`"""
    aws_api_key: str
    r"""This value can be a constant or a JavaScript expression (`${C.env.SOME_ACCESS_KEY}`)"""
    aws_authentication_method: NotRequired[AwsAuthenticationMethodOptions]
    r"""AWS authentication method. Choose Auto to use IAM roles."""
    id: NotRequired[str]
    r"""Unique ID for this output"""
    pipeline: NotRequired[str]
    r"""Pipeline to process data before sending out to this output"""
    system_fields: NotRequired[List[str]]
    r"""Fields to automatically add to events, such as cribl_pipe. Supports wildcards."""
    environment: NotRequired[str]
    r"""Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere."""
    streamtags: NotRequired[List[str]]
    r"""Tags for filtering and grouping in @{product}"""
    aws_secret_key: NotRequired[str]
    r"""Secret key. This value can be a constant or a JavaScript expression, such as `${C.env.SOME_SECRET}`)."""
    region: NotRequired[str]
    r"""Region where the MinIO service/cluster is located"""
    stage_path: NotRequired[str]
    r"""Filesystem location in which to buffer files, before compressing and moving to final destination. Use performant stable storage."""
    add_id_to_stage_path: NotRequired[bool]
    r"""Add the Output ID value to staging location"""
    dest_path: NotRequired[str]
    r"""Root directory to prepend to path before uploading. Enter a constant, or a JavaScript expression enclosed in quotes or backticks."""
    signature_version: NotRequired[SignatureVersionOptions]
    r"""Signature version to use for signing MSK cluster requests"""
    object_acl: NotRequired[ObjectACLOptions]
    r"""Object ACL to assign to uploaded objects"""
    storage_class: NotRequired[StorageClass2]
    r"""Storage class to select for uploaded objects"""
    server_side_encryption: NotRequired[ServerSideEncryption2]
    r"""Server-side encryption for uploaded objects"""
    reuse_connections: NotRequired[bool]
    r"""Reuse connections between requests, which can improve performance"""
    reject_unauthorized: NotRequired[bool]
    r"""Reject certificates that cannot be verified against a valid CA, such as self-signed certificates)"""
    verify_permissions: NotRequired[bool]
    r"""Disable if you can access files within the bucket but not the bucket itself"""
    remove_empty_dirs: NotRequired[bool]
    r"""Remove empty staging directories after moving files"""
    partition_expr: NotRequired[str]
    r"""JavaScript expression defining how files are partitioned and organized. Default is date-based. If blank, Stream will fall back to the event's __partition field value – if present – otherwise to each location's root directory."""
    format_: NotRequired[Format1Options]
    r"""Format of the output data"""
    base_file_name: NotRequired[str]
    r"""JavaScript expression to define the output filename prefix (can be constant)"""
    file_name_suffix: NotRequired[str]
    r"""JavaScript expression to define the output filename suffix (can be constant).  The `__format` variable refers to the value of the `Data format` field (`json` or `raw`).  The `__compression` field refers to the kind of compression being used (`none` or `gzip`)."""
    max_file_size_mb: NotRequired[float]
    r"""Maximum uncompressed output file size. Files of this size will be closed and moved to final output location."""
    max_open_files: NotRequired[float]
    r"""Maximum number of files to keep open concurrently. When exceeded, @{product} will close the oldest open files and move them to the final output location."""
    header_line: NotRequired[str]
    r"""If set, this line will be written to the beginning of each output file"""
    write_high_water_mark: NotRequired[float]
    r"""Buffer size used to write to a file"""
    on_backpressure: NotRequired[PqOnBackpressureOptions]
    r"""How to handle events when the queue is exerting backpressure (full capacity or low disk). 'Block' is the same behavior as non-PQ blocking. 'Drop new data' throws away incoming data, while leaving the contents of the PQ unchanged."""
    deadletter_enabled: NotRequired[bool]
    r"""If a file fails to move to its final destination after the maximum number of retries, move it to a designated directory to prevent further errors"""
    on_disk_full_backpressure: NotRequired[PqOnBackpressureOptions]
    r"""How to handle events when the queue is exerting backpressure (full capacity or low disk). 'Block' is the same behavior as non-PQ blocking. 'Drop new data' throws away incoming data, while leaving the contents of the PQ unchanged."""
    max_file_open_time_sec: NotRequired[float]
    r"""Maximum amount of time to write to a file. Files open for longer than this will be closed and moved to final output location."""
    max_file_idle_time_sec: NotRequired[float]
    r"""Maximum amount of time to keep inactive files open. Files open for longer than this will be closed and moved to final output location."""
    max_concurrent_file_parts: NotRequired[float]
    r"""Maximum number of parts to upload in parallel per file. Minimum part size is 5MB."""
    description: NotRequired[str]
    aws_secret: NotRequired[str]
    r"""Select or create a stored secret that references your access key and secret key"""
    compress: NotRequired[PqCompressOptions]
    r"""Codec to use to compress the persisted data"""
    compression_level: NotRequired[CompressionLevelOptions]
    r"""Compression level to apply before moving files to final destination"""
    automatic_schema: NotRequired[bool]
    r"""Automatically calculate the schema based on the events of each Parquet file generated"""
    parquet_schema: NotRequired[str]
    r"""To add a new schema, navigate to Processing > Knowledge > Parquet Schemas"""
    parquet_version: NotRequired[ParquetVersionOptions]
    r"""Determines which data types are supported and how they are represented"""
    parquet_data_page_version: NotRequired[ParquetDataPageVersionOptions]
    r"""Serialization format of data pages. Note that some reader implementations use Data page V2's attributes to work more efficiently, while others ignore it."""
    parquet_row_group_length: NotRequired[float]
    r"""The number of rows that every group will contain. The final group can contain a smaller number of rows."""
    parquet_page_size: NotRequired[str]
    r"""Target memory size for page segments, such as 1MB or 128MB. Generally, lower values improve reading speed, while higher values improve compression."""
    should_log_invalid_rows: NotRequired[bool]
    r"""Log up to 3 rows that @{product} skips due to data mismatch"""
    key_value_metadata: NotRequired[List[TagsTypeTypedDict]]
    r"""The metadata of files the Destination writes will include the properties you add here as key-value pairs. Useful for tagging. Examples: \"key\":\"OCSF Event Class\", \"value\":\"9001\" """
    enable_statistics: NotRequired[bool]
    r"""Statistics profile an entire file in terms of minimum/maximum values within data, numbers of nulls, etc. You can use Parquet tools to view statistics."""
    enable_write_page_index: NotRequired[bool]
    r"""One page index contains statistics for one data page. Parquet readers use statistics to enable page skipping."""
    enable_page_checksum: NotRequired[bool]
    r"""Parquet tools can use the checksum of a Parquet page to verify data integrity"""
    empty_dir_cleanup_sec: NotRequired[float]
    r"""How frequently, in seconds, to clean up empty directories"""
    deadletter_path: NotRequired[str]
    r"""Storage location for files that fail to reach their final destination after maximum retries are exceeded"""
    max_retry_num: NotRequired[float]
    r"""The maximum number of times a file will attempt to move to its final destination before being dead-lettered"""


class OutputMinioMinio2(BaseModel):
    type: OutputMinioType2

    endpoint: str
    r"""MinIO service url (e.g. http://minioHost:9000)"""

    bucket: str
    r"""Name of the destination MinIO bucket. This value can be a constant or a JavaScript expression that can only be evaluated at init time. Example referencing a Global Variable: `myBucket-${C.vars.myVar}`"""

    aws_api_key: Annotated[str, pydantic.Field(alias="awsApiKey")]
    r"""This value can be a constant or a JavaScript expression (`${C.env.SOME_ACCESS_KEY}`)"""

    aws_authentication_method: Annotated[
        Annotated[
            Optional[AwsAuthenticationMethodOptions],
            PlainValidator(validate_open_enum(False)),
        ],
        pydantic.Field(alias="awsAuthenticationMethod"),
    ] = AwsAuthenticationMethodOptions.AUTO
    r"""AWS authentication method. Choose Auto to use IAM roles."""

    id: Optional[str] = None
    r"""Unique ID for this output"""

    pipeline: Optional[str] = None
    r"""Pipeline to process data before sending out to this output"""

    system_fields: Annotated[
        Optional[List[str]], pydantic.Field(alias="systemFields")
    ] = None
    r"""Fields to automatically add to events, such as cribl_pipe. Supports wildcards."""

    environment: Optional[str] = None
    r"""Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere."""

    streamtags: Optional[List[str]] = None
    r"""Tags for filtering and grouping in @{product}"""

    aws_secret_key: Annotated[Optional[str], pydantic.Field(alias="awsSecretKey")] = (
        None
    )
    r"""Secret key. This value can be a constant or a JavaScript expression, such as `${C.env.SOME_SECRET}`)."""

    region: Optional[str] = None
    r"""Region where the MinIO service/cluster is located"""

    stage_path: Annotated[Optional[str], pydantic.Field(alias="stagePath")] = (
        "$CRIBL_HOME/state/outputs/staging"
    )
    r"""Filesystem location in which to buffer files, before compressing and moving to final destination. Use performant stable storage."""

    add_id_to_stage_path: Annotated[
        Optional[bool], pydantic.Field(alias="addIdToStagePath")
    ] = True
    r"""Add the Output ID value to staging location"""

    dest_path: Annotated[Optional[str], pydantic.Field(alias="destPath")] = None
    r"""Root directory to prepend to path before uploading. Enter a constant, or a JavaScript expression enclosed in quotes or backticks."""

    signature_version: Annotated[
        Annotated[
            Optional[SignatureVersionOptions], PlainValidator(validate_open_enum(False))
        ],
        pydantic.Field(alias="signatureVersion"),
    ] = SignatureVersionOptions.V4
    r"""Signature version to use for signing MSK cluster requests"""

    object_acl: Annotated[
        Annotated[
            Optional[ObjectACLOptions], PlainValidator(validate_open_enum(False))
        ],
        pydantic.Field(alias="objectACL"),
    ] = ObjectACLOptions.PRIVATE
    r"""Object ACL to assign to uploaded objects"""

    storage_class: Annotated[
        Annotated[Optional[StorageClass2], PlainValidator(validate_open_enum(False))],
        pydantic.Field(alias="storageClass"),
    ] = None
    r"""Storage class to select for uploaded objects"""

    server_side_encryption: Annotated[
        Annotated[
            Optional[ServerSideEncryption2], PlainValidator(validate_open_enum(False))
        ],
        pydantic.Field(alias="serverSideEncryption"),
    ] = None
    r"""Server-side encryption for uploaded objects"""

    reuse_connections: Annotated[
        Optional[bool], pydantic.Field(alias="reuseConnections")
    ] = True
    r"""Reuse connections between requests, which can improve performance"""

    reject_unauthorized: Annotated[
        Optional[bool], pydantic.Field(alias="rejectUnauthorized")
    ] = True
    r"""Reject certificates that cannot be verified against a valid CA, such as self-signed certificates)"""

    verify_permissions: Annotated[
        Optional[bool], pydantic.Field(alias="verifyPermissions")
    ] = True
    r"""Disable if you can access files within the bucket but not the bucket itself"""

    remove_empty_dirs: Annotated[
        Optional[bool], pydantic.Field(alias="removeEmptyDirs")
    ] = True
    r"""Remove empty staging directories after moving files"""

    partition_expr: Annotated[Optional[str], pydantic.Field(alias="partitionExpr")] = (
        "C.Time.strftime(_time ? _time : Date.now()/1000, '%Y/%m/%d')"
    )
    r"""JavaScript expression defining how files are partitioned and organized. Default is date-based. If blank, Stream will fall back to the event's __partition field value – if present – otherwise to each location's root directory."""

    format_: Annotated[
        Annotated[Optional[Format1Options], PlainValidator(validate_open_enum(False))],
        pydantic.Field(alias="format"),
    ] = Format1Options.JSON
    r"""Format of the output data"""

    base_file_name: Annotated[Optional[str], pydantic.Field(alias="baseFileName")] = (
        "`CriblOut`"
    )
    r"""JavaScript expression to define the output filename prefix (can be constant)"""

    file_name_suffix: Annotated[
        Optional[str], pydantic.Field(alias="fileNameSuffix")
    ] = '`.${C.env["CRIBL_WORKER_ID"]}.${__format}${__compression === "gzip" ? ".gz" : ""}`'
    r"""JavaScript expression to define the output filename suffix (can be constant).  The `__format` variable refers to the value of the `Data format` field (`json` or `raw`).  The `__compression` field refers to the kind of compression being used (`none` or `gzip`)."""

    max_file_size_mb: Annotated[
        Optional[float], pydantic.Field(alias="maxFileSizeMB")
    ] = 32
    r"""Maximum uncompressed output file size. Files of this size will be closed and moved to final output location."""

    max_open_files: Annotated[Optional[float], pydantic.Field(alias="maxOpenFiles")] = (
        100
    )
    r"""Maximum number of files to keep open concurrently. When exceeded, @{product} will close the oldest open files and move them to the final output location."""

    header_line: Annotated[Optional[str], pydantic.Field(alias="headerLine")] = ""
    r"""If set, this line will be written to the beginning of each output file"""

    write_high_water_mark: Annotated[
        Optional[float], pydantic.Field(alias="writeHighWaterMark")
    ] = 64
    r"""Buffer size used to write to a file"""

    on_backpressure: Annotated[
        Annotated[
            Optional[PqOnBackpressureOptions], PlainValidator(validate_open_enum(False))
        ],
        pydantic.Field(alias="onBackpressure"),
    ] = PqOnBackpressureOptions.BLOCK
    r"""How to handle events when the queue is exerting backpressure (full capacity or low disk). 'Block' is the same behavior as non-PQ blocking. 'Drop new data' throws away incoming data, while leaving the contents of the PQ unchanged."""

    deadletter_enabled: Annotated[
        Optional[bool], pydantic.Field(alias="deadletterEnabled")
    ] = False
    r"""If a file fails to move to its final destination after the maximum number of retries, move it to a designated directory to prevent further errors"""

    on_disk_full_backpressure: Annotated[
        Annotated[
            Optional[PqOnBackpressureOptions], PlainValidator(validate_open_enum(False))
        ],
        pydantic.Field(alias="onDiskFullBackpressure"),
    ] = PqOnBackpressureOptions.BLOCK
    r"""How to handle events when the queue is exerting backpressure (full capacity or low disk). 'Block' is the same behavior as non-PQ blocking. 'Drop new data' throws away incoming data, while leaving the contents of the PQ unchanged."""

    max_file_open_time_sec: Annotated[
        Optional[float], pydantic.Field(alias="maxFileOpenTimeSec")
    ] = 300
    r"""Maximum amount of time to write to a file. Files open for longer than this will be closed and moved to final output location."""

    max_file_idle_time_sec: Annotated[
        Optional[float], pydantic.Field(alias="maxFileIdleTimeSec")
    ] = 30
    r"""Maximum amount of time to keep inactive files open. Files open for longer than this will be closed and moved to final output location."""

    max_concurrent_file_parts: Annotated[
        Optional[float], pydantic.Field(alias="maxConcurrentFileParts")
    ] = 4
    r"""Maximum number of parts to upload in parallel per file. Minimum part size is 5MB."""

    description: Optional[str] = None

    aws_secret: Annotated[Optional[str], pydantic.Field(alias="awsSecret")] = None
    r"""Select or create a stored secret that references your access key and secret key"""

    compress: Annotated[
        Optional[PqCompressOptions], PlainValidator(validate_open_enum(False))
    ] = PqCompressOptions.NONE
    r"""Codec to use to compress the persisted data"""

    compression_level: Annotated[
        Annotated[
            Optional[CompressionLevelOptions], PlainValidator(validate_open_enum(False))
        ],
        pydantic.Field(alias="compressionLevel"),
    ] = CompressionLevelOptions.BEST_SPEED
    r"""Compression level to apply before moving files to final destination"""

    automatic_schema: Annotated[
        Optional[bool], pydantic.Field(alias="automaticSchema")
    ] = False
    r"""Automatically calculate the schema based on the events of each Parquet file generated"""

    parquet_schema: Annotated[Optional[str], pydantic.Field(alias="parquetSchema")] = (
        None
    )
    r"""To add a new schema, navigate to Processing > Knowledge > Parquet Schemas"""

    parquet_version: Annotated[
        Annotated[
            Optional[ParquetVersionOptions], PlainValidator(validate_open_enum(False))
        ],
        pydantic.Field(alias="parquetVersion"),
    ] = ParquetVersionOptions.PARQUET_2_6
    r"""Determines which data types are supported and how they are represented"""

    parquet_data_page_version: Annotated[
        Annotated[
            Optional[ParquetDataPageVersionOptions],
            PlainValidator(validate_open_enum(False)),
        ],
        pydantic.Field(alias="parquetDataPageVersion"),
    ] = ParquetDataPageVersionOptions.DATA_PAGE_V2
    r"""Serialization format of data pages. Note that some reader implementations use Data page V2's attributes to work more efficiently, while others ignore it."""

    parquet_row_group_length: Annotated[
        Optional[float], pydantic.Field(alias="parquetRowGroupLength")
    ] = 10000
    r"""The number of rows that every group will contain. The final group can contain a smaller number of rows."""

    parquet_page_size: Annotated[
        Optional[str], pydantic.Field(alias="parquetPageSize")
    ] = "1MB"
    r"""Target memory size for page segments, such as 1MB or 128MB. Generally, lower values improve reading speed, while higher values improve compression."""

    should_log_invalid_rows: Annotated[
        Optional[bool], pydantic.Field(alias="shouldLogInvalidRows")
    ] = None
    r"""Log up to 3 rows that @{product} skips due to data mismatch"""

    key_value_metadata: Annotated[
        Optional[List[TagsType]], pydantic.Field(alias="keyValueMetadata")
    ] = None
    r"""The metadata of files the Destination writes will include the properties you add here as key-value pairs. Useful for tagging. Examples: \"key\":\"OCSF Event Class\", \"value\":\"9001\" """

    enable_statistics: Annotated[
        Optional[bool], pydantic.Field(alias="enableStatistics")
    ] = True
    r"""Statistics profile an entire file in terms of minimum/maximum values within data, numbers of nulls, etc. You can use Parquet tools to view statistics."""

    enable_write_page_index: Annotated[
        Optional[bool], pydantic.Field(alias="enableWritePageIndex")
    ] = True
    r"""One page index contains statistics for one data page. Parquet readers use statistics to enable page skipping."""

    enable_page_checksum: Annotated[
        Optional[bool], pydantic.Field(alias="enablePageChecksum")
    ] = False
    r"""Parquet tools can use the checksum of a Parquet page to verify data integrity"""

    empty_dir_cleanup_sec: Annotated[
        Optional[float], pydantic.Field(alias="emptyDirCleanupSec")
    ] = 300
    r"""How frequently, in seconds, to clean up empty directories"""

    deadletter_path: Annotated[
        Optional[str], pydantic.Field(alias="deadletterPath")
    ] = "$CRIBL_HOME/state/outputs/dead-letter"
    r"""Storage location for files that fail to reach their final destination after maximum retries are exceeded"""

    max_retry_num: Annotated[Optional[float], pydantic.Field(alias="maxRetryNum")] = 20
    r"""The maximum number of times a file will attempt to move to its final destination before being dead-lettered"""

    @field_serializer("aws_authentication_method")
    def serialize_aws_authentication_method(self, value):
        if isinstance(value, str):
            try:
                return models.AwsAuthenticationMethodOptions(value)
            except ValueError:
                return value
        return value

    @field_serializer("signature_version")
    def serialize_signature_version(self, value):
        if isinstance(value, str):
            try:
                return models.SignatureVersionOptions(value)
            except ValueError:
                return value
        return value

    @field_serializer("object_acl")
    def serialize_object_acl(self, value):
        if isinstance(value, str):
            try:
                return models.ObjectACLOptions(value)
            except ValueError:
                return value
        return value

    @field_serializer("storage_class")
    def serialize_storage_class(self, value):
        if isinstance(value, str):
            try:
                return models.StorageClass2(value)
            except ValueError:
                return value
        return value

    @field_serializer("server_side_encryption")
    def serialize_server_side_encryption(self, value):
        if isinstance(value, str):
            try:
                return models.ServerSideEncryption2(value)
            except ValueError:
                return value
        return value

    @field_serializer("format_")
    def serialize_format_(self, value):
        if isinstance(value, str):
            try:
                return models.Format1Options(value)
            except ValueError:
                return value
        return value

    @field_serializer("on_backpressure")
    def serialize_on_backpressure(self, value):
        if isinstance(value, str):
            try:
                return models.PqOnBackpressureOptions(value)
            except ValueError:
                return value
        return value

    @field_serializer("on_disk_full_backpressure")
    def serialize_on_disk_full_backpressure(self, value):
        if isinstance(value, str):
            try:
                return models.PqOnBackpressureOptions(value)
            except ValueError:
                return value
        return value

    @field_serializer("compress")
    def serialize_compress(self, value):
        if isinstance(value, str):
            try:
                return models.PqCompressOptions(value)
            except ValueError:
                return value
        return value

    @field_serializer("compression_level")
    def serialize_compression_level(self, value):
        if isinstance(value, str):
            try:
                return models.CompressionLevelOptions(value)
            except ValueError:
                return value
        return value

    @field_serializer("parquet_version")
    def serialize_parquet_version(self, value):
        if isinstance(value, str):
            try:
                return models.ParquetVersionOptions(value)
            except ValueError:
                return value
        return value

    @field_serializer("parquet_data_page_version")
    def serialize_parquet_data_page_version(self, value):
        if isinstance(value, str):
            try:
                return models.ParquetDataPageVersionOptions(value)
            except ValueError:
                return value
        return value


class OutputMinioType1(str, Enum):
    MINIO = "minio"


class StorageClass1(str, Enum, metaclass=utils.OpenEnumMeta):
    r"""Storage class to select for uploaded objects"""

    # Standard
    STANDARD = "STANDARD"
    # Reduced Redundancy Storage
    REDUCED_REDUNDANCY = "REDUCED_REDUNDANCY"


class ServerSideEncryption1(str, Enum, metaclass=utils.OpenEnumMeta):
    r"""Server-side encryption for uploaded objects"""

    # Amazon S3 Managed Key
    AES256 = "AES256"


class OutputMinioMinio1TypedDict(TypedDict):
    type: OutputMinioType1
    endpoint: str
    r"""MinIO service url (e.g. http://minioHost:9000)"""
    bucket: str
    r"""Name of the destination MinIO bucket. This value can be a constant or a JavaScript expression that can only be evaluated at init time. Example referencing a Global Variable: `myBucket-${C.vars.myVar}`"""
    aws_authentication_method: NotRequired[AwsAuthenticationMethodOptions]
    r"""AWS authentication method. Choose Auto to use IAM roles."""
    id: NotRequired[str]
    r"""Unique ID for this output"""
    pipeline: NotRequired[str]
    r"""Pipeline to process data before sending out to this output"""
    system_fields: NotRequired[List[str]]
    r"""Fields to automatically add to events, such as cribl_pipe. Supports wildcards."""
    environment: NotRequired[str]
    r"""Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere."""
    streamtags: NotRequired[List[str]]
    r"""Tags for filtering and grouping in @{product}"""
    aws_secret_key: NotRequired[str]
    r"""Secret key. This value can be a constant or a JavaScript expression, such as `${C.env.SOME_SECRET}`)."""
    region: NotRequired[str]
    r"""Region where the MinIO service/cluster is located"""
    stage_path: NotRequired[str]
    r"""Filesystem location in which to buffer files, before compressing and moving to final destination. Use performant stable storage."""
    add_id_to_stage_path: NotRequired[bool]
    r"""Add the Output ID value to staging location"""
    dest_path: NotRequired[str]
    r"""Root directory to prepend to path before uploading. Enter a constant, or a JavaScript expression enclosed in quotes or backticks."""
    signature_version: NotRequired[SignatureVersionOptions]
    r"""Signature version to use for signing MSK cluster requests"""
    object_acl: NotRequired[ObjectACLOptions]
    r"""Object ACL to assign to uploaded objects"""
    storage_class: NotRequired[StorageClass1]
    r"""Storage class to select for uploaded objects"""
    server_side_encryption: NotRequired[ServerSideEncryption1]
    r"""Server-side encryption for uploaded objects"""
    reuse_connections: NotRequired[bool]
    r"""Reuse connections between requests, which can improve performance"""
    reject_unauthorized: NotRequired[bool]
    r"""Reject certificates that cannot be verified against a valid CA, such as self-signed certificates)"""
    verify_permissions: NotRequired[bool]
    r"""Disable if you can access files within the bucket but not the bucket itself"""
    remove_empty_dirs: NotRequired[bool]
    r"""Remove empty staging directories after moving files"""
    partition_expr: NotRequired[str]
    r"""JavaScript expression defining how files are partitioned and organized. Default is date-based. If blank, Stream will fall back to the event's __partition field value – if present – otherwise to each location's root directory."""
    format_: NotRequired[Format1Options]
    r"""Format of the output data"""
    base_file_name: NotRequired[str]
    r"""JavaScript expression to define the output filename prefix (can be constant)"""
    file_name_suffix: NotRequired[str]
    r"""JavaScript expression to define the output filename suffix (can be constant).  The `__format` variable refers to the value of the `Data format` field (`json` or `raw`).  The `__compression` field refers to the kind of compression being used (`none` or `gzip`)."""
    max_file_size_mb: NotRequired[float]
    r"""Maximum uncompressed output file size. Files of this size will be closed and moved to final output location."""
    max_open_files: NotRequired[float]
    r"""Maximum number of files to keep open concurrently. When exceeded, @{product} will close the oldest open files and move them to the final output location."""
    header_line: NotRequired[str]
    r"""If set, this line will be written to the beginning of each output file"""
    write_high_water_mark: NotRequired[float]
    r"""Buffer size used to write to a file"""
    on_backpressure: NotRequired[PqOnBackpressureOptions]
    r"""How to handle events when the queue is exerting backpressure (full capacity or low disk). 'Block' is the same behavior as non-PQ blocking. 'Drop new data' throws away incoming data, while leaving the contents of the PQ unchanged."""
    deadletter_enabled: NotRequired[bool]
    r"""If a file fails to move to its final destination after the maximum number of retries, move it to a designated directory to prevent further errors"""
    on_disk_full_backpressure: NotRequired[PqOnBackpressureOptions]
    r"""How to handle events when the queue is exerting backpressure (full capacity or low disk). 'Block' is the same behavior as non-PQ blocking. 'Drop new data' throws away incoming data, while leaving the contents of the PQ unchanged."""
    max_file_open_time_sec: NotRequired[float]
    r"""Maximum amount of time to write to a file. Files open for longer than this will be closed and moved to final output location."""
    max_file_idle_time_sec: NotRequired[float]
    r"""Maximum amount of time to keep inactive files open. Files open for longer than this will be closed and moved to final output location."""
    max_concurrent_file_parts: NotRequired[float]
    r"""Maximum number of parts to upload in parallel per file. Minimum part size is 5MB."""
    description: NotRequired[str]
    aws_api_key: NotRequired[str]
    r"""This value can be a constant or a JavaScript expression (`${C.env.SOME_ACCESS_KEY}`)"""
    aws_secret: NotRequired[str]
    r"""Select or create a stored secret that references your access key and secret key"""
    compress: NotRequired[PqCompressOptions]
    r"""Codec to use to compress the persisted data"""
    compression_level: NotRequired[CompressionLevelOptions]
    r"""Compression level to apply before moving files to final destination"""
    automatic_schema: NotRequired[bool]
    r"""Automatically calculate the schema based on the events of each Parquet file generated"""
    parquet_schema: NotRequired[str]
    r"""To add a new schema, navigate to Processing > Knowledge > Parquet Schemas"""
    parquet_version: NotRequired[ParquetVersionOptions]
    r"""Determines which data types are supported and how they are represented"""
    parquet_data_page_version: NotRequired[ParquetDataPageVersionOptions]
    r"""Serialization format of data pages. Note that some reader implementations use Data page V2's attributes to work more efficiently, while others ignore it."""
    parquet_row_group_length: NotRequired[float]
    r"""The number of rows that every group will contain. The final group can contain a smaller number of rows."""
    parquet_page_size: NotRequired[str]
    r"""Target memory size for page segments, such as 1MB or 128MB. Generally, lower values improve reading speed, while higher values improve compression."""
    should_log_invalid_rows: NotRequired[bool]
    r"""Log up to 3 rows that @{product} skips due to data mismatch"""
    key_value_metadata: NotRequired[List[TagsTypeTypedDict]]
    r"""The metadata of files the Destination writes will include the properties you add here as key-value pairs. Useful for tagging. Examples: \"key\":\"OCSF Event Class\", \"value\":\"9001\" """
    enable_statistics: NotRequired[bool]
    r"""Statistics profile an entire file in terms of minimum/maximum values within data, numbers of nulls, etc. You can use Parquet tools to view statistics."""
    enable_write_page_index: NotRequired[bool]
    r"""One page index contains statistics for one data page. Parquet readers use statistics to enable page skipping."""
    enable_page_checksum: NotRequired[bool]
    r"""Parquet tools can use the checksum of a Parquet page to verify data integrity"""
    empty_dir_cleanup_sec: NotRequired[float]
    r"""How frequently, in seconds, to clean up empty directories"""
    deadletter_path: NotRequired[str]
    r"""Storage location for files that fail to reach their final destination after maximum retries are exceeded"""
    max_retry_num: NotRequired[float]
    r"""The maximum number of times a file will attempt to move to its final destination before being dead-lettered"""


class OutputMinioMinio1(BaseModel):
    type: OutputMinioType1

    endpoint: str
    r"""MinIO service url (e.g. http://minioHost:9000)"""

    bucket: str
    r"""Name of the destination MinIO bucket. This value can be a constant or a JavaScript expression that can only be evaluated at init time. Example referencing a Global Variable: `myBucket-${C.vars.myVar}`"""

    aws_authentication_method: Annotated[
        Annotated[
            Optional[AwsAuthenticationMethodOptions],
            PlainValidator(validate_open_enum(False)),
        ],
        pydantic.Field(alias="awsAuthenticationMethod"),
    ] = AwsAuthenticationMethodOptions.AUTO
    r"""AWS authentication method. Choose Auto to use IAM roles."""

    id: Optional[str] = None
    r"""Unique ID for this output"""

    pipeline: Optional[str] = None
    r"""Pipeline to process data before sending out to this output"""

    system_fields: Annotated[
        Optional[List[str]], pydantic.Field(alias="systemFields")
    ] = None
    r"""Fields to automatically add to events, such as cribl_pipe. Supports wildcards."""

    environment: Optional[str] = None
    r"""Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere."""

    streamtags: Optional[List[str]] = None
    r"""Tags for filtering and grouping in @{product}"""

    aws_secret_key: Annotated[Optional[str], pydantic.Field(alias="awsSecretKey")] = (
        None
    )
    r"""Secret key. This value can be a constant or a JavaScript expression, such as `${C.env.SOME_SECRET}`)."""

    region: Optional[str] = None
    r"""Region where the MinIO service/cluster is located"""

    stage_path: Annotated[Optional[str], pydantic.Field(alias="stagePath")] = (
        "$CRIBL_HOME/state/outputs/staging"
    )
    r"""Filesystem location in which to buffer files, before compressing and moving to final destination. Use performant stable storage."""

    add_id_to_stage_path: Annotated[
        Optional[bool], pydantic.Field(alias="addIdToStagePath")
    ] = True
    r"""Add the Output ID value to staging location"""

    dest_path: Annotated[Optional[str], pydantic.Field(alias="destPath")] = None
    r"""Root directory to prepend to path before uploading. Enter a constant, or a JavaScript expression enclosed in quotes or backticks."""

    signature_version: Annotated[
        Annotated[
            Optional[SignatureVersionOptions], PlainValidator(validate_open_enum(False))
        ],
        pydantic.Field(alias="signatureVersion"),
    ] = SignatureVersionOptions.V4
    r"""Signature version to use for signing MSK cluster requests"""

    object_acl: Annotated[
        Annotated[
            Optional[ObjectACLOptions], PlainValidator(validate_open_enum(False))
        ],
        pydantic.Field(alias="objectACL"),
    ] = ObjectACLOptions.PRIVATE
    r"""Object ACL to assign to uploaded objects"""

    storage_class: Annotated[
        Annotated[Optional[StorageClass1], PlainValidator(validate_open_enum(False))],
        pydantic.Field(alias="storageClass"),
    ] = None
    r"""Storage class to select for uploaded objects"""

    server_side_encryption: Annotated[
        Annotated[
            Optional[ServerSideEncryption1], PlainValidator(validate_open_enum(False))
        ],
        pydantic.Field(alias="serverSideEncryption"),
    ] = None
    r"""Server-side encryption for uploaded objects"""

    reuse_connections: Annotated[
        Optional[bool], pydantic.Field(alias="reuseConnections")
    ] = True
    r"""Reuse connections between requests, which can improve performance"""

    reject_unauthorized: Annotated[
        Optional[bool], pydantic.Field(alias="rejectUnauthorized")
    ] = True
    r"""Reject certificates that cannot be verified against a valid CA, such as self-signed certificates)"""

    verify_permissions: Annotated[
        Optional[bool], pydantic.Field(alias="verifyPermissions")
    ] = True
    r"""Disable if you can access files within the bucket but not the bucket itself"""

    remove_empty_dirs: Annotated[
        Optional[bool], pydantic.Field(alias="removeEmptyDirs")
    ] = True
    r"""Remove empty staging directories after moving files"""

    partition_expr: Annotated[Optional[str], pydantic.Field(alias="partitionExpr")] = (
        "C.Time.strftime(_time ? _time : Date.now()/1000, '%Y/%m/%d')"
    )
    r"""JavaScript expression defining how files are partitioned and organized. Default is date-based. If blank, Stream will fall back to the event's __partition field value – if present – otherwise to each location's root directory."""

    format_: Annotated[
        Annotated[Optional[Format1Options], PlainValidator(validate_open_enum(False))],
        pydantic.Field(alias="format"),
    ] = Format1Options.JSON
    r"""Format of the output data"""

    base_file_name: Annotated[Optional[str], pydantic.Field(alias="baseFileName")] = (
        "`CriblOut`"
    )
    r"""JavaScript expression to define the output filename prefix (can be constant)"""

    file_name_suffix: Annotated[
        Optional[str], pydantic.Field(alias="fileNameSuffix")
    ] = '`.${C.env["CRIBL_WORKER_ID"]}.${__format}${__compression === "gzip" ? ".gz" : ""}`'
    r"""JavaScript expression to define the output filename suffix (can be constant).  The `__format` variable refers to the value of the `Data format` field (`json` or `raw`).  The `__compression` field refers to the kind of compression being used (`none` or `gzip`)."""

    max_file_size_mb: Annotated[
        Optional[float], pydantic.Field(alias="maxFileSizeMB")
    ] = 32
    r"""Maximum uncompressed output file size. Files of this size will be closed and moved to final output location."""

    max_open_files: Annotated[Optional[float], pydantic.Field(alias="maxOpenFiles")] = (
        100
    )
    r"""Maximum number of files to keep open concurrently. When exceeded, @{product} will close the oldest open files and move them to the final output location."""

    header_line: Annotated[Optional[str], pydantic.Field(alias="headerLine")] = ""
    r"""If set, this line will be written to the beginning of each output file"""

    write_high_water_mark: Annotated[
        Optional[float], pydantic.Field(alias="writeHighWaterMark")
    ] = 64
    r"""Buffer size used to write to a file"""

    on_backpressure: Annotated[
        Annotated[
            Optional[PqOnBackpressureOptions], PlainValidator(validate_open_enum(False))
        ],
        pydantic.Field(alias="onBackpressure"),
    ] = PqOnBackpressureOptions.BLOCK
    r"""How to handle events when the queue is exerting backpressure (full capacity or low disk). 'Block' is the same behavior as non-PQ blocking. 'Drop new data' throws away incoming data, while leaving the contents of the PQ unchanged."""

    deadletter_enabled: Annotated[
        Optional[bool], pydantic.Field(alias="deadletterEnabled")
    ] = False
    r"""If a file fails to move to its final destination after the maximum number of retries, move it to a designated directory to prevent further errors"""

    on_disk_full_backpressure: Annotated[
        Annotated[
            Optional[PqOnBackpressureOptions], PlainValidator(validate_open_enum(False))
        ],
        pydantic.Field(alias="onDiskFullBackpressure"),
    ] = PqOnBackpressureOptions.BLOCK
    r"""How to handle events when the queue is exerting backpressure (full capacity or low disk). 'Block' is the same behavior as non-PQ blocking. 'Drop new data' throws away incoming data, while leaving the contents of the PQ unchanged."""

    max_file_open_time_sec: Annotated[
        Optional[float], pydantic.Field(alias="maxFileOpenTimeSec")
    ] = 300
    r"""Maximum amount of time to write to a file. Files open for longer than this will be closed and moved to final output location."""

    max_file_idle_time_sec: Annotated[
        Optional[float], pydantic.Field(alias="maxFileIdleTimeSec")
    ] = 30
    r"""Maximum amount of time to keep inactive files open. Files open for longer than this will be closed and moved to final output location."""

    max_concurrent_file_parts: Annotated[
        Optional[float], pydantic.Field(alias="maxConcurrentFileParts")
    ] = 4
    r"""Maximum number of parts to upload in parallel per file. Minimum part size is 5MB."""

    description: Optional[str] = None

    aws_api_key: Annotated[Optional[str], pydantic.Field(alias="awsApiKey")] = None
    r"""This value can be a constant or a JavaScript expression (`${C.env.SOME_ACCESS_KEY}`)"""

    aws_secret: Annotated[Optional[str], pydantic.Field(alias="awsSecret")] = None
    r"""Select or create a stored secret that references your access key and secret key"""

    compress: Annotated[
        Optional[PqCompressOptions], PlainValidator(validate_open_enum(False))
    ] = PqCompressOptions.NONE
    r"""Codec to use to compress the persisted data"""

    compression_level: Annotated[
        Annotated[
            Optional[CompressionLevelOptions], PlainValidator(validate_open_enum(False))
        ],
        pydantic.Field(alias="compressionLevel"),
    ] = CompressionLevelOptions.BEST_SPEED
    r"""Compression level to apply before moving files to final destination"""

    automatic_schema: Annotated[
        Optional[bool], pydantic.Field(alias="automaticSchema")
    ] = False
    r"""Automatically calculate the schema based on the events of each Parquet file generated"""

    parquet_schema: Annotated[Optional[str], pydantic.Field(alias="parquetSchema")] = (
        None
    )
    r"""To add a new schema, navigate to Processing > Knowledge > Parquet Schemas"""

    parquet_version: Annotated[
        Annotated[
            Optional[ParquetVersionOptions], PlainValidator(validate_open_enum(False))
        ],
        pydantic.Field(alias="parquetVersion"),
    ] = ParquetVersionOptions.PARQUET_2_6
    r"""Determines which data types are supported and how they are represented"""

    parquet_data_page_version: Annotated[
        Annotated[
            Optional[ParquetDataPageVersionOptions],
            PlainValidator(validate_open_enum(False)),
        ],
        pydantic.Field(alias="parquetDataPageVersion"),
    ] = ParquetDataPageVersionOptions.DATA_PAGE_V2
    r"""Serialization format of data pages. Note that some reader implementations use Data page V2's attributes to work more efficiently, while others ignore it."""

    parquet_row_group_length: Annotated[
        Optional[float], pydantic.Field(alias="parquetRowGroupLength")
    ] = 10000
    r"""The number of rows that every group will contain. The final group can contain a smaller number of rows."""

    parquet_page_size: Annotated[
        Optional[str], pydantic.Field(alias="parquetPageSize")
    ] = "1MB"
    r"""Target memory size for page segments, such as 1MB or 128MB. Generally, lower values improve reading speed, while higher values improve compression."""

    should_log_invalid_rows: Annotated[
        Optional[bool], pydantic.Field(alias="shouldLogInvalidRows")
    ] = None
    r"""Log up to 3 rows that @{product} skips due to data mismatch"""

    key_value_metadata: Annotated[
        Optional[List[TagsType]], pydantic.Field(alias="keyValueMetadata")
    ] = None
    r"""The metadata of files the Destination writes will include the properties you add here as key-value pairs. Useful for tagging. Examples: \"key\":\"OCSF Event Class\", \"value\":\"9001\" """

    enable_statistics: Annotated[
        Optional[bool], pydantic.Field(alias="enableStatistics")
    ] = True
    r"""Statistics profile an entire file in terms of minimum/maximum values within data, numbers of nulls, etc. You can use Parquet tools to view statistics."""

    enable_write_page_index: Annotated[
        Optional[bool], pydantic.Field(alias="enableWritePageIndex")
    ] = True
    r"""One page index contains statistics for one data page. Parquet readers use statistics to enable page skipping."""

    enable_page_checksum: Annotated[
        Optional[bool], pydantic.Field(alias="enablePageChecksum")
    ] = False
    r"""Parquet tools can use the checksum of a Parquet page to verify data integrity"""

    empty_dir_cleanup_sec: Annotated[
        Optional[float], pydantic.Field(alias="emptyDirCleanupSec")
    ] = 300
    r"""How frequently, in seconds, to clean up empty directories"""

    deadletter_path: Annotated[
        Optional[str], pydantic.Field(alias="deadletterPath")
    ] = "$CRIBL_HOME/state/outputs/dead-letter"
    r"""Storage location for files that fail to reach their final destination after maximum retries are exceeded"""

    max_retry_num: Annotated[Optional[float], pydantic.Field(alias="maxRetryNum")] = 20
    r"""The maximum number of times a file will attempt to move to its final destination before being dead-lettered"""

    @field_serializer("aws_authentication_method")
    def serialize_aws_authentication_method(self, value):
        if isinstance(value, str):
            try:
                return models.AwsAuthenticationMethodOptions(value)
            except ValueError:
                return value
        return value

    @field_serializer("signature_version")
    def serialize_signature_version(self, value):
        if isinstance(value, str):
            try:
                return models.SignatureVersionOptions(value)
            except ValueError:
                return value
        return value

    @field_serializer("object_acl")
    def serialize_object_acl(self, value):
        if isinstance(value, str):
            try:
                return models.ObjectACLOptions(value)
            except ValueError:
                return value
        return value

    @field_serializer("storage_class")
    def serialize_storage_class(self, value):
        if isinstance(value, str):
            try:
                return models.StorageClass1(value)
            except ValueError:
                return value
        return value

    @field_serializer("server_side_encryption")
    def serialize_server_side_encryption(self, value):
        if isinstance(value, str):
            try:
                return models.ServerSideEncryption1(value)
            except ValueError:
                return value
        return value

    @field_serializer("format_")
    def serialize_format_(self, value):
        if isinstance(value, str):
            try:
                return models.Format1Options(value)
            except ValueError:
                return value
        return value

    @field_serializer("on_backpressure")
    def serialize_on_backpressure(self, value):
        if isinstance(value, str):
            try:
                return models.PqOnBackpressureOptions(value)
            except ValueError:
                return value
        return value

    @field_serializer("on_disk_full_backpressure")
    def serialize_on_disk_full_backpressure(self, value):
        if isinstance(value, str):
            try:
                return models.PqOnBackpressureOptions(value)
            except ValueError:
                return value
        return value

    @field_serializer("compress")
    def serialize_compress(self, value):
        if isinstance(value, str):
            try:
                return models.PqCompressOptions(value)
            except ValueError:
                return value
        return value

    @field_serializer("compression_level")
    def serialize_compression_level(self, value):
        if isinstance(value, str):
            try:
                return models.CompressionLevelOptions(value)
            except ValueError:
                return value
        return value

    @field_serializer("parquet_version")
    def serialize_parquet_version(self, value):
        if isinstance(value, str):
            try:
                return models.ParquetVersionOptions(value)
            except ValueError:
                return value
        return value

    @field_serializer("parquet_data_page_version")
    def serialize_parquet_data_page_version(self, value):
        if isinstance(value, str):
            try:
                return models.ParquetDataPageVersionOptions(value)
            except ValueError:
                return value
        return value


OutputMinioTypedDict = TypeAliasType(
    "OutputMinioTypedDict",
    Union[
        OutputMinioMinio1TypedDict,
        OutputMinioMinio2TypedDict,
        OutputMinioMinio3TypedDict,
        OutputMinioMinio4TypedDict,
        OutputMinioMinio5TypedDict,
        OutputMinioMinio6TypedDict,
        OutputMinioMinio7TypedDict,
        OutputMinioMinio8TypedDict,
        OutputMinioMinio9TypedDict,
    ],
)


OutputMinio = TypeAliasType(
    "OutputMinio",
    Union[
        OutputMinioMinio1,
        OutputMinioMinio2,
        OutputMinioMinio3,
        OutputMinioMinio4,
        OutputMinioMinio5,
        OutputMinioMinio6,
        OutputMinioMinio7,
        OutputMinioMinio8,
        OutputMinioMinio9,
    ],
)
