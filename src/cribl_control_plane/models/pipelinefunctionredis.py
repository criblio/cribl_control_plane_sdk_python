"""Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT."""

from __future__ import annotations
from .maximumtlsversionoptionsredisdeploymenttypestandalonetlsoptions import (
    MaximumTLSVersionOptionsRedisDeploymentTypeStandaloneTLSOptions,
)
from .minimumtlsversionoptionsredisdeploymenttypestandalonetlsoptions import (
    MinimumTLSVersionOptionsRedisDeploymentTypeStandaloneTLSOptions,
)
from .tlsoptionstyperedisdeploymenttypeclustertlstrue import (
    TLSOptionsTypeRedisDeploymentTypeClusterTLSTrue,
    TLSOptionsTypeRedisDeploymentTypeClusterTLSTrueTypedDict,
)
from cribl_control_plane import models, utils
from cribl_control_plane.types import BaseModel, UNSET_SENTINEL
from cribl_control_plane.utils.unions import parse_open_union
from enum import Enum
from functools import partial
import pydantic
from pydantic import ConfigDict, field_serializer, model_serializer
from pydantic.functional_validators import BeforeValidator
from typing import Any, List, Literal, Optional, Union
from typing_extensions import Annotated, NotRequired, TypeAliasType, TypedDict


class PipelineFunctionRedisID(str, Enum):
    r"""Function ID"""

    REDIS = "redis"


class RedisAuthTypeTextSecretAuthenticationMethod(
    str, Enum, metaclass=utils.OpenEnumMeta
):
    # None
    NONE = "none"
    # Manual
    MANUAL = "manual"
    # User Secret
    CREDENTIALS_SECRET = "credentialsSecret"
    # Admin Secret
    TEXT_SECRET = "textSecret"


class RedisAuthTypeTextSecretCommandTypedDict(TypedDict):
    command: str
    r"""Redis command to perform. For a complete list visit: https://redis.io/commands"""
    key_expr: str
    r"""A JavaScript expression to compute the value of the key to operate on. Can also be a constant such as 'username'."""
    out_field: NotRequired[str]
    r"""Name of the field in which to store the returned value. Leave blank to discard returned value."""
    args_expr: NotRequired[str]
    r"""A JavaScript expression to compute arguments to the operation. Can return an array."""


class RedisAuthTypeTextSecretCommand(BaseModel):
    command: str
    r"""Redis command to perform. For a complete list visit: https://redis.io/commands"""

    key_expr: Annotated[str, pydantic.Field(alias="keyExpr")]
    r"""A JavaScript expression to compute the value of the key to operate on. Can also be a constant such as 'username'."""

    out_field: Annotated[Optional[str], pydantic.Field(alias="outField")] = None
    r"""Name of the field in which to store the returned value. Leave blank to discard returned value."""

    args_expr: Annotated[Optional[str], pydantic.Field(alias="argsExpr")] = None
    r"""A JavaScript expression to compute arguments to the operation. Can return an array."""

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(["outField", "argsExpr"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


class RedisAuthTypeTextSecretDeploymentType(str, Enum, metaclass=utils.OpenEnumMeta):
    r"""How the Redis server is configured. Defaults to Standalone"""

    # Standalone
    STANDALONE = "standalone"
    # Cluster
    CLUSTER = "cluster"
    # Sentinel
    SENTINEL = "sentinel"


class RedisAuthTypeTextSecretTypedDict(TypedDict):
    text_secret: str
    r"""Secret that references Redis admin password"""
    commands: List[RedisAuthTypeTextSecretCommandTypedDict]
    auth_type: NotRequired[RedisAuthTypeTextSecretAuthenticationMethod]
    deployment_type: NotRequired[RedisAuthTypeTextSecretDeploymentType]
    r"""How the Redis server is configured. Defaults to Standalone"""
    max_block_secs: NotRequired[float]
    r"""Maximum amount of time (seconds) to wait before assuming that Redis is down and passing events through. Use 0 to disable."""
    enable_client_side_caching: NotRequired[bool]
    r"""Enable client-side cache. Redundant when using Redis write operations. See more options at Settings > General > Limits > Redis Cache."""


class RedisAuthTypeTextSecret(BaseModel):
    text_secret: Annotated[str, pydantic.Field(alias="textSecret")]
    r"""Secret that references Redis admin password"""

    commands: List[RedisAuthTypeTextSecretCommand]

    auth_type: Annotated[
        Optional[RedisAuthTypeTextSecretAuthenticationMethod],
        pydantic.Field(alias="authType"),
    ] = None

    deployment_type: Annotated[
        Optional[RedisAuthTypeTextSecretDeploymentType],
        pydantic.Field(alias="deploymentType"),
    ] = None
    r"""How the Redis server is configured. Defaults to Standalone"""

    max_block_secs: Annotated[Optional[float], pydantic.Field(alias="maxBlockSecs")] = (
        None
    )
    r"""Maximum amount of time (seconds) to wait before assuming that Redis is down and passing events through. Use 0 to disable."""

    enable_client_side_caching: Annotated[
        Optional[bool], pydantic.Field(alias="enableClientSideCaching")
    ] = None
    r"""Enable client-side cache. Redundant when using Redis write operations. See more options at Settings > General > Limits > Redis Cache."""

    @field_serializer("auth_type")
    def serialize_auth_type(self, value):
        if isinstance(value, str):
            try:
                return models.RedisAuthTypeTextSecretAuthenticationMethod(value)
            except ValueError:
                return value
        return value

    @field_serializer("deployment_type")
    def serialize_deployment_type(self, value):
        if isinstance(value, str):
            try:
                return models.RedisAuthTypeTextSecretDeploymentType(value)
            except ValueError:
                return value
        return value

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(
            ["authType", "deploymentType", "maxBlockSecs", "enableClientSideCaching"]
        )
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


class RedisAuthTypeCredentialsSecretAuthenticationMethod(
    str, Enum, metaclass=utils.OpenEnumMeta
):
    # None
    NONE = "none"
    # Manual
    MANUAL = "manual"
    # User Secret
    CREDENTIALS_SECRET = "credentialsSecret"
    # Admin Secret
    TEXT_SECRET = "textSecret"


class RedisAuthTypeCredentialsSecretCommandTypedDict(TypedDict):
    command: str
    r"""Redis command to perform. For a complete list visit: https://redis.io/commands"""
    key_expr: str
    r"""A JavaScript expression to compute the value of the key to operate on. Can also be a constant such as 'username'."""
    out_field: NotRequired[str]
    r"""Name of the field in which to store the returned value. Leave blank to discard returned value."""
    args_expr: NotRequired[str]
    r"""A JavaScript expression to compute arguments to the operation. Can return an array."""


class RedisAuthTypeCredentialsSecretCommand(BaseModel):
    command: str
    r"""Redis command to perform. For a complete list visit: https://redis.io/commands"""

    key_expr: Annotated[str, pydantic.Field(alias="keyExpr")]
    r"""A JavaScript expression to compute the value of the key to operate on. Can also be a constant such as 'username'."""

    out_field: Annotated[Optional[str], pydantic.Field(alias="outField")] = None
    r"""Name of the field in which to store the returned value. Leave blank to discard returned value."""

    args_expr: Annotated[Optional[str], pydantic.Field(alias="argsExpr")] = None
    r"""A JavaScript expression to compute arguments to the operation. Can return an array."""

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(["outField", "argsExpr"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


class RedisAuthTypeCredentialsSecretDeploymentType(
    str, Enum, metaclass=utils.OpenEnumMeta
):
    r"""How the Redis server is configured. Defaults to Standalone"""

    # Standalone
    STANDALONE = "standalone"
    # Cluster
    CLUSTER = "cluster"
    # Sentinel
    SENTINEL = "sentinel"


class RedisAuthTypeCredentialsSecretTypedDict(TypedDict):
    credentials_secret: str
    r"""Secret that references Redis username and password"""
    commands: List[RedisAuthTypeCredentialsSecretCommandTypedDict]
    auth_type: NotRequired[RedisAuthTypeCredentialsSecretAuthenticationMethod]
    deployment_type: NotRequired[RedisAuthTypeCredentialsSecretDeploymentType]
    r"""How the Redis server is configured. Defaults to Standalone"""
    max_block_secs: NotRequired[float]
    r"""Maximum amount of time (seconds) to wait before assuming that Redis is down and passing events through. Use 0 to disable."""
    enable_client_side_caching: NotRequired[bool]
    r"""Enable client-side cache. Redundant when using Redis write operations. See more options at Settings > General > Limits > Redis Cache."""


class RedisAuthTypeCredentialsSecret(BaseModel):
    credentials_secret: Annotated[str, pydantic.Field(alias="credentialsSecret")]
    r"""Secret that references Redis username and password"""

    commands: List[RedisAuthTypeCredentialsSecretCommand]

    auth_type: Annotated[
        Optional[RedisAuthTypeCredentialsSecretAuthenticationMethod],
        pydantic.Field(alias="authType"),
    ] = None

    deployment_type: Annotated[
        Optional[RedisAuthTypeCredentialsSecretDeploymentType],
        pydantic.Field(alias="deploymentType"),
    ] = None
    r"""How the Redis server is configured. Defaults to Standalone"""

    max_block_secs: Annotated[Optional[float], pydantic.Field(alias="maxBlockSecs")] = (
        None
    )
    r"""Maximum amount of time (seconds) to wait before assuming that Redis is down and passing events through. Use 0 to disable."""

    enable_client_side_caching: Annotated[
        Optional[bool], pydantic.Field(alias="enableClientSideCaching")
    ] = None
    r"""Enable client-side cache. Redundant when using Redis write operations. See more options at Settings > General > Limits > Redis Cache."""

    @field_serializer("auth_type")
    def serialize_auth_type(self, value):
        if isinstance(value, str):
            try:
                return models.RedisAuthTypeCredentialsSecretAuthenticationMethod(value)
            except ValueError:
                return value
        return value

    @field_serializer("deployment_type")
    def serialize_deployment_type(self, value):
        if isinstance(value, str):
            try:
                return models.RedisAuthTypeCredentialsSecretDeploymentType(value)
            except ValueError:
                return value
        return value

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(
            ["authType", "deploymentType", "maxBlockSecs", "enableClientSideCaching"]
        )
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


class RedisAuthTypeManualAuthenticationMethod(str, Enum, metaclass=utils.OpenEnumMeta):
    # None
    NONE = "none"
    # Manual
    MANUAL = "manual"
    # User Secret
    CREDENTIALS_SECRET = "credentialsSecret"
    # Admin Secret
    TEXT_SECRET = "textSecret"


class RedisAuthTypeManualCommandTypedDict(TypedDict):
    command: str
    r"""Redis command to perform. For a complete list visit: https://redis.io/commands"""
    key_expr: str
    r"""A JavaScript expression to compute the value of the key to operate on. Can also be a constant such as 'username'."""
    out_field: NotRequired[str]
    r"""Name of the field in which to store the returned value. Leave blank to discard returned value."""
    args_expr: NotRequired[str]
    r"""A JavaScript expression to compute arguments to the operation. Can return an array."""


class RedisAuthTypeManualCommand(BaseModel):
    command: str
    r"""Redis command to perform. For a complete list visit: https://redis.io/commands"""

    key_expr: Annotated[str, pydantic.Field(alias="keyExpr")]
    r"""A JavaScript expression to compute the value of the key to operate on. Can also be a constant such as 'username'."""

    out_field: Annotated[Optional[str], pydantic.Field(alias="outField")] = None
    r"""Name of the field in which to store the returned value. Leave blank to discard returned value."""

    args_expr: Annotated[Optional[str], pydantic.Field(alias="argsExpr")] = None
    r"""A JavaScript expression to compute arguments to the operation. Can return an array."""

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(["outField", "argsExpr"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


class RedisAuthTypeManualDeploymentType(str, Enum, metaclass=utils.OpenEnumMeta):
    r"""How the Redis server is configured. Defaults to Standalone"""

    # Standalone
    STANDALONE = "standalone"
    # Cluster
    CLUSTER = "cluster"
    # Sentinel
    SENTINEL = "sentinel"


class RedisAuthTypeManualTypedDict(TypedDict):
    password: str
    commands: List[RedisAuthTypeManualCommandTypedDict]
    auth_type: NotRequired[RedisAuthTypeManualAuthenticationMethod]
    username: NotRequired[str]
    deployment_type: NotRequired[RedisAuthTypeManualDeploymentType]
    r"""How the Redis server is configured. Defaults to Standalone"""
    max_block_secs: NotRequired[float]
    r"""Maximum amount of time (seconds) to wait before assuming that Redis is down and passing events through. Use 0 to disable."""
    enable_client_side_caching: NotRequired[bool]
    r"""Enable client-side cache. Redundant when using Redis write operations. See more options at Settings > General > Limits > Redis Cache."""


class RedisAuthTypeManual(BaseModel):
    password: str

    commands: List[RedisAuthTypeManualCommand]

    auth_type: Annotated[
        Optional[RedisAuthTypeManualAuthenticationMethod],
        pydantic.Field(alias="authType"),
    ] = None

    username: Optional[str] = None

    deployment_type: Annotated[
        Optional[RedisAuthTypeManualDeploymentType],
        pydantic.Field(alias="deploymentType"),
    ] = None
    r"""How the Redis server is configured. Defaults to Standalone"""

    max_block_secs: Annotated[Optional[float], pydantic.Field(alias="maxBlockSecs")] = (
        None
    )
    r"""Maximum amount of time (seconds) to wait before assuming that Redis is down and passing events through. Use 0 to disable."""

    enable_client_side_caching: Annotated[
        Optional[bool], pydantic.Field(alias="enableClientSideCaching")
    ] = None
    r"""Enable client-side cache. Redundant when using Redis write operations. See more options at Settings > General > Limits > Redis Cache."""

    @field_serializer("auth_type")
    def serialize_auth_type(self, value):
        if isinstance(value, str):
            try:
                return models.RedisAuthTypeManualAuthenticationMethod(value)
            except ValueError:
                return value
        return value

    @field_serializer("deployment_type")
    def serialize_deployment_type(self, value):
        if isinstance(value, str):
            try:
                return models.RedisAuthTypeManualDeploymentType(value)
            except ValueError:
                return value
        return value

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(
            [
                "authType",
                "username",
                "deploymentType",
                "maxBlockSecs",
                "enableClientSideCaching",
            ]
        )
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


class RedisAuthTypeNoneAuthenticationMethod(str, Enum, metaclass=utils.OpenEnumMeta):
    # None
    NONE = "none"
    # Manual
    MANUAL = "manual"
    # User Secret
    CREDENTIALS_SECRET = "credentialsSecret"
    # Admin Secret
    TEXT_SECRET = "textSecret"


class RedisAuthTypeNoneCommandTypedDict(TypedDict):
    command: str
    r"""Redis command to perform. For a complete list visit: https://redis.io/commands"""
    key_expr: str
    r"""A JavaScript expression to compute the value of the key to operate on. Can also be a constant such as 'username'."""
    out_field: NotRequired[str]
    r"""Name of the field in which to store the returned value. Leave blank to discard returned value."""
    args_expr: NotRequired[str]
    r"""A JavaScript expression to compute arguments to the operation. Can return an array."""


class RedisAuthTypeNoneCommand(BaseModel):
    command: str
    r"""Redis command to perform. For a complete list visit: https://redis.io/commands"""

    key_expr: Annotated[str, pydantic.Field(alias="keyExpr")]
    r"""A JavaScript expression to compute the value of the key to operate on. Can also be a constant such as 'username'."""

    out_field: Annotated[Optional[str], pydantic.Field(alias="outField")] = None
    r"""Name of the field in which to store the returned value. Leave blank to discard returned value."""

    args_expr: Annotated[Optional[str], pydantic.Field(alias="argsExpr")] = None
    r"""A JavaScript expression to compute arguments to the operation. Can return an array."""

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(["outField", "argsExpr"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


class RedisAuthTypeNoneDeploymentType(str, Enum, metaclass=utils.OpenEnumMeta):
    r"""How the Redis server is configured. Defaults to Standalone"""

    # Standalone
    STANDALONE = "standalone"
    # Cluster
    CLUSTER = "cluster"
    # Sentinel
    SENTINEL = "sentinel"


class RedisAuthTypeNoneTypedDict(TypedDict):
    commands: List[RedisAuthTypeNoneCommandTypedDict]
    auth_type: NotRequired[RedisAuthTypeNoneAuthenticationMethod]
    deployment_type: NotRequired[RedisAuthTypeNoneDeploymentType]
    r"""How the Redis server is configured. Defaults to Standalone"""
    max_block_secs: NotRequired[float]
    r"""Maximum amount of time (seconds) to wait before assuming that Redis is down and passing events through. Use 0 to disable."""
    enable_client_side_caching: NotRequired[bool]
    r"""Enable client-side cache. Redundant when using Redis write operations. See more options at Settings > General > Limits > Redis Cache."""


class RedisAuthTypeNone(BaseModel):
    commands: List[RedisAuthTypeNoneCommand]

    auth_type: Annotated[
        Optional[RedisAuthTypeNoneAuthenticationMethod],
        pydantic.Field(alias="authType"),
    ] = None

    deployment_type: Annotated[
        Optional[RedisAuthTypeNoneDeploymentType],
        pydantic.Field(alias="deploymentType"),
    ] = None
    r"""How the Redis server is configured. Defaults to Standalone"""

    max_block_secs: Annotated[Optional[float], pydantic.Field(alias="maxBlockSecs")] = (
        None
    )
    r"""Maximum amount of time (seconds) to wait before assuming that Redis is down and passing events through. Use 0 to disable."""

    enable_client_side_caching: Annotated[
        Optional[bool], pydantic.Field(alias="enableClientSideCaching")
    ] = None
    r"""Enable client-side cache. Redundant when using Redis write operations. See more options at Settings > General > Limits > Redis Cache."""

    @field_serializer("auth_type")
    def serialize_auth_type(self, value):
        if isinstance(value, str):
            try:
                return models.RedisAuthTypeNoneAuthenticationMethod(value)
            except ValueError:
                return value
        return value

    @field_serializer("deployment_type")
    def serialize_deployment_type(self, value):
        if isinstance(value, str):
            try:
                return models.RedisAuthTypeNoneDeploymentType(value)
            except ValueError:
                return value
        return value

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(
            ["authType", "deploymentType", "maxBlockSecs", "enableClientSideCaching"]
        )
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


class RedisDeploymentTypeSentinelTLSFalseDeploymentType(
    str, Enum, metaclass=utils.OpenEnumMeta
):
    r"""How the Redis server is configured. Defaults to Standalone"""

    # Standalone
    STANDALONE = "standalone"
    # Cluster
    CLUSTER = "cluster"
    # Sentinel
    SENTINEL = "sentinel"


class RedisDeploymentTypeSentinelTLSFalseRootNodeTypedDict(TypedDict):
    host: str
    r"""Hostname of sentinel node. Must be a JavaScript expression (which can evaluate to a constant value), enclosed in quotes or backticks. Can be evaluated only at init time. Example referencing a Global Variable: `myBucket-${C.vars.myVar}`."""
    port: float
    r"""Port of sentinel node"""


class RedisDeploymentTypeSentinelTLSFalseRootNode(BaseModel):
    host: str
    r"""Hostname of sentinel node. Must be a JavaScript expression (which can evaluate to a constant value), enclosed in quotes or backticks. Can be evaluated only at init time. Example referencing a Global Variable: `myBucket-${C.vars.myVar}`."""

    port: float
    r"""Port of sentinel node"""


class RedisDeploymentTypeSentinelTLSFalseCommandTypedDict(TypedDict):
    command: str
    r"""Redis command to perform. For a complete list visit: https://redis.io/commands"""
    key_expr: str
    r"""A JavaScript expression to compute the value of the key to operate on. Can also be a constant such as 'username'."""
    out_field: NotRequired[str]
    r"""Name of the field in which to store the returned value. Leave blank to discard returned value."""
    args_expr: NotRequired[str]
    r"""A JavaScript expression to compute arguments to the operation. Can return an array."""


class RedisDeploymentTypeSentinelTLSFalseCommand(BaseModel):
    command: str
    r"""Redis command to perform. For a complete list visit: https://redis.io/commands"""

    key_expr: Annotated[str, pydantic.Field(alias="keyExpr")]
    r"""A JavaScript expression to compute the value of the key to operate on. Can also be a constant such as 'username'."""

    out_field: Annotated[Optional[str], pydantic.Field(alias="outField")] = None
    r"""Name of the field in which to store the returned value. Leave blank to discard returned value."""

    args_expr: Annotated[Optional[str], pydantic.Field(alias="argsExpr")] = None
    r"""A JavaScript expression to compute arguments to the operation. Can return an array."""

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(["outField", "argsExpr"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


class RedisDeploymentTypeSentinelTLSFalseAuthenticationMethod(
    str, Enum, metaclass=utils.OpenEnumMeta
):
    # None
    NONE = "none"
    # Manual
    MANUAL = "manual"
    # User Secret
    CREDENTIALS_SECRET = "credentialsSecret"
    # Admin Secret
    TEXT_SECRET = "textSecret"


class RedisDeploymentTypeSentinelTLSFalseTypedDict(TypedDict):
    master_name: str
    commands: List[RedisDeploymentTypeSentinelTLSFalseCommandTypedDict]
    tls: NotRequired[bool]
    r"""Use TLS for connections to this cluster"""
    deployment_type: NotRequired[RedisDeploymentTypeSentinelTLSFalseDeploymentType]
    r"""How the Redis server is configured. Defaults to Standalone"""
    root_nodes: NotRequired[List[RedisDeploymentTypeSentinelTLSFalseRootNodeTypedDict]]
    r"""List of sentinels to be used"""
    auth_type: NotRequired[RedisDeploymentTypeSentinelTLSFalseAuthenticationMethod]
    max_block_secs: NotRequired[float]
    r"""Maximum amount of time (seconds) to wait before assuming that Redis is down and passing events through. Use 0 to disable."""
    enable_client_side_caching: NotRequired[bool]
    r"""Enable client-side cache. Redundant when using Redis write operations. See more options at Settings > General > Limits > Redis Cache."""


class RedisDeploymentTypeSentinelTLSFalse(BaseModel):
    master_name: Annotated[str, pydantic.Field(alias="masterName")]

    commands: List[RedisDeploymentTypeSentinelTLSFalseCommand]

    tls: Optional[bool] = None
    r"""Use TLS for connections to this cluster"""

    deployment_type: Annotated[
        Optional[RedisDeploymentTypeSentinelTLSFalseDeploymentType],
        pydantic.Field(alias="deploymentType"),
    ] = None
    r"""How the Redis server is configured. Defaults to Standalone"""

    root_nodes: Annotated[
        Optional[List[RedisDeploymentTypeSentinelTLSFalseRootNode]],
        pydantic.Field(alias="rootNodes"),
    ] = None
    r"""List of sentinels to be used"""

    auth_type: Annotated[
        Optional[RedisDeploymentTypeSentinelTLSFalseAuthenticationMethod],
        pydantic.Field(alias="authType"),
    ] = None

    max_block_secs: Annotated[Optional[float], pydantic.Field(alias="maxBlockSecs")] = (
        None
    )
    r"""Maximum amount of time (seconds) to wait before assuming that Redis is down and passing events through. Use 0 to disable."""

    enable_client_side_caching: Annotated[
        Optional[bool], pydantic.Field(alias="enableClientSideCaching")
    ] = None
    r"""Enable client-side cache. Redundant when using Redis write operations. See more options at Settings > General > Limits > Redis Cache."""

    @field_serializer("deployment_type")
    def serialize_deployment_type(self, value):
        if isinstance(value, str):
            try:
                return models.RedisDeploymentTypeSentinelTLSFalseDeploymentType(value)
            except ValueError:
                return value
        return value

    @field_serializer("auth_type")
    def serialize_auth_type(self, value):
        if isinstance(value, str):
            try:
                return models.RedisDeploymentTypeSentinelTLSFalseAuthenticationMethod(
                    value
                )
            except ValueError:
                return value
        return value

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(
            [
                "tls",
                "deploymentType",
                "rootNodes",
                "authType",
                "maxBlockSecs",
                "enableClientSideCaching",
            ]
        )
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


class RedisDeploymentTypeSentinelTLSTrueDeploymentType(
    str, Enum, metaclass=utils.OpenEnumMeta
):
    r"""How the Redis server is configured. Defaults to Standalone"""

    # Standalone
    STANDALONE = "standalone"
    # Cluster
    CLUSTER = "cluster"
    # Sentinel
    SENTINEL = "sentinel"


class RedisDeploymentTypeSentinelTLSTrueRootNodeTypedDict(TypedDict):
    host: str
    r"""Hostname of sentinel node. Must be a JavaScript expression (which can evaluate to a constant value), enclosed in quotes or backticks. Can be evaluated only at init time. Example referencing a Global Variable: `myBucket-${C.vars.myVar}`."""
    port: float
    r"""Port of sentinel node"""


class RedisDeploymentTypeSentinelTLSTrueRootNode(BaseModel):
    host: str
    r"""Hostname of sentinel node. Must be a JavaScript expression (which can evaluate to a constant value), enclosed in quotes or backticks. Can be evaluated only at init time. Example referencing a Global Variable: `myBucket-${C.vars.myVar}`."""

    port: float
    r"""Port of sentinel node"""


class RedisDeploymentTypeSentinelTLSTrueCommandTypedDict(TypedDict):
    command: str
    r"""Redis command to perform. For a complete list visit: https://redis.io/commands"""
    key_expr: str
    r"""A JavaScript expression to compute the value of the key to operate on. Can also be a constant such as 'username'."""
    out_field: NotRequired[str]
    r"""Name of the field in which to store the returned value. Leave blank to discard returned value."""
    args_expr: NotRequired[str]
    r"""A JavaScript expression to compute arguments to the operation. Can return an array."""


class RedisDeploymentTypeSentinelTLSTrueCommand(BaseModel):
    command: str
    r"""Redis command to perform. For a complete list visit: https://redis.io/commands"""

    key_expr: Annotated[str, pydantic.Field(alias="keyExpr")]
    r"""A JavaScript expression to compute the value of the key to operate on. Can also be a constant such as 'username'."""

    out_field: Annotated[Optional[str], pydantic.Field(alias="outField")] = None
    r"""Name of the field in which to store the returned value. Leave blank to discard returned value."""

    args_expr: Annotated[Optional[str], pydantic.Field(alias="argsExpr")] = None
    r"""A JavaScript expression to compute arguments to the operation. Can return an array."""

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(["outField", "argsExpr"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


class RedisDeploymentTypeSentinelTLSTrueAuthenticationMethod(
    str, Enum, metaclass=utils.OpenEnumMeta
):
    # None
    NONE = "none"
    # Manual
    MANUAL = "manual"
    # User Secret
    CREDENTIALS_SECRET = "credentialsSecret"
    # Admin Secret
    TEXT_SECRET = "textSecret"


class RedisDeploymentTypeSentinelTLSTrueTypedDict(TypedDict):
    master_name: str
    commands: List[RedisDeploymentTypeSentinelTLSTrueCommandTypedDict]
    tls: NotRequired[bool]
    r"""Use TLS for connections to this cluster"""
    tls_options: NotRequired[TLSOptionsTypeRedisDeploymentTypeClusterTLSTrueTypedDict]
    deployment_type: NotRequired[RedisDeploymentTypeSentinelTLSTrueDeploymentType]
    r"""How the Redis server is configured. Defaults to Standalone"""
    root_nodes: NotRequired[List[RedisDeploymentTypeSentinelTLSTrueRootNodeTypedDict]]
    r"""List of sentinels to be used"""
    auth_type: NotRequired[RedisDeploymentTypeSentinelTLSTrueAuthenticationMethod]
    max_block_secs: NotRequired[float]
    r"""Maximum amount of time (seconds) to wait before assuming that Redis is down and passing events through. Use 0 to disable."""
    enable_client_side_caching: NotRequired[bool]
    r"""Enable client-side cache. Redundant when using Redis write operations. See more options at Settings > General > Limits > Redis Cache."""


class RedisDeploymentTypeSentinelTLSTrue(BaseModel):
    master_name: Annotated[str, pydantic.Field(alias="masterName")]

    commands: List[RedisDeploymentTypeSentinelTLSTrueCommand]

    tls: Optional[bool] = None
    r"""Use TLS for connections to this cluster"""

    tls_options: Annotated[
        Optional[TLSOptionsTypeRedisDeploymentTypeClusterTLSTrue],
        pydantic.Field(alias="tlsOptions"),
    ] = None

    deployment_type: Annotated[
        Optional[RedisDeploymentTypeSentinelTLSTrueDeploymentType],
        pydantic.Field(alias="deploymentType"),
    ] = None
    r"""How the Redis server is configured. Defaults to Standalone"""

    root_nodes: Annotated[
        Optional[List[RedisDeploymentTypeSentinelTLSTrueRootNode]],
        pydantic.Field(alias="rootNodes"),
    ] = None
    r"""List of sentinels to be used"""

    auth_type: Annotated[
        Optional[RedisDeploymentTypeSentinelTLSTrueAuthenticationMethod],
        pydantic.Field(alias="authType"),
    ] = None

    max_block_secs: Annotated[Optional[float], pydantic.Field(alias="maxBlockSecs")] = (
        None
    )
    r"""Maximum amount of time (seconds) to wait before assuming that Redis is down and passing events through. Use 0 to disable."""

    enable_client_side_caching: Annotated[
        Optional[bool], pydantic.Field(alias="enableClientSideCaching")
    ] = None
    r"""Enable client-side cache. Redundant when using Redis write operations. See more options at Settings > General > Limits > Redis Cache."""

    @field_serializer("deployment_type")
    def serialize_deployment_type(self, value):
        if isinstance(value, str):
            try:
                return models.RedisDeploymentTypeSentinelTLSTrueDeploymentType(value)
            except ValueError:
                return value
        return value

    @field_serializer("auth_type")
    def serialize_auth_type(self, value):
        if isinstance(value, str):
            try:
                return models.RedisDeploymentTypeSentinelTLSTrueAuthenticationMethod(
                    value
                )
            except ValueError:
                return value
        return value

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(
            [
                "tls",
                "tlsOptions",
                "deploymentType",
                "rootNodes",
                "authType",
                "maxBlockSecs",
                "enableClientSideCaching",
            ]
        )
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


RedisDeploymentTypeSentinelTypedDict = TypeAliasType(
    "RedisDeploymentTypeSentinelTypedDict",
    Union[
        RedisDeploymentTypeSentinelTLSFalseTypedDict,
        RedisDeploymentTypeSentinelTLSTrueTypedDict,
    ],
)


RedisDeploymentTypeSentinel = TypeAliasType(
    "RedisDeploymentTypeSentinel",
    Union[RedisDeploymentTypeSentinelTLSFalse, RedisDeploymentTypeSentinelTLSTrue],
)


class RedisDeploymentTypeClusterTLSFalseDeploymentType(
    str, Enum, metaclass=utils.OpenEnumMeta
):
    r"""How the Redis server is configured. Defaults to Standalone"""

    # Standalone
    STANDALONE = "standalone"
    # Cluster
    CLUSTER = "cluster"
    # Sentinel
    SENTINEL = "sentinel"


class RedisDeploymentTypeClusterTLSFalseRootNodeTypedDict(TypedDict):
    host: str
    r"""Hostname of cluster node. Must be a JavaScript expression (which can evaluate to a constant value), enclosed in quotes or backticks. Can be evaluated only at init time. Example referencing a Global Variable: `myBucket-${C.vars.myVar}`."""
    port: float
    r"""Port of cluster node"""


class RedisDeploymentTypeClusterTLSFalseRootNode(BaseModel):
    host: str
    r"""Hostname of cluster node. Must be a JavaScript expression (which can evaluate to a constant value), enclosed in quotes or backticks. Can be evaluated only at init time. Example referencing a Global Variable: `myBucket-${C.vars.myVar}`."""

    port: float
    r"""Port of cluster node"""


class RedisDeploymentTypeClusterTLSFalseScaleReads(
    str, Enum, metaclass=utils.OpenEnumMeta
):
    r"""Which nodes read commands should be sent to"""

    # Masters
    MASTER = "master"
    # Replicas
    REPLICA = "replica"
    # Masters and Replicas
    ALL = "all"


class RedisDeploymentTypeClusterTLSFalseCommandTypedDict(TypedDict):
    command: str
    r"""Redis command to perform. For a complete list visit: https://redis.io/commands"""
    key_expr: str
    r"""A JavaScript expression to compute the value of the key to operate on. Can also be a constant such as 'username'."""
    out_field: NotRequired[str]
    r"""Name of the field in which to store the returned value. Leave blank to discard returned value."""
    args_expr: NotRequired[str]
    r"""A JavaScript expression to compute arguments to the operation. Can return an array."""


class RedisDeploymentTypeClusterTLSFalseCommand(BaseModel):
    command: str
    r"""Redis command to perform. For a complete list visit: https://redis.io/commands"""

    key_expr: Annotated[str, pydantic.Field(alias="keyExpr")]
    r"""A JavaScript expression to compute the value of the key to operate on. Can also be a constant such as 'username'."""

    out_field: Annotated[Optional[str], pydantic.Field(alias="outField")] = None
    r"""Name of the field in which to store the returned value. Leave blank to discard returned value."""

    args_expr: Annotated[Optional[str], pydantic.Field(alias="argsExpr")] = None
    r"""A JavaScript expression to compute arguments to the operation. Can return an array."""

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(["outField", "argsExpr"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


class RedisDeploymentTypeClusterTLSFalseAuthenticationMethod(
    str, Enum, metaclass=utils.OpenEnumMeta
):
    # None
    NONE = "none"
    # Manual
    MANUAL = "manual"
    # User Secret
    CREDENTIALS_SECRET = "credentialsSecret"
    # Admin Secret
    TEXT_SECRET = "textSecret"


class RedisDeploymentTypeClusterTLSFalseTypedDict(TypedDict):
    commands: List[RedisDeploymentTypeClusterTLSFalseCommandTypedDict]
    tls: NotRequired[bool]
    r"""Use TLS for connections to this cluster"""
    deployment_type: NotRequired[RedisDeploymentTypeClusterTLSFalseDeploymentType]
    r"""How the Redis server is configured. Defaults to Standalone"""
    root_nodes: NotRequired[List[RedisDeploymentTypeClusterTLSFalseRootNodeTypedDict]]
    r"""Root nodes to which the cluster connection should be initiated"""
    scale_reads: NotRequired[RedisDeploymentTypeClusterTLSFalseScaleReads]
    r"""Which nodes read commands should be sent to"""
    auth_type: NotRequired[RedisDeploymentTypeClusterTLSFalseAuthenticationMethod]
    max_block_secs: NotRequired[float]
    r"""Maximum amount of time (seconds) to wait before assuming that Redis is down and passing events through. Use 0 to disable."""
    enable_client_side_caching: NotRequired[bool]
    r"""Enable client-side cache. Redundant when using Redis write operations. See more options at Settings > General > Limits > Redis Cache."""


class RedisDeploymentTypeClusterTLSFalse(BaseModel):
    commands: List[RedisDeploymentTypeClusterTLSFalseCommand]

    tls: Optional[bool] = None
    r"""Use TLS for connections to this cluster"""

    deployment_type: Annotated[
        Optional[RedisDeploymentTypeClusterTLSFalseDeploymentType],
        pydantic.Field(alias="deploymentType"),
    ] = None
    r"""How the Redis server is configured. Defaults to Standalone"""

    root_nodes: Annotated[
        Optional[List[RedisDeploymentTypeClusterTLSFalseRootNode]],
        pydantic.Field(alias="rootNodes"),
    ] = None
    r"""Root nodes to which the cluster connection should be initiated"""

    scale_reads: Annotated[
        Optional[RedisDeploymentTypeClusterTLSFalseScaleReads],
        pydantic.Field(alias="scaleReads"),
    ] = None
    r"""Which nodes read commands should be sent to"""

    auth_type: Annotated[
        Optional[RedisDeploymentTypeClusterTLSFalseAuthenticationMethod],
        pydantic.Field(alias="authType"),
    ] = None

    max_block_secs: Annotated[Optional[float], pydantic.Field(alias="maxBlockSecs")] = (
        None
    )
    r"""Maximum amount of time (seconds) to wait before assuming that Redis is down and passing events through. Use 0 to disable."""

    enable_client_side_caching: Annotated[
        Optional[bool], pydantic.Field(alias="enableClientSideCaching")
    ] = None
    r"""Enable client-side cache. Redundant when using Redis write operations. See more options at Settings > General > Limits > Redis Cache."""

    @field_serializer("deployment_type")
    def serialize_deployment_type(self, value):
        if isinstance(value, str):
            try:
                return models.RedisDeploymentTypeClusterTLSFalseDeploymentType(value)
            except ValueError:
                return value
        return value

    @field_serializer("scale_reads")
    def serialize_scale_reads(self, value):
        if isinstance(value, str):
            try:
                return models.RedisDeploymentTypeClusterTLSFalseScaleReads(value)
            except ValueError:
                return value
        return value

    @field_serializer("auth_type")
    def serialize_auth_type(self, value):
        if isinstance(value, str):
            try:
                return models.RedisDeploymentTypeClusterTLSFalseAuthenticationMethod(
                    value
                )
            except ValueError:
                return value
        return value

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(
            [
                "tls",
                "deploymentType",
                "rootNodes",
                "scaleReads",
                "authType",
                "maxBlockSecs",
                "enableClientSideCaching",
            ]
        )
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


class RedisDeploymentTypeClusterTLSTrueDeploymentType(
    str, Enum, metaclass=utils.OpenEnumMeta
):
    r"""How the Redis server is configured. Defaults to Standalone"""

    # Standalone
    STANDALONE = "standalone"
    # Cluster
    CLUSTER = "cluster"
    # Sentinel
    SENTINEL = "sentinel"


class RedisDeploymentTypeClusterTLSTrueRootNodeTypedDict(TypedDict):
    host: str
    r"""Hostname of cluster node. Must be a JavaScript expression (which can evaluate to a constant value), enclosed in quotes or backticks. Can be evaluated only at init time. Example referencing a Global Variable: `myBucket-${C.vars.myVar}`."""
    port: float
    r"""Port of cluster node"""


class RedisDeploymentTypeClusterTLSTrueRootNode(BaseModel):
    host: str
    r"""Hostname of cluster node. Must be a JavaScript expression (which can evaluate to a constant value), enclosed in quotes or backticks. Can be evaluated only at init time. Example referencing a Global Variable: `myBucket-${C.vars.myVar}`."""

    port: float
    r"""Port of cluster node"""


class RedisDeploymentTypeClusterTLSTrueScaleReads(
    str, Enum, metaclass=utils.OpenEnumMeta
):
    r"""Which nodes read commands should be sent to"""

    # Masters
    MASTER = "master"
    # Replicas
    REPLICA = "replica"
    # Masters and Replicas
    ALL = "all"


class RedisDeploymentTypeClusterTLSTrueCommandTypedDict(TypedDict):
    command: str
    r"""Redis command to perform. For a complete list visit: https://redis.io/commands"""
    key_expr: str
    r"""A JavaScript expression to compute the value of the key to operate on. Can also be a constant such as 'username'."""
    out_field: NotRequired[str]
    r"""Name of the field in which to store the returned value. Leave blank to discard returned value."""
    args_expr: NotRequired[str]
    r"""A JavaScript expression to compute arguments to the operation. Can return an array."""


class RedisDeploymentTypeClusterTLSTrueCommand(BaseModel):
    command: str
    r"""Redis command to perform. For a complete list visit: https://redis.io/commands"""

    key_expr: Annotated[str, pydantic.Field(alias="keyExpr")]
    r"""A JavaScript expression to compute the value of the key to operate on. Can also be a constant such as 'username'."""

    out_field: Annotated[Optional[str], pydantic.Field(alias="outField")] = None
    r"""Name of the field in which to store the returned value. Leave blank to discard returned value."""

    args_expr: Annotated[Optional[str], pydantic.Field(alias="argsExpr")] = None
    r"""A JavaScript expression to compute arguments to the operation. Can return an array."""

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(["outField", "argsExpr"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


class RedisDeploymentTypeClusterTLSTrueAuthenticationMethod(
    str, Enum, metaclass=utils.OpenEnumMeta
):
    # None
    NONE = "none"
    # Manual
    MANUAL = "manual"
    # User Secret
    CREDENTIALS_SECRET = "credentialsSecret"
    # Admin Secret
    TEXT_SECRET = "textSecret"


class RedisDeploymentTypeClusterTLSTrueTypedDict(TypedDict):
    commands: List[RedisDeploymentTypeClusterTLSTrueCommandTypedDict]
    tls: NotRequired[bool]
    r"""Use TLS for connections to this cluster"""
    tls_options: NotRequired[TLSOptionsTypeRedisDeploymentTypeClusterTLSTrueTypedDict]
    deployment_type: NotRequired[RedisDeploymentTypeClusterTLSTrueDeploymentType]
    r"""How the Redis server is configured. Defaults to Standalone"""
    root_nodes: NotRequired[List[RedisDeploymentTypeClusterTLSTrueRootNodeTypedDict]]
    r"""Root nodes to which the cluster connection should be initiated"""
    scale_reads: NotRequired[RedisDeploymentTypeClusterTLSTrueScaleReads]
    r"""Which nodes read commands should be sent to"""
    auth_type: NotRequired[RedisDeploymentTypeClusterTLSTrueAuthenticationMethod]
    max_block_secs: NotRequired[float]
    r"""Maximum amount of time (seconds) to wait before assuming that Redis is down and passing events through. Use 0 to disable."""
    enable_client_side_caching: NotRequired[bool]
    r"""Enable client-side cache. Redundant when using Redis write operations. See more options at Settings > General > Limits > Redis Cache."""


class RedisDeploymentTypeClusterTLSTrue(BaseModel):
    commands: List[RedisDeploymentTypeClusterTLSTrueCommand]

    tls: Optional[bool] = None
    r"""Use TLS for connections to this cluster"""

    tls_options: Annotated[
        Optional[TLSOptionsTypeRedisDeploymentTypeClusterTLSTrue],
        pydantic.Field(alias="tlsOptions"),
    ] = None

    deployment_type: Annotated[
        Optional[RedisDeploymentTypeClusterTLSTrueDeploymentType],
        pydantic.Field(alias="deploymentType"),
    ] = None
    r"""How the Redis server is configured. Defaults to Standalone"""

    root_nodes: Annotated[
        Optional[List[RedisDeploymentTypeClusterTLSTrueRootNode]],
        pydantic.Field(alias="rootNodes"),
    ] = None
    r"""Root nodes to which the cluster connection should be initiated"""

    scale_reads: Annotated[
        Optional[RedisDeploymentTypeClusterTLSTrueScaleReads],
        pydantic.Field(alias="scaleReads"),
    ] = None
    r"""Which nodes read commands should be sent to"""

    auth_type: Annotated[
        Optional[RedisDeploymentTypeClusterTLSTrueAuthenticationMethod],
        pydantic.Field(alias="authType"),
    ] = None

    max_block_secs: Annotated[Optional[float], pydantic.Field(alias="maxBlockSecs")] = (
        None
    )
    r"""Maximum amount of time (seconds) to wait before assuming that Redis is down and passing events through. Use 0 to disable."""

    enable_client_side_caching: Annotated[
        Optional[bool], pydantic.Field(alias="enableClientSideCaching")
    ] = None
    r"""Enable client-side cache. Redundant when using Redis write operations. See more options at Settings > General > Limits > Redis Cache."""

    @field_serializer("deployment_type")
    def serialize_deployment_type(self, value):
        if isinstance(value, str):
            try:
                return models.RedisDeploymentTypeClusterTLSTrueDeploymentType(value)
            except ValueError:
                return value
        return value

    @field_serializer("scale_reads")
    def serialize_scale_reads(self, value):
        if isinstance(value, str):
            try:
                return models.RedisDeploymentTypeClusterTLSTrueScaleReads(value)
            except ValueError:
                return value
        return value

    @field_serializer("auth_type")
    def serialize_auth_type(self, value):
        if isinstance(value, str):
            try:
                return models.RedisDeploymentTypeClusterTLSTrueAuthenticationMethod(
                    value
                )
            except ValueError:
                return value
        return value

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(
            [
                "tls",
                "tlsOptions",
                "deploymentType",
                "rootNodes",
                "scaleReads",
                "authType",
                "maxBlockSecs",
                "enableClientSideCaching",
            ]
        )
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


RedisDeploymentTypeClusterTypedDict = TypeAliasType(
    "RedisDeploymentTypeClusterTypedDict",
    Union[
        RedisDeploymentTypeClusterTLSFalseTypedDict,
        RedisDeploymentTypeClusterTLSTrueTypedDict,
    ],
)


RedisDeploymentTypeCluster = TypeAliasType(
    "RedisDeploymentTypeCluster",
    Union[RedisDeploymentTypeClusterTLSFalse, RedisDeploymentTypeClusterTLSTrue],
)


class RedisDeploymentTypeStandaloneDeploymentType(
    str, Enum, metaclass=utils.OpenEnumMeta
):
    r"""How the Redis server is configured. Defaults to Standalone"""

    # Standalone
    STANDALONE = "standalone"
    # Cluster
    CLUSTER = "cluster"
    # Sentinel
    SENTINEL = "sentinel"


class TLSOptionsTypedDict(TypedDict):
    reject_unauthorized: NotRequired[bool]
    r"""Reject certificates that are not authorized by a CA in the 'CA certificate path', or by another trusted CA (such as the system's CA)"""
    servername: NotRequired[str]
    r"""Server name for the SNI (Server Name Indication) TLS extension. Must be a host name, not an IP address."""
    certificate_name: NotRequired[str]
    r"""The name of the predefined certificate"""
    ca_path: NotRequired[str]
    r"""Path on client in which to find CA certificates to verify the server's certificate. PEM format. Can reference $ENV_VARS."""
    priv_key_path: NotRequired[str]
    r"""Path on client in which to find the private key to use. PEM format. Can reference $ENV_VARS."""
    cert_path: NotRequired[str]
    r"""Path on client in which to find certificates to use. PEM format. Can reference $ENV_VARS."""
    passphrase: NotRequired[str]
    r"""Passphrase to use to decrypt private key"""
    min_version: NotRequired[
        MinimumTLSVersionOptionsRedisDeploymentTypeStandaloneTLSOptions
    ]
    r"""Minimum TLS version to use when connecting"""
    max_version: NotRequired[
        MaximumTLSVersionOptionsRedisDeploymentTypeStandaloneTLSOptions
    ]
    r"""Maximum TLS version to use when connecting"""


class TLSOptions(BaseModel):
    reject_unauthorized: Annotated[
        Optional[bool], pydantic.Field(alias="rejectUnauthorized")
    ] = None
    r"""Reject certificates that are not authorized by a CA in the 'CA certificate path', or by another trusted CA (such as the system's CA)"""

    servername: Optional[str] = None
    r"""Server name for the SNI (Server Name Indication) TLS extension. Must be a host name, not an IP address."""

    certificate_name: Annotated[
        Optional[str], pydantic.Field(alias="certificateName")
    ] = None
    r"""The name of the predefined certificate"""

    ca_path: Annotated[Optional[str], pydantic.Field(alias="caPath")] = None
    r"""Path on client in which to find CA certificates to verify the server's certificate. PEM format. Can reference $ENV_VARS."""

    priv_key_path: Annotated[Optional[str], pydantic.Field(alias="privKeyPath")] = None
    r"""Path on client in which to find the private key to use. PEM format. Can reference $ENV_VARS."""

    cert_path: Annotated[Optional[str], pydantic.Field(alias="certPath")] = None
    r"""Path on client in which to find certificates to use. PEM format. Can reference $ENV_VARS."""

    passphrase: Optional[str] = None
    r"""Passphrase to use to decrypt private key"""

    min_version: Annotated[
        Optional[MinimumTLSVersionOptionsRedisDeploymentTypeStandaloneTLSOptions],
        pydantic.Field(alias="minVersion"),
    ] = None
    r"""Minimum TLS version to use when connecting"""

    max_version: Annotated[
        Optional[MaximumTLSVersionOptionsRedisDeploymentTypeStandaloneTLSOptions],
        pydantic.Field(alias="maxVersion"),
    ] = None
    r"""Maximum TLS version to use when connecting"""

    @field_serializer("min_version")
    def serialize_min_version(self, value):
        if isinstance(value, str):
            try:
                return models.MinimumTLSVersionOptionsRedisDeploymentTypeStandaloneTLSOptions(
                    value
                )
            except ValueError:
                return value
        return value

    @field_serializer("max_version")
    def serialize_max_version(self, value):
        if isinstance(value, str):
            try:
                return models.MaximumTLSVersionOptionsRedisDeploymentTypeStandaloneTLSOptions(
                    value
                )
            except ValueError:
                return value
        return value

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(
            [
                "rejectUnauthorized",
                "servername",
                "certificateName",
                "caPath",
                "privKeyPath",
                "certPath",
                "passphrase",
                "minVersion",
                "maxVersion",
            ]
        )
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


class RedisDeploymentTypeStandaloneCommandTypedDict(TypedDict):
    command: str
    r"""Redis command to perform. For a complete list visit: https://redis.io/commands"""
    key_expr: str
    r"""A JavaScript expression to compute the value of the key to operate on. Can also be a constant such as 'username'."""
    out_field: NotRequired[str]
    r"""Name of the field in which to store the returned value. Leave blank to discard returned value."""
    args_expr: NotRequired[str]
    r"""A JavaScript expression to compute arguments to the operation. Can return an array."""


class RedisDeploymentTypeStandaloneCommand(BaseModel):
    command: str
    r"""Redis command to perform. For a complete list visit: https://redis.io/commands"""

    key_expr: Annotated[str, pydantic.Field(alias="keyExpr")]
    r"""A JavaScript expression to compute the value of the key to operate on. Can also be a constant such as 'username'."""

    out_field: Annotated[Optional[str], pydantic.Field(alias="outField")] = None
    r"""Name of the field in which to store the returned value. Leave blank to discard returned value."""

    args_expr: Annotated[Optional[str], pydantic.Field(alias="argsExpr")] = None
    r"""A JavaScript expression to compute arguments to the operation. Can return an array."""

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(["outField", "argsExpr"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


class RedisDeploymentTypeStandaloneAuthenticationMethod(
    str, Enum, metaclass=utils.OpenEnumMeta
):
    # None
    NONE = "none"
    # Manual
    MANUAL = "manual"
    # User Secret
    CREDENTIALS_SECRET = "credentialsSecret"
    # Admin Secret
    TEXT_SECRET = "textSecret"


class RedisDeploymentTypeStandaloneTypedDict(TypedDict):
    url: str
    r"""Redis URL to connect to. Format: redis[s]://[[user][:password@]][host][:port][/db-number][?db=db-number[&password=bar[&option=value]]]. Must be a JavaScript expression (which can evaluate to a constant value), enclosed in quotes or backticks. Can be evaluated only at init time. Example referencing a Global Variable: `myBucket-${C.vars.myVar}`"""
    commands: List[RedisDeploymentTypeStandaloneCommandTypedDict]
    deployment_type: NotRequired[RedisDeploymentTypeStandaloneDeploymentType]
    r"""How the Redis server is configured. Defaults to Standalone"""
    tls_options: NotRequired[TLSOptionsTypedDict]
    auth_type: NotRequired[RedisDeploymentTypeStandaloneAuthenticationMethod]
    max_block_secs: NotRequired[float]
    r"""Maximum amount of time (seconds) to wait before assuming that Redis is down and passing events through. Use 0 to disable."""
    enable_client_side_caching: NotRequired[bool]
    r"""Enable client-side cache. Redundant when using Redis write operations. See more options at Settings > General > Limits > Redis Cache."""


class RedisDeploymentTypeStandalone(BaseModel):
    url: str
    r"""Redis URL to connect to. Format: redis[s]://[[user][:password@]][host][:port][/db-number][?db=db-number[&password=bar[&option=value]]]. Must be a JavaScript expression (which can evaluate to a constant value), enclosed in quotes or backticks. Can be evaluated only at init time. Example referencing a Global Variable: `myBucket-${C.vars.myVar}`"""

    commands: List[RedisDeploymentTypeStandaloneCommand]

    deployment_type: Annotated[
        Optional[RedisDeploymentTypeStandaloneDeploymentType],
        pydantic.Field(alias="deploymentType"),
    ] = None
    r"""How the Redis server is configured. Defaults to Standalone"""

    tls_options: Annotated[Optional[TLSOptions], pydantic.Field(alias="tlsOptions")] = (
        None
    )

    auth_type: Annotated[
        Optional[RedisDeploymentTypeStandaloneAuthenticationMethod],
        pydantic.Field(alias="authType"),
    ] = None

    max_block_secs: Annotated[Optional[float], pydantic.Field(alias="maxBlockSecs")] = (
        None
    )
    r"""Maximum amount of time (seconds) to wait before assuming that Redis is down and passing events through. Use 0 to disable."""

    enable_client_side_caching: Annotated[
        Optional[bool], pydantic.Field(alias="enableClientSideCaching")
    ] = None
    r"""Enable client-side cache. Redundant when using Redis write operations. See more options at Settings > General > Limits > Redis Cache."""

    @field_serializer("deployment_type")
    def serialize_deployment_type(self, value):
        if isinstance(value, str):
            try:
                return models.RedisDeploymentTypeStandaloneDeploymentType(value)
            except ValueError:
                return value
        return value

    @field_serializer("auth_type")
    def serialize_auth_type(self, value):
        if isinstance(value, str):
            try:
                return models.RedisDeploymentTypeStandaloneAuthenticationMethod(value)
            except ValueError:
                return value
        return value

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(
            [
                "deploymentType",
                "tlsOptions",
                "authType",
                "maxBlockSecs",
                "enableClientSideCaching",
            ]
        )
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


PipelineFunctionRedisConfTypedDict = TypeAliasType(
    "PipelineFunctionRedisConfTypedDict",
    Union[
        RedisAuthTypeNoneTypedDict,
        RedisAuthTypeCredentialsSecretTypedDict,
        RedisAuthTypeTextSecretTypedDict,
        RedisDeploymentTypeStandaloneTypedDict,
        RedisAuthTypeManualTypedDict,
        RedisDeploymentTypeClusterTypedDict,
        RedisDeploymentTypeSentinelTypedDict,
    ],
)


class UnknownPipelineFunctionRedisConf(BaseModel):
    r"""A PipelineFunctionRedisConf variant the SDK doesn't recognize. Preserves the raw payload."""

    auth_type: Literal["UNKNOWN"] = "UNKNOWN"
    raw: Any
    is_unknown: Literal[True] = True

    model_config = ConfigDict(frozen=True)


_PIPELINE_FUNCTION_REDIS_CONF_VARIANTS: dict[str, Any] = {
    "none": RedisAuthTypeNone,
    "manual": RedisAuthTypeManual,
    "credentialsSecret": RedisAuthTypeCredentialsSecret,
    "textSecret": RedisAuthTypeTextSecret,
}


PipelineFunctionRedisConf = Annotated[
    Union[
        RedisAuthTypeNone,
        RedisAuthTypeManual,
        RedisAuthTypeCredentialsSecret,
        RedisAuthTypeTextSecret,
        UnknownPipelineFunctionRedisConf,
    ],
    BeforeValidator(
        partial(
            parse_open_union,
            disc_key="authType",
            variants=_PIPELINE_FUNCTION_REDIS_CONF_VARIANTS,
            unknown_cls=UnknownPipelineFunctionRedisConf,
            union_name="PipelineFunctionRedisConf",
        )
    ),
]


class PipelineFunctionRedisTypedDict(TypedDict):
    id: PipelineFunctionRedisID
    r"""Function ID"""
    conf: PipelineFunctionRedisConfTypedDict
    filter_: NotRequired[str]
    r"""Filter that selects data to be fed through this Function"""
    description: NotRequired[str]
    r"""Simple description of this step"""
    disabled: NotRequired[bool]
    r"""If true, data will not be pushed through this function"""
    final: NotRequired[bool]
    r"""If enabled, stops the results of this Function from being passed to the downstream Functions"""
    group_id: NotRequired[str]
    r"""Group ID"""


class PipelineFunctionRedis(BaseModel):
    id: PipelineFunctionRedisID
    r"""Function ID"""

    conf: PipelineFunctionRedisConf

    filter_: Annotated[Optional[str], pydantic.Field(alias="filter")] = None
    r"""Filter that selects data to be fed through this Function"""

    description: Optional[str] = None
    r"""Simple description of this step"""

    disabled: Optional[bool] = None
    r"""If true, data will not be pushed through this function"""

    final: Optional[bool] = None
    r"""If enabled, stops the results of this Function from being passed to the downstream Functions"""

    group_id: Annotated[Optional[str], pydantic.Field(alias="groupId")] = None
    r"""Group ID"""

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(["filter", "description", "disabled", "final", "groupId"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


try:
    RedisAuthTypeTextSecretCommand.model_rebuild()
except NameError:
    pass
try:
    RedisAuthTypeTextSecret.model_rebuild()
except NameError:
    pass
try:
    RedisAuthTypeCredentialsSecretCommand.model_rebuild()
except NameError:
    pass
try:
    RedisAuthTypeCredentialsSecret.model_rebuild()
except NameError:
    pass
try:
    RedisAuthTypeManualCommand.model_rebuild()
except NameError:
    pass
try:
    RedisAuthTypeManual.model_rebuild()
except NameError:
    pass
try:
    RedisAuthTypeNoneCommand.model_rebuild()
except NameError:
    pass
try:
    RedisAuthTypeNone.model_rebuild()
except NameError:
    pass
try:
    RedisDeploymentTypeSentinelTLSFalseCommand.model_rebuild()
except NameError:
    pass
try:
    RedisDeploymentTypeSentinelTLSFalse.model_rebuild()
except NameError:
    pass
try:
    RedisDeploymentTypeSentinelTLSTrueCommand.model_rebuild()
except NameError:
    pass
try:
    RedisDeploymentTypeSentinelTLSTrue.model_rebuild()
except NameError:
    pass
try:
    RedisDeploymentTypeClusterTLSFalseCommand.model_rebuild()
except NameError:
    pass
try:
    RedisDeploymentTypeClusterTLSFalse.model_rebuild()
except NameError:
    pass
try:
    RedisDeploymentTypeClusterTLSTrueCommand.model_rebuild()
except NameError:
    pass
try:
    RedisDeploymentTypeClusterTLSTrue.model_rebuild()
except NameError:
    pass
try:
    TLSOptions.model_rebuild()
except NameError:
    pass
try:
    RedisDeploymentTypeStandaloneCommand.model_rebuild()
except NameError:
    pass
try:
    RedisDeploymentTypeStandalone.model_rebuild()
except NameError:
    pass
try:
    PipelineFunctionRedis.model_rebuild()
except NameError:
    pass
