"""Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT."""

from __future__ import annotations
from .itemstyperestcollectmethodgetcollectrequestparams import (
    ItemsTypeRestCollectMethodGetCollectRequestParams,
    ItemsTypeRestCollectMethodGetCollectRequestParamsTypedDict,
)
from .paginationoptionsrestdiscoverydiscovertypehttppagination import (
    PaginationOptionsRestDiscoveryDiscoverTypeHTTPPagination,
)
from .restauthenticationlogingetauthtokenfromheadertrue_restdiscoverydiscovertypehttpenablediscovercodefalse_discover_method import (
    RestAuthenticationLoginGetAuthTokenFromHeaderTrueAuthentication,
    RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHTTPDiscoverMethodGet,
    RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHTTPDiscoverMethodGetTypedDict,
    RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHTTPDiscoverMethodOther,
    RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHTTPDiscoverMethodOtherTypedDict,
    RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHTTPDiscoverMethodPost,
    RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHTTPDiscoverMethodPostTypedDict,
    RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHTTPDiscoverMethodPostWithBody,
    RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHTTPDiscoverMethodPostWithBodyTypedDict,
    RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHTTPEnableDiscoverCodeFalseDiscoverMethod,
    RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHTTPEnableDiscoverCodeFalseDiscoverType,
    RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHTTPEnableDiscoverCodeTrueTypedDict,
    RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeJSON,
    RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeJSONTypedDict,
    RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeList,
    RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeListTypedDict,
    RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeNone,
    RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeNoneTypedDict,
)
from .retrytypeoptionshealthcheckcollectorconfretryrules import (
    RetryTypeOptionsHealthCheckCollectorConfRetryRules,
)
from cribl_control_plane import models, utils
from cribl_control_plane.types import BaseModel, UNSET_SENTINEL
from cribl_control_plane.utils.unions import parse_open_union
from enum import Enum
from functools import partial
import pydantic
from pydantic import ConfigDict, field_serializer, model_serializer
from pydantic.functional_validators import BeforeValidator
from typing import Any, List, Literal, Optional, Union
from typing_extensions import Annotated, NotRequired, TypeAliasType, TypedDict


class RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHTTPEnableDiscoverCodeFalsePaginationTypedDict(
    TypedDict
):
    type: PaginationOptionsRestDiscoveryDiscoverTypeHTTPPagination


class RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHTTPEnableDiscoverCodeFalsePagination(
    BaseModel
):
    type: PaginationOptionsRestDiscoveryDiscoverTypeHTTPPagination

    @field_serializer("type")
    def serialize_type(self, value):
        if isinstance(value, str):
            try:
                return models.PaginationOptionsRestDiscoveryDiscoverTypeHTTPPagination(
                    value
                )
            except ValueError:
                return value
        return value


class RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHTTPEnableDiscoverCodeFalseTypedDict(
    TypedDict
):
    discover_type: RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHTTPEnableDiscoverCodeFalseDiscoverType
    r"""Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task."""
    discover_url: str
    r"""URL to use for the Discover operation. Can be a constant URL, or a JavaScript expression to derive the URL."""
    discover_method: RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHTTPEnableDiscoverCodeFalseDiscoverMethod
    enable_discover_code: NotRequired[bool]
    discover_request_headers: NotRequired[
        List[ItemsTypeRestCollectMethodGetCollectRequestParamsTypedDict]
    ]
    pagination: NotRequired[
        RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHTTPEnableDiscoverCodeFalsePaginationTypedDict
    ]
    discover_data_field: NotRequired[str]
    r"""Path to field in the response object that contains discovery results (ex: level1.name). Leave blank if the result is an array."""
    enable_strict_discover_parsing: NotRequired[bool]
    r"""Explicitly set the discover response format. When disabled, best effort parsing is used."""


class RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHTTPEnableDiscoverCodeFalse(
    BaseModel
):
    discover_type: Annotated[
        RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHTTPEnableDiscoverCodeFalseDiscoverType,
        pydantic.Field(alias="discoverType"),
    ]
    r"""Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task."""

    discover_url: Annotated[str, pydantic.Field(alias="discoverUrl")]
    r"""URL to use for the Discover operation. Can be a constant URL, or a JavaScript expression to derive the URL."""

    discover_method: Annotated[
        RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHTTPEnableDiscoverCodeFalseDiscoverMethod,
        pydantic.Field(alias="discoverMethod"),
    ]

    enable_discover_code: Annotated[
        Optional[bool], pydantic.Field(alias="enableDiscoverCode")
    ] = None

    discover_request_headers: Annotated[
        Optional[List[ItemsTypeRestCollectMethodGetCollectRequestParams]],
        pydantic.Field(alias="discoverRequestHeaders"),
    ] = None

    pagination: Optional[
        RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHTTPEnableDiscoverCodeFalsePagination
    ] = None

    discover_data_field: Annotated[
        Optional[str], pydantic.Field(alias="discoverDataField")
    ] = None
    r"""Path to field in the response object that contains discovery results (ex: level1.name). Leave blank if the result is an array."""

    enable_strict_discover_parsing: Annotated[
        Optional[bool], pydantic.Field(alias="enableStrictDiscoverParsing")
    ] = None
    r"""Explicitly set the discover response format. When disabled, best effort parsing is used."""

    @field_serializer("discover_type")
    def serialize_discover_type(self, value):
        if isinstance(value, str):
            try:
                return models.RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHTTPEnableDiscoverCodeFalseDiscoverType(
                    value
                )
            except ValueError:
                return value
        return value

    @field_serializer("discover_method")
    def serialize_discover_method(self, value):
        if isinstance(value, str):
            try:
                return models.RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHTTPEnableDiscoverCodeFalseDiscoverMethod(
                    value
                )
            except ValueError:
                return value
        return value

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(
            [
                "enableDiscoverCode",
                "discoverRequestHeaders",
                "pagination",
                "discoverDataField",
                "enableStrictDiscoverParsing",
            ]
        )
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


class RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHTTPEnableStrictDiscoverParsingTrueDiscoverType(
    str, Enum, metaclass=utils.OpenEnumMeta
):
    r"""Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task."""

    HTTP = "http"
    JSON = "json"
    LIST = "list"
    NONE = "none"


class RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHTTPEnableStrictDiscoverParsingTrueDiscoverMethod(
    str, Enum, metaclass=utils.OpenEnumMeta
):
    # GET
    GET = "get"
    # POST
    POST = "post"
    # POST with Body
    POST_WITH_BODY = "post_with_body"
    # Other
    OTHER = "other"


class RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHTTPEnableStrictDiscoverParsingTruePaginationTypedDict(
    TypedDict
):
    type: PaginationOptionsRestDiscoveryDiscoverTypeHTTPPagination


class RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHTTPEnableStrictDiscoverParsingTruePagination(
    BaseModel
):
    type: PaginationOptionsRestDiscoveryDiscoverTypeHTTPPagination

    @field_serializer("type")
    def serialize_type(self, value):
        if isinstance(value, str):
            try:
                return models.PaginationOptionsRestDiscoveryDiscoverTypeHTTPPagination(
                    value
                )
            except ValueError:
                return value
        return value


class RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHTTPEnableStrictDiscoverParsingTrueTypedDict(
    TypedDict
):
    discover_response_format: str
    r"""If 'Strict discover response parsing' parsing is enabled, provide the response format"""
    discover_type: RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHTTPEnableStrictDiscoverParsingTrueDiscoverType
    r"""Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task."""
    discover_url: str
    r"""URL to use for the Discover operation. Can be a constant URL, or a JavaScript expression to derive the URL."""
    discover_method: RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHTTPEnableStrictDiscoverParsingTrueDiscoverMethod
    enable_strict_discover_parsing: NotRequired[bool]
    r"""Explicitly set the discover response format. When disabled, best effort parsing is used."""
    discover_request_headers: NotRequired[
        List[ItemsTypeRestCollectMethodGetCollectRequestParamsTypedDict]
    ]
    pagination: NotRequired[
        RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHTTPEnableStrictDiscoverParsingTruePaginationTypedDict
    ]
    discover_data_field: NotRequired[str]
    r"""Path to field in the response object that contains discovery results (ex: level1.name). Leave blank if the result is an array."""
    enable_discover_code: NotRequired[bool]


class RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHTTPEnableStrictDiscoverParsingTrue(
    BaseModel
):
    discover_response_format: Annotated[
        str, pydantic.Field(alias="discoverResponseFormat")
    ]
    r"""If 'Strict discover response parsing' parsing is enabled, provide the response format"""

    discover_type: Annotated[
        RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHTTPEnableStrictDiscoverParsingTrueDiscoverType,
        pydantic.Field(alias="discoverType"),
    ]
    r"""Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task."""

    discover_url: Annotated[str, pydantic.Field(alias="discoverUrl")]
    r"""URL to use for the Discover operation. Can be a constant URL, or a JavaScript expression to derive the URL."""

    discover_method: Annotated[
        RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHTTPEnableStrictDiscoverParsingTrueDiscoverMethod,
        pydantic.Field(alias="discoverMethod"),
    ]

    enable_strict_discover_parsing: Annotated[
        Optional[bool], pydantic.Field(alias="enableStrictDiscoverParsing")
    ] = None
    r"""Explicitly set the discover response format. When disabled, best effort parsing is used."""

    discover_request_headers: Annotated[
        Optional[List[ItemsTypeRestCollectMethodGetCollectRequestParams]],
        pydantic.Field(alias="discoverRequestHeaders"),
    ] = None

    pagination: Optional[
        RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHTTPEnableStrictDiscoverParsingTruePagination
    ] = None

    discover_data_field: Annotated[
        Optional[str], pydantic.Field(alias="discoverDataField")
    ] = None
    r"""Path to field in the response object that contains discovery results (ex: level1.name). Leave blank if the result is an array."""

    enable_discover_code: Annotated[
        Optional[bool], pydantic.Field(alias="enableDiscoverCode")
    ] = None

    @field_serializer("discover_type")
    def serialize_discover_type(self, value):
        if isinstance(value, str):
            try:
                return models.RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHTTPEnableStrictDiscoverParsingTrueDiscoverType(
                    value
                )
            except ValueError:
                return value
        return value

    @field_serializer("discover_method")
    def serialize_discover_method(self, value):
        if isinstance(value, str):
            try:
                return models.RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHTTPEnableStrictDiscoverParsingTrueDiscoverMethod(
                    value
                )
            except ValueError:
                return value
        return value

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(
            [
                "enableStrictDiscoverParsing",
                "discoverRequestHeaders",
                "pagination",
                "discoverDataField",
                "enableDiscoverCode",
            ]
        )
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


class RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHTTPEnableStrictDiscoverParsingFalseDiscoverType(
    str, Enum, metaclass=utils.OpenEnumMeta
):
    r"""Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task."""

    HTTP = "http"
    JSON = "json"
    LIST = "list"
    NONE = "none"


class RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHTTPEnableStrictDiscoverParsingFalseDiscoverMethod(
    str, Enum, metaclass=utils.OpenEnumMeta
):
    # GET
    GET = "get"
    # POST
    POST = "post"
    # POST with Body
    POST_WITH_BODY = "post_with_body"
    # Other
    OTHER = "other"


class RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHTTPEnableStrictDiscoverParsingFalsePaginationTypedDict(
    TypedDict
):
    type: PaginationOptionsRestDiscoveryDiscoverTypeHTTPPagination


class RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHTTPEnableStrictDiscoverParsingFalsePagination(
    BaseModel
):
    type: PaginationOptionsRestDiscoveryDiscoverTypeHTTPPagination

    @field_serializer("type")
    def serialize_type(self, value):
        if isinstance(value, str):
            try:
                return models.PaginationOptionsRestDiscoveryDiscoverTypeHTTPPagination(
                    value
                )
            except ValueError:
                return value
        return value


class RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHTTPEnableStrictDiscoverParsingFalseTypedDict(
    TypedDict
):
    discover_type: RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHTTPEnableStrictDiscoverParsingFalseDiscoverType
    r"""Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task."""
    discover_url: str
    r"""URL to use for the Discover operation. Can be a constant URL, or a JavaScript expression to derive the URL."""
    discover_method: RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHTTPEnableStrictDiscoverParsingFalseDiscoverMethod
    enable_strict_discover_parsing: NotRequired[bool]
    r"""Explicitly set the discover response format. When disabled, best effort parsing is used."""
    discover_request_headers: NotRequired[
        List[ItemsTypeRestCollectMethodGetCollectRequestParamsTypedDict]
    ]
    pagination: NotRequired[
        RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHTTPEnableStrictDiscoverParsingFalsePaginationTypedDict
    ]
    discover_data_field: NotRequired[str]
    r"""Path to field in the response object that contains discovery results (ex: level1.name). Leave blank if the result is an array."""
    enable_discover_code: NotRequired[bool]


class RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHTTPEnableStrictDiscoverParsingFalse(
    BaseModel
):
    discover_type: Annotated[
        RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHTTPEnableStrictDiscoverParsingFalseDiscoverType,
        pydantic.Field(alias="discoverType"),
    ]
    r"""Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task."""

    discover_url: Annotated[str, pydantic.Field(alias="discoverUrl")]
    r"""URL to use for the Discover operation. Can be a constant URL, or a JavaScript expression to derive the URL."""

    discover_method: Annotated[
        RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHTTPEnableStrictDiscoverParsingFalseDiscoverMethod,
        pydantic.Field(alias="discoverMethod"),
    ]

    enable_strict_discover_parsing: Annotated[
        Optional[bool], pydantic.Field(alias="enableStrictDiscoverParsing")
    ] = None
    r"""Explicitly set the discover response format. When disabled, best effort parsing is used."""

    discover_request_headers: Annotated[
        Optional[List[ItemsTypeRestCollectMethodGetCollectRequestParams]],
        pydantic.Field(alias="discoverRequestHeaders"),
    ] = None

    pagination: Optional[
        RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHTTPEnableStrictDiscoverParsingFalsePagination
    ] = None

    discover_data_field: Annotated[
        Optional[str], pydantic.Field(alias="discoverDataField")
    ] = None
    r"""Path to field in the response object that contains discovery results (ex: level1.name). Leave blank if the result is an array."""

    enable_discover_code: Annotated[
        Optional[bool], pydantic.Field(alias="enableDiscoverCode")
    ] = None

    @field_serializer("discover_type")
    def serialize_discover_type(self, value):
        if isinstance(value, str):
            try:
                return models.RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHTTPEnableStrictDiscoverParsingFalseDiscoverType(
                    value
                )
            except ValueError:
                return value
        return value

    @field_serializer("discover_method")
    def serialize_discover_method(self, value):
        if isinstance(value, str):
            try:
                return models.RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHTTPEnableStrictDiscoverParsingFalseDiscoverMethod(
                    value
                )
            except ValueError:
                return value
        return value

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(
            [
                "enableStrictDiscoverParsing",
                "discoverRequestHeaders",
                "pagination",
                "discoverDataField",
                "enableDiscoverCode",
            ]
        )
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHTTPTypedDict = TypeAliasType(
    "RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHTTPTypedDict",
    Union[
        RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHTTPEnableStrictDiscoverParsingFalseTypedDict,
        RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHTTPEnableDiscoverCodeFalseTypedDict,
        RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHTTPEnableStrictDiscoverParsingTrueTypedDict,
        RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHTTPEnableDiscoverCodeTrueTypedDict,
        RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHTTPDiscoverMethodGetTypedDict,
        RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHTTPDiscoverMethodPostTypedDict,
        RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHTTPDiscoverMethodPostWithBodyTypedDict,
        RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHTTPDiscoverMethodOtherTypedDict,
    ],
)


class UnknownRestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHTTP(
    BaseModel
):
    r"""A RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHTTP variant the SDK doesn't recognize. Preserves the raw payload."""

    discover_method: Literal["UNKNOWN"] = "UNKNOWN"
    raw: Any
    is_unknown: Literal[True] = True

    model_config = ConfigDict(frozen=True)


_REST_AUTHENTICATION_LOGIN_GET_AUTH_TOKEN_FROM_HEADER_TRUE_REST_DISCOVERY_DISCOVER_TYPE_HTTP_VARIANTS: dict[
    str, Any
] = {
    "get": RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHTTPDiscoverMethodGet,
    "post": RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHTTPDiscoverMethodPost,
    "post_with_body": RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHTTPDiscoverMethodPostWithBody,
    "other": RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHTTPDiscoverMethodOther,
}


RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHTTP = Annotated[
    Union[
        RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHTTPDiscoverMethodGet,
        RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHTTPDiscoverMethodPost,
        RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHTTPDiscoverMethodPostWithBody,
        RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHTTPDiscoverMethodOther,
        UnknownRestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHTTP,
    ],
    BeforeValidator(
        partial(
            parse_open_union,
            disc_key="discoverMethod",
            variants=_REST_AUTHENTICATION_LOGIN_GET_AUTH_TOKEN_FROM_HEADER_TRUE_REST_DISCOVERY_DISCOVER_TYPE_HTTP_VARIANTS,
            unknown_cls=UnknownRestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHTTP,
            union_name="RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHTTP",
        )
    ),
]


RestAuthenticationLoginGetAuthTokenFromHeaderTrueDiscoveryTypedDict = TypeAliasType(
    "RestAuthenticationLoginGetAuthTokenFromHeaderTrueDiscoveryTypedDict",
    Union[
        RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeNoneTypedDict,
        RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeListTypedDict,
        RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeJSONTypedDict,
        RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHTTPTypedDict,
    ],
)


class UnknownRestAuthenticationLoginGetAuthTokenFromHeaderTrueDiscovery(BaseModel):
    r"""A RestAuthenticationLoginGetAuthTokenFromHeaderTrueDiscovery variant the SDK doesn't recognize. Preserves the raw payload."""

    discover_type: Literal["UNKNOWN"] = "UNKNOWN"
    raw: Any
    is_unknown: Literal[True] = True

    model_config = ConfigDict(frozen=True)


_REST_AUTHENTICATION_LOGIN_GET_AUTH_TOKEN_FROM_HEADER_TRUE_DISCOVERY_VARIANTS: dict[
    str, Any
] = {
    "http": RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHTTP,
    "json": RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeJSON,
    "list": RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeList,
    "none": RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeNone,
}


RestAuthenticationLoginGetAuthTokenFromHeaderTrueDiscovery = Annotated[
    Union[
        RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHTTP,
        RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeJSON,
        RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeList,
        RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeNone,
        UnknownRestAuthenticationLoginGetAuthTokenFromHeaderTrueDiscovery,
    ],
    BeforeValidator(
        partial(
            parse_open_union,
            disc_key="discoverType",
            variants=_REST_AUTHENTICATION_LOGIN_GET_AUTH_TOKEN_FROM_HEADER_TRUE_DISCOVERY_VARIANTS,
            unknown_cls=UnknownRestAuthenticationLoginGetAuthTokenFromHeaderTrueDiscovery,
            union_name="RestAuthenticationLoginGetAuthTokenFromHeaderTrueDiscovery",
        )
    ),
]


class RestAuthenticationLoginGetAuthTokenFromHeaderTrueCollectMethod(
    str, Enum, metaclass=utils.OpenEnumMeta
):
    # GET
    GET = "get"
    # POST
    POST = "post"
    # POST with Body
    POST_WITH_BODY = "post_with_body"
    # Other
    OTHER = "other"


class RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestPaginationTypeRequestPageTypedDict(
    TypedDict
):
    type: PaginationOptionsRestDiscoveryDiscoverTypeHTTPPagination
    page_field: str
    r"""Query string parameter that sets the page index to be returned. Example: /api/v1/query?term=cribl&page_size=100&page_number=0"""
    size_field: str
    r"""Query string parameter that sets the number of records retrieved per request. Example: /api/v1/query?term=cribl&page_size=100&page_number=0"""
    size: float
    r"""Maximum number of records to collect per page"""
    max_pages: float
    r"""Maximum number of pages to retrieve per collection task. Defaults to 50 pages. Set to 0 to retrieve all pages."""
    zero_indexed: bool
    r"""Enable to indicate that the first page in the requested data is at index 0. Disabled by default, which indicates index 1."""
    page: NotRequired[float]
    r"""Page number from which to start request. Defaults to undefined, which will start collection from the first page."""
    total_page_field: NotRequired[str]
    r"""Name of the attribute in the response that contains the total number of pages for the query"""
    total_record_field: NotRequired[str]
    r"""Name of the attribute in the response that contains the total number of records for the query"""


class RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestPaginationTypeRequestPage(
    BaseModel
):
    type: PaginationOptionsRestDiscoveryDiscoverTypeHTTPPagination

    page_field: Annotated[str, pydantic.Field(alias="pageField")]
    r"""Query string parameter that sets the page index to be returned. Example: /api/v1/query?term=cribl&page_size=100&page_number=0"""

    size_field: Annotated[str, pydantic.Field(alias="sizeField")]
    r"""Query string parameter that sets the number of records retrieved per request. Example: /api/v1/query?term=cribl&page_size=100&page_number=0"""

    size: float
    r"""Maximum number of records to collect per page"""

    max_pages: Annotated[float, pydantic.Field(alias="maxPages")]
    r"""Maximum number of pages to retrieve per collection task. Defaults to 50 pages. Set to 0 to retrieve all pages."""

    zero_indexed: Annotated[bool, pydantic.Field(alias="zeroIndexed")]
    r"""Enable to indicate that the first page in the requested data is at index 0. Disabled by default, which indicates index 1."""

    page: Optional[float] = None
    r"""Page number from which to start request. Defaults to undefined, which will start collection from the first page."""

    total_page_field: Annotated[
        Optional[str], pydantic.Field(alias="totalPageField")
    ] = None
    r"""Name of the attribute in the response that contains the total number of pages for the query"""

    total_record_field: Annotated[
        Optional[str], pydantic.Field(alias="totalRecordField")
    ] = None
    r"""Name of the attribute in the response that contains the total number of records for the query"""

    @field_serializer("type")
    def serialize_type(self, value):
        if isinstance(value, str):
            try:
                return models.PaginationOptionsRestDiscoveryDiscoverTypeHTTPPagination(
                    value
                )
            except ValueError:
                return value
        return value

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(["page", "totalPageField", "totalRecordField"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


class RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestPaginationTypeRequestOffsetTypedDict(
    TypedDict
):
    type: PaginationOptionsRestDiscoveryDiscoverTypeHTTPPagination
    offset_field: str
    r"""Query string parameter that sets the index from which to begin returning records. Example: /api/v1/query?term=cribl&limit=100&offset=0"""
    limit_field: str
    r"""Query string parameter that sets the number of records retrieved per request. Example: /api/v1/query?term=cribl&limit=100&offset=0"""
    limit: float
    r"""Maximum number of records to collect per request"""
    max_pages: float
    r"""Maximum number of pages to retrieve per collection task. Defaults to 50 pages. Set to 0 to retrieve all pages."""
    zero_indexed: bool
    r"""Enable to indicate that the first page in the requested data is at index 0. Disabled by default, which indicates index 1."""
    offset: NotRequired[float]
    r"""Offset index from which to start request. Defaults to undefined, which will start collection from the first record."""
    total_record_field: NotRequired[str]
    r"""Name of the attribute in the response that contains the total number of records for the query"""


class RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestPaginationTypeRequestOffset(
    BaseModel
):
    type: PaginationOptionsRestDiscoveryDiscoverTypeHTTPPagination

    offset_field: Annotated[str, pydantic.Field(alias="offsetField")]
    r"""Query string parameter that sets the index from which to begin returning records. Example: /api/v1/query?term=cribl&limit=100&offset=0"""

    limit_field: Annotated[str, pydantic.Field(alias="limitField")]
    r"""Query string parameter that sets the number of records retrieved per request. Example: /api/v1/query?term=cribl&limit=100&offset=0"""

    limit: float
    r"""Maximum number of records to collect per request"""

    max_pages: Annotated[float, pydantic.Field(alias="maxPages")]
    r"""Maximum number of pages to retrieve per collection task. Defaults to 50 pages. Set to 0 to retrieve all pages."""

    zero_indexed: Annotated[bool, pydantic.Field(alias="zeroIndexed")]
    r"""Enable to indicate that the first page in the requested data is at index 0. Disabled by default, which indicates index 1."""

    offset: Optional[float] = None
    r"""Offset index from which to start request. Defaults to undefined, which will start collection from the first record."""

    total_record_field: Annotated[
        Optional[str], pydantic.Field(alias="totalRecordField")
    ] = None
    r"""Name of the attribute in the response that contains the total number of records for the query"""

    @field_serializer("type")
    def serialize_type(self, value):
        if isinstance(value, str):
            try:
                return models.PaginationOptionsRestDiscoveryDiscoverTypeHTTPPagination(
                    value
                )
            except ValueError:
                return value
        return value

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(["offset", "totalRecordField"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


class RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestPaginationTypeResponseHeaderLinkTypedDict(
    TypedDict
):
    type: PaginationOptionsRestDiscoveryDiscoverTypeHTTPPagination
    next_relation_attribute: str
    r"""Relation name used in the link header that refers to the next page in the result set. Example: rel=\"next\" refers to the next page of results: <https://myHost/nextPage>; rel=\"next\" """
    max_pages: float
    r"""Maximum number of pages to retrieve per collection task. Defaults to 50 pages. Set to 0 to retrieve all pages."""
    cur_relation_attribute: NotRequired[str]
    r"""Relation name used in the link header that refers to the current result set. Example: rel=\"self\" refers to the current page of results: <https://myHost/curPage>; rel=\"self\" """


class RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestPaginationTypeResponseHeaderLink(
    BaseModel
):
    type: PaginationOptionsRestDiscoveryDiscoverTypeHTTPPagination

    next_relation_attribute: Annotated[
        str, pydantic.Field(alias="nextRelationAttribute")
    ]
    r"""Relation name used in the link header that refers to the next page in the result set. Example: rel=\"next\" refers to the next page of results: <https://myHost/nextPage>; rel=\"next\" """

    max_pages: Annotated[float, pydantic.Field(alias="maxPages")]
    r"""Maximum number of pages to retrieve per collection task. Defaults to 50 pages. Set to 0 to retrieve all pages."""

    cur_relation_attribute: Annotated[
        Optional[str], pydantic.Field(alias="curRelationAttribute")
    ] = None
    r"""Relation name used in the link header that refers to the current result set. Example: rel=\"self\" refers to the current page of results: <https://myHost/curPage>; rel=\"self\" """

    @field_serializer("type")
    def serialize_type(self, value):
        if isinstance(value, str):
            try:
                return models.PaginationOptionsRestDiscoveryDiscoverTypeHTTPPagination(
                    value
                )
            except ValueError:
                return value
        return value

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(["curRelationAttribute"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


class RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestPaginationTypeResponseHeaderTypedDict(
    TypedDict
):
    type: PaginationOptionsRestDiscoveryDiscoverTypeHTTPPagination
    attribute: List[str]
    r"""Names of attributes within the response that contain next-page information"""
    max_pages: float
    r"""Maximum number of pages to retrieve per collection task. Defaults to 50 pages. Set to 0 to retrieve all pages."""


class RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestPaginationTypeResponseHeader(
    BaseModel
):
    type: PaginationOptionsRestDiscoveryDiscoverTypeHTTPPagination

    attribute: List[str]
    r"""Names of attributes within the response that contain next-page information"""

    max_pages: Annotated[float, pydantic.Field(alias="maxPages")]
    r"""Maximum number of pages to retrieve per collection task. Defaults to 50 pages. Set to 0 to retrieve all pages."""

    @field_serializer("type")
    def serialize_type(self, value):
        if isinstance(value, str):
            try:
                return models.PaginationOptionsRestDiscoveryDiscoverTypeHTTPPagination(
                    value
                )
            except ValueError:
                return value
        return value


class RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestPaginationTypeResponseBodyTypedDict(
    TypedDict
):
    type: PaginationOptionsRestDiscoveryDiscoverTypeHTTPPagination
    attribute: List[str]
    r"""Names of attributes within the response that contain next-page information"""
    max_pages: float
    r"""Maximum number of pages to retrieve per collection task. Defaults to 50 pages. Set to 0 to retrieve all pages."""
    last_page_expr: NotRequired[str]
    r"""JavaScript expression used to determine when the last page has been reached. The values tested by this expression must be in the Response attributes section."""


class RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestPaginationTypeResponseBody(
    BaseModel
):
    type: PaginationOptionsRestDiscoveryDiscoverTypeHTTPPagination

    attribute: List[str]
    r"""Names of attributes within the response that contain next-page information"""

    max_pages: Annotated[float, pydantic.Field(alias="maxPages")]
    r"""Maximum number of pages to retrieve per collection task. Defaults to 50 pages. Set to 0 to retrieve all pages."""

    last_page_expr: Annotated[Optional[str], pydantic.Field(alias="lastPageExpr")] = (
        None
    )
    r"""JavaScript expression used to determine when the last page has been reached. The values tested by this expression must be in the Response attributes section."""

    @field_serializer("type")
    def serialize_type(self, value):
        if isinstance(value, str):
            try:
                return models.PaginationOptionsRestDiscoveryDiscoverTypeHTTPPagination(
                    value
                )
            except ValueError:
                return value
        return value

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(["lastPageExpr"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


class RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestPaginationTypeNoneTypedDict(
    TypedDict
):
    type: PaginationOptionsRestDiscoveryDiscoverTypeHTTPPagination


class RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestPaginationTypeNone(
    BaseModel
):
    type: PaginationOptionsRestDiscoveryDiscoverTypeHTTPPagination

    @field_serializer("type")
    def serialize_type(self, value):
        if isinstance(value, str):
            try:
                return models.PaginationOptionsRestDiscoveryDiscoverTypeHTTPPagination(
                    value
                )
            except ValueError:
                return value
        return value


RestAuthenticationLoginGetAuthTokenFromHeaderTruePaginationUnionTypedDict = TypeAliasType(
    "RestAuthenticationLoginGetAuthTokenFromHeaderTruePaginationUnionTypedDict",
    Union[
        RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestPaginationTypeNoneTypedDict,
        RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestPaginationTypeResponseHeaderTypedDict,
        RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestPaginationTypeResponseBodyTypedDict,
        RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestPaginationTypeResponseHeaderLinkTypedDict,
        RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestPaginationTypeRequestOffsetTypedDict,
        RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestPaginationTypeRequestPageTypedDict,
    ],
)


class UnknownRestAuthenticationLoginGetAuthTokenFromHeaderTruePaginationUnion(
    BaseModel
):
    r"""A RestAuthenticationLoginGetAuthTokenFromHeaderTruePaginationUnion variant the SDK doesn't recognize. Preserves the raw payload."""

    type: Literal["UNKNOWN"] = "UNKNOWN"
    raw: Any
    is_unknown: Literal[True] = True

    model_config = ConfigDict(frozen=True)


_REST_AUTHENTICATION_LOGIN_GET_AUTH_TOKEN_FROM_HEADER_TRUE_PAGINATION_UNION_VARIANTS: dict[
    str, Any
] = {
    "none": RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestPaginationTypeNone,
    "response_body": RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestPaginationTypeResponseBody,
    "response_header": RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestPaginationTypeResponseHeader,
    "response_header_link": RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestPaginationTypeResponseHeaderLink,
    "request_offset": RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestPaginationTypeRequestOffset,
    "request_page": RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestPaginationTypeRequestPage,
}


RestAuthenticationLoginGetAuthTokenFromHeaderTruePaginationUnion = Annotated[
    Union[
        RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestPaginationTypeNone,
        RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestPaginationTypeResponseBody,
        RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestPaginationTypeResponseHeader,
        RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestPaginationTypeResponseHeaderLink,
        RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestPaginationTypeRequestOffset,
        RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestPaginationTypeRequestPage,
        UnknownRestAuthenticationLoginGetAuthTokenFromHeaderTruePaginationUnion,
    ],
    BeforeValidator(
        partial(
            parse_open_union,
            disc_key="type",
            variants=_REST_AUTHENTICATION_LOGIN_GET_AUTH_TOKEN_FROM_HEADER_TRUE_PAGINATION_UNION_VARIANTS,
            unknown_cls=UnknownRestAuthenticationLoginGetAuthTokenFromHeaderTruePaginationUnion,
            union_name="RestAuthenticationLoginGetAuthTokenFromHeaderTruePaginationUnion",
        )
    ),
]


class RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestRetryRulesTypeBackoffEnableHeaderTrueTypedDict(
    TypedDict
):
    type: RetryTypeOptionsHealthCheckCollectorConfRetryRules
    r"""The algorithm to use when performing HTTP retries"""
    enable_header: NotRequired[bool]
    r"""Honor any Retry-After header that specifies a delay (in seconds) or a timestamp after which to retry the request. The delay is limited to the `Longest interval between retries (ms)` value, even if the Retry-After header specifies a longer delay. When disabled, all Retry-After headers are ignored."""
    retry_header_name: NotRequired[str]
    interval: NotRequired[float]
    r"""Time interval between a failed request and the first retry"""
    limit: NotRequired[float]
    r"""Maximum number of times to retry a failed HTTP request"""
    multiplier: NotRequired[float]
    r"""Base for exponential backoff. Example: base 2 means that retries will occur after 2, then 4, then 8 seconds, and so on."""
    max_interval_ms: NotRequired[float]
    codes: NotRequired[List[float]]
    r"""List of HTTP codes that trigger a retry. Leave empty to use the default list of 429 and 503."""
    retry_connect_timeout: NotRequired[bool]
    r"""Make a single retry attempt when a connection timeout (ETIMEDOUT) error occurs"""
    retry_connect_reset: NotRequired[bool]
    r"""Retry request when a connection reset (ECONNRESET) error occurs"""


class RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestRetryRulesTypeBackoffEnableHeaderTrue(
    BaseModel
):
    type: RetryTypeOptionsHealthCheckCollectorConfRetryRules
    r"""The algorithm to use when performing HTTP retries"""

    enable_header: Annotated[Optional[bool], pydantic.Field(alias="enableHeader")] = (
        None
    )
    r"""Honor any Retry-After header that specifies a delay (in seconds) or a timestamp after which to retry the request. The delay is limited to the `Longest interval between retries (ms)` value, even if the Retry-After header specifies a longer delay. When disabled, all Retry-After headers are ignored."""

    retry_header_name: Annotated[
        Optional[str], pydantic.Field(alias="retryHeaderName")
    ] = None

    interval: Optional[float] = None
    r"""Time interval between a failed request and the first retry"""

    limit: Optional[float] = None
    r"""Maximum number of times to retry a failed HTTP request"""

    multiplier: Optional[float] = None
    r"""Base for exponential backoff. Example: base 2 means that retries will occur after 2, then 4, then 8 seconds, and so on."""

    max_interval_ms: Annotated[
        Optional[float], pydantic.Field(alias="maxIntervalMs")
    ] = None

    codes: Optional[List[float]] = None
    r"""List of HTTP codes that trigger a retry. Leave empty to use the default list of 429 and 503."""

    retry_connect_timeout: Annotated[
        Optional[bool], pydantic.Field(alias="retryConnectTimeout")
    ] = None
    r"""Make a single retry attempt when a connection timeout (ETIMEDOUT) error occurs"""

    retry_connect_reset: Annotated[
        Optional[bool], pydantic.Field(alias="retryConnectReset")
    ] = None
    r"""Retry request when a connection reset (ECONNRESET) error occurs"""

    @field_serializer("type")
    def serialize_type(self, value):
        if isinstance(value, str):
            try:
                return models.RetryTypeOptionsHealthCheckCollectorConfRetryRules(value)
            except ValueError:
                return value
        return value

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(
            [
                "enableHeader",
                "retryHeaderName",
                "interval",
                "limit",
                "multiplier",
                "maxIntervalMs",
                "codes",
                "retryConnectTimeout",
                "retryConnectReset",
            ]
        )
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


class RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestRetryRulesTypeBackoffEnableHeaderFalseTypedDict(
    TypedDict
):
    type: RetryTypeOptionsHealthCheckCollectorConfRetryRules
    r"""The algorithm to use when performing HTTP retries"""
    enable_header: NotRequired[bool]
    r"""Honor any Retry-After header that specifies a delay (in seconds) or a timestamp after which to retry the request. The delay is limited to the `Longest interval between retries (ms)` value, even if the Retry-After header specifies a longer delay. When disabled, all Retry-After headers are ignored."""
    interval: NotRequired[float]
    r"""Time interval between a failed request and the first retry"""
    limit: NotRequired[float]
    r"""Maximum number of times to retry a failed HTTP request"""
    multiplier: NotRequired[float]
    r"""Base for exponential backoff. Example: base 2 means that retries will occur after 2, then 4, then 8 seconds, and so on."""
    max_interval_ms: NotRequired[float]
    codes: NotRequired[List[float]]
    r"""List of HTTP codes that trigger a retry. Leave empty to use the default list of 429 and 503."""
    retry_connect_timeout: NotRequired[bool]
    r"""Make a single retry attempt when a connection timeout (ETIMEDOUT) error occurs"""
    retry_connect_reset: NotRequired[bool]
    r"""Retry request when a connection reset (ECONNRESET) error occurs"""


class RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestRetryRulesTypeBackoffEnableHeaderFalse(
    BaseModel
):
    type: RetryTypeOptionsHealthCheckCollectorConfRetryRules
    r"""The algorithm to use when performing HTTP retries"""

    enable_header: Annotated[Optional[bool], pydantic.Field(alias="enableHeader")] = (
        None
    )
    r"""Honor any Retry-After header that specifies a delay (in seconds) or a timestamp after which to retry the request. The delay is limited to the `Longest interval between retries (ms)` value, even if the Retry-After header specifies a longer delay. When disabled, all Retry-After headers are ignored."""

    interval: Optional[float] = None
    r"""Time interval between a failed request and the first retry"""

    limit: Optional[float] = None
    r"""Maximum number of times to retry a failed HTTP request"""

    multiplier: Optional[float] = None
    r"""Base for exponential backoff. Example: base 2 means that retries will occur after 2, then 4, then 8 seconds, and so on."""

    max_interval_ms: Annotated[
        Optional[float], pydantic.Field(alias="maxIntervalMs")
    ] = None

    codes: Optional[List[float]] = None
    r"""List of HTTP codes that trigger a retry. Leave empty to use the default list of 429 and 503."""

    retry_connect_timeout: Annotated[
        Optional[bool], pydantic.Field(alias="retryConnectTimeout")
    ] = None
    r"""Make a single retry attempt when a connection timeout (ETIMEDOUT) error occurs"""

    retry_connect_reset: Annotated[
        Optional[bool], pydantic.Field(alias="retryConnectReset")
    ] = None
    r"""Retry request when a connection reset (ECONNRESET) error occurs"""

    @field_serializer("type")
    def serialize_type(self, value):
        if isinstance(value, str):
            try:
                return models.RetryTypeOptionsHealthCheckCollectorConfRetryRules(value)
            except ValueError:
                return value
        return value

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(
            [
                "enableHeader",
                "interval",
                "limit",
                "multiplier",
                "maxIntervalMs",
                "codes",
                "retryConnectTimeout",
                "retryConnectReset",
            ]
        )
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestRetryRulesTypeBackoffTypedDict = TypeAliasType(
    "RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestRetryRulesTypeBackoffTypedDict",
    Union[
        RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestRetryRulesTypeBackoffEnableHeaderFalseTypedDict,
        RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestRetryRulesTypeBackoffEnableHeaderTrueTypedDict,
    ],
)


RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestRetryRulesTypeBackoff = TypeAliasType(
    "RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestRetryRulesTypeBackoff",
    Union[
        RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestRetryRulesTypeBackoffEnableHeaderFalse,
        RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestRetryRulesTypeBackoffEnableHeaderTrue,
    ],
)


class RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestRetryRulesTypeStaticEnableHeaderTrueTypedDict(
    TypedDict
):
    type: RetryTypeOptionsHealthCheckCollectorConfRetryRules
    r"""The algorithm to use when performing HTTP retries"""
    enable_header: NotRequired[bool]
    r"""Honor any Retry-After header that specifies a delay (in seconds) or a timestamp after which to retry the request. The delay is limited to the `Longest interval between retries (ms)` value, even if the Retry-After header specifies a longer delay. When disabled, all Retry-After headers are ignored."""
    retry_header_name: NotRequired[str]
    interval: NotRequired[float]
    r"""Time interval between retries. Maximum allowed value is 20,000 ms (1/3 minute)."""
    limit: NotRequired[float]
    r"""Maximum number of times to retry a failed HTTP request"""
    codes: NotRequired[List[float]]
    r"""List of HTTP codes that trigger a retry. Leave empty to use the default list of 429 and 503."""
    retry_connect_timeout: NotRequired[bool]
    r"""Make a single retry attempt when a connection timeout (ETIMEDOUT) error occurs"""
    retry_connect_reset: NotRequired[bool]
    r"""Retry request when a connection reset (ECONNRESET) error occurs"""


class RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestRetryRulesTypeStaticEnableHeaderTrue(
    BaseModel
):
    type: RetryTypeOptionsHealthCheckCollectorConfRetryRules
    r"""The algorithm to use when performing HTTP retries"""

    enable_header: Annotated[Optional[bool], pydantic.Field(alias="enableHeader")] = (
        None
    )
    r"""Honor any Retry-After header that specifies a delay (in seconds) or a timestamp after which to retry the request. The delay is limited to the `Longest interval between retries (ms)` value, even if the Retry-After header specifies a longer delay. When disabled, all Retry-After headers are ignored."""

    retry_header_name: Annotated[
        Optional[str], pydantic.Field(alias="retryHeaderName")
    ] = None

    interval: Optional[float] = None
    r"""Time interval between retries. Maximum allowed value is 20,000 ms (1/3 minute)."""

    limit: Optional[float] = None
    r"""Maximum number of times to retry a failed HTTP request"""

    codes: Optional[List[float]] = None
    r"""List of HTTP codes that trigger a retry. Leave empty to use the default list of 429 and 503."""

    retry_connect_timeout: Annotated[
        Optional[bool], pydantic.Field(alias="retryConnectTimeout")
    ] = None
    r"""Make a single retry attempt when a connection timeout (ETIMEDOUT) error occurs"""

    retry_connect_reset: Annotated[
        Optional[bool], pydantic.Field(alias="retryConnectReset")
    ] = None
    r"""Retry request when a connection reset (ECONNRESET) error occurs"""

    @field_serializer("type")
    def serialize_type(self, value):
        if isinstance(value, str):
            try:
                return models.RetryTypeOptionsHealthCheckCollectorConfRetryRules(value)
            except ValueError:
                return value
        return value

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(
            [
                "enableHeader",
                "retryHeaderName",
                "interval",
                "limit",
                "codes",
                "retryConnectTimeout",
                "retryConnectReset",
            ]
        )
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


class RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestRetryRulesTypeStaticEnableHeaderFalseTypedDict(
    TypedDict
):
    type: RetryTypeOptionsHealthCheckCollectorConfRetryRules
    r"""The algorithm to use when performing HTTP retries"""
    enable_header: NotRequired[bool]
    r"""Honor any Retry-After header that specifies a delay (in seconds) or a timestamp after which to retry the request. The delay is limited to the `Longest interval between retries (ms)` value, even if the Retry-After header specifies a longer delay. When disabled, all Retry-After headers are ignored."""
    interval: NotRequired[float]
    r"""Time interval between retries. Maximum allowed value is 20,000 ms (1/3 minute)."""
    limit: NotRequired[float]
    r"""Maximum number of times to retry a failed HTTP request"""
    codes: NotRequired[List[float]]
    r"""List of HTTP codes that trigger a retry. Leave empty to use the default list of 429 and 503."""
    retry_connect_timeout: NotRequired[bool]
    r"""Make a single retry attempt when a connection timeout (ETIMEDOUT) error occurs"""
    retry_connect_reset: NotRequired[bool]
    r"""Retry request when a connection reset (ECONNRESET) error occurs"""


class RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestRetryRulesTypeStaticEnableHeaderFalse(
    BaseModel
):
    type: RetryTypeOptionsHealthCheckCollectorConfRetryRules
    r"""The algorithm to use when performing HTTP retries"""

    enable_header: Annotated[Optional[bool], pydantic.Field(alias="enableHeader")] = (
        None
    )
    r"""Honor any Retry-After header that specifies a delay (in seconds) or a timestamp after which to retry the request. The delay is limited to the `Longest interval between retries (ms)` value, even if the Retry-After header specifies a longer delay. When disabled, all Retry-After headers are ignored."""

    interval: Optional[float] = None
    r"""Time interval between retries. Maximum allowed value is 20,000 ms (1/3 minute)."""

    limit: Optional[float] = None
    r"""Maximum number of times to retry a failed HTTP request"""

    codes: Optional[List[float]] = None
    r"""List of HTTP codes that trigger a retry. Leave empty to use the default list of 429 and 503."""

    retry_connect_timeout: Annotated[
        Optional[bool], pydantic.Field(alias="retryConnectTimeout")
    ] = None
    r"""Make a single retry attempt when a connection timeout (ETIMEDOUT) error occurs"""

    retry_connect_reset: Annotated[
        Optional[bool], pydantic.Field(alias="retryConnectReset")
    ] = None
    r"""Retry request when a connection reset (ECONNRESET) error occurs"""

    @field_serializer("type")
    def serialize_type(self, value):
        if isinstance(value, str):
            try:
                return models.RetryTypeOptionsHealthCheckCollectorConfRetryRules(value)
            except ValueError:
                return value
        return value

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(
            [
                "enableHeader",
                "interval",
                "limit",
                "codes",
                "retryConnectTimeout",
                "retryConnectReset",
            ]
        )
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestRetryRulesTypeStaticTypedDict = TypeAliasType(
    "RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestRetryRulesTypeStaticTypedDict",
    Union[
        RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestRetryRulesTypeStaticEnableHeaderFalseTypedDict,
        RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestRetryRulesTypeStaticEnableHeaderTrueTypedDict,
    ],
)


RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestRetryRulesTypeStatic = TypeAliasType(
    "RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestRetryRulesTypeStatic",
    Union[
        RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestRetryRulesTypeStaticEnableHeaderFalse,
        RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestRetryRulesTypeStaticEnableHeaderTrue,
    ],
)


class RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestRetryRulesTypeNoneTypedDict(
    TypedDict
):
    type: RetryTypeOptionsHealthCheckCollectorConfRetryRules
    r"""The algorithm to use when performing HTTP retries"""


class RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestRetryRulesTypeNone(
    BaseModel
):
    type: RetryTypeOptionsHealthCheckCollectorConfRetryRules
    r"""The algorithm to use when performing HTTP retries"""

    @field_serializer("type")
    def serialize_type(self, value):
        if isinstance(value, str):
            try:
                return models.RetryTypeOptionsHealthCheckCollectorConfRetryRules(value)
            except ValueError:
                return value
        return value


RestAuthenticationLoginGetAuthTokenFromHeaderTrueRetryRulesTypedDict = TypeAliasType(
    "RestAuthenticationLoginGetAuthTokenFromHeaderTrueRetryRulesTypedDict",
    Union[
        RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestRetryRulesTypeNoneTypedDict,
        RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestRetryRulesTypeStaticTypedDict,
        RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestRetryRulesTypeBackoffTypedDict,
    ],
)


class UnknownRestAuthenticationLoginGetAuthTokenFromHeaderTrueRetryRules(BaseModel):
    r"""A RestAuthenticationLoginGetAuthTokenFromHeaderTrueRetryRules variant the SDK doesn't recognize. Preserves the raw payload."""

    type: Literal["UNKNOWN"] = "UNKNOWN"
    raw: Any
    is_unknown: Literal[True] = True

    model_config = ConfigDict(frozen=True)


_REST_AUTHENTICATION_LOGIN_GET_AUTH_TOKEN_FROM_HEADER_TRUE_RETRY_RULES_VARIANTS: dict[
    str, Any
] = {
    "none": RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestRetryRulesTypeNone,
    "static": RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestRetryRulesTypeStatic,
    "backoff": RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestRetryRulesTypeBackoff,
}


RestAuthenticationLoginGetAuthTokenFromHeaderTrueRetryRules = Annotated[
    Union[
        RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestRetryRulesTypeNone,
        RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestRetryRulesTypeStatic,
        RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestRetryRulesTypeBackoff,
        UnknownRestAuthenticationLoginGetAuthTokenFromHeaderTrueRetryRules,
    ],
    BeforeValidator(
        partial(
            parse_open_union,
            disc_key="type",
            variants=_REST_AUTHENTICATION_LOGIN_GET_AUTH_TOKEN_FROM_HEADER_TRUE_RETRY_RULES_VARIANTS,
            unknown_cls=UnknownRestAuthenticationLoginGetAuthTokenFromHeaderTrueRetryRules,
            union_name="RestAuthenticationLoginGetAuthTokenFromHeaderTrueRetryRules",
        )
    ),
]


class RestAuthenticationLoginGetAuthTokenFromHeaderTrueStateTrackingTypedDict(
    TypedDict
):
    enabled: NotRequired[bool]
    r"""Track collection progress between consecutive scheduled executions"""


class RestAuthenticationLoginGetAuthTokenFromHeaderTrueStateTracking(BaseModel):
    enabled: Optional[bool] = None
    r"""Track collection progress between consecutive scheduled executions"""

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(["enabled"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


class RestAuthenticationLoginGetAuthTokenFromHeaderTrueSchedulingTypedDict(TypedDict):
    state_tracking: NotRequired[
        RestAuthenticationLoginGetAuthTokenFromHeaderTrueStateTrackingTypedDict
    ]


class RestAuthenticationLoginGetAuthTokenFromHeaderTrueScheduling(BaseModel):
    state_tracking: Annotated[
        Optional[RestAuthenticationLoginGetAuthTokenFromHeaderTrueStateTracking],
        pydantic.Field(alias="stateTracking"),
    ] = None

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(["stateTracking"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


class RestAuthenticationLoginGetAuthTokenFromHeaderTrueTypedDict(TypedDict):
    authentication: RestAuthenticationLoginGetAuthTokenFromHeaderTrueAuthentication
    r"""Authentication method for Discover and Collect REST calls. You can specify API keybased authentication by adding the appropriate Collectheaders."""
    login_url: str
    r"""URL to use for login API call. This call is expected to be a POST."""
    username: str
    password: str
    login_body: str
    r"""Template for POST body to send with login request. ${username} and ${password} are used to specify location of these attributes in the message."""
    auth_header_expr: str
    r"""JavaScript expression used to compute the Authorization header to pass in Discover and Collect calls. The value ${token} is used to reference the token obtained from login."""
    collect_url: str
    r"""URL (constant or JavaScript expression) to use for the Collect operation"""
    collect_method: RestAuthenticationLoginGetAuthTokenFromHeaderTrueCollectMethod
    get_auth_token_from_header: NotRequired[bool]
    r"""Extract the auth token from the HTTP 'Authorization' response header instead of the standard JSON body of the login response"""
    auth_header_key: NotRequired[str]
    r"""Authorization header key to pass in Discover and Collect calls. Defaults to the literal name 'Authorization'."""
    auth_request_headers: NotRequired[
        List[ItemsTypeRestCollectMethodGetCollectRequestParamsTypedDict]
    ]
    discovery: NotRequired[
        RestAuthenticationLoginGetAuthTokenFromHeaderTrueDiscoveryTypedDict
    ]
    collect_request_headers: NotRequired[
        List[ItemsTypeRestCollectMethodGetCollectRequestParamsTypedDict]
    ]
    pagination: NotRequired[
        RestAuthenticationLoginGetAuthTokenFromHeaderTruePaginationUnionTypedDict
    ]
    timeout: NotRequired[float]
    r"""HTTP request inactivity timeout. Use 0 to disable."""
    use_round_robin_dns: NotRequired[bool]
    r"""Use round-robin DNS lookup. Suitable when DNS server returns multiple addresses in sort order."""
    disable_time_filter: NotRequired[bool]
    r"""Disable Collector event time filtering when a date range is specified"""
    decode_url: NotRequired[bool]
    r"""Decode the URL before sending requests (including pagination requests)"""
    reject_unauthorized: NotRequired[bool]
    r"""Reject certificates that cannot be verified against a valid CA (such as self-signed certificates)"""
    capture_headers: NotRequired[bool]
    r"""Enable to add response headers to the resHeaders field under the __collectible object"""
    stop_on_empty_results: NotRequired[bool]
    r"""Stop pagination when the Event Breaker produces no events"""
    safe_headers: NotRequired[List[str]]
    r"""List of headers that are safe to log in plain text"""
    retry_rules: NotRequired[
        RestAuthenticationLoginGetAuthTokenFromHeaderTrueRetryRulesTypedDict
    ]
    scheduling: NotRequired[
        RestAuthenticationLoginGetAuthTokenFromHeaderTrueSchedulingTypedDict
    ]


class RestAuthenticationLoginGetAuthTokenFromHeaderTrue(BaseModel):
    authentication: RestAuthenticationLoginGetAuthTokenFromHeaderTrueAuthentication
    r"""Authentication method for Discover and Collect REST calls. You can specify API keybased authentication by adding the appropriate Collectheaders."""

    login_url: Annotated[str, pydantic.Field(alias="loginUrl")]
    r"""URL to use for login API call. This call is expected to be a POST."""

    username: str

    password: str

    login_body: Annotated[str, pydantic.Field(alias="loginBody")]
    r"""Template for POST body to send with login request. ${username} and ${password} are used to specify location of these attributes in the message."""

    auth_header_expr: Annotated[str, pydantic.Field(alias="authHeaderExpr")]
    r"""JavaScript expression used to compute the Authorization header to pass in Discover and Collect calls. The value ${token} is used to reference the token obtained from login."""

    collect_url: Annotated[str, pydantic.Field(alias="collectUrl")]
    r"""URL (constant or JavaScript expression) to use for the Collect operation"""

    collect_method: Annotated[
        RestAuthenticationLoginGetAuthTokenFromHeaderTrueCollectMethod,
        pydantic.Field(alias="collectMethod"),
    ]

    get_auth_token_from_header: Annotated[
        Optional[bool], pydantic.Field(alias="getAuthTokenFromHeader")
    ] = None
    r"""Extract the auth token from the HTTP 'Authorization' response header instead of the standard JSON body of the login response"""

    auth_header_key: Annotated[Optional[str], pydantic.Field(alias="authHeaderKey")] = (
        None
    )
    r"""Authorization header key to pass in Discover and Collect calls. Defaults to the literal name 'Authorization'."""

    auth_request_headers: Annotated[
        Optional[List[ItemsTypeRestCollectMethodGetCollectRequestParams]],
        pydantic.Field(alias="authRequestHeaders"),
    ] = None

    discovery: Optional[RestAuthenticationLoginGetAuthTokenFromHeaderTrueDiscovery] = (
        None
    )

    collect_request_headers: Annotated[
        Optional[List[ItemsTypeRestCollectMethodGetCollectRequestParams]],
        pydantic.Field(alias="collectRequestHeaders"),
    ] = None

    pagination: Optional[
        RestAuthenticationLoginGetAuthTokenFromHeaderTruePaginationUnion
    ] = None

    timeout: Optional[float] = None
    r"""HTTP request inactivity timeout. Use 0 to disable."""

    use_round_robin_dns: Annotated[
        Optional[bool], pydantic.Field(alias="useRoundRobinDns")
    ] = None
    r"""Use round-robin DNS lookup. Suitable when DNS server returns multiple addresses in sort order."""

    disable_time_filter: Annotated[
        Optional[bool], pydantic.Field(alias="disableTimeFilter")
    ] = None
    r"""Disable Collector event time filtering when a date range is specified"""

    decode_url: Annotated[Optional[bool], pydantic.Field(alias="decodeUrl")] = None
    r"""Decode the URL before sending requests (including pagination requests)"""

    reject_unauthorized: Annotated[
        Optional[bool], pydantic.Field(alias="rejectUnauthorized")
    ] = None
    r"""Reject certificates that cannot be verified against a valid CA (such as self-signed certificates)"""

    capture_headers: Annotated[
        Optional[bool], pydantic.Field(alias="captureHeaders")
    ] = None
    r"""Enable to add response headers to the resHeaders field under the __collectible object"""

    stop_on_empty_results: Annotated[
        Optional[bool], pydantic.Field(alias="stopOnEmptyResults")
    ] = None
    r"""Stop pagination when the Event Breaker produces no events"""

    safe_headers: Annotated[
        Optional[List[str]], pydantic.Field(alias="safeHeaders")
    ] = None
    r"""List of headers that are safe to log in plain text"""

    retry_rules: Annotated[
        Optional[RestAuthenticationLoginGetAuthTokenFromHeaderTrueRetryRules],
        pydantic.Field(alias="retryRules"),
    ] = None

    scheduling: Annotated[
        Optional[RestAuthenticationLoginGetAuthTokenFromHeaderTrueScheduling],
        pydantic.Field(alias="__scheduling"),
    ] = None

    @field_serializer("authentication")
    def serialize_authentication(self, value):
        if isinstance(value, str):
            try:
                return models.RestAuthenticationLoginGetAuthTokenFromHeaderTrueAuthentication(
                    value
                )
            except ValueError:
                return value
        return value

    @field_serializer("collect_method")
    def serialize_collect_method(self, value):
        if isinstance(value, str):
            try:
                return models.RestAuthenticationLoginGetAuthTokenFromHeaderTrueCollectMethod(
                    value
                )
            except ValueError:
                return value
        return value

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(
            [
                "getAuthTokenFromHeader",
                "authHeaderKey",
                "authRequestHeaders",
                "discovery",
                "collectRequestHeaders",
                "pagination",
                "timeout",
                "useRoundRobinDns",
                "disableTimeFilter",
                "decodeUrl",
                "rejectUnauthorized",
                "captureHeaders",
                "stopOnEmptyResults",
                "safeHeaders",
                "retryRules",
                "__scheduling",
            ]
        )
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


class RestAuthenticationLoginGetAuthTokenFromHeaderFalseAuthentication(
    str, Enum, metaclass=utils.OpenEnumMeta
):
    r"""Authentication method for Discover and Collect REST calls. You can specify API keybased authentication by adding the appropriate Collectheaders."""

    NONE = "none"
    BASIC = "basic"
    BASIC_SECRET = "basicSecret"
    LOGIN = "login"
    LOGIN_SECRET = "loginSecret"
    OAUTH = "oauth"
    OAUTH_SECRET = "oauthSecret"
    GOOGLE_OAUTH = "google_oauth"
    GOOGLE_OAUTH_SECRET = "google_oauthSecret"
    HMAC = "hmac"


class RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeNoneDiscoverType(
    str, Enum, metaclass=utils.OpenEnumMeta
):
    r"""Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task."""

    HTTP = "http"
    JSON = "json"
    LIST = "list"
    NONE = "none"


class RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeNoneTypedDict(
    TypedDict
):
    discover_type: RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeNoneDiscoverType
    r"""Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task."""


class RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeNone(
    BaseModel
):
    discover_type: Annotated[
        RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeNoneDiscoverType,
        pydantic.Field(alias="discoverType"),
    ]
    r"""Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task."""

    @field_serializer("discover_type")
    def serialize_discover_type(self, value):
        if isinstance(value, str):
            try:
                return models.RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeNoneDiscoverType(
                    value
                )
            except ValueError:
                return value
        return value


class RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeListDiscoverType(
    str, Enum, metaclass=utils.OpenEnumMeta
):
    r"""Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task."""

    HTTP = "http"
    JSON = "json"
    LIST = "list"
    NONE = "none"


class RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeListTypedDict(
    TypedDict
):
    discover_type: RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeListDiscoverType
    r"""Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task."""
    item_list: List[str]
    r"""Comma-separated list of items to return from the Discover task. Each item returned generates a Collect task and can be referenced using `${id}` in the Collect URL, headers, or parameters."""


class RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeList(
    BaseModel
):
    discover_type: Annotated[
        RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeListDiscoverType,
        pydantic.Field(alias="discoverType"),
    ]
    r"""Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task."""

    item_list: Annotated[List[str], pydantic.Field(alias="itemList")]
    r"""Comma-separated list of items to return from the Discover task. Each item returned generates a Collect task and can be referenced using `${id}` in the Collect URL, headers, or parameters."""

    @field_serializer("discover_type")
    def serialize_discover_type(self, value):
        if isinstance(value, str):
            try:
                return models.RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeListDiscoverType(
                    value
                )
            except ValueError:
                return value
        return value


class RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeJSONDiscoverType(
    str, Enum, metaclass=utils.OpenEnumMeta
):
    r"""Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task."""

    HTTP = "http"
    JSON = "json"
    LIST = "list"
    NONE = "none"


class RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeJSONTypedDict(
    TypedDict
):
    discover_type: RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeJSONDiscoverType
    r"""Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task."""
    manual_discover_result: str
    r"""Allows hard-coding the Discover result. Must be a JSON object or array. Works with Discover data field."""
    discover_data_field: NotRequired[str]
    r"""Within the response JSON, the name of the field to pull results from, typically a JSON array. Leave blank if the result itself is an array of values. Sample entry: items, json: { items: [{id: 'first'},{id: 'second'}] }"""


class RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeJSON(
    BaseModel
):
    discover_type: Annotated[
        RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeJSONDiscoverType,
        pydantic.Field(alias="discoverType"),
    ]
    r"""Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task."""

    manual_discover_result: Annotated[str, pydantic.Field(alias="manualDiscoverResult")]
    r"""Allows hard-coding the Discover result. Must be a JSON object or array. Works with Discover data field."""

    discover_data_field: Annotated[
        Optional[str], pydantic.Field(alias="discoverDataField")
    ] = None
    r"""Within the response JSON, the name of the field to pull results from, typically a JSON array. Leave blank if the result itself is an array of values. Sample entry: items, json: { items: [{id: 'first'},{id: 'second'}] }"""

    @field_serializer("discover_type")
    def serialize_discover_type(self, value):
        if isinstance(value, str):
            try:
                return models.RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeJSONDiscoverType(
                    value
                )
            except ValueError:
                return value
        return value

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(["discoverDataField"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


class RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHTTPDiscoverMethodOtherDiscoverMethod(
    str, Enum, metaclass=utils.OpenEnumMeta
):
    # GET
    GET = "get"
    # POST
    POST = "post"
    # POST with Body
    POST_WITH_BODY = "post_with_body"
    # Other
    OTHER = "other"


class RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHTTPDiscoverMethodOtherDiscoverType(
    str, Enum, metaclass=utils.OpenEnumMeta
):
    r"""Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task."""

    HTTP = "http"
    JSON = "json"
    LIST = "list"
    NONE = "none"


class RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHTTPDiscoverMethodOtherPaginationTypedDict(
    TypedDict
):
    type: PaginationOptionsRestDiscoveryDiscoverTypeHTTPPagination


class RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHTTPDiscoverMethodOtherPagination(
    BaseModel
):
    type: PaginationOptionsRestDiscoveryDiscoverTypeHTTPPagination

    @field_serializer("type")
    def serialize_type(self, value):
        if isinstance(value, str):
            try:
                return models.PaginationOptionsRestDiscoveryDiscoverTypeHTTPPagination(
                    value
                )
            except ValueError:
                return value
        return value


class RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHTTPDiscoverMethodOtherTypedDict(
    TypedDict
):
    discover_method: RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHTTPDiscoverMethodOtherDiscoverMethod
    discover_verb: str
    r"""Custom HTTP method to use for the Discover operation"""
    discover_type: RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHTTPDiscoverMethodOtherDiscoverType
    r"""Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task."""
    discover_url: str
    r"""URL to use for the Discover operation. Can be a constant URL, or a JavaScript expression to derive the URL."""
    discover_body: NotRequired[str]
    r"""Template for body to send with the discover request"""
    discover_request_params: NotRequired[
        List[ItemsTypeRestCollectMethodGetCollectRequestParamsTypedDict]
    ]
    discover_request_headers: NotRequired[
        List[ItemsTypeRestCollectMethodGetCollectRequestParamsTypedDict]
    ]
    pagination: NotRequired[
        RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHTTPDiscoverMethodOtherPaginationTypedDict
    ]
    discover_data_field: NotRequired[str]
    r"""Path to field in the response object that contains discovery results (ex: level1.name). Leave blank if the result is an array."""
    enable_strict_discover_parsing: NotRequired[bool]
    r"""Explicitly set the discover response format. When disabled, best effort parsing is used."""
    enable_discover_code: NotRequired[bool]


class RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHTTPDiscoverMethodOther(
    BaseModel
):
    discover_method: Annotated[
        RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHTTPDiscoverMethodOtherDiscoverMethod,
        pydantic.Field(alias="discoverMethod"),
    ]

    discover_verb: Annotated[str, pydantic.Field(alias="discoverVerb")]
    r"""Custom HTTP method to use for the Discover operation"""

    discover_type: Annotated[
        RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHTTPDiscoverMethodOtherDiscoverType,
        pydantic.Field(alias="discoverType"),
    ]
    r"""Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task."""

    discover_url: Annotated[str, pydantic.Field(alias="discoverUrl")]
    r"""URL to use for the Discover operation. Can be a constant URL, or a JavaScript expression to derive the URL."""

    discover_body: Annotated[Optional[str], pydantic.Field(alias="discoverBody")] = None
    r"""Template for body to send with the discover request"""

    discover_request_params: Annotated[
        Optional[List[ItemsTypeRestCollectMethodGetCollectRequestParams]],
        pydantic.Field(alias="discoverRequestParams"),
    ] = None

    discover_request_headers: Annotated[
        Optional[List[ItemsTypeRestCollectMethodGetCollectRequestParams]],
        pydantic.Field(alias="discoverRequestHeaders"),
    ] = None

    pagination: Optional[
        RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHTTPDiscoverMethodOtherPagination
    ] = None

    discover_data_field: Annotated[
        Optional[str], pydantic.Field(alias="discoverDataField")
    ] = None
    r"""Path to field in the response object that contains discovery results (ex: level1.name). Leave blank if the result is an array."""

    enable_strict_discover_parsing: Annotated[
        Optional[bool], pydantic.Field(alias="enableStrictDiscoverParsing")
    ] = None
    r"""Explicitly set the discover response format. When disabled, best effort parsing is used."""

    enable_discover_code: Annotated[
        Optional[bool], pydantic.Field(alias="enableDiscoverCode")
    ] = None

    @field_serializer("discover_method")
    def serialize_discover_method(self, value):
        if isinstance(value, str):
            try:
                return models.RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHTTPDiscoverMethodOtherDiscoverMethod(
                    value
                )
            except ValueError:
                return value
        return value

    @field_serializer("discover_type")
    def serialize_discover_type(self, value):
        if isinstance(value, str):
            try:
                return models.RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHTTPDiscoverMethodOtherDiscoverType(
                    value
                )
            except ValueError:
                return value
        return value

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(
            [
                "discoverBody",
                "discoverRequestParams",
                "discoverRequestHeaders",
                "pagination",
                "discoverDataField",
                "enableStrictDiscoverParsing",
                "enableDiscoverCode",
            ]
        )
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


class RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHTTPDiscoverMethodPostWithBodyDiscoverMethod(
    str, Enum, metaclass=utils.OpenEnumMeta
):
    # GET
    GET = "get"
    # POST
    POST = "post"
    # POST with Body
    POST_WITH_BODY = "post_with_body"
    # Other
    OTHER = "other"


class RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHTTPDiscoverMethodPostWithBodyDiscoverType(
    str, Enum, metaclass=utils.OpenEnumMeta
):
    r"""Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task."""

    HTTP = "http"
    JSON = "json"
    LIST = "list"
    NONE = "none"


class RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHTTPDiscoverMethodPostWithBodyPaginationTypedDict(
    TypedDict
):
    type: PaginationOptionsRestDiscoveryDiscoverTypeHTTPPagination


class RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHTTPDiscoverMethodPostWithBodyPagination(
    BaseModel
):
    type: PaginationOptionsRestDiscoveryDiscoverTypeHTTPPagination

    @field_serializer("type")
    def serialize_type(self, value):
        if isinstance(value, str):
            try:
                return models.PaginationOptionsRestDiscoveryDiscoverTypeHTTPPagination(
                    value
                )
            except ValueError:
                return value
        return value


class RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHTTPDiscoverMethodPostWithBodyTypedDict(
    TypedDict
):
    discover_method: RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHTTPDiscoverMethodPostWithBodyDiscoverMethod
    discover_body: str
    r"""Template for POST body to send with the discover request. To reference global variables or functions, use template parameters: `{ myVar: ${C.vars.myVar}, secret: ${C.Secret('mySecret','text').value} }`"""
    discover_type: RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHTTPDiscoverMethodPostWithBodyDiscoverType
    r"""Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task."""
    discover_url: str
    r"""URL to use for the Discover operation. Can be a constant URL, or a JavaScript expression to derive the URL."""
    discover_request_headers: NotRequired[
        List[ItemsTypeRestCollectMethodGetCollectRequestParamsTypedDict]
    ]
    pagination: NotRequired[
        RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHTTPDiscoverMethodPostWithBodyPaginationTypedDict
    ]
    discover_data_field: NotRequired[str]
    r"""Path to field in the response object that contains discovery results (ex: level1.name). Leave blank if the result is an array."""
    enable_strict_discover_parsing: NotRequired[bool]
    r"""Explicitly set the discover response format. When disabled, best effort parsing is used."""
    enable_discover_code: NotRequired[bool]


class RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHTTPDiscoverMethodPostWithBody(
    BaseModel
):
    discover_method: Annotated[
        RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHTTPDiscoverMethodPostWithBodyDiscoverMethod,
        pydantic.Field(alias="discoverMethod"),
    ]

    discover_body: Annotated[str, pydantic.Field(alias="discoverBody")]
    r"""Template for POST body to send with the discover request. To reference global variables or functions, use template parameters: `{ myVar: ${C.vars.myVar}, secret: ${C.Secret('mySecret','text').value} }`"""

    discover_type: Annotated[
        RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHTTPDiscoverMethodPostWithBodyDiscoverType,
        pydantic.Field(alias="discoverType"),
    ]
    r"""Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task."""

    discover_url: Annotated[str, pydantic.Field(alias="discoverUrl")]
    r"""URL to use for the Discover operation. Can be a constant URL, or a JavaScript expression to derive the URL."""

    discover_request_headers: Annotated[
        Optional[List[ItemsTypeRestCollectMethodGetCollectRequestParams]],
        pydantic.Field(alias="discoverRequestHeaders"),
    ] = None

    pagination: Optional[
        RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHTTPDiscoverMethodPostWithBodyPagination
    ] = None

    discover_data_field: Annotated[
        Optional[str], pydantic.Field(alias="discoverDataField")
    ] = None
    r"""Path to field in the response object that contains discovery results (ex: level1.name). Leave blank if the result is an array."""

    enable_strict_discover_parsing: Annotated[
        Optional[bool], pydantic.Field(alias="enableStrictDiscoverParsing")
    ] = None
    r"""Explicitly set the discover response format. When disabled, best effort parsing is used."""

    enable_discover_code: Annotated[
        Optional[bool], pydantic.Field(alias="enableDiscoverCode")
    ] = None

    @field_serializer("discover_method")
    def serialize_discover_method(self, value):
        if isinstance(value, str):
            try:
                return models.RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHTTPDiscoverMethodPostWithBodyDiscoverMethod(
                    value
                )
            except ValueError:
                return value
        return value

    @field_serializer("discover_type")
    def serialize_discover_type(self, value):
        if isinstance(value, str):
            try:
                return models.RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHTTPDiscoverMethodPostWithBodyDiscoverType(
                    value
                )
            except ValueError:
                return value
        return value

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(
            [
                "discoverRequestHeaders",
                "pagination",
                "discoverDataField",
                "enableStrictDiscoverParsing",
                "enableDiscoverCode",
            ]
        )
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


class RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHTTPDiscoverMethodPostDiscoverMethod(
    str, Enum, metaclass=utils.OpenEnumMeta
):
    # GET
    GET = "get"
    # POST
    POST = "post"
    # POST with Body
    POST_WITH_BODY = "post_with_body"
    # Other
    OTHER = "other"


class RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHTTPDiscoverMethodPostDiscoverType(
    str, Enum, metaclass=utils.OpenEnumMeta
):
    r"""Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task."""

    HTTP = "http"
    JSON = "json"
    LIST = "list"
    NONE = "none"


class RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHTTPDiscoverMethodPostPaginationTypedDict(
    TypedDict
):
    type: PaginationOptionsRestDiscoveryDiscoverTypeHTTPPagination


class RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHTTPDiscoverMethodPostPagination(
    BaseModel
):
    type: PaginationOptionsRestDiscoveryDiscoverTypeHTTPPagination

    @field_serializer("type")
    def serialize_type(self, value):
        if isinstance(value, str):
            try:
                return models.PaginationOptionsRestDiscoveryDiscoverTypeHTTPPagination(
                    value
                )
            except ValueError:
                return value
        return value


class RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHTTPDiscoverMethodPostTypedDict(
    TypedDict
):
    discover_method: RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHTTPDiscoverMethodPostDiscoverMethod
    discover_type: RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHTTPDiscoverMethodPostDiscoverType
    r"""Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task."""
    discover_url: str
    r"""URL to use for the Discover operation. Can be a constant URL, or a JavaScript expression to derive the URL."""
    discover_request_params: NotRequired[
        List[ItemsTypeRestCollectMethodGetCollectRequestParamsTypedDict]
    ]
    discover_request_headers: NotRequired[
        List[ItemsTypeRestCollectMethodGetCollectRequestParamsTypedDict]
    ]
    pagination: NotRequired[
        RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHTTPDiscoverMethodPostPaginationTypedDict
    ]
    discover_data_field: NotRequired[str]
    r"""Path to field in the response object that contains discovery results (ex: level1.name). Leave blank if the result is an array."""
    enable_strict_discover_parsing: NotRequired[bool]
    r"""Explicitly set the discover response format. When disabled, best effort parsing is used."""
    enable_discover_code: NotRequired[bool]


class RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHTTPDiscoverMethodPost(
    BaseModel
):
    discover_method: Annotated[
        RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHTTPDiscoverMethodPostDiscoverMethod,
        pydantic.Field(alias="discoverMethod"),
    ]

    discover_type: Annotated[
        RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHTTPDiscoverMethodPostDiscoverType,
        pydantic.Field(alias="discoverType"),
    ]
    r"""Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task."""

    discover_url: Annotated[str, pydantic.Field(alias="discoverUrl")]
    r"""URL to use for the Discover operation. Can be a constant URL, or a JavaScript expression to derive the URL."""

    discover_request_params: Annotated[
        Optional[List[ItemsTypeRestCollectMethodGetCollectRequestParams]],
        pydantic.Field(alias="discoverRequestParams"),
    ] = None

    discover_request_headers: Annotated[
        Optional[List[ItemsTypeRestCollectMethodGetCollectRequestParams]],
        pydantic.Field(alias="discoverRequestHeaders"),
    ] = None

    pagination: Optional[
        RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHTTPDiscoverMethodPostPagination
    ] = None

    discover_data_field: Annotated[
        Optional[str], pydantic.Field(alias="discoverDataField")
    ] = None
    r"""Path to field in the response object that contains discovery results (ex: level1.name). Leave blank if the result is an array."""

    enable_strict_discover_parsing: Annotated[
        Optional[bool], pydantic.Field(alias="enableStrictDiscoverParsing")
    ] = None
    r"""Explicitly set the discover response format. When disabled, best effort parsing is used."""

    enable_discover_code: Annotated[
        Optional[bool], pydantic.Field(alias="enableDiscoverCode")
    ] = None

    @field_serializer("discover_method")
    def serialize_discover_method(self, value):
        if isinstance(value, str):
            try:
                return models.RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHTTPDiscoverMethodPostDiscoverMethod(
                    value
                )
            except ValueError:
                return value
        return value

    @field_serializer("discover_type")
    def serialize_discover_type(self, value):
        if isinstance(value, str):
            try:
                return models.RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHTTPDiscoverMethodPostDiscoverType(
                    value
                )
            except ValueError:
                return value
        return value

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(
            [
                "discoverRequestParams",
                "discoverRequestHeaders",
                "pagination",
                "discoverDataField",
                "enableStrictDiscoverParsing",
                "enableDiscoverCode",
            ]
        )
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


class RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHTTPDiscoverMethodGetDiscoverMethod(
    str, Enum, metaclass=utils.OpenEnumMeta
):
    # GET
    GET = "get"
    # POST
    POST = "post"
    # POST with Body
    POST_WITH_BODY = "post_with_body"
    # Other
    OTHER = "other"


class RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHTTPDiscoverMethodGetDiscoverType(
    str, Enum, metaclass=utils.OpenEnumMeta
):
    r"""Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task."""

    HTTP = "http"
    JSON = "json"
    LIST = "list"
    NONE = "none"


class RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHTTPDiscoverMethodGetPaginationTypedDict(
    TypedDict
):
    type: PaginationOptionsRestDiscoveryDiscoverTypeHTTPPagination


class RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHTTPDiscoverMethodGetPagination(
    BaseModel
):
    type: PaginationOptionsRestDiscoveryDiscoverTypeHTTPPagination

    @field_serializer("type")
    def serialize_type(self, value):
        if isinstance(value, str):
            try:
                return models.PaginationOptionsRestDiscoveryDiscoverTypeHTTPPagination(
                    value
                )
            except ValueError:
                return value
        return value


class RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHTTPDiscoverMethodGetTypedDict(
    TypedDict
):
    discover_method: RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHTTPDiscoverMethodGetDiscoverMethod
    discover_type: RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHTTPDiscoverMethodGetDiscoverType
    r"""Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task."""
    discover_url: str
    r"""URL to use for the Discover operation. Can be a constant URL, or a JavaScript expression to derive the URL."""
    discover_request_params: NotRequired[
        List[ItemsTypeRestCollectMethodGetCollectRequestParamsTypedDict]
    ]
    discover_request_headers: NotRequired[
        List[ItemsTypeRestCollectMethodGetCollectRequestParamsTypedDict]
    ]
    pagination: NotRequired[
        RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHTTPDiscoverMethodGetPaginationTypedDict
    ]
    discover_data_field: NotRequired[str]
    r"""Path to field in the response object that contains discovery results (ex: level1.name). Leave blank if the result is an array."""
    enable_strict_discover_parsing: NotRequired[bool]
    r"""Explicitly set the discover response format. When disabled, best effort parsing is used."""
    enable_discover_code: NotRequired[bool]


class RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHTTPDiscoverMethodGet(
    BaseModel
):
    discover_method: Annotated[
        RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHTTPDiscoverMethodGetDiscoverMethod,
        pydantic.Field(alias="discoverMethod"),
    ]

    discover_type: Annotated[
        RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHTTPDiscoverMethodGetDiscoverType,
        pydantic.Field(alias="discoverType"),
    ]
    r"""Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task."""

    discover_url: Annotated[str, pydantic.Field(alias="discoverUrl")]
    r"""URL to use for the Discover operation. Can be a constant URL, or a JavaScript expression to derive the URL."""

    discover_request_params: Annotated[
        Optional[List[ItemsTypeRestCollectMethodGetCollectRequestParams]],
        pydantic.Field(alias="discoverRequestParams"),
    ] = None

    discover_request_headers: Annotated[
        Optional[List[ItemsTypeRestCollectMethodGetCollectRequestParams]],
        pydantic.Field(alias="discoverRequestHeaders"),
    ] = None

    pagination: Optional[
        RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHTTPDiscoverMethodGetPagination
    ] = None

    discover_data_field: Annotated[
        Optional[str], pydantic.Field(alias="discoverDataField")
    ] = None
    r"""Path to field in the response object that contains discovery results (ex: level1.name). Leave blank if the result is an array."""

    enable_strict_discover_parsing: Annotated[
        Optional[bool], pydantic.Field(alias="enableStrictDiscoverParsing")
    ] = None
    r"""Explicitly set the discover response format. When disabled, best effort parsing is used."""

    enable_discover_code: Annotated[
        Optional[bool], pydantic.Field(alias="enableDiscoverCode")
    ] = None

    @field_serializer("discover_method")
    def serialize_discover_method(self, value):
        if isinstance(value, str):
            try:
                return models.RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHTTPDiscoverMethodGetDiscoverMethod(
                    value
                )
            except ValueError:
                return value
        return value

    @field_serializer("discover_type")
    def serialize_discover_type(self, value):
        if isinstance(value, str):
            try:
                return models.RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHTTPDiscoverMethodGetDiscoverType(
                    value
                )
            except ValueError:
                return value
        return value

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(
            [
                "discoverRequestParams",
                "discoverRequestHeaders",
                "pagination",
                "discoverDataField",
                "enableStrictDiscoverParsing",
                "enableDiscoverCode",
            ]
        )
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


class RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHTTPEnableDiscoverCodeTrueDiscoverType(
    str, Enum, metaclass=utils.OpenEnumMeta
):
    r"""Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task."""

    HTTP = "http"
    JSON = "json"
    LIST = "list"
    NONE = "none"


class RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHTTPEnableDiscoverCodeTrueDiscoverMethod(
    str, Enum, metaclass=utils.OpenEnumMeta
):
    # GET
    GET = "get"
    # POST
    POST = "post"
    # POST with Body
    POST_WITH_BODY = "post_with_body"
    # Other
    OTHER = "other"


class RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHTTPEnableDiscoverCodeTruePaginationTypedDict(
    TypedDict
):
    type: PaginationOptionsRestDiscoveryDiscoverTypeHTTPPagination


class RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHTTPEnableDiscoverCodeTruePagination(
    BaseModel
):
    type: PaginationOptionsRestDiscoveryDiscoverTypeHTTPPagination

    @field_serializer("type")
    def serialize_type(self, value):
        if isinstance(value, str):
            try:
                return models.PaginationOptionsRestDiscoveryDiscoverTypeHTTPPagination(
                    value
                )
            except ValueError:
                return value
        return value


class RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHTTPEnableDiscoverCodeTrueTypedDict(
    TypedDict
):
    discover_type: RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHTTPEnableDiscoverCodeTrueDiscoverType
    r"""Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task."""
    discover_url: str
    r"""URL to use for the Discover operation. Can be a constant URL, or a JavaScript expression to derive the URL."""
    discover_method: RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHTTPEnableDiscoverCodeTrueDiscoverMethod
    enable_discover_code: NotRequired[bool]
    format_result_code: NotRequired[str]
    r"""Custom JavaScript code to format the discover result through the __e variable which is a JSON object or array containing the original discover results. The object or array passed should be manipulated to contain the desired discover results, i.e.: __e['myResult'] = [{lat: -1.1234, long: 2.345, zip: 11111},{lat: -1.235, long 2.346, zip: 22222}] or ['11111','22222']. Caution: This function is evaluated in an unprotected context, allowing you to execute almost any JavaScript code."""
    discover_request_headers: NotRequired[
        List[ItemsTypeRestCollectMethodGetCollectRequestParamsTypedDict]
    ]
    pagination: NotRequired[
        RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHTTPEnableDiscoverCodeTruePaginationTypedDict
    ]
    discover_data_field: NotRequired[str]
    r"""Path to field in the response object that contains discovery results (ex: level1.name). Leave blank if the result is an array."""
    enable_strict_discover_parsing: NotRequired[bool]
    r"""Explicitly set the discover response format. When disabled, best effort parsing is used."""


class RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHTTPEnableDiscoverCodeTrue(
    BaseModel
):
    discover_type: Annotated[
        RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHTTPEnableDiscoverCodeTrueDiscoverType,
        pydantic.Field(alias="discoverType"),
    ]
    r"""Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task."""

    discover_url: Annotated[str, pydantic.Field(alias="discoverUrl")]
    r"""URL to use for the Discover operation. Can be a constant URL, or a JavaScript expression to derive the URL."""

    discover_method: Annotated[
        RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHTTPEnableDiscoverCodeTrueDiscoverMethod,
        pydantic.Field(alias="discoverMethod"),
    ]

    enable_discover_code: Annotated[
        Optional[bool], pydantic.Field(alias="enableDiscoverCode")
    ] = None

    format_result_code: Annotated[
        Optional[str], pydantic.Field(alias="formatResultCode")
    ] = None
    r"""Custom JavaScript code to format the discover result through the __e variable which is a JSON object or array containing the original discover results. The object or array passed should be manipulated to contain the desired discover results, i.e.: __e['myResult'] = [{lat: -1.1234, long: 2.345, zip: 11111},{lat: -1.235, long 2.346, zip: 22222}] or ['11111','22222']. Caution: This function is evaluated in an unprotected context, allowing you to execute almost any JavaScript code."""

    discover_request_headers: Annotated[
        Optional[List[ItemsTypeRestCollectMethodGetCollectRequestParams]],
        pydantic.Field(alias="discoverRequestHeaders"),
    ] = None

    pagination: Optional[
        RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHTTPEnableDiscoverCodeTruePagination
    ] = None

    discover_data_field: Annotated[
        Optional[str], pydantic.Field(alias="discoverDataField")
    ] = None
    r"""Path to field in the response object that contains discovery results (ex: level1.name). Leave blank if the result is an array."""

    enable_strict_discover_parsing: Annotated[
        Optional[bool], pydantic.Field(alias="enableStrictDiscoverParsing")
    ] = None
    r"""Explicitly set the discover response format. When disabled, best effort parsing is used."""

    @field_serializer("discover_type")
    def serialize_discover_type(self, value):
        if isinstance(value, str):
            try:
                return models.RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHTTPEnableDiscoverCodeTrueDiscoverType(
                    value
                )
            except ValueError:
                return value
        return value

    @field_serializer("discover_method")
    def serialize_discover_method(self, value):
        if isinstance(value, str):
            try:
                return models.RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHTTPEnableDiscoverCodeTrueDiscoverMethod(
                    value
                )
            except ValueError:
                return value
        return value

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(
            [
                "enableDiscoverCode",
                "formatResultCode",
                "discoverRequestHeaders",
                "pagination",
                "discoverDataField",
                "enableStrictDiscoverParsing",
            ]
        )
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


class RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHTTPEnableDiscoverCodeFalseDiscoverType(
    str, Enum, metaclass=utils.OpenEnumMeta
):
    r"""Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task."""

    HTTP = "http"
    JSON = "json"
    LIST = "list"
    NONE = "none"


class RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHTTPEnableDiscoverCodeFalseDiscoverMethod(
    str, Enum, metaclass=utils.OpenEnumMeta
):
    # GET
    GET = "get"
    # POST
    POST = "post"
    # POST with Body
    POST_WITH_BODY = "post_with_body"
    # Other
    OTHER = "other"


class RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHTTPEnableDiscoverCodeFalsePaginationTypedDict(
    TypedDict
):
    type: PaginationOptionsRestDiscoveryDiscoverTypeHTTPPagination


class RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHTTPEnableDiscoverCodeFalsePagination(
    BaseModel
):
    type: PaginationOptionsRestDiscoveryDiscoverTypeHTTPPagination

    @field_serializer("type")
    def serialize_type(self, value):
        if isinstance(value, str):
            try:
                return models.PaginationOptionsRestDiscoveryDiscoverTypeHTTPPagination(
                    value
                )
            except ValueError:
                return value
        return value


class RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHTTPEnableDiscoverCodeFalseTypedDict(
    TypedDict
):
    discover_type: RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHTTPEnableDiscoverCodeFalseDiscoverType
    r"""Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task."""
    discover_url: str
    r"""URL to use for the Discover operation. Can be a constant URL, or a JavaScript expression to derive the URL."""
    discover_method: RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHTTPEnableDiscoverCodeFalseDiscoverMethod
    enable_discover_code: NotRequired[bool]
    discover_request_headers: NotRequired[
        List[ItemsTypeRestCollectMethodGetCollectRequestParamsTypedDict]
    ]
    pagination: NotRequired[
        RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHTTPEnableDiscoverCodeFalsePaginationTypedDict
    ]
    discover_data_field: NotRequired[str]
    r"""Path to field in the response object that contains discovery results (ex: level1.name). Leave blank if the result is an array."""
    enable_strict_discover_parsing: NotRequired[bool]
    r"""Explicitly set the discover response format. When disabled, best effort parsing is used."""


class RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHTTPEnableDiscoverCodeFalse(
    BaseModel
):
    discover_type: Annotated[
        RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHTTPEnableDiscoverCodeFalseDiscoverType,
        pydantic.Field(alias="discoverType"),
    ]
    r"""Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task."""

    discover_url: Annotated[str, pydantic.Field(alias="discoverUrl")]
    r"""URL to use for the Discover operation. Can be a constant URL, or a JavaScript expression to derive the URL."""

    discover_method: Annotated[
        RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHTTPEnableDiscoverCodeFalseDiscoverMethod,
        pydantic.Field(alias="discoverMethod"),
    ]

    enable_discover_code: Annotated[
        Optional[bool], pydantic.Field(alias="enableDiscoverCode")
    ] = None

    discover_request_headers: Annotated[
        Optional[List[ItemsTypeRestCollectMethodGetCollectRequestParams]],
        pydantic.Field(alias="discoverRequestHeaders"),
    ] = None

    pagination: Optional[
        RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHTTPEnableDiscoverCodeFalsePagination
    ] = None

    discover_data_field: Annotated[
        Optional[str], pydantic.Field(alias="discoverDataField")
    ] = None
    r"""Path to field in the response object that contains discovery results (ex: level1.name). Leave blank if the result is an array."""

    enable_strict_discover_parsing: Annotated[
        Optional[bool], pydantic.Field(alias="enableStrictDiscoverParsing")
    ] = None
    r"""Explicitly set the discover response format. When disabled, best effort parsing is used."""

    @field_serializer("discover_type")
    def serialize_discover_type(self, value):
        if isinstance(value, str):
            try:
                return models.RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHTTPEnableDiscoverCodeFalseDiscoverType(
                    value
                )
            except ValueError:
                return value
        return value

    @field_serializer("discover_method")
    def serialize_discover_method(self, value):
        if isinstance(value, str):
            try:
                return models.RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHTTPEnableDiscoverCodeFalseDiscoverMethod(
                    value
                )
            except ValueError:
                return value
        return value

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(
            [
                "enableDiscoverCode",
                "discoverRequestHeaders",
                "pagination",
                "discoverDataField",
                "enableStrictDiscoverParsing",
            ]
        )
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


class RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHTTPEnableStrictDiscoverParsingTrueDiscoverType(
    str, Enum, metaclass=utils.OpenEnumMeta
):
    r"""Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task."""

    HTTP = "http"
    JSON = "json"
    LIST = "list"
    NONE = "none"


class RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHTTPEnableStrictDiscoverParsingTrueDiscoverMethod(
    str, Enum, metaclass=utils.OpenEnumMeta
):
    # GET
    GET = "get"
    # POST
    POST = "post"
    # POST with Body
    POST_WITH_BODY = "post_with_body"
    # Other
    OTHER = "other"


class RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHTTPEnableStrictDiscoverParsingTruePaginationTypedDict(
    TypedDict
):
    type: PaginationOptionsRestDiscoveryDiscoverTypeHTTPPagination


class RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHTTPEnableStrictDiscoverParsingTruePagination(
    BaseModel
):
    type: PaginationOptionsRestDiscoveryDiscoverTypeHTTPPagination

    @field_serializer("type")
    def serialize_type(self, value):
        if isinstance(value, str):
            try:
                return models.PaginationOptionsRestDiscoveryDiscoverTypeHTTPPagination(
                    value
                )
            except ValueError:
                return value
        return value


class RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHTTPEnableStrictDiscoverParsingTrueTypedDict(
    TypedDict
):
    discover_response_format: str
    r"""If 'Strict discover response parsing' parsing is enabled, provide the response format"""
    discover_type: RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHTTPEnableStrictDiscoverParsingTrueDiscoverType
    r"""Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task."""
    discover_url: str
    r"""URL to use for the Discover operation. Can be a constant URL, or a JavaScript expression to derive the URL."""
    discover_method: RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHTTPEnableStrictDiscoverParsingTrueDiscoverMethod
    enable_strict_discover_parsing: NotRequired[bool]
    r"""Explicitly set the discover response format. When disabled, best effort parsing is used."""
    discover_request_headers: NotRequired[
        List[ItemsTypeRestCollectMethodGetCollectRequestParamsTypedDict]
    ]
    pagination: NotRequired[
        RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHTTPEnableStrictDiscoverParsingTruePaginationTypedDict
    ]
    discover_data_field: NotRequired[str]
    r"""Path to field in the response object that contains discovery results (ex: level1.name). Leave blank if the result is an array."""
    enable_discover_code: NotRequired[bool]


class RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHTTPEnableStrictDiscoverParsingTrue(
    BaseModel
):
    discover_response_format: Annotated[
        str, pydantic.Field(alias="discoverResponseFormat")
    ]
    r"""If 'Strict discover response parsing' parsing is enabled, provide the response format"""

    discover_type: Annotated[
        RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHTTPEnableStrictDiscoverParsingTrueDiscoverType,
        pydantic.Field(alias="discoverType"),
    ]
    r"""Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task."""

    discover_url: Annotated[str, pydantic.Field(alias="discoverUrl")]
    r"""URL to use for the Discover operation. Can be a constant URL, or a JavaScript expression to derive the URL."""

    discover_method: Annotated[
        RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHTTPEnableStrictDiscoverParsingTrueDiscoverMethod,
        pydantic.Field(alias="discoverMethod"),
    ]

    enable_strict_discover_parsing: Annotated[
        Optional[bool], pydantic.Field(alias="enableStrictDiscoverParsing")
    ] = None
    r"""Explicitly set the discover response format. When disabled, best effort parsing is used."""

    discover_request_headers: Annotated[
        Optional[List[ItemsTypeRestCollectMethodGetCollectRequestParams]],
        pydantic.Field(alias="discoverRequestHeaders"),
    ] = None

    pagination: Optional[
        RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHTTPEnableStrictDiscoverParsingTruePagination
    ] = None

    discover_data_field: Annotated[
        Optional[str], pydantic.Field(alias="discoverDataField")
    ] = None
    r"""Path to field in the response object that contains discovery results (ex: level1.name). Leave blank if the result is an array."""

    enable_discover_code: Annotated[
        Optional[bool], pydantic.Field(alias="enableDiscoverCode")
    ] = None

    @field_serializer("discover_type")
    def serialize_discover_type(self, value):
        if isinstance(value, str):
            try:
                return models.RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHTTPEnableStrictDiscoverParsingTrueDiscoverType(
                    value
                )
            except ValueError:
                return value
        return value

    @field_serializer("discover_method")
    def serialize_discover_method(self, value):
        if isinstance(value, str):
            try:
                return models.RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHTTPEnableStrictDiscoverParsingTrueDiscoverMethod(
                    value
                )
            except ValueError:
                return value
        return value

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(
            [
                "enableStrictDiscoverParsing",
                "discoverRequestHeaders",
                "pagination",
                "discoverDataField",
                "enableDiscoverCode",
            ]
        )
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


class RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHTTPEnableStrictDiscoverParsingFalseDiscoverType(
    str, Enum, metaclass=utils.OpenEnumMeta
):
    r"""Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task."""

    HTTP = "http"
    JSON = "json"
    LIST = "list"
    NONE = "none"


class RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHTTPEnableStrictDiscoverParsingFalseDiscoverMethod(
    str, Enum, metaclass=utils.OpenEnumMeta
):
    # GET
    GET = "get"
    # POST
    POST = "post"
    # POST with Body
    POST_WITH_BODY = "post_with_body"
    # Other
    OTHER = "other"


class RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHTTPEnableStrictDiscoverParsingFalsePaginationTypedDict(
    TypedDict
):
    type: PaginationOptionsRestDiscoveryDiscoverTypeHTTPPagination


class RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHTTPEnableStrictDiscoverParsingFalsePagination(
    BaseModel
):
    type: PaginationOptionsRestDiscoveryDiscoverTypeHTTPPagination

    @field_serializer("type")
    def serialize_type(self, value):
        if isinstance(value, str):
            try:
                return models.PaginationOptionsRestDiscoveryDiscoverTypeHTTPPagination(
                    value
                )
            except ValueError:
                return value
        return value


class RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHTTPEnableStrictDiscoverParsingFalseTypedDict(
    TypedDict
):
    discover_type: RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHTTPEnableStrictDiscoverParsingFalseDiscoverType
    r"""Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task."""
    discover_url: str
    r"""URL to use for the Discover operation. Can be a constant URL, or a JavaScript expression to derive the URL."""
    discover_method: RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHTTPEnableStrictDiscoverParsingFalseDiscoverMethod
    enable_strict_discover_parsing: NotRequired[bool]
    r"""Explicitly set the discover response format. When disabled, best effort parsing is used."""
    discover_request_headers: NotRequired[
        List[ItemsTypeRestCollectMethodGetCollectRequestParamsTypedDict]
    ]
    pagination: NotRequired[
        RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHTTPEnableStrictDiscoverParsingFalsePaginationTypedDict
    ]
    discover_data_field: NotRequired[str]
    r"""Path to field in the response object that contains discovery results (ex: level1.name). Leave blank if the result is an array."""
    enable_discover_code: NotRequired[bool]


class RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHTTPEnableStrictDiscoverParsingFalse(
    BaseModel
):
    discover_type: Annotated[
        RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHTTPEnableStrictDiscoverParsingFalseDiscoverType,
        pydantic.Field(alias="discoverType"),
    ]
    r"""Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task."""

    discover_url: Annotated[str, pydantic.Field(alias="discoverUrl")]
    r"""URL to use for the Discover operation. Can be a constant URL, or a JavaScript expression to derive the URL."""

    discover_method: Annotated[
        RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHTTPEnableStrictDiscoverParsingFalseDiscoverMethod,
        pydantic.Field(alias="discoverMethod"),
    ]

    enable_strict_discover_parsing: Annotated[
        Optional[bool], pydantic.Field(alias="enableStrictDiscoverParsing")
    ] = None
    r"""Explicitly set the discover response format. When disabled, best effort parsing is used."""

    discover_request_headers: Annotated[
        Optional[List[ItemsTypeRestCollectMethodGetCollectRequestParams]],
        pydantic.Field(alias="discoverRequestHeaders"),
    ] = None

    pagination: Optional[
        RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHTTPEnableStrictDiscoverParsingFalsePagination
    ] = None

    discover_data_field: Annotated[
        Optional[str], pydantic.Field(alias="discoverDataField")
    ] = None
    r"""Path to field in the response object that contains discovery results (ex: level1.name). Leave blank if the result is an array."""

    enable_discover_code: Annotated[
        Optional[bool], pydantic.Field(alias="enableDiscoverCode")
    ] = None

    @field_serializer("discover_type")
    def serialize_discover_type(self, value):
        if isinstance(value, str):
            try:
                return models.RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHTTPEnableStrictDiscoverParsingFalseDiscoverType(
                    value
                )
            except ValueError:
                return value
        return value

    @field_serializer("discover_method")
    def serialize_discover_method(self, value):
        if isinstance(value, str):
            try:
                return models.RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHTTPEnableStrictDiscoverParsingFalseDiscoverMethod(
                    value
                )
            except ValueError:
                return value
        return value

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(
            [
                "enableStrictDiscoverParsing",
                "discoverRequestHeaders",
                "pagination",
                "discoverDataField",
                "enableDiscoverCode",
            ]
        )
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHTTPTypedDict = TypeAliasType(
    "RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHTTPTypedDict",
    Union[
        RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHTTPEnableStrictDiscoverParsingFalseTypedDict,
        RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHTTPEnableDiscoverCodeFalseTypedDict,
        RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHTTPEnableStrictDiscoverParsingTrueTypedDict,
        RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHTTPEnableDiscoverCodeTrueTypedDict,
        RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHTTPDiscoverMethodGetTypedDict,
        RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHTTPDiscoverMethodPostTypedDict,
        RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHTTPDiscoverMethodPostWithBodyTypedDict,
        RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHTTPDiscoverMethodOtherTypedDict,
    ],
)


class UnknownRestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHTTP(
    BaseModel
):
    r"""A RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHTTP variant the SDK doesn't recognize. Preserves the raw payload."""

    discover_method: Literal["UNKNOWN"] = "UNKNOWN"
    raw: Any
    is_unknown: Literal[True] = True

    model_config = ConfigDict(frozen=True)


_REST_AUTHENTICATION_LOGIN_GET_AUTH_TOKEN_FROM_HEADER_FALSE_REST_DISCOVERY_DISCOVER_TYPE_HTTP_VARIANTS: dict[
    str, Any
] = {
    "get": RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHTTPDiscoverMethodGet,
    "post": RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHTTPDiscoverMethodPost,
    "post_with_body": RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHTTPDiscoverMethodPostWithBody,
    "other": RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHTTPDiscoverMethodOther,
}


RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHTTP = Annotated[
    Union[
        RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHTTPDiscoverMethodGet,
        RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHTTPDiscoverMethodPost,
        RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHTTPDiscoverMethodPostWithBody,
        RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHTTPDiscoverMethodOther,
        UnknownRestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHTTP,
    ],
    BeforeValidator(
        partial(
            parse_open_union,
            disc_key="discoverMethod",
            variants=_REST_AUTHENTICATION_LOGIN_GET_AUTH_TOKEN_FROM_HEADER_FALSE_REST_DISCOVERY_DISCOVER_TYPE_HTTP_VARIANTS,
            unknown_cls=UnknownRestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHTTP,
            union_name="RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHTTP",
        )
    ),
]


RestAuthenticationLoginGetAuthTokenFromHeaderFalseDiscoveryTypedDict = TypeAliasType(
    "RestAuthenticationLoginGetAuthTokenFromHeaderFalseDiscoveryTypedDict",
    Union[
        RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeNoneTypedDict,
        RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeListTypedDict,
        RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeJSONTypedDict,
        RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHTTPTypedDict,
    ],
)


class UnknownRestAuthenticationLoginGetAuthTokenFromHeaderFalseDiscovery(BaseModel):
    r"""A RestAuthenticationLoginGetAuthTokenFromHeaderFalseDiscovery variant the SDK doesn't recognize. Preserves the raw payload."""

    discover_type: Literal["UNKNOWN"] = "UNKNOWN"
    raw: Any
    is_unknown: Literal[True] = True

    model_config = ConfigDict(frozen=True)


_REST_AUTHENTICATION_LOGIN_GET_AUTH_TOKEN_FROM_HEADER_FALSE_DISCOVERY_VARIANTS: dict[
    str, Any
] = {
    "http": RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHTTP,
    "json": RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeJSON,
    "list": RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeList,
    "none": RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeNone,
}


RestAuthenticationLoginGetAuthTokenFromHeaderFalseDiscovery = Annotated[
    Union[
        RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHTTP,
        RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeJSON,
        RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeList,
        RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeNone,
        UnknownRestAuthenticationLoginGetAuthTokenFromHeaderFalseDiscovery,
    ],
    BeforeValidator(
        partial(
            parse_open_union,
            disc_key="discoverType",
            variants=_REST_AUTHENTICATION_LOGIN_GET_AUTH_TOKEN_FROM_HEADER_FALSE_DISCOVERY_VARIANTS,
            unknown_cls=UnknownRestAuthenticationLoginGetAuthTokenFromHeaderFalseDiscovery,
            union_name="RestAuthenticationLoginGetAuthTokenFromHeaderFalseDiscovery",
        )
    ),
]


class RestAuthenticationLoginGetAuthTokenFromHeaderFalseCollectMethod(
    str, Enum, metaclass=utils.OpenEnumMeta
):
    # GET
    GET = "get"
    # POST
    POST = "post"
    # POST with Body
    POST_WITH_BODY = "post_with_body"
    # Other
    OTHER = "other"


class RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestPaginationTypeRequestPageTypedDict(
    TypedDict
):
    type: PaginationOptionsRestDiscoveryDiscoverTypeHTTPPagination
    page_field: str
    r"""Query string parameter that sets the page index to be returned. Example: /api/v1/query?term=cribl&page_size=100&page_number=0"""
    size_field: str
    r"""Query string parameter that sets the number of records retrieved per request. Example: /api/v1/query?term=cribl&page_size=100&page_number=0"""
    size: float
    r"""Maximum number of records to collect per page"""
    max_pages: float
    r"""Maximum number of pages to retrieve per collection task. Defaults to 50 pages. Set to 0 to retrieve all pages."""
    zero_indexed: bool
    r"""Enable to indicate that the first page in the requested data is at index 0. Disabled by default, which indicates index 1."""
    page: NotRequired[float]
    r"""Page number from which to start request. Defaults to undefined, which will start collection from the first page."""
    total_page_field: NotRequired[str]
    r"""Name of the attribute in the response that contains the total number of pages for the query"""
    total_record_field: NotRequired[str]
    r"""Name of the attribute in the response that contains the total number of records for the query"""


class RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestPaginationTypeRequestPage(
    BaseModel
):
    type: PaginationOptionsRestDiscoveryDiscoverTypeHTTPPagination

    page_field: Annotated[str, pydantic.Field(alias="pageField")]
    r"""Query string parameter that sets the page index to be returned. Example: /api/v1/query?term=cribl&page_size=100&page_number=0"""

    size_field: Annotated[str, pydantic.Field(alias="sizeField")]
    r"""Query string parameter that sets the number of records retrieved per request. Example: /api/v1/query?term=cribl&page_size=100&page_number=0"""

    size: float
    r"""Maximum number of records to collect per page"""

    max_pages: Annotated[float, pydantic.Field(alias="maxPages")]
    r"""Maximum number of pages to retrieve per collection task. Defaults to 50 pages. Set to 0 to retrieve all pages."""

    zero_indexed: Annotated[bool, pydantic.Field(alias="zeroIndexed")]
    r"""Enable to indicate that the first page in the requested data is at index 0. Disabled by default, which indicates index 1."""

    page: Optional[float] = None
    r"""Page number from which to start request. Defaults to undefined, which will start collection from the first page."""

    total_page_field: Annotated[
        Optional[str], pydantic.Field(alias="totalPageField")
    ] = None
    r"""Name of the attribute in the response that contains the total number of pages for the query"""

    total_record_field: Annotated[
        Optional[str], pydantic.Field(alias="totalRecordField")
    ] = None
    r"""Name of the attribute in the response that contains the total number of records for the query"""

    @field_serializer("type")
    def serialize_type(self, value):
        if isinstance(value, str):
            try:
                return models.PaginationOptionsRestDiscoveryDiscoverTypeHTTPPagination(
                    value
                )
            except ValueError:
                return value
        return value

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(["page", "totalPageField", "totalRecordField"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


class RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestPaginationTypeRequestOffsetTypedDict(
    TypedDict
):
    type: PaginationOptionsRestDiscoveryDiscoverTypeHTTPPagination
    offset_field: str
    r"""Query string parameter that sets the index from which to begin returning records. Example: /api/v1/query?term=cribl&limit=100&offset=0"""
    limit_field: str
    r"""Query string parameter that sets the number of records retrieved per request. Example: /api/v1/query?term=cribl&limit=100&offset=0"""
    limit: float
    r"""Maximum number of records to collect per request"""
    max_pages: float
    r"""Maximum number of pages to retrieve per collection task. Defaults to 50 pages. Set to 0 to retrieve all pages."""
    zero_indexed: bool
    r"""Enable to indicate that the first page in the requested data is at index 0. Disabled by default, which indicates index 1."""
    offset: NotRequired[float]
    r"""Offset index from which to start request. Defaults to undefined, which will start collection from the first record."""
    total_record_field: NotRequired[str]
    r"""Name of the attribute in the response that contains the total number of records for the query"""


class RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestPaginationTypeRequestOffset(
    BaseModel
):
    type: PaginationOptionsRestDiscoveryDiscoverTypeHTTPPagination

    offset_field: Annotated[str, pydantic.Field(alias="offsetField")]
    r"""Query string parameter that sets the index from which to begin returning records. Example: /api/v1/query?term=cribl&limit=100&offset=0"""

    limit_field: Annotated[str, pydantic.Field(alias="limitField")]
    r"""Query string parameter that sets the number of records retrieved per request. Example: /api/v1/query?term=cribl&limit=100&offset=0"""

    limit: float
    r"""Maximum number of records to collect per request"""

    max_pages: Annotated[float, pydantic.Field(alias="maxPages")]
    r"""Maximum number of pages to retrieve per collection task. Defaults to 50 pages. Set to 0 to retrieve all pages."""

    zero_indexed: Annotated[bool, pydantic.Field(alias="zeroIndexed")]
    r"""Enable to indicate that the first page in the requested data is at index 0. Disabled by default, which indicates index 1."""

    offset: Optional[float] = None
    r"""Offset index from which to start request. Defaults to undefined, which will start collection from the first record."""

    total_record_field: Annotated[
        Optional[str], pydantic.Field(alias="totalRecordField")
    ] = None
    r"""Name of the attribute in the response that contains the total number of records for the query"""

    @field_serializer("type")
    def serialize_type(self, value):
        if isinstance(value, str):
            try:
                return models.PaginationOptionsRestDiscoveryDiscoverTypeHTTPPagination(
                    value
                )
            except ValueError:
                return value
        return value

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(["offset", "totalRecordField"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


class RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestPaginationTypeResponseHeaderLinkTypedDict(
    TypedDict
):
    type: PaginationOptionsRestDiscoveryDiscoverTypeHTTPPagination
    next_relation_attribute: str
    r"""Relation name used in the link header that refers to the next page in the result set. Example: rel=\"next\" refers to the next page of results: <https://myHost/nextPage>; rel=\"next\" """
    max_pages: float
    r"""Maximum number of pages to retrieve per collection task. Defaults to 50 pages. Set to 0 to retrieve all pages."""
    cur_relation_attribute: NotRequired[str]
    r"""Relation name used in the link header that refers to the current result set. Example: rel=\"self\" refers to the current page of results: <https://myHost/curPage>; rel=\"self\" """


class RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestPaginationTypeResponseHeaderLink(
    BaseModel
):
    type: PaginationOptionsRestDiscoveryDiscoverTypeHTTPPagination

    next_relation_attribute: Annotated[
        str, pydantic.Field(alias="nextRelationAttribute")
    ]
    r"""Relation name used in the link header that refers to the next page in the result set. Example: rel=\"next\" refers to the next page of results: <https://myHost/nextPage>; rel=\"next\" """

    max_pages: Annotated[float, pydantic.Field(alias="maxPages")]
    r"""Maximum number of pages to retrieve per collection task. Defaults to 50 pages. Set to 0 to retrieve all pages."""

    cur_relation_attribute: Annotated[
        Optional[str], pydantic.Field(alias="curRelationAttribute")
    ] = None
    r"""Relation name used in the link header that refers to the current result set. Example: rel=\"self\" refers to the current page of results: <https://myHost/curPage>; rel=\"self\" """

    @field_serializer("type")
    def serialize_type(self, value):
        if isinstance(value, str):
            try:
                return models.PaginationOptionsRestDiscoveryDiscoverTypeHTTPPagination(
                    value
                )
            except ValueError:
                return value
        return value

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(["curRelationAttribute"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


class RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestPaginationTypeResponseHeaderTypedDict(
    TypedDict
):
    type: PaginationOptionsRestDiscoveryDiscoverTypeHTTPPagination
    attribute: List[str]
    r"""Names of attributes within the response that contain next-page information"""
    max_pages: float
    r"""Maximum number of pages to retrieve per collection task. Defaults to 50 pages. Set to 0 to retrieve all pages."""


class RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestPaginationTypeResponseHeader(
    BaseModel
):
    type: PaginationOptionsRestDiscoveryDiscoverTypeHTTPPagination

    attribute: List[str]
    r"""Names of attributes within the response that contain next-page information"""

    max_pages: Annotated[float, pydantic.Field(alias="maxPages")]
    r"""Maximum number of pages to retrieve per collection task. Defaults to 50 pages. Set to 0 to retrieve all pages."""

    @field_serializer("type")
    def serialize_type(self, value):
        if isinstance(value, str):
            try:
                return models.PaginationOptionsRestDiscoveryDiscoverTypeHTTPPagination(
                    value
                )
            except ValueError:
                return value
        return value


class RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestPaginationTypeResponseBodyTypedDict(
    TypedDict
):
    type: PaginationOptionsRestDiscoveryDiscoverTypeHTTPPagination
    attribute: List[str]
    r"""Names of attributes within the response that contain next-page information"""
    max_pages: float
    r"""Maximum number of pages to retrieve per collection task. Defaults to 50 pages. Set to 0 to retrieve all pages."""
    last_page_expr: NotRequired[str]
    r"""JavaScript expression used to determine when the last page has been reached. The values tested by this expression must be in the Response attributes section."""


class RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestPaginationTypeResponseBody(
    BaseModel
):
    type: PaginationOptionsRestDiscoveryDiscoverTypeHTTPPagination

    attribute: List[str]
    r"""Names of attributes within the response that contain next-page information"""

    max_pages: Annotated[float, pydantic.Field(alias="maxPages")]
    r"""Maximum number of pages to retrieve per collection task. Defaults to 50 pages. Set to 0 to retrieve all pages."""

    last_page_expr: Annotated[Optional[str], pydantic.Field(alias="lastPageExpr")] = (
        None
    )
    r"""JavaScript expression used to determine when the last page has been reached. The values tested by this expression must be in the Response attributes section."""

    @field_serializer("type")
    def serialize_type(self, value):
        if isinstance(value, str):
            try:
                return models.PaginationOptionsRestDiscoveryDiscoverTypeHTTPPagination(
                    value
                )
            except ValueError:
                return value
        return value

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(["lastPageExpr"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


class RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestPaginationTypeNoneTypedDict(
    TypedDict
):
    type: PaginationOptionsRestDiscoveryDiscoverTypeHTTPPagination


class RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestPaginationTypeNone(
    BaseModel
):
    type: PaginationOptionsRestDiscoveryDiscoverTypeHTTPPagination

    @field_serializer("type")
    def serialize_type(self, value):
        if isinstance(value, str):
            try:
                return models.PaginationOptionsRestDiscoveryDiscoverTypeHTTPPagination(
                    value
                )
            except ValueError:
                return value
        return value


RestAuthenticationLoginGetAuthTokenFromHeaderFalsePaginationUnionTypedDict = TypeAliasType(
    "RestAuthenticationLoginGetAuthTokenFromHeaderFalsePaginationUnionTypedDict",
    Union[
        RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestPaginationTypeNoneTypedDict,
        RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestPaginationTypeResponseHeaderTypedDict,
        RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestPaginationTypeResponseBodyTypedDict,
        RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestPaginationTypeResponseHeaderLinkTypedDict,
        RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestPaginationTypeRequestOffsetTypedDict,
        RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestPaginationTypeRequestPageTypedDict,
    ],
)


class UnknownRestAuthenticationLoginGetAuthTokenFromHeaderFalsePaginationUnion(
    BaseModel
):
    r"""A RestAuthenticationLoginGetAuthTokenFromHeaderFalsePaginationUnion variant the SDK doesn't recognize. Preserves the raw payload."""

    type: Literal["UNKNOWN"] = "UNKNOWN"
    raw: Any
    is_unknown: Literal[True] = True

    model_config = ConfigDict(frozen=True)


_REST_AUTHENTICATION_LOGIN_GET_AUTH_TOKEN_FROM_HEADER_FALSE_PAGINATION_UNION_VARIANTS: dict[
    str, Any
] = {
    "none": RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestPaginationTypeNone,
    "response_body": RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestPaginationTypeResponseBody,
    "response_header": RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestPaginationTypeResponseHeader,
    "response_header_link": RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestPaginationTypeResponseHeaderLink,
    "request_offset": RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestPaginationTypeRequestOffset,
    "request_page": RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestPaginationTypeRequestPage,
}


RestAuthenticationLoginGetAuthTokenFromHeaderFalsePaginationUnion = Annotated[
    Union[
        RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestPaginationTypeNone,
        RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestPaginationTypeResponseBody,
        RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestPaginationTypeResponseHeader,
        RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestPaginationTypeResponseHeaderLink,
        RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestPaginationTypeRequestOffset,
        RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestPaginationTypeRequestPage,
        UnknownRestAuthenticationLoginGetAuthTokenFromHeaderFalsePaginationUnion,
    ],
    BeforeValidator(
        partial(
            parse_open_union,
            disc_key="type",
            variants=_REST_AUTHENTICATION_LOGIN_GET_AUTH_TOKEN_FROM_HEADER_FALSE_PAGINATION_UNION_VARIANTS,
            unknown_cls=UnknownRestAuthenticationLoginGetAuthTokenFromHeaderFalsePaginationUnion,
            union_name="RestAuthenticationLoginGetAuthTokenFromHeaderFalsePaginationUnion",
        )
    ),
]


class RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestRetryRulesTypeBackoffEnableHeaderTrueTypedDict(
    TypedDict
):
    type: RetryTypeOptionsHealthCheckCollectorConfRetryRules
    r"""The algorithm to use when performing HTTP retries"""
    enable_header: NotRequired[bool]
    r"""Honor any Retry-After header that specifies a delay (in seconds) or a timestamp after which to retry the request. The delay is limited to the `Longest interval between retries (ms)` value, even if the Retry-After header specifies a longer delay. When disabled, all Retry-After headers are ignored."""
    retry_header_name: NotRequired[str]
    interval: NotRequired[float]
    r"""Time interval between a failed request and the first retry"""
    limit: NotRequired[float]
    r"""Maximum number of times to retry a failed HTTP request"""
    multiplier: NotRequired[float]
    r"""Base for exponential backoff. Example: base 2 means that retries will occur after 2, then 4, then 8 seconds, and so on."""
    max_interval_ms: NotRequired[float]
    codes: NotRequired[List[float]]
    r"""List of HTTP codes that trigger a retry. Leave empty to use the default list of 429 and 503."""
    retry_connect_timeout: NotRequired[bool]
    r"""Make a single retry attempt when a connection timeout (ETIMEDOUT) error occurs"""
    retry_connect_reset: NotRequired[bool]
    r"""Retry request when a connection reset (ECONNRESET) error occurs"""


class RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestRetryRulesTypeBackoffEnableHeaderTrue(
    BaseModel
):
    type: RetryTypeOptionsHealthCheckCollectorConfRetryRules
    r"""The algorithm to use when performing HTTP retries"""

    enable_header: Annotated[Optional[bool], pydantic.Field(alias="enableHeader")] = (
        None
    )
    r"""Honor any Retry-After header that specifies a delay (in seconds) or a timestamp after which to retry the request. The delay is limited to the `Longest interval between retries (ms)` value, even if the Retry-After header specifies a longer delay. When disabled, all Retry-After headers are ignored."""

    retry_header_name: Annotated[
        Optional[str], pydantic.Field(alias="retryHeaderName")
    ] = None

    interval: Optional[float] = None
    r"""Time interval between a failed request and the first retry"""

    limit: Optional[float] = None
    r"""Maximum number of times to retry a failed HTTP request"""

    multiplier: Optional[float] = None
    r"""Base for exponential backoff. Example: base 2 means that retries will occur after 2, then 4, then 8 seconds, and so on."""

    max_interval_ms: Annotated[
        Optional[float], pydantic.Field(alias="maxIntervalMs")
    ] = None

    codes: Optional[List[float]] = None
    r"""List of HTTP codes that trigger a retry. Leave empty to use the default list of 429 and 503."""

    retry_connect_timeout: Annotated[
        Optional[bool], pydantic.Field(alias="retryConnectTimeout")
    ] = None
    r"""Make a single retry attempt when a connection timeout (ETIMEDOUT) error occurs"""

    retry_connect_reset: Annotated[
        Optional[bool], pydantic.Field(alias="retryConnectReset")
    ] = None
    r"""Retry request when a connection reset (ECONNRESET) error occurs"""

    @field_serializer("type")
    def serialize_type(self, value):
        if isinstance(value, str):
            try:
                return models.RetryTypeOptionsHealthCheckCollectorConfRetryRules(value)
            except ValueError:
                return value
        return value

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(
            [
                "enableHeader",
                "retryHeaderName",
                "interval",
                "limit",
                "multiplier",
                "maxIntervalMs",
                "codes",
                "retryConnectTimeout",
                "retryConnectReset",
            ]
        )
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


class RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestRetryRulesTypeBackoffEnableHeaderFalseTypedDict(
    TypedDict
):
    type: RetryTypeOptionsHealthCheckCollectorConfRetryRules
    r"""The algorithm to use when performing HTTP retries"""
    enable_header: NotRequired[bool]
    r"""Honor any Retry-After header that specifies a delay (in seconds) or a timestamp after which to retry the request. The delay is limited to the `Longest interval between retries (ms)` value, even if the Retry-After header specifies a longer delay. When disabled, all Retry-After headers are ignored."""
    interval: NotRequired[float]
    r"""Time interval between a failed request and the first retry"""
    limit: NotRequired[float]
    r"""Maximum number of times to retry a failed HTTP request"""
    multiplier: NotRequired[float]
    r"""Base for exponential backoff. Example: base 2 means that retries will occur after 2, then 4, then 8 seconds, and so on."""
    max_interval_ms: NotRequired[float]
    codes: NotRequired[List[float]]
    r"""List of HTTP codes that trigger a retry. Leave empty to use the default list of 429 and 503."""
    retry_connect_timeout: NotRequired[bool]
    r"""Make a single retry attempt when a connection timeout (ETIMEDOUT) error occurs"""
    retry_connect_reset: NotRequired[bool]
    r"""Retry request when a connection reset (ECONNRESET) error occurs"""


class RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestRetryRulesTypeBackoffEnableHeaderFalse(
    BaseModel
):
    type: RetryTypeOptionsHealthCheckCollectorConfRetryRules
    r"""The algorithm to use when performing HTTP retries"""

    enable_header: Annotated[Optional[bool], pydantic.Field(alias="enableHeader")] = (
        None
    )
    r"""Honor any Retry-After header that specifies a delay (in seconds) or a timestamp after which to retry the request. The delay is limited to the `Longest interval between retries (ms)` value, even if the Retry-After header specifies a longer delay. When disabled, all Retry-After headers are ignored."""

    interval: Optional[float] = None
    r"""Time interval between a failed request and the first retry"""

    limit: Optional[float] = None
    r"""Maximum number of times to retry a failed HTTP request"""

    multiplier: Optional[float] = None
    r"""Base for exponential backoff. Example: base 2 means that retries will occur after 2, then 4, then 8 seconds, and so on."""

    max_interval_ms: Annotated[
        Optional[float], pydantic.Field(alias="maxIntervalMs")
    ] = None

    codes: Optional[List[float]] = None
    r"""List of HTTP codes that trigger a retry. Leave empty to use the default list of 429 and 503."""

    retry_connect_timeout: Annotated[
        Optional[bool], pydantic.Field(alias="retryConnectTimeout")
    ] = None
    r"""Make a single retry attempt when a connection timeout (ETIMEDOUT) error occurs"""

    retry_connect_reset: Annotated[
        Optional[bool], pydantic.Field(alias="retryConnectReset")
    ] = None
    r"""Retry request when a connection reset (ECONNRESET) error occurs"""

    @field_serializer("type")
    def serialize_type(self, value):
        if isinstance(value, str):
            try:
                return models.RetryTypeOptionsHealthCheckCollectorConfRetryRules(value)
            except ValueError:
                return value
        return value

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(
            [
                "enableHeader",
                "interval",
                "limit",
                "multiplier",
                "maxIntervalMs",
                "codes",
                "retryConnectTimeout",
                "retryConnectReset",
            ]
        )
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestRetryRulesTypeBackoffTypedDict = TypeAliasType(
    "RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestRetryRulesTypeBackoffTypedDict",
    Union[
        RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestRetryRulesTypeBackoffEnableHeaderFalseTypedDict,
        RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestRetryRulesTypeBackoffEnableHeaderTrueTypedDict,
    ],
)


RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestRetryRulesTypeBackoff = TypeAliasType(
    "RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestRetryRulesTypeBackoff",
    Union[
        RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestRetryRulesTypeBackoffEnableHeaderFalse,
        RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestRetryRulesTypeBackoffEnableHeaderTrue,
    ],
)


class RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestRetryRulesTypeStaticEnableHeaderTrueTypedDict(
    TypedDict
):
    type: RetryTypeOptionsHealthCheckCollectorConfRetryRules
    r"""The algorithm to use when performing HTTP retries"""
    enable_header: NotRequired[bool]
    r"""Honor any Retry-After header that specifies a delay (in seconds) or a timestamp after which to retry the request. The delay is limited to the `Longest interval between retries (ms)` value, even if the Retry-After header specifies a longer delay. When disabled, all Retry-After headers are ignored."""
    retry_header_name: NotRequired[str]
    interval: NotRequired[float]
    r"""Time interval between retries. Maximum allowed value is 20,000 ms (1/3 minute)."""
    limit: NotRequired[float]
    r"""Maximum number of times to retry a failed HTTP request"""
    codes: NotRequired[List[float]]
    r"""List of HTTP codes that trigger a retry. Leave empty to use the default list of 429 and 503."""
    retry_connect_timeout: NotRequired[bool]
    r"""Make a single retry attempt when a connection timeout (ETIMEDOUT) error occurs"""
    retry_connect_reset: NotRequired[bool]
    r"""Retry request when a connection reset (ECONNRESET) error occurs"""


class RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestRetryRulesTypeStaticEnableHeaderTrue(
    BaseModel
):
    type: RetryTypeOptionsHealthCheckCollectorConfRetryRules
    r"""The algorithm to use when performing HTTP retries"""

    enable_header: Annotated[Optional[bool], pydantic.Field(alias="enableHeader")] = (
        None
    )
    r"""Honor any Retry-After header that specifies a delay (in seconds) or a timestamp after which to retry the request. The delay is limited to the `Longest interval between retries (ms)` value, even if the Retry-After header specifies a longer delay. When disabled, all Retry-After headers are ignored."""

    retry_header_name: Annotated[
        Optional[str], pydantic.Field(alias="retryHeaderName")
    ] = None

    interval: Optional[float] = None
    r"""Time interval between retries. Maximum allowed value is 20,000 ms (1/3 minute)."""

    limit: Optional[float] = None
    r"""Maximum number of times to retry a failed HTTP request"""

    codes: Optional[List[float]] = None
    r"""List of HTTP codes that trigger a retry. Leave empty to use the default list of 429 and 503."""

    retry_connect_timeout: Annotated[
        Optional[bool], pydantic.Field(alias="retryConnectTimeout")
    ] = None
    r"""Make a single retry attempt when a connection timeout (ETIMEDOUT) error occurs"""

    retry_connect_reset: Annotated[
        Optional[bool], pydantic.Field(alias="retryConnectReset")
    ] = None
    r"""Retry request when a connection reset (ECONNRESET) error occurs"""

    @field_serializer("type")
    def serialize_type(self, value):
        if isinstance(value, str):
            try:
                return models.RetryTypeOptionsHealthCheckCollectorConfRetryRules(value)
            except ValueError:
                return value
        return value

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(
            [
                "enableHeader",
                "retryHeaderName",
                "interval",
                "limit",
                "codes",
                "retryConnectTimeout",
                "retryConnectReset",
            ]
        )
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


class RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestRetryRulesTypeStaticEnableHeaderFalseTypedDict(
    TypedDict
):
    type: RetryTypeOptionsHealthCheckCollectorConfRetryRules
    r"""The algorithm to use when performing HTTP retries"""
    enable_header: NotRequired[bool]
    r"""Honor any Retry-After header that specifies a delay (in seconds) or a timestamp after which to retry the request. The delay is limited to the `Longest interval between retries (ms)` value, even if the Retry-After header specifies a longer delay. When disabled, all Retry-After headers are ignored."""
    interval: NotRequired[float]
    r"""Time interval between retries. Maximum allowed value is 20,000 ms (1/3 minute)."""
    limit: NotRequired[float]
    r"""Maximum number of times to retry a failed HTTP request"""
    codes: NotRequired[List[float]]
    r"""List of HTTP codes that trigger a retry. Leave empty to use the default list of 429 and 503."""
    retry_connect_timeout: NotRequired[bool]
    r"""Make a single retry attempt when a connection timeout (ETIMEDOUT) error occurs"""
    retry_connect_reset: NotRequired[bool]
    r"""Retry request when a connection reset (ECONNRESET) error occurs"""


class RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestRetryRulesTypeStaticEnableHeaderFalse(
    BaseModel
):
    type: RetryTypeOptionsHealthCheckCollectorConfRetryRules
    r"""The algorithm to use when performing HTTP retries"""

    enable_header: Annotated[Optional[bool], pydantic.Field(alias="enableHeader")] = (
        None
    )
    r"""Honor any Retry-After header that specifies a delay (in seconds) or a timestamp after which to retry the request. The delay is limited to the `Longest interval between retries (ms)` value, even if the Retry-After header specifies a longer delay. When disabled, all Retry-After headers are ignored."""

    interval: Optional[float] = None
    r"""Time interval between retries. Maximum allowed value is 20,000 ms (1/3 minute)."""

    limit: Optional[float] = None
    r"""Maximum number of times to retry a failed HTTP request"""

    codes: Optional[List[float]] = None
    r"""List of HTTP codes that trigger a retry. Leave empty to use the default list of 429 and 503."""

    retry_connect_timeout: Annotated[
        Optional[bool], pydantic.Field(alias="retryConnectTimeout")
    ] = None
    r"""Make a single retry attempt when a connection timeout (ETIMEDOUT) error occurs"""

    retry_connect_reset: Annotated[
        Optional[bool], pydantic.Field(alias="retryConnectReset")
    ] = None
    r"""Retry request when a connection reset (ECONNRESET) error occurs"""

    @field_serializer("type")
    def serialize_type(self, value):
        if isinstance(value, str):
            try:
                return models.RetryTypeOptionsHealthCheckCollectorConfRetryRules(value)
            except ValueError:
                return value
        return value

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(
            [
                "enableHeader",
                "interval",
                "limit",
                "codes",
                "retryConnectTimeout",
                "retryConnectReset",
            ]
        )
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestRetryRulesTypeStaticTypedDict = TypeAliasType(
    "RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestRetryRulesTypeStaticTypedDict",
    Union[
        RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestRetryRulesTypeStaticEnableHeaderFalseTypedDict,
        RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestRetryRulesTypeStaticEnableHeaderTrueTypedDict,
    ],
)


RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestRetryRulesTypeStatic = TypeAliasType(
    "RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestRetryRulesTypeStatic",
    Union[
        RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestRetryRulesTypeStaticEnableHeaderFalse,
        RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestRetryRulesTypeStaticEnableHeaderTrue,
    ],
)


class RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestRetryRulesTypeNoneTypedDict(
    TypedDict
):
    type: RetryTypeOptionsHealthCheckCollectorConfRetryRules
    r"""The algorithm to use when performing HTTP retries"""


class RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestRetryRulesTypeNone(
    BaseModel
):
    type: RetryTypeOptionsHealthCheckCollectorConfRetryRules
    r"""The algorithm to use when performing HTTP retries"""

    @field_serializer("type")
    def serialize_type(self, value):
        if isinstance(value, str):
            try:
                return models.RetryTypeOptionsHealthCheckCollectorConfRetryRules(value)
            except ValueError:
                return value
        return value


RestAuthenticationLoginGetAuthTokenFromHeaderFalseRetryRulesTypedDict = TypeAliasType(
    "RestAuthenticationLoginGetAuthTokenFromHeaderFalseRetryRulesTypedDict",
    Union[
        RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestRetryRulesTypeNoneTypedDict,
        RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestRetryRulesTypeStaticTypedDict,
        RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestRetryRulesTypeBackoffTypedDict,
    ],
)


class UnknownRestAuthenticationLoginGetAuthTokenFromHeaderFalseRetryRules(BaseModel):
    r"""A RestAuthenticationLoginGetAuthTokenFromHeaderFalseRetryRules variant the SDK doesn't recognize. Preserves the raw payload."""

    type: Literal["UNKNOWN"] = "UNKNOWN"
    raw: Any
    is_unknown: Literal[True] = True

    model_config = ConfigDict(frozen=True)


_REST_AUTHENTICATION_LOGIN_GET_AUTH_TOKEN_FROM_HEADER_FALSE_RETRY_RULES_VARIANTS: dict[
    str, Any
] = {
    "none": RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestRetryRulesTypeNone,
    "static": RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestRetryRulesTypeStatic,
    "backoff": RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestRetryRulesTypeBackoff,
}


RestAuthenticationLoginGetAuthTokenFromHeaderFalseRetryRules = Annotated[
    Union[
        RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestRetryRulesTypeNone,
        RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestRetryRulesTypeStatic,
        RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestRetryRulesTypeBackoff,
        UnknownRestAuthenticationLoginGetAuthTokenFromHeaderFalseRetryRules,
    ],
    BeforeValidator(
        partial(
            parse_open_union,
            disc_key="type",
            variants=_REST_AUTHENTICATION_LOGIN_GET_AUTH_TOKEN_FROM_HEADER_FALSE_RETRY_RULES_VARIANTS,
            unknown_cls=UnknownRestAuthenticationLoginGetAuthTokenFromHeaderFalseRetryRules,
            union_name="RestAuthenticationLoginGetAuthTokenFromHeaderFalseRetryRules",
        )
    ),
]


class RestAuthenticationLoginGetAuthTokenFromHeaderFalseStateTrackingTypedDict(
    TypedDict
):
    enabled: NotRequired[bool]
    r"""Track collection progress between consecutive scheduled executions"""


class RestAuthenticationLoginGetAuthTokenFromHeaderFalseStateTracking(BaseModel):
    enabled: Optional[bool] = None
    r"""Track collection progress between consecutive scheduled executions"""

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(["enabled"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


class RestAuthenticationLoginGetAuthTokenFromHeaderFalseSchedulingTypedDict(TypedDict):
    state_tracking: NotRequired[
        RestAuthenticationLoginGetAuthTokenFromHeaderFalseStateTrackingTypedDict
    ]


class RestAuthenticationLoginGetAuthTokenFromHeaderFalseScheduling(BaseModel):
    state_tracking: Annotated[
        Optional[RestAuthenticationLoginGetAuthTokenFromHeaderFalseStateTracking],
        pydantic.Field(alias="stateTracking"),
    ] = None

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(["stateTracking"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


class RestAuthenticationLoginGetAuthTokenFromHeaderFalseTypedDict(TypedDict):
    authentication: RestAuthenticationLoginGetAuthTokenFromHeaderFalseAuthentication
    r"""Authentication method for Discover and Collect REST calls. You can specify API keybased authentication by adding the appropriate Collectheaders."""
    login_url: str
    r"""URL to use for login API call. This call is expected to be a POST."""
    username: str
    password: str
    login_body: str
    r"""Template for POST body to send with login request. ${username} and ${password} are used to specify location of these attributes in the message."""
    auth_header_expr: str
    r"""JavaScript expression used to compute the Authorization header to pass in Discover and Collect calls. The value ${token} is used to reference the token obtained from login."""
    collect_url: str
    r"""URL (constant or JavaScript expression) to use for the Collect operation"""
    collect_method: RestAuthenticationLoginGetAuthTokenFromHeaderFalseCollectMethod
    get_auth_token_from_header: NotRequired[bool]
    r"""Extract the auth token from the HTTP 'Authorization' response header instead of the standard JSON body of the login response"""
    token_resp_attribute: NotRequired[str]
    r"""Path to token attribute in login response body. Nested attributes are OK. Leave blank if the response content type is text/plain; the entire response body will be used to derive the authorization header."""
    auth_header_key: NotRequired[str]
    r"""Authorization header key to pass in Discover and Collect calls. Defaults to the literal name 'Authorization'."""
    auth_request_headers: NotRequired[
        List[ItemsTypeRestCollectMethodGetCollectRequestParamsTypedDict]
    ]
    discovery: NotRequired[
        RestAuthenticationLoginGetAuthTokenFromHeaderFalseDiscoveryTypedDict
    ]
    collect_request_headers: NotRequired[
        List[ItemsTypeRestCollectMethodGetCollectRequestParamsTypedDict]
    ]
    pagination: NotRequired[
        RestAuthenticationLoginGetAuthTokenFromHeaderFalsePaginationUnionTypedDict
    ]
    timeout: NotRequired[float]
    r"""HTTP request inactivity timeout. Use 0 to disable."""
    use_round_robin_dns: NotRequired[bool]
    r"""Use round-robin DNS lookup. Suitable when DNS server returns multiple addresses in sort order."""
    disable_time_filter: NotRequired[bool]
    r"""Disable Collector event time filtering when a date range is specified"""
    decode_url: NotRequired[bool]
    r"""Decode the URL before sending requests (including pagination requests)"""
    reject_unauthorized: NotRequired[bool]
    r"""Reject certificates that cannot be verified against a valid CA (such as self-signed certificates)"""
    capture_headers: NotRequired[bool]
    r"""Enable to add response headers to the resHeaders field under the __collectible object"""
    stop_on_empty_results: NotRequired[bool]
    r"""Stop pagination when the Event Breaker produces no events"""
    safe_headers: NotRequired[List[str]]
    r"""List of headers that are safe to log in plain text"""
    retry_rules: NotRequired[
        RestAuthenticationLoginGetAuthTokenFromHeaderFalseRetryRulesTypedDict
    ]
    scheduling: NotRequired[
        RestAuthenticationLoginGetAuthTokenFromHeaderFalseSchedulingTypedDict
    ]


class RestAuthenticationLoginGetAuthTokenFromHeaderFalse(BaseModel):
    authentication: RestAuthenticationLoginGetAuthTokenFromHeaderFalseAuthentication
    r"""Authentication method for Discover and Collect REST calls. You can specify API keybased authentication by adding the appropriate Collectheaders."""

    login_url: Annotated[str, pydantic.Field(alias="loginUrl")]
    r"""URL to use for login API call. This call is expected to be a POST."""

    username: str

    password: str

    login_body: Annotated[str, pydantic.Field(alias="loginBody")]
    r"""Template for POST body to send with login request. ${username} and ${password} are used to specify location of these attributes in the message."""

    auth_header_expr: Annotated[str, pydantic.Field(alias="authHeaderExpr")]
    r"""JavaScript expression used to compute the Authorization header to pass in Discover and Collect calls. The value ${token} is used to reference the token obtained from login."""

    collect_url: Annotated[str, pydantic.Field(alias="collectUrl")]
    r"""URL (constant or JavaScript expression) to use for the Collect operation"""

    collect_method: Annotated[
        RestAuthenticationLoginGetAuthTokenFromHeaderFalseCollectMethod,
        pydantic.Field(alias="collectMethod"),
    ]

    get_auth_token_from_header: Annotated[
        Optional[bool], pydantic.Field(alias="getAuthTokenFromHeader")
    ] = None
    r"""Extract the auth token from the HTTP 'Authorization' response header instead of the standard JSON body of the login response"""

    token_resp_attribute: Annotated[
        Optional[str], pydantic.Field(alias="tokenRespAttribute")
    ] = None
    r"""Path to token attribute in login response body. Nested attributes are OK. Leave blank if the response content type is text/plain; the entire response body will be used to derive the authorization header."""

    auth_header_key: Annotated[Optional[str], pydantic.Field(alias="authHeaderKey")] = (
        None
    )
    r"""Authorization header key to pass in Discover and Collect calls. Defaults to the literal name 'Authorization'."""

    auth_request_headers: Annotated[
        Optional[List[ItemsTypeRestCollectMethodGetCollectRequestParams]],
        pydantic.Field(alias="authRequestHeaders"),
    ] = None

    discovery: Optional[RestAuthenticationLoginGetAuthTokenFromHeaderFalseDiscovery] = (
        None
    )

    collect_request_headers: Annotated[
        Optional[List[ItemsTypeRestCollectMethodGetCollectRequestParams]],
        pydantic.Field(alias="collectRequestHeaders"),
    ] = None

    pagination: Optional[
        RestAuthenticationLoginGetAuthTokenFromHeaderFalsePaginationUnion
    ] = None

    timeout: Optional[float] = None
    r"""HTTP request inactivity timeout. Use 0 to disable."""

    use_round_robin_dns: Annotated[
        Optional[bool], pydantic.Field(alias="useRoundRobinDns")
    ] = None
    r"""Use round-robin DNS lookup. Suitable when DNS server returns multiple addresses in sort order."""

    disable_time_filter: Annotated[
        Optional[bool], pydantic.Field(alias="disableTimeFilter")
    ] = None
    r"""Disable Collector event time filtering when a date range is specified"""

    decode_url: Annotated[Optional[bool], pydantic.Field(alias="decodeUrl")] = None
    r"""Decode the URL before sending requests (including pagination requests)"""

    reject_unauthorized: Annotated[
        Optional[bool], pydantic.Field(alias="rejectUnauthorized")
    ] = None
    r"""Reject certificates that cannot be verified against a valid CA (such as self-signed certificates)"""

    capture_headers: Annotated[
        Optional[bool], pydantic.Field(alias="captureHeaders")
    ] = None
    r"""Enable to add response headers to the resHeaders field under the __collectible object"""

    stop_on_empty_results: Annotated[
        Optional[bool], pydantic.Field(alias="stopOnEmptyResults")
    ] = None
    r"""Stop pagination when the Event Breaker produces no events"""

    safe_headers: Annotated[
        Optional[List[str]], pydantic.Field(alias="safeHeaders")
    ] = None
    r"""List of headers that are safe to log in plain text"""

    retry_rules: Annotated[
        Optional[RestAuthenticationLoginGetAuthTokenFromHeaderFalseRetryRules],
        pydantic.Field(alias="retryRules"),
    ] = None

    scheduling: Annotated[
        Optional[RestAuthenticationLoginGetAuthTokenFromHeaderFalseScheduling],
        pydantic.Field(alias="__scheduling"),
    ] = None

    @field_serializer("authentication")
    def serialize_authentication(self, value):
        if isinstance(value, str):
            try:
                return models.RestAuthenticationLoginGetAuthTokenFromHeaderFalseAuthentication(
                    value
                )
            except ValueError:
                return value
        return value

    @field_serializer("collect_method")
    def serialize_collect_method(self, value):
        if isinstance(value, str):
            try:
                return models.RestAuthenticationLoginGetAuthTokenFromHeaderFalseCollectMethod(
                    value
                )
            except ValueError:
                return value
        return value

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(
            [
                "getAuthTokenFromHeader",
                "tokenRespAttribute",
                "authHeaderKey",
                "authRequestHeaders",
                "discovery",
                "collectRequestHeaders",
                "pagination",
                "timeout",
                "useRoundRobinDns",
                "disableTimeFilter",
                "decodeUrl",
                "rejectUnauthorized",
                "captureHeaders",
                "stopOnEmptyResults",
                "safeHeaders",
                "retryRules",
                "__scheduling",
            ]
        )
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


RestAuthenticationLoginTypedDict = TypeAliasType(
    "RestAuthenticationLoginTypedDict",
    Union[
        RestAuthenticationLoginGetAuthTokenFromHeaderTrueTypedDict,
        RestAuthenticationLoginGetAuthTokenFromHeaderFalseTypedDict,
    ],
)


RestAuthenticationLogin = TypeAliasType(
    "RestAuthenticationLogin",
    Union[
        RestAuthenticationLoginGetAuthTokenFromHeaderTrue,
        RestAuthenticationLoginGetAuthTokenFromHeaderFalse,
    ],
)


class RestAuthenticationBasicSecretAuthentication(
    str, Enum, metaclass=utils.OpenEnumMeta
):
    r"""Authentication method for Discover and Collect REST calls. You can specify API keybased authentication by adding the appropriate Collectheaders."""

    NONE = "none"
    BASIC = "basic"
    BASIC_SECRET = "basicSecret"
    LOGIN = "login"
    LOGIN_SECRET = "loginSecret"
    OAUTH = "oauth"
    OAUTH_SECRET = "oauthSecret"
    GOOGLE_OAUTH = "google_oauth"
    GOOGLE_OAUTH_SECRET = "google_oauthSecret"
    HMAC = "hmac"


class RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeNoneDiscoverType(
    str, Enum, metaclass=utils.OpenEnumMeta
):
    r"""Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task."""

    HTTP = "http"
    JSON = "json"
    LIST = "list"
    NONE = "none"


class RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeNoneTypedDict(TypedDict):
    discover_type: (
        RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeNoneDiscoverType
    )
    r"""Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task."""


class RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeNone(BaseModel):
    discover_type: Annotated[
        RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeNoneDiscoverType,
        pydantic.Field(alias="discoverType"),
    ]
    r"""Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task."""

    @field_serializer("discover_type")
    def serialize_discover_type(self, value):
        if isinstance(value, str):
            try:
                return models.RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeNoneDiscoverType(
                    value
                )
            except ValueError:
                return value
        return value


class RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeListDiscoverType(
    str, Enum, metaclass=utils.OpenEnumMeta
):
    r"""Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task."""

    HTTP = "http"
    JSON = "json"
    LIST = "list"
    NONE = "none"


class RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeListTypedDict(TypedDict):
    discover_type: (
        RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeListDiscoverType
    )
    r"""Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task."""
    item_list: List[str]
    r"""Comma-separated list of items to return from the Discover task. Each item returned generates a Collect task and can be referenced using `${id}` in the Collect URL, headers, or parameters."""


class RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeList(BaseModel):
    discover_type: Annotated[
        RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeListDiscoverType,
        pydantic.Field(alias="discoverType"),
    ]
    r"""Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task."""

    item_list: Annotated[List[str], pydantic.Field(alias="itemList")]
    r"""Comma-separated list of items to return from the Discover task. Each item returned generates a Collect task and can be referenced using `${id}` in the Collect URL, headers, or parameters."""

    @field_serializer("discover_type")
    def serialize_discover_type(self, value):
        if isinstance(value, str):
            try:
                return models.RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeListDiscoverType(
                    value
                )
            except ValueError:
                return value
        return value


class RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeJSONDiscoverType(
    str, Enum, metaclass=utils.OpenEnumMeta
):
    r"""Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task."""

    HTTP = "http"
    JSON = "json"
    LIST = "list"
    NONE = "none"


class RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeJSONTypedDict(TypedDict):
    discover_type: (
        RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeJSONDiscoverType
    )
    r"""Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task."""
    manual_discover_result: str
    r"""Allows hard-coding the Discover result. Must be a JSON object or array. Works with Discover data field."""
    discover_data_field: NotRequired[str]
    r"""Within the response JSON, the name of the field to pull results from, typically a JSON array. Leave blank if the result itself is an array of values. Sample entry: items, json: { items: [{id: 'first'},{id: 'second'}] }"""


class RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeJSON(BaseModel):
    discover_type: Annotated[
        RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeJSONDiscoverType,
        pydantic.Field(alias="discoverType"),
    ]
    r"""Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task."""

    manual_discover_result: Annotated[str, pydantic.Field(alias="manualDiscoverResult")]
    r"""Allows hard-coding the Discover result. Must be a JSON object or array. Works with Discover data field."""

    discover_data_field: Annotated[
        Optional[str], pydantic.Field(alias="discoverDataField")
    ] = None
    r"""Within the response JSON, the name of the field to pull results from, typically a JSON array. Leave blank if the result itself is an array of values. Sample entry: items, json: { items: [{id: 'first'},{id: 'second'}] }"""

    @field_serializer("discover_type")
    def serialize_discover_type(self, value):
        if isinstance(value, str):
            try:
                return models.RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeJSONDiscoverType(
                    value
                )
            except ValueError:
                return value
        return value

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(["discoverDataField"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


class RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHTTPDiscoverMethodOtherDiscoverMethod(
    str, Enum, metaclass=utils.OpenEnumMeta
):
    # GET
    GET = "get"
    # POST
    POST = "post"
    # POST with Body
    POST_WITH_BODY = "post_with_body"
    # Other
    OTHER = "other"


class RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHTTPDiscoverMethodOtherDiscoverType(
    str, Enum, metaclass=utils.OpenEnumMeta
):
    r"""Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task."""

    HTTP = "http"
    JSON = "json"
    LIST = "list"
    NONE = "none"


class RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHTTPDiscoverMethodOtherPaginationTypedDict(
    TypedDict
):
    type: PaginationOptionsRestDiscoveryDiscoverTypeHTTPPagination


class RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHTTPDiscoverMethodOtherPagination(
    BaseModel
):
    type: PaginationOptionsRestDiscoveryDiscoverTypeHTTPPagination

    @field_serializer("type")
    def serialize_type(self, value):
        if isinstance(value, str):
            try:
                return models.PaginationOptionsRestDiscoveryDiscoverTypeHTTPPagination(
                    value
                )
            except ValueError:
                return value
        return value


class RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHTTPDiscoverMethodOtherTypedDict(
    TypedDict
):
    discover_method: RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHTTPDiscoverMethodOtherDiscoverMethod
    discover_verb: str
    r"""Custom HTTP method to use for the Discover operation"""
    discover_type: RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHTTPDiscoverMethodOtherDiscoverType
    r"""Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task."""
    discover_url: str
    r"""URL to use for the Discover operation. Can be a constant URL, or a JavaScript expression to derive the URL."""
    discover_body: NotRequired[str]
    r"""Template for body to send with the discover request"""
    discover_request_params: NotRequired[
        List[ItemsTypeRestCollectMethodGetCollectRequestParamsTypedDict]
    ]
    discover_request_headers: NotRequired[
        List[ItemsTypeRestCollectMethodGetCollectRequestParamsTypedDict]
    ]
    pagination: NotRequired[
        RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHTTPDiscoverMethodOtherPaginationTypedDict
    ]
    discover_data_field: NotRequired[str]
    r"""Path to field in the response object that contains discovery results (ex: level1.name). Leave blank if the result is an array."""
    enable_strict_discover_parsing: NotRequired[bool]
    r"""Explicitly set the discover response format. When disabled, best effort parsing is used."""
    enable_discover_code: NotRequired[bool]


class RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHTTPDiscoverMethodOther(
    BaseModel
):
    discover_method: Annotated[
        RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHTTPDiscoverMethodOtherDiscoverMethod,
        pydantic.Field(alias="discoverMethod"),
    ]

    discover_verb: Annotated[str, pydantic.Field(alias="discoverVerb")]
    r"""Custom HTTP method to use for the Discover operation"""

    discover_type: Annotated[
        RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHTTPDiscoverMethodOtherDiscoverType,
        pydantic.Field(alias="discoverType"),
    ]
    r"""Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task."""

    discover_url: Annotated[str, pydantic.Field(alias="discoverUrl")]
    r"""URL to use for the Discover operation. Can be a constant URL, or a JavaScript expression to derive the URL."""

    discover_body: Annotated[Optional[str], pydantic.Field(alias="discoverBody")] = None
    r"""Template for body to send with the discover request"""

    discover_request_params: Annotated[
        Optional[List[ItemsTypeRestCollectMethodGetCollectRequestParams]],
        pydantic.Field(alias="discoverRequestParams"),
    ] = None

    discover_request_headers: Annotated[
        Optional[List[ItemsTypeRestCollectMethodGetCollectRequestParams]],
        pydantic.Field(alias="discoverRequestHeaders"),
    ] = None

    pagination: Optional[
        RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHTTPDiscoverMethodOtherPagination
    ] = None

    discover_data_field: Annotated[
        Optional[str], pydantic.Field(alias="discoverDataField")
    ] = None
    r"""Path to field in the response object that contains discovery results (ex: level1.name). Leave blank if the result is an array."""

    enable_strict_discover_parsing: Annotated[
        Optional[bool], pydantic.Field(alias="enableStrictDiscoverParsing")
    ] = None
    r"""Explicitly set the discover response format. When disabled, best effort parsing is used."""

    enable_discover_code: Annotated[
        Optional[bool], pydantic.Field(alias="enableDiscoverCode")
    ] = None

    @field_serializer("discover_method")
    def serialize_discover_method(self, value):
        if isinstance(value, str):
            try:
                return models.RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHTTPDiscoverMethodOtherDiscoverMethod(
                    value
                )
            except ValueError:
                return value
        return value

    @field_serializer("discover_type")
    def serialize_discover_type(self, value):
        if isinstance(value, str):
            try:
                return models.RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHTTPDiscoverMethodOtherDiscoverType(
                    value
                )
            except ValueError:
                return value
        return value

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(
            [
                "discoverBody",
                "discoverRequestParams",
                "discoverRequestHeaders",
                "pagination",
                "discoverDataField",
                "enableStrictDiscoverParsing",
                "enableDiscoverCode",
            ]
        )
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


class RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHTTPDiscoverMethodPostWithBodyDiscoverMethod(
    str, Enum, metaclass=utils.OpenEnumMeta
):
    # GET
    GET = "get"
    # POST
    POST = "post"
    # POST with Body
    POST_WITH_BODY = "post_with_body"
    # Other
    OTHER = "other"


class RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHTTPDiscoverMethodPostWithBodyDiscoverType(
    str, Enum, metaclass=utils.OpenEnumMeta
):
    r"""Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task."""

    HTTP = "http"
    JSON = "json"
    LIST = "list"
    NONE = "none"


class RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHTTPDiscoverMethodPostWithBodyPaginationTypedDict(
    TypedDict
):
    type: PaginationOptionsRestDiscoveryDiscoverTypeHTTPPagination


class RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHTTPDiscoverMethodPostWithBodyPagination(
    BaseModel
):
    type: PaginationOptionsRestDiscoveryDiscoverTypeHTTPPagination

    @field_serializer("type")
    def serialize_type(self, value):
        if isinstance(value, str):
            try:
                return models.PaginationOptionsRestDiscoveryDiscoverTypeHTTPPagination(
                    value
                )
            except ValueError:
                return value
        return value


class RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHTTPDiscoverMethodPostWithBodyTypedDict(
    TypedDict
):
    discover_method: RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHTTPDiscoverMethodPostWithBodyDiscoverMethod
    discover_body: str
    r"""Template for POST body to send with the discover request. To reference global variables or functions, use template parameters: `{ myVar: ${C.vars.myVar}, secret: ${C.Secret('mySecret','text').value} }`"""
    discover_type: RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHTTPDiscoverMethodPostWithBodyDiscoverType
    r"""Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task."""
    discover_url: str
    r"""URL to use for the Discover operation. Can be a constant URL, or a JavaScript expression to derive the URL."""
    discover_request_headers: NotRequired[
        List[ItemsTypeRestCollectMethodGetCollectRequestParamsTypedDict]
    ]
    pagination: NotRequired[
        RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHTTPDiscoverMethodPostWithBodyPaginationTypedDict
    ]
    discover_data_field: NotRequired[str]
    r"""Path to field in the response object that contains discovery results (ex: level1.name). Leave blank if the result is an array."""
    enable_strict_discover_parsing: NotRequired[bool]
    r"""Explicitly set the discover response format. When disabled, best effort parsing is used."""
    enable_discover_code: NotRequired[bool]


class RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHTTPDiscoverMethodPostWithBody(
    BaseModel
):
    discover_method: Annotated[
        RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHTTPDiscoverMethodPostWithBodyDiscoverMethod,
        pydantic.Field(alias="discoverMethod"),
    ]

    discover_body: Annotated[str, pydantic.Field(alias="discoverBody")]
    r"""Template for POST body to send with the discover request. To reference global variables or functions, use template parameters: `{ myVar: ${C.vars.myVar}, secret: ${C.Secret('mySecret','text').value} }`"""

    discover_type: Annotated[
        RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHTTPDiscoverMethodPostWithBodyDiscoverType,
        pydantic.Field(alias="discoverType"),
    ]
    r"""Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task."""

    discover_url: Annotated[str, pydantic.Field(alias="discoverUrl")]
    r"""URL to use for the Discover operation. Can be a constant URL, or a JavaScript expression to derive the URL."""

    discover_request_headers: Annotated[
        Optional[List[ItemsTypeRestCollectMethodGetCollectRequestParams]],
        pydantic.Field(alias="discoverRequestHeaders"),
    ] = None

    pagination: Optional[
        RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHTTPDiscoverMethodPostWithBodyPagination
    ] = None

    discover_data_field: Annotated[
        Optional[str], pydantic.Field(alias="discoverDataField")
    ] = None
    r"""Path to field in the response object that contains discovery results (ex: level1.name). Leave blank if the result is an array."""

    enable_strict_discover_parsing: Annotated[
        Optional[bool], pydantic.Field(alias="enableStrictDiscoverParsing")
    ] = None
    r"""Explicitly set the discover response format. When disabled, best effort parsing is used."""

    enable_discover_code: Annotated[
        Optional[bool], pydantic.Field(alias="enableDiscoverCode")
    ] = None

    @field_serializer("discover_method")
    def serialize_discover_method(self, value):
        if isinstance(value, str):
            try:
                return models.RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHTTPDiscoverMethodPostWithBodyDiscoverMethod(
                    value
                )
            except ValueError:
                return value
        return value

    @field_serializer("discover_type")
    def serialize_discover_type(self, value):
        if isinstance(value, str):
            try:
                return models.RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHTTPDiscoverMethodPostWithBodyDiscoverType(
                    value
                )
            except ValueError:
                return value
        return value

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(
            [
                "discoverRequestHeaders",
                "pagination",
                "discoverDataField",
                "enableStrictDiscoverParsing",
                "enableDiscoverCode",
            ]
        )
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


class RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHTTPDiscoverMethodPostDiscoverMethod(
    str, Enum, metaclass=utils.OpenEnumMeta
):
    # GET
    GET = "get"
    # POST
    POST = "post"
    # POST with Body
    POST_WITH_BODY = "post_with_body"
    # Other
    OTHER = "other"


class RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHTTPDiscoverMethodPostDiscoverType(
    str, Enum, metaclass=utils.OpenEnumMeta
):
    r"""Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task."""

    HTTP = "http"
    JSON = "json"
    LIST = "list"
    NONE = "none"


class RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHTTPDiscoverMethodPostPaginationTypedDict(
    TypedDict
):
    type: PaginationOptionsRestDiscoveryDiscoverTypeHTTPPagination


class RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHTTPDiscoverMethodPostPagination(
    BaseModel
):
    type: PaginationOptionsRestDiscoveryDiscoverTypeHTTPPagination

    @field_serializer("type")
    def serialize_type(self, value):
        if isinstance(value, str):
            try:
                return models.PaginationOptionsRestDiscoveryDiscoverTypeHTTPPagination(
                    value
                )
            except ValueError:
                return value
        return value


class RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHTTPDiscoverMethodPostTypedDict(
    TypedDict
):
    discover_method: RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHTTPDiscoverMethodPostDiscoverMethod
    discover_type: RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHTTPDiscoverMethodPostDiscoverType
    r"""Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task."""
    discover_url: str
    r"""URL to use for the Discover operation. Can be a constant URL, or a JavaScript expression to derive the URL."""
    discover_request_params: NotRequired[
        List[ItemsTypeRestCollectMethodGetCollectRequestParamsTypedDict]
    ]
    discover_request_headers: NotRequired[
        List[ItemsTypeRestCollectMethodGetCollectRequestParamsTypedDict]
    ]
    pagination: NotRequired[
        RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHTTPDiscoverMethodPostPaginationTypedDict
    ]
    discover_data_field: NotRequired[str]
    r"""Path to field in the response object that contains discovery results (ex: level1.name). Leave blank if the result is an array."""
    enable_strict_discover_parsing: NotRequired[bool]
    r"""Explicitly set the discover response format. When disabled, best effort parsing is used."""
    enable_discover_code: NotRequired[bool]


class RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHTTPDiscoverMethodPost(
    BaseModel
):
    discover_method: Annotated[
        RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHTTPDiscoverMethodPostDiscoverMethod,
        pydantic.Field(alias="discoverMethod"),
    ]

    discover_type: Annotated[
        RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHTTPDiscoverMethodPostDiscoverType,
        pydantic.Field(alias="discoverType"),
    ]
    r"""Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task."""

    discover_url: Annotated[str, pydantic.Field(alias="discoverUrl")]
    r"""URL to use for the Discover operation. Can be a constant URL, or a JavaScript expression to derive the URL."""

    discover_request_params: Annotated[
        Optional[List[ItemsTypeRestCollectMethodGetCollectRequestParams]],
        pydantic.Field(alias="discoverRequestParams"),
    ] = None

    discover_request_headers: Annotated[
        Optional[List[ItemsTypeRestCollectMethodGetCollectRequestParams]],
        pydantic.Field(alias="discoverRequestHeaders"),
    ] = None

    pagination: Optional[
        RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHTTPDiscoverMethodPostPagination
    ] = None

    discover_data_field: Annotated[
        Optional[str], pydantic.Field(alias="discoverDataField")
    ] = None
    r"""Path to field in the response object that contains discovery results (ex: level1.name). Leave blank if the result is an array."""

    enable_strict_discover_parsing: Annotated[
        Optional[bool], pydantic.Field(alias="enableStrictDiscoverParsing")
    ] = None
    r"""Explicitly set the discover response format. When disabled, best effort parsing is used."""

    enable_discover_code: Annotated[
        Optional[bool], pydantic.Field(alias="enableDiscoverCode")
    ] = None

    @field_serializer("discover_method")
    def serialize_discover_method(self, value):
        if isinstance(value, str):
            try:
                return models.RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHTTPDiscoverMethodPostDiscoverMethod(
                    value
                )
            except ValueError:
                return value
        return value

    @field_serializer("discover_type")
    def serialize_discover_type(self, value):
        if isinstance(value, str):
            try:
                return models.RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHTTPDiscoverMethodPostDiscoverType(
                    value
                )
            except ValueError:
                return value
        return value

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(
            [
                "discoverRequestParams",
                "discoverRequestHeaders",
                "pagination",
                "discoverDataField",
                "enableStrictDiscoverParsing",
                "enableDiscoverCode",
            ]
        )
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


class RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHTTPDiscoverMethodGetDiscoverMethod(
    str, Enum, metaclass=utils.OpenEnumMeta
):
    # GET
    GET = "get"
    # POST
    POST = "post"
    # POST with Body
    POST_WITH_BODY = "post_with_body"
    # Other
    OTHER = "other"


class RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHTTPDiscoverMethodGetDiscoverType(
    str, Enum, metaclass=utils.OpenEnumMeta
):
    r"""Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task."""

    HTTP = "http"
    JSON = "json"
    LIST = "list"
    NONE = "none"


class RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHTTPDiscoverMethodGetPaginationTypedDict(
    TypedDict
):
    type: PaginationOptionsRestDiscoveryDiscoverTypeHTTPPagination


class RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHTTPDiscoverMethodGetPagination(
    BaseModel
):
    type: PaginationOptionsRestDiscoveryDiscoverTypeHTTPPagination

    @field_serializer("type")
    def serialize_type(self, value):
        if isinstance(value, str):
            try:
                return models.PaginationOptionsRestDiscoveryDiscoverTypeHTTPPagination(
                    value
                )
            except ValueError:
                return value
        return value


class RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHTTPDiscoverMethodGetTypedDict(
    TypedDict
):
    discover_method: RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHTTPDiscoverMethodGetDiscoverMethod
    discover_type: RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHTTPDiscoverMethodGetDiscoverType
    r"""Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task."""
    discover_url: str
    r"""URL to use for the Discover operation. Can be a constant URL, or a JavaScript expression to derive the URL."""
    discover_request_params: NotRequired[
        List[ItemsTypeRestCollectMethodGetCollectRequestParamsTypedDict]
    ]
    discover_request_headers: NotRequired[
        List[ItemsTypeRestCollectMethodGetCollectRequestParamsTypedDict]
    ]
    pagination: NotRequired[
        RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHTTPDiscoverMethodGetPaginationTypedDict
    ]
    discover_data_field: NotRequired[str]
    r"""Path to field in the response object that contains discovery results (ex: level1.name). Leave blank if the result is an array."""
    enable_strict_discover_parsing: NotRequired[bool]
    r"""Explicitly set the discover response format. When disabled, best effort parsing is used."""
    enable_discover_code: NotRequired[bool]


class RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHTTPDiscoverMethodGet(
    BaseModel
):
    discover_method: Annotated[
        RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHTTPDiscoverMethodGetDiscoverMethod,
        pydantic.Field(alias="discoverMethod"),
    ]

    discover_type: Annotated[
        RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHTTPDiscoverMethodGetDiscoverType,
        pydantic.Field(alias="discoverType"),
    ]
    r"""Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task."""

    discover_url: Annotated[str, pydantic.Field(alias="discoverUrl")]
    r"""URL to use for the Discover operation. Can be a constant URL, or a JavaScript expression to derive the URL."""

    discover_request_params: Annotated[
        Optional[List[ItemsTypeRestCollectMethodGetCollectRequestParams]],
        pydantic.Field(alias="discoverRequestParams"),
    ] = None

    discover_request_headers: Annotated[
        Optional[List[ItemsTypeRestCollectMethodGetCollectRequestParams]],
        pydantic.Field(alias="discoverRequestHeaders"),
    ] = None

    pagination: Optional[
        RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHTTPDiscoverMethodGetPagination
    ] = None

    discover_data_field: Annotated[
        Optional[str], pydantic.Field(alias="discoverDataField")
    ] = None
    r"""Path to field in the response object that contains discovery results (ex: level1.name). Leave blank if the result is an array."""

    enable_strict_discover_parsing: Annotated[
        Optional[bool], pydantic.Field(alias="enableStrictDiscoverParsing")
    ] = None
    r"""Explicitly set the discover response format. When disabled, best effort parsing is used."""

    enable_discover_code: Annotated[
        Optional[bool], pydantic.Field(alias="enableDiscoverCode")
    ] = None

    @field_serializer("discover_method")
    def serialize_discover_method(self, value):
        if isinstance(value, str):
            try:
                return models.RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHTTPDiscoverMethodGetDiscoverMethod(
                    value
                )
            except ValueError:
                return value
        return value

    @field_serializer("discover_type")
    def serialize_discover_type(self, value):
        if isinstance(value, str):
            try:
                return models.RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHTTPDiscoverMethodGetDiscoverType(
                    value
                )
            except ValueError:
                return value
        return value

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(
            [
                "discoverRequestParams",
                "discoverRequestHeaders",
                "pagination",
                "discoverDataField",
                "enableStrictDiscoverParsing",
                "enableDiscoverCode",
            ]
        )
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


class RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHTTPEnableDiscoverCodeTrueDiscoverType(
    str, Enum, metaclass=utils.OpenEnumMeta
):
    r"""Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task."""

    HTTP = "http"
    JSON = "json"
    LIST = "list"
    NONE = "none"


class RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHTTPEnableDiscoverCodeTrueDiscoverMethod(
    str, Enum, metaclass=utils.OpenEnumMeta
):
    # GET
    GET = "get"
    # POST
    POST = "post"
    # POST with Body
    POST_WITH_BODY = "post_with_body"
    # Other
    OTHER = "other"


class RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHTTPEnableDiscoverCodeTruePaginationTypedDict(
    TypedDict
):
    type: PaginationOptionsRestDiscoveryDiscoverTypeHTTPPagination


class RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHTTPEnableDiscoverCodeTruePagination(
    BaseModel
):
    type: PaginationOptionsRestDiscoveryDiscoverTypeHTTPPagination

    @field_serializer("type")
    def serialize_type(self, value):
        if isinstance(value, str):
            try:
                return models.PaginationOptionsRestDiscoveryDiscoverTypeHTTPPagination(
                    value
                )
            except ValueError:
                return value
        return value


class RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHTTPEnableDiscoverCodeTrueTypedDict(
    TypedDict
):
    discover_type: RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHTTPEnableDiscoverCodeTrueDiscoverType
    r"""Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task."""
    discover_url: str
    r"""URL to use for the Discover operation. Can be a constant URL, or a JavaScript expression to derive the URL."""
    discover_method: RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHTTPEnableDiscoverCodeTrueDiscoverMethod
    enable_discover_code: NotRequired[bool]
    format_result_code: NotRequired[str]
    r"""Custom JavaScript code to format the discover result through the __e variable which is a JSON object or array containing the original discover results. The object or array passed should be manipulated to contain the desired discover results, i.e.: __e['myResult'] = [{lat: -1.1234, long: 2.345, zip: 11111},{lat: -1.235, long 2.346, zip: 22222}] or ['11111','22222']. Caution: This function is evaluated in an unprotected context, allowing you to execute almost any JavaScript code."""
    discover_request_headers: NotRequired[
        List[ItemsTypeRestCollectMethodGetCollectRequestParamsTypedDict]
    ]
    pagination: NotRequired[
        RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHTTPEnableDiscoverCodeTruePaginationTypedDict
    ]
    discover_data_field: NotRequired[str]
    r"""Path to field in the response object that contains discovery results (ex: level1.name). Leave blank if the result is an array."""
    enable_strict_discover_parsing: NotRequired[bool]
    r"""Explicitly set the discover response format. When disabled, best effort parsing is used."""


class RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHTTPEnableDiscoverCodeTrue(
    BaseModel
):
    discover_type: Annotated[
        RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHTTPEnableDiscoverCodeTrueDiscoverType,
        pydantic.Field(alias="discoverType"),
    ]
    r"""Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task."""

    discover_url: Annotated[str, pydantic.Field(alias="discoverUrl")]
    r"""URL to use for the Discover operation. Can be a constant URL, or a JavaScript expression to derive the URL."""

    discover_method: Annotated[
        RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHTTPEnableDiscoverCodeTrueDiscoverMethod,
        pydantic.Field(alias="discoverMethod"),
    ]

    enable_discover_code: Annotated[
        Optional[bool], pydantic.Field(alias="enableDiscoverCode")
    ] = None

    format_result_code: Annotated[
        Optional[str], pydantic.Field(alias="formatResultCode")
    ] = None
    r"""Custom JavaScript code to format the discover result through the __e variable which is a JSON object or array containing the original discover results. The object or array passed should be manipulated to contain the desired discover results, i.e.: __e['myResult'] = [{lat: -1.1234, long: 2.345, zip: 11111},{lat: -1.235, long 2.346, zip: 22222}] or ['11111','22222']. Caution: This function is evaluated in an unprotected context, allowing you to execute almost any JavaScript code."""

    discover_request_headers: Annotated[
        Optional[List[ItemsTypeRestCollectMethodGetCollectRequestParams]],
        pydantic.Field(alias="discoverRequestHeaders"),
    ] = None

    pagination: Optional[
        RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHTTPEnableDiscoverCodeTruePagination
    ] = None

    discover_data_field: Annotated[
        Optional[str], pydantic.Field(alias="discoverDataField")
    ] = None
    r"""Path to field in the response object that contains discovery results (ex: level1.name). Leave blank if the result is an array."""

    enable_strict_discover_parsing: Annotated[
        Optional[bool], pydantic.Field(alias="enableStrictDiscoverParsing")
    ] = None
    r"""Explicitly set the discover response format. When disabled, best effort parsing is used."""

    @field_serializer("discover_type")
    def serialize_discover_type(self, value):
        if isinstance(value, str):
            try:
                return models.RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHTTPEnableDiscoverCodeTrueDiscoverType(
                    value
                )
            except ValueError:
                return value
        return value

    @field_serializer("discover_method")
    def serialize_discover_method(self, value):
        if isinstance(value, str):
            try:
                return models.RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHTTPEnableDiscoverCodeTrueDiscoverMethod(
                    value
                )
            except ValueError:
                return value
        return value

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(
            [
                "enableDiscoverCode",
                "formatResultCode",
                "discoverRequestHeaders",
                "pagination",
                "discoverDataField",
                "enableStrictDiscoverParsing",
            ]
        )
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


class RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHTTPEnableDiscoverCodeFalseDiscoverType(
    str, Enum, metaclass=utils.OpenEnumMeta
):
    r"""Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task."""

    HTTP = "http"
    JSON = "json"
    LIST = "list"
    NONE = "none"


class RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHTTPEnableDiscoverCodeFalseDiscoverMethod(
    str, Enum, metaclass=utils.OpenEnumMeta
):
    # GET
    GET = "get"
    # POST
    POST = "post"
    # POST with Body
    POST_WITH_BODY = "post_with_body"
    # Other
    OTHER = "other"


class RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHTTPEnableDiscoverCodeFalsePaginationTypedDict(
    TypedDict
):
    type: PaginationOptionsRestDiscoveryDiscoverTypeHTTPPagination


class RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHTTPEnableDiscoverCodeFalsePagination(
    BaseModel
):
    type: PaginationOptionsRestDiscoveryDiscoverTypeHTTPPagination

    @field_serializer("type")
    def serialize_type(self, value):
        if isinstance(value, str):
            try:
                return models.PaginationOptionsRestDiscoveryDiscoverTypeHTTPPagination(
                    value
                )
            except ValueError:
                return value
        return value


class RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHTTPEnableDiscoverCodeFalseTypedDict(
    TypedDict
):
    discover_type: RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHTTPEnableDiscoverCodeFalseDiscoverType
    r"""Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task."""
    discover_url: str
    r"""URL to use for the Discover operation. Can be a constant URL, or a JavaScript expression to derive the URL."""
    discover_method: RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHTTPEnableDiscoverCodeFalseDiscoverMethod
    enable_discover_code: NotRequired[bool]
    discover_request_headers: NotRequired[
        List[ItemsTypeRestCollectMethodGetCollectRequestParamsTypedDict]
    ]
    pagination: NotRequired[
        RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHTTPEnableDiscoverCodeFalsePaginationTypedDict
    ]
    discover_data_field: NotRequired[str]
    r"""Path to field in the response object that contains discovery results (ex: level1.name). Leave blank if the result is an array."""
    enable_strict_discover_parsing: NotRequired[bool]
    r"""Explicitly set the discover response format. When disabled, best effort parsing is used."""


class RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHTTPEnableDiscoverCodeFalse(
    BaseModel
):
    discover_type: Annotated[
        RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHTTPEnableDiscoverCodeFalseDiscoverType,
        pydantic.Field(alias="discoverType"),
    ]
    r"""Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task."""

    discover_url: Annotated[str, pydantic.Field(alias="discoverUrl")]
    r"""URL to use for the Discover operation. Can be a constant URL, or a JavaScript expression to derive the URL."""

    discover_method: Annotated[
        RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHTTPEnableDiscoverCodeFalseDiscoverMethod,
        pydantic.Field(alias="discoverMethod"),
    ]

    enable_discover_code: Annotated[
        Optional[bool], pydantic.Field(alias="enableDiscoverCode")
    ] = None

    discover_request_headers: Annotated[
        Optional[List[ItemsTypeRestCollectMethodGetCollectRequestParams]],
        pydantic.Field(alias="discoverRequestHeaders"),
    ] = None

    pagination: Optional[
        RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHTTPEnableDiscoverCodeFalsePagination
    ] = None

    discover_data_field: Annotated[
        Optional[str], pydantic.Field(alias="discoverDataField")
    ] = None
    r"""Path to field in the response object that contains discovery results (ex: level1.name). Leave blank if the result is an array."""

    enable_strict_discover_parsing: Annotated[
        Optional[bool], pydantic.Field(alias="enableStrictDiscoverParsing")
    ] = None
    r"""Explicitly set the discover response format. When disabled, best effort parsing is used."""

    @field_serializer("discover_type")
    def serialize_discover_type(self, value):
        if isinstance(value, str):
            try:
                return models.RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHTTPEnableDiscoverCodeFalseDiscoverType(
                    value
                )
            except ValueError:
                return value
        return value

    @field_serializer("discover_method")
    def serialize_discover_method(self, value):
        if isinstance(value, str):
            try:
                return models.RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHTTPEnableDiscoverCodeFalseDiscoverMethod(
                    value
                )
            except ValueError:
                return value
        return value

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(
            [
                "enableDiscoverCode",
                "discoverRequestHeaders",
                "pagination",
                "discoverDataField",
                "enableStrictDiscoverParsing",
            ]
        )
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


class RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHTTPEnableStrictDiscoverParsingTrueDiscoverType(
    str, Enum, metaclass=utils.OpenEnumMeta
):
    r"""Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task."""

    HTTP = "http"
    JSON = "json"
    LIST = "list"
    NONE = "none"


class RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHTTPEnableStrictDiscoverParsingTrueDiscoverMethod(
    str, Enum, metaclass=utils.OpenEnumMeta
):
    # GET
    GET = "get"
    # POST
    POST = "post"
    # POST with Body
    POST_WITH_BODY = "post_with_body"
    # Other
    OTHER = "other"


class RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHTTPEnableStrictDiscoverParsingTruePaginationTypedDict(
    TypedDict
):
    type: PaginationOptionsRestDiscoveryDiscoverTypeHTTPPagination


class RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHTTPEnableStrictDiscoverParsingTruePagination(
    BaseModel
):
    type: PaginationOptionsRestDiscoveryDiscoverTypeHTTPPagination

    @field_serializer("type")
    def serialize_type(self, value):
        if isinstance(value, str):
            try:
                return models.PaginationOptionsRestDiscoveryDiscoverTypeHTTPPagination(
                    value
                )
            except ValueError:
                return value
        return value


class RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHTTPEnableStrictDiscoverParsingTrueTypedDict(
    TypedDict
):
    discover_response_format: str
    r"""If 'Strict discover response parsing' parsing is enabled, provide the response format"""
    discover_type: RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHTTPEnableStrictDiscoverParsingTrueDiscoverType
    r"""Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task."""
    discover_url: str
    r"""URL to use for the Discover operation. Can be a constant URL, or a JavaScript expression to derive the URL."""
    discover_method: RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHTTPEnableStrictDiscoverParsingTrueDiscoverMethod
    enable_strict_discover_parsing: NotRequired[bool]
    r"""Explicitly set the discover response format. When disabled, best effort parsing is used."""
    discover_request_headers: NotRequired[
        List[ItemsTypeRestCollectMethodGetCollectRequestParamsTypedDict]
    ]
    pagination: NotRequired[
        RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHTTPEnableStrictDiscoverParsingTruePaginationTypedDict
    ]
    discover_data_field: NotRequired[str]
    r"""Path to field in the response object that contains discovery results (ex: level1.name). Leave blank if the result is an array."""
    enable_discover_code: NotRequired[bool]


class RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHTTPEnableStrictDiscoverParsingTrue(
    BaseModel
):
    discover_response_format: Annotated[
        str, pydantic.Field(alias="discoverResponseFormat")
    ]
    r"""If 'Strict discover response parsing' parsing is enabled, provide the response format"""

    discover_type: Annotated[
        RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHTTPEnableStrictDiscoverParsingTrueDiscoverType,
        pydantic.Field(alias="discoverType"),
    ]
    r"""Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task."""

    discover_url: Annotated[str, pydantic.Field(alias="discoverUrl")]
    r"""URL to use for the Discover operation. Can be a constant URL, or a JavaScript expression to derive the URL."""

    discover_method: Annotated[
        RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHTTPEnableStrictDiscoverParsingTrueDiscoverMethod,
        pydantic.Field(alias="discoverMethod"),
    ]

    enable_strict_discover_parsing: Annotated[
        Optional[bool], pydantic.Field(alias="enableStrictDiscoverParsing")
    ] = None
    r"""Explicitly set the discover response format. When disabled, best effort parsing is used."""

    discover_request_headers: Annotated[
        Optional[List[ItemsTypeRestCollectMethodGetCollectRequestParams]],
        pydantic.Field(alias="discoverRequestHeaders"),
    ] = None

    pagination: Optional[
        RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHTTPEnableStrictDiscoverParsingTruePagination
    ] = None

    discover_data_field: Annotated[
        Optional[str], pydantic.Field(alias="discoverDataField")
    ] = None
    r"""Path to field in the response object that contains discovery results (ex: level1.name). Leave blank if the result is an array."""

    enable_discover_code: Annotated[
        Optional[bool], pydantic.Field(alias="enableDiscoverCode")
    ] = None

    @field_serializer("discover_type")
    def serialize_discover_type(self, value):
        if isinstance(value, str):
            try:
                return models.RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHTTPEnableStrictDiscoverParsingTrueDiscoverType(
                    value
                )
            except ValueError:
                return value
        return value

    @field_serializer("discover_method")
    def serialize_discover_method(self, value):
        if isinstance(value, str):
            try:
                return models.RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHTTPEnableStrictDiscoverParsingTrueDiscoverMethod(
                    value
                )
            except ValueError:
                return value
        return value

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(
            [
                "enableStrictDiscoverParsing",
                "discoverRequestHeaders",
                "pagination",
                "discoverDataField",
                "enableDiscoverCode",
            ]
        )
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


class RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHTTPEnableStrictDiscoverParsingFalseDiscoverType(
    str, Enum, metaclass=utils.OpenEnumMeta
):
    r"""Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task."""

    HTTP = "http"
    JSON = "json"
    LIST = "list"
    NONE = "none"


class RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHTTPEnableStrictDiscoverParsingFalseDiscoverMethod(
    str, Enum, metaclass=utils.OpenEnumMeta
):
    # GET
    GET = "get"
    # POST
    POST = "post"
    # POST with Body
    POST_WITH_BODY = "post_with_body"
    # Other
    OTHER = "other"


class RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHTTPEnableStrictDiscoverParsingFalsePaginationTypedDict(
    TypedDict
):
    type: PaginationOptionsRestDiscoveryDiscoverTypeHTTPPagination


class RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHTTPEnableStrictDiscoverParsingFalsePagination(
    BaseModel
):
    type: PaginationOptionsRestDiscoveryDiscoverTypeHTTPPagination

    @field_serializer("type")
    def serialize_type(self, value):
        if isinstance(value, str):
            try:
                return models.PaginationOptionsRestDiscoveryDiscoverTypeHTTPPagination(
                    value
                )
            except ValueError:
                return value
        return value


class RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHTTPEnableStrictDiscoverParsingFalseTypedDict(
    TypedDict
):
    discover_type: RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHTTPEnableStrictDiscoverParsingFalseDiscoverType
    r"""Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task."""
    discover_url: str
    r"""URL to use for the Discover operation. Can be a constant URL, or a JavaScript expression to derive the URL."""
    discover_method: RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHTTPEnableStrictDiscoverParsingFalseDiscoverMethod
    enable_strict_discover_parsing: NotRequired[bool]
    r"""Explicitly set the discover response format. When disabled, best effort parsing is used."""
    discover_request_headers: NotRequired[
        List[ItemsTypeRestCollectMethodGetCollectRequestParamsTypedDict]
    ]
    pagination: NotRequired[
        RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHTTPEnableStrictDiscoverParsingFalsePaginationTypedDict
    ]
    discover_data_field: NotRequired[str]
    r"""Path to field in the response object that contains discovery results (ex: level1.name). Leave blank if the result is an array."""
    enable_discover_code: NotRequired[bool]


class RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHTTPEnableStrictDiscoverParsingFalse(
    BaseModel
):
    discover_type: Annotated[
        RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHTTPEnableStrictDiscoverParsingFalseDiscoverType,
        pydantic.Field(alias="discoverType"),
    ]
    r"""Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task."""

    discover_url: Annotated[str, pydantic.Field(alias="discoverUrl")]
    r"""URL to use for the Discover operation. Can be a constant URL, or a JavaScript expression to derive the URL."""

    discover_method: Annotated[
        RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHTTPEnableStrictDiscoverParsingFalseDiscoverMethod,
        pydantic.Field(alias="discoverMethod"),
    ]

    enable_strict_discover_parsing: Annotated[
        Optional[bool], pydantic.Field(alias="enableStrictDiscoverParsing")
    ] = None
    r"""Explicitly set the discover response format. When disabled, best effort parsing is used."""

    discover_request_headers: Annotated[
        Optional[List[ItemsTypeRestCollectMethodGetCollectRequestParams]],
        pydantic.Field(alias="discoverRequestHeaders"),
    ] = None

    pagination: Optional[
        RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHTTPEnableStrictDiscoverParsingFalsePagination
    ] = None

    discover_data_field: Annotated[
        Optional[str], pydantic.Field(alias="discoverDataField")
    ] = None
    r"""Path to field in the response object that contains discovery results (ex: level1.name). Leave blank if the result is an array."""

    enable_discover_code: Annotated[
        Optional[bool], pydantic.Field(alias="enableDiscoverCode")
    ] = None

    @field_serializer("discover_type")
    def serialize_discover_type(self, value):
        if isinstance(value, str):
            try:
                return models.RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHTTPEnableStrictDiscoverParsingFalseDiscoverType(
                    value
                )
            except ValueError:
                return value
        return value

    @field_serializer("discover_method")
    def serialize_discover_method(self, value):
        if isinstance(value, str):
            try:
                return models.RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHTTPEnableStrictDiscoverParsingFalseDiscoverMethod(
                    value
                )
            except ValueError:
                return value
        return value

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(
            [
                "enableStrictDiscoverParsing",
                "discoverRequestHeaders",
                "pagination",
                "discoverDataField",
                "enableDiscoverCode",
            ]
        )
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHTTPTypedDict = TypeAliasType(
    "RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHTTPTypedDict",
    Union[
        RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHTTPEnableStrictDiscoverParsingFalseTypedDict,
        RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHTTPEnableDiscoverCodeFalseTypedDict,
        RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHTTPEnableStrictDiscoverParsingTrueTypedDict,
        RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHTTPEnableDiscoverCodeTrueTypedDict,
        RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHTTPDiscoverMethodGetTypedDict,
        RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHTTPDiscoverMethodPostTypedDict,
        RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHTTPDiscoverMethodPostWithBodyTypedDict,
        RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHTTPDiscoverMethodOtherTypedDict,
    ],
)


class UnknownRestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHTTP(BaseModel):
    r"""A RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHTTP variant the SDK doesn't recognize. Preserves the raw payload."""

    discover_method: Literal["UNKNOWN"] = "UNKNOWN"
    raw: Any
    is_unknown: Literal[True] = True

    model_config = ConfigDict(frozen=True)


_REST_AUTHENTICATION_BASIC_SECRET_REST_DISCOVERY_DISCOVER_TYPE_HTTP_VARIANTS: dict[
    str, Any
] = {
    "get": RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHTTPDiscoverMethodGet,
    "post": RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHTTPDiscoverMethodPost,
    "post_with_body": RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHTTPDiscoverMethodPostWithBody,
    "other": RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHTTPDiscoverMethodOther,
}


RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHTTP = Annotated[
    Union[
        RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHTTPDiscoverMethodGet,
        RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHTTPDiscoverMethodPost,
        RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHTTPDiscoverMethodPostWithBody,
        RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHTTPDiscoverMethodOther,
        UnknownRestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHTTP,
    ],
    BeforeValidator(
        partial(
            parse_open_union,
            disc_key="discoverMethod",
            variants=_REST_AUTHENTICATION_BASIC_SECRET_REST_DISCOVERY_DISCOVER_TYPE_HTTP_VARIANTS,
            unknown_cls=UnknownRestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHTTP,
            union_name="RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHTTP",
        )
    ),
]


RestAuthenticationBasicSecretDiscoveryTypedDict = TypeAliasType(
    "RestAuthenticationBasicSecretDiscoveryTypedDict",
    Union[
        RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeNoneTypedDict,
        RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeListTypedDict,
        RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeJSONTypedDict,
        RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHTTPTypedDict,
    ],
)


class UnknownRestAuthenticationBasicSecretDiscovery(BaseModel):
    r"""A RestAuthenticationBasicSecretDiscovery variant the SDK doesn't recognize. Preserves the raw payload."""

    discover_type: Literal["UNKNOWN"] = "UNKNOWN"
    raw: Any
    is_unknown: Literal[True] = True

    model_config = ConfigDict(frozen=True)


_REST_AUTHENTICATION_BASIC_SECRET_DISCOVERY_VARIANTS: dict[str, Any] = {
    "http": RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHTTP,
    "json": RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeJSON,
    "list": RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeList,
    "none": RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeNone,
}


RestAuthenticationBasicSecretDiscovery = Annotated[
    Union[
        RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHTTP,
        RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeJSON,
        RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeList,
        RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeNone,
        UnknownRestAuthenticationBasicSecretDiscovery,
    ],
    BeforeValidator(
        partial(
            parse_open_union,
            disc_key="discoverType",
            variants=_REST_AUTHENTICATION_BASIC_SECRET_DISCOVERY_VARIANTS,
            unknown_cls=UnknownRestAuthenticationBasicSecretDiscovery,
            union_name="RestAuthenticationBasicSecretDiscovery",
        )
    ),
]


class RestAuthenticationBasicSecretCollectMethod(
    str, Enum, metaclass=utils.OpenEnumMeta
):
    # GET
    GET = "get"
    # POST
    POST = "post"
    # POST with Body
    POST_WITH_BODY = "post_with_body"
    # Other
    OTHER = "other"


class RestAuthenticationBasicSecretRestPaginationTypeRequestPageTypedDict(TypedDict):
    type: PaginationOptionsRestDiscoveryDiscoverTypeHTTPPagination
    page_field: str
    r"""Query string parameter that sets the page index to be returned. Example: /api/v1/query?term=cribl&page_size=100&page_number=0"""
    size_field: str
    r"""Query string parameter that sets the number of records retrieved per request. Example: /api/v1/query?term=cribl&page_size=100&page_number=0"""
    size: float
    r"""Maximum number of records to collect per page"""
    max_pages: float
    r"""Maximum number of pages to retrieve per collection task. Defaults to 50 pages. Set to 0 to retrieve all pages."""
    zero_indexed: bool
    r"""Enable to indicate that the first page in the requested data is at index 0. Disabled by default, which indicates index 1."""
    page: NotRequired[float]
    r"""Page number from which to start request. Defaults to undefined, which will start collection from the first page."""
    total_page_field: NotRequired[str]
    r"""Name of the attribute in the response that contains the total number of pages for the query"""
    total_record_field: NotRequired[str]
    r"""Name of the attribute in the response that contains the total number of records for the query"""


class RestAuthenticationBasicSecretRestPaginationTypeRequestPage(BaseModel):
    type: PaginationOptionsRestDiscoveryDiscoverTypeHTTPPagination

    page_field: Annotated[str, pydantic.Field(alias="pageField")]
    r"""Query string parameter that sets the page index to be returned. Example: /api/v1/query?term=cribl&page_size=100&page_number=0"""

    size_field: Annotated[str, pydantic.Field(alias="sizeField")]
    r"""Query string parameter that sets the number of records retrieved per request. Example: /api/v1/query?term=cribl&page_size=100&page_number=0"""

    size: float
    r"""Maximum number of records to collect per page"""

    max_pages: Annotated[float, pydantic.Field(alias="maxPages")]
    r"""Maximum number of pages to retrieve per collection task. Defaults to 50 pages. Set to 0 to retrieve all pages."""

    zero_indexed: Annotated[bool, pydantic.Field(alias="zeroIndexed")]
    r"""Enable to indicate that the first page in the requested data is at index 0. Disabled by default, which indicates index 1."""

    page: Optional[float] = None
    r"""Page number from which to start request. Defaults to undefined, which will start collection from the first page."""

    total_page_field: Annotated[
        Optional[str], pydantic.Field(alias="totalPageField")
    ] = None
    r"""Name of the attribute in the response that contains the total number of pages for the query"""

    total_record_field: Annotated[
        Optional[str], pydantic.Field(alias="totalRecordField")
    ] = None
    r"""Name of the attribute in the response that contains the total number of records for the query"""

    @field_serializer("type")
    def serialize_type(self, value):
        if isinstance(value, str):
            try:
                return models.PaginationOptionsRestDiscoveryDiscoverTypeHTTPPagination(
                    value
                )
            except ValueError:
                return value
        return value

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(["page", "totalPageField", "totalRecordField"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


class RestAuthenticationBasicSecretRestPaginationTypeRequestOffsetTypedDict(TypedDict):
    type: PaginationOptionsRestDiscoveryDiscoverTypeHTTPPagination
    offset_field: str
    r"""Query string parameter that sets the index from which to begin returning records. Example: /api/v1/query?term=cribl&limit=100&offset=0"""
    limit_field: str
    r"""Query string parameter that sets the number of records retrieved per request. Example: /api/v1/query?term=cribl&limit=100&offset=0"""
    limit: float
    r"""Maximum number of records to collect per request"""
    max_pages: float
    r"""Maximum number of pages to retrieve per collection task. Defaults to 50 pages. Set to 0 to retrieve all pages."""
    zero_indexed: bool
    r"""Enable to indicate that the first page in the requested data is at index 0. Disabled by default, which indicates index 1."""
    offset: NotRequired[float]
    r"""Offset index from which to start request. Defaults to undefined, which will start collection from the first record."""
    total_record_field: NotRequired[str]
    r"""Name of the attribute in the response that contains the total number of records for the query"""


class RestAuthenticationBasicSecretRestPaginationTypeRequestOffset(BaseModel):
    type: PaginationOptionsRestDiscoveryDiscoverTypeHTTPPagination

    offset_field: Annotated[str, pydantic.Field(alias="offsetField")]
    r"""Query string parameter that sets the index from which to begin returning records. Example: /api/v1/query?term=cribl&limit=100&offset=0"""

    limit_field: Annotated[str, pydantic.Field(alias="limitField")]
    r"""Query string parameter that sets the number of records retrieved per request. Example: /api/v1/query?term=cribl&limit=100&offset=0"""

    limit: float
    r"""Maximum number of records to collect per request"""

    max_pages: Annotated[float, pydantic.Field(alias="maxPages")]
    r"""Maximum number of pages to retrieve per collection task. Defaults to 50 pages. Set to 0 to retrieve all pages."""

    zero_indexed: Annotated[bool, pydantic.Field(alias="zeroIndexed")]
    r"""Enable to indicate that the first page in the requested data is at index 0. Disabled by default, which indicates index 1."""

    offset: Optional[float] = None
    r"""Offset index from which to start request. Defaults to undefined, which will start collection from the first record."""

    total_record_field: Annotated[
        Optional[str], pydantic.Field(alias="totalRecordField")
    ] = None
    r"""Name of the attribute in the response that contains the total number of records for the query"""

    @field_serializer("type")
    def serialize_type(self, value):
        if isinstance(value, str):
            try:
                return models.PaginationOptionsRestDiscoveryDiscoverTypeHTTPPagination(
                    value
                )
            except ValueError:
                return value
        return value

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(["offset", "totalRecordField"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


class RestAuthenticationBasicSecretRestPaginationTypeResponseHeaderLinkTypedDict(
    TypedDict
):
    type: PaginationOptionsRestDiscoveryDiscoverTypeHTTPPagination
    next_relation_attribute: str
    r"""Relation name used in the link header that refers to the next page in the result set. Example: rel=\"next\" refers to the next page of results: <https://myHost/nextPage>; rel=\"next\" """
    max_pages: float
    r"""Maximum number of pages to retrieve per collection task. Defaults to 50 pages. Set to 0 to retrieve all pages."""
    cur_relation_attribute: NotRequired[str]
    r"""Relation name used in the link header that refers to the current result set. Example: rel=\"self\" refers to the current page of results: <https://myHost/curPage>; rel=\"self\" """


class RestAuthenticationBasicSecretRestPaginationTypeResponseHeaderLink(BaseModel):
    type: PaginationOptionsRestDiscoveryDiscoverTypeHTTPPagination

    next_relation_attribute: Annotated[
        str, pydantic.Field(alias="nextRelationAttribute")
    ]
    r"""Relation name used in the link header that refers to the next page in the result set. Example: rel=\"next\" refers to the next page of results: <https://myHost/nextPage>; rel=\"next\" """

    max_pages: Annotated[float, pydantic.Field(alias="maxPages")]
    r"""Maximum number of pages to retrieve per collection task. Defaults to 50 pages. Set to 0 to retrieve all pages."""

    cur_relation_attribute: Annotated[
        Optional[str], pydantic.Field(alias="curRelationAttribute")
    ] = None
    r"""Relation name used in the link header that refers to the current result set. Example: rel=\"self\" refers to the current page of results: <https://myHost/curPage>; rel=\"self\" """

    @field_serializer("type")
    def serialize_type(self, value):
        if isinstance(value, str):
            try:
                return models.PaginationOptionsRestDiscoveryDiscoverTypeHTTPPagination(
                    value
                )
            except ValueError:
                return value
        return value

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(["curRelationAttribute"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


class RestAuthenticationBasicSecretRestPaginationTypeResponseHeaderTypedDict(TypedDict):
    type: PaginationOptionsRestDiscoveryDiscoverTypeHTTPPagination
    attribute: List[str]
    r"""Names of attributes within the response that contain next-page information"""
    max_pages: float
    r"""Maximum number of pages to retrieve per collection task. Defaults to 50 pages. Set to 0 to retrieve all pages."""


class RestAuthenticationBasicSecretRestPaginationTypeResponseHeader(BaseModel):
    type: PaginationOptionsRestDiscoveryDiscoverTypeHTTPPagination

    attribute: List[str]
    r"""Names of attributes within the response that contain next-page information"""

    max_pages: Annotated[float, pydantic.Field(alias="maxPages")]
    r"""Maximum number of pages to retrieve per collection task. Defaults to 50 pages. Set to 0 to retrieve all pages."""

    @field_serializer("type")
    def serialize_type(self, value):
        if isinstance(value, str):
            try:
                return models.PaginationOptionsRestDiscoveryDiscoverTypeHTTPPagination(
                    value
                )
            except ValueError:
                return value
        return value


class RestAuthenticationBasicSecretRestPaginationTypeResponseBodyTypedDict(TypedDict):
    type: PaginationOptionsRestDiscoveryDiscoverTypeHTTPPagination
    attribute: List[str]
    r"""Names of attributes within the response that contain next-page information"""
    max_pages: float
    r"""Maximum number of pages to retrieve per collection task. Defaults to 50 pages. Set to 0 to retrieve all pages."""
    last_page_expr: NotRequired[str]
    r"""JavaScript expression used to determine when the last page has been reached. The values tested by this expression must be in the Response attributes section."""


class RestAuthenticationBasicSecretRestPaginationTypeResponseBody(BaseModel):
    type: PaginationOptionsRestDiscoveryDiscoverTypeHTTPPagination

    attribute: List[str]
    r"""Names of attributes within the response that contain next-page information"""

    max_pages: Annotated[float, pydantic.Field(alias="maxPages")]
    r"""Maximum number of pages to retrieve per collection task. Defaults to 50 pages. Set to 0 to retrieve all pages."""

    last_page_expr: Annotated[Optional[str], pydantic.Field(alias="lastPageExpr")] = (
        None
    )
    r"""JavaScript expression used to determine when the last page has been reached. The values tested by this expression must be in the Response attributes section."""

    @field_serializer("type")
    def serialize_type(self, value):
        if isinstance(value, str):
            try:
                return models.PaginationOptionsRestDiscoveryDiscoverTypeHTTPPagination(
                    value
                )
            except ValueError:
                return value
        return value

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(["lastPageExpr"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


class RestAuthenticationBasicSecretRestPaginationTypeNoneTypedDict(TypedDict):
    type: PaginationOptionsRestDiscoveryDiscoverTypeHTTPPagination


class RestAuthenticationBasicSecretRestPaginationTypeNone(BaseModel):
    type: PaginationOptionsRestDiscoveryDiscoverTypeHTTPPagination

    @field_serializer("type")
    def serialize_type(self, value):
        if isinstance(value, str):
            try:
                return models.PaginationOptionsRestDiscoveryDiscoverTypeHTTPPagination(
                    value
                )
            except ValueError:
                return value
        return value


RestAuthenticationBasicSecretPaginationUnionTypedDict = TypeAliasType(
    "RestAuthenticationBasicSecretPaginationUnionTypedDict",
    Union[
        RestAuthenticationBasicSecretRestPaginationTypeNoneTypedDict,
        RestAuthenticationBasicSecretRestPaginationTypeResponseHeaderTypedDict,
        RestAuthenticationBasicSecretRestPaginationTypeResponseBodyTypedDict,
        RestAuthenticationBasicSecretRestPaginationTypeResponseHeaderLinkTypedDict,
        RestAuthenticationBasicSecretRestPaginationTypeRequestOffsetTypedDict,
        RestAuthenticationBasicSecretRestPaginationTypeRequestPageTypedDict,
    ],
)


class UnknownRestAuthenticationBasicSecretPaginationUnion(BaseModel):
    r"""A RestAuthenticationBasicSecretPaginationUnion variant the SDK doesn't recognize. Preserves the raw payload."""

    type: Literal["UNKNOWN"] = "UNKNOWN"
    raw: Any
    is_unknown: Literal[True] = True

    model_config = ConfigDict(frozen=True)


_REST_AUTHENTICATION_BASIC_SECRET_PAGINATION_UNION_VARIANTS: dict[str, Any] = {
    "none": RestAuthenticationBasicSecretRestPaginationTypeNone,
    "response_body": RestAuthenticationBasicSecretRestPaginationTypeResponseBody,
    "response_header": RestAuthenticationBasicSecretRestPaginationTypeResponseHeader,
    "response_header_link": RestAuthenticationBasicSecretRestPaginationTypeResponseHeaderLink,
    "request_offset": RestAuthenticationBasicSecretRestPaginationTypeRequestOffset,
    "request_page": RestAuthenticationBasicSecretRestPaginationTypeRequestPage,
}


RestAuthenticationBasicSecretPaginationUnion = Annotated[
    Union[
        RestAuthenticationBasicSecretRestPaginationTypeNone,
        RestAuthenticationBasicSecretRestPaginationTypeResponseBody,
        RestAuthenticationBasicSecretRestPaginationTypeResponseHeader,
        RestAuthenticationBasicSecretRestPaginationTypeResponseHeaderLink,
        RestAuthenticationBasicSecretRestPaginationTypeRequestOffset,
        RestAuthenticationBasicSecretRestPaginationTypeRequestPage,
        UnknownRestAuthenticationBasicSecretPaginationUnion,
    ],
    BeforeValidator(
        partial(
            parse_open_union,
            disc_key="type",
            variants=_REST_AUTHENTICATION_BASIC_SECRET_PAGINATION_UNION_VARIANTS,
            unknown_cls=UnknownRestAuthenticationBasicSecretPaginationUnion,
            union_name="RestAuthenticationBasicSecretPaginationUnion",
        )
    ),
]


class RestAuthenticationBasicSecretRestRetryRulesTypeBackoffEnableHeaderTrueTypedDict(
    TypedDict
):
    type: RetryTypeOptionsHealthCheckCollectorConfRetryRules
    r"""The algorithm to use when performing HTTP retries"""
    enable_header: NotRequired[bool]
    r"""Honor any Retry-After header that specifies a delay (in seconds) or a timestamp after which to retry the request. The delay is limited to the `Longest interval between retries (ms)` value, even if the Retry-After header specifies a longer delay. When disabled, all Retry-After headers are ignored."""
    retry_header_name: NotRequired[str]
    interval: NotRequired[float]
    r"""Time interval between a failed request and the first retry"""
    limit: NotRequired[float]
    r"""Maximum number of times to retry a failed HTTP request"""
    multiplier: NotRequired[float]
    r"""Base for exponential backoff. Example: base 2 means that retries will occur after 2, then 4, then 8 seconds, and so on."""
    max_interval_ms: NotRequired[float]
    codes: NotRequired[List[float]]
    r"""List of HTTP codes that trigger a retry. Leave empty to use the default list of 429 and 503."""
    retry_connect_timeout: NotRequired[bool]
    r"""Make a single retry attempt when a connection timeout (ETIMEDOUT) error occurs"""
    retry_connect_reset: NotRequired[bool]
    r"""Retry request when a connection reset (ECONNRESET) error occurs"""


class RestAuthenticationBasicSecretRestRetryRulesTypeBackoffEnableHeaderTrue(BaseModel):
    type: RetryTypeOptionsHealthCheckCollectorConfRetryRules
    r"""The algorithm to use when performing HTTP retries"""

    enable_header: Annotated[Optional[bool], pydantic.Field(alias="enableHeader")] = (
        None
    )
    r"""Honor any Retry-After header that specifies a delay (in seconds) or a timestamp after which to retry the request. The delay is limited to the `Longest interval between retries (ms)` value, even if the Retry-After header specifies a longer delay. When disabled, all Retry-After headers are ignored."""

    retry_header_name: Annotated[
        Optional[str], pydantic.Field(alias="retryHeaderName")
    ] = None

    interval: Optional[float] = None
    r"""Time interval between a failed request and the first retry"""

    limit: Optional[float] = None
    r"""Maximum number of times to retry a failed HTTP request"""

    multiplier: Optional[float] = None
    r"""Base for exponential backoff. Example: base 2 means that retries will occur after 2, then 4, then 8 seconds, and so on."""

    max_interval_ms: Annotated[
        Optional[float], pydantic.Field(alias="maxIntervalMs")
    ] = None

    codes: Optional[List[float]] = None
    r"""List of HTTP codes that trigger a retry. Leave empty to use the default list of 429 and 503."""

    retry_connect_timeout: Annotated[
        Optional[bool], pydantic.Field(alias="retryConnectTimeout")
    ] = None
    r"""Make a single retry attempt when a connection timeout (ETIMEDOUT) error occurs"""

    retry_connect_reset: Annotated[
        Optional[bool], pydantic.Field(alias="retryConnectReset")
    ] = None
    r"""Retry request when a connection reset (ECONNRESET) error occurs"""

    @field_serializer("type")
    def serialize_type(self, value):
        if isinstance(value, str):
            try:
                return models.RetryTypeOptionsHealthCheckCollectorConfRetryRules(value)
            except ValueError:
                return value
        return value

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(
            [
                "enableHeader",
                "retryHeaderName",
                "interval",
                "limit",
                "multiplier",
                "maxIntervalMs",
                "codes",
                "retryConnectTimeout",
                "retryConnectReset",
            ]
        )
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


class RestAuthenticationBasicSecretRestRetryRulesTypeBackoffEnableHeaderFalseTypedDict(
    TypedDict
):
    type: RetryTypeOptionsHealthCheckCollectorConfRetryRules
    r"""The algorithm to use when performing HTTP retries"""
    enable_header: NotRequired[bool]
    r"""Honor any Retry-After header that specifies a delay (in seconds) or a timestamp after which to retry the request. The delay is limited to the `Longest interval between retries (ms)` value, even if the Retry-After header specifies a longer delay. When disabled, all Retry-After headers are ignored."""
    interval: NotRequired[float]
    r"""Time interval between a failed request and the first retry"""
    limit: NotRequired[float]
    r"""Maximum number of times to retry a failed HTTP request"""
    multiplier: NotRequired[float]
    r"""Base for exponential backoff. Example: base 2 means that retries will occur after 2, then 4, then 8 seconds, and so on."""
    max_interval_ms: NotRequired[float]
    codes: NotRequired[List[float]]
    r"""List of HTTP codes that trigger a retry. Leave empty to use the default list of 429 and 503."""
    retry_connect_timeout: NotRequired[bool]
    r"""Make a single retry attempt when a connection timeout (ETIMEDOUT) error occurs"""
    retry_connect_reset: NotRequired[bool]
    r"""Retry request when a connection reset (ECONNRESET) error occurs"""


class RestAuthenticationBasicSecretRestRetryRulesTypeBackoffEnableHeaderFalse(
    BaseModel
):
    type: RetryTypeOptionsHealthCheckCollectorConfRetryRules
    r"""The algorithm to use when performing HTTP retries"""

    enable_header: Annotated[Optional[bool], pydantic.Field(alias="enableHeader")] = (
        None
    )
    r"""Honor any Retry-After header that specifies a delay (in seconds) or a timestamp after which to retry the request. The delay is limited to the `Longest interval between retries (ms)` value, even if the Retry-After header specifies a longer delay. When disabled, all Retry-After headers are ignored."""

    interval: Optional[float] = None
    r"""Time interval between a failed request and the first retry"""

    limit: Optional[float] = None
    r"""Maximum number of times to retry a failed HTTP request"""

    multiplier: Optional[float] = None
    r"""Base for exponential backoff. Example: base 2 means that retries will occur after 2, then 4, then 8 seconds, and so on."""

    max_interval_ms: Annotated[
        Optional[float], pydantic.Field(alias="maxIntervalMs")
    ] = None

    codes: Optional[List[float]] = None
    r"""List of HTTP codes that trigger a retry. Leave empty to use the default list of 429 and 503."""

    retry_connect_timeout: Annotated[
        Optional[bool], pydantic.Field(alias="retryConnectTimeout")
    ] = None
    r"""Make a single retry attempt when a connection timeout (ETIMEDOUT) error occurs"""

    retry_connect_reset: Annotated[
        Optional[bool], pydantic.Field(alias="retryConnectReset")
    ] = None
    r"""Retry request when a connection reset (ECONNRESET) error occurs"""

    @field_serializer("type")
    def serialize_type(self, value):
        if isinstance(value, str):
            try:
                return models.RetryTypeOptionsHealthCheckCollectorConfRetryRules(value)
            except ValueError:
                return value
        return value

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(
            [
                "enableHeader",
                "interval",
                "limit",
                "multiplier",
                "maxIntervalMs",
                "codes",
                "retryConnectTimeout",
                "retryConnectReset",
            ]
        )
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


RestAuthenticationBasicSecretRestRetryRulesTypeBackoffTypedDict = TypeAliasType(
    "RestAuthenticationBasicSecretRestRetryRulesTypeBackoffTypedDict",
    Union[
        RestAuthenticationBasicSecretRestRetryRulesTypeBackoffEnableHeaderFalseTypedDict,
        RestAuthenticationBasicSecretRestRetryRulesTypeBackoffEnableHeaderTrueTypedDict,
    ],
)


RestAuthenticationBasicSecretRestRetryRulesTypeBackoff = TypeAliasType(
    "RestAuthenticationBasicSecretRestRetryRulesTypeBackoff",
    Union[
        RestAuthenticationBasicSecretRestRetryRulesTypeBackoffEnableHeaderFalse,
        RestAuthenticationBasicSecretRestRetryRulesTypeBackoffEnableHeaderTrue,
    ],
)


class RestAuthenticationBasicSecretRestRetryRulesTypeStaticEnableHeaderTrueTypedDict(
    TypedDict
):
    type: RetryTypeOptionsHealthCheckCollectorConfRetryRules
    r"""The algorithm to use when performing HTTP retries"""
    enable_header: NotRequired[bool]
    r"""Honor any Retry-After header that specifies a delay (in seconds) or a timestamp after which to retry the request. The delay is limited to the `Longest interval between retries (ms)` value, even if the Retry-After header specifies a longer delay. When disabled, all Retry-After headers are ignored."""
    retry_header_name: NotRequired[str]
    interval: NotRequired[float]
    r"""Time interval between retries. Maximum allowed value is 20,000 ms (1/3 minute)."""
    limit: NotRequired[float]
    r"""Maximum number of times to retry a failed HTTP request"""
    codes: NotRequired[List[float]]
    r"""List of HTTP codes that trigger a retry. Leave empty to use the default list of 429 and 503."""
    retry_connect_timeout: NotRequired[bool]
    r"""Make a single retry attempt when a connection timeout (ETIMEDOUT) error occurs"""
    retry_connect_reset: NotRequired[bool]
    r"""Retry request when a connection reset (ECONNRESET) error occurs"""


class RestAuthenticationBasicSecretRestRetryRulesTypeStaticEnableHeaderTrue(BaseModel):
    type: RetryTypeOptionsHealthCheckCollectorConfRetryRules
    r"""The algorithm to use when performing HTTP retries"""

    enable_header: Annotated[Optional[bool], pydantic.Field(alias="enableHeader")] = (
        None
    )
    r"""Honor any Retry-After header that specifies a delay (in seconds) or a timestamp after which to retry the request. The delay is limited to the `Longest interval between retries (ms)` value, even if the Retry-After header specifies a longer delay. When disabled, all Retry-After headers are ignored."""

    retry_header_name: Annotated[
        Optional[str], pydantic.Field(alias="retryHeaderName")
    ] = None

    interval: Optional[float] = None
    r"""Time interval between retries. Maximum allowed value is 20,000 ms (1/3 minute)."""

    limit: Optional[float] = None
    r"""Maximum number of times to retry a failed HTTP request"""

    codes: Optional[List[float]] = None
    r"""List of HTTP codes that trigger a retry. Leave empty to use the default list of 429 and 503."""

    retry_connect_timeout: Annotated[
        Optional[bool], pydantic.Field(alias="retryConnectTimeout")
    ] = None
    r"""Make a single retry attempt when a connection timeout (ETIMEDOUT) error occurs"""

    retry_connect_reset: Annotated[
        Optional[bool], pydantic.Field(alias="retryConnectReset")
    ] = None
    r"""Retry request when a connection reset (ECONNRESET) error occurs"""

    @field_serializer("type")
    def serialize_type(self, value):
        if isinstance(value, str):
            try:
                return models.RetryTypeOptionsHealthCheckCollectorConfRetryRules(value)
            except ValueError:
                return value
        return value

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(
            [
                "enableHeader",
                "retryHeaderName",
                "interval",
                "limit",
                "codes",
                "retryConnectTimeout",
                "retryConnectReset",
            ]
        )
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


class RestAuthenticationBasicSecretRestRetryRulesTypeStaticEnableHeaderFalseTypedDict(
    TypedDict
):
    type: RetryTypeOptionsHealthCheckCollectorConfRetryRules
    r"""The algorithm to use when performing HTTP retries"""
    enable_header: NotRequired[bool]
    r"""Honor any Retry-After header that specifies a delay (in seconds) or a timestamp after which to retry the request. The delay is limited to the `Longest interval between retries (ms)` value, even if the Retry-After header specifies a longer delay. When disabled, all Retry-After headers are ignored."""
    interval: NotRequired[float]
    r"""Time interval between retries. Maximum allowed value is 20,000 ms (1/3 minute)."""
    limit: NotRequired[float]
    r"""Maximum number of times to retry a failed HTTP request"""
    codes: NotRequired[List[float]]
    r"""List of HTTP codes that trigger a retry. Leave empty to use the default list of 429 and 503."""
    retry_connect_timeout: NotRequired[bool]
    r"""Make a single retry attempt when a connection timeout (ETIMEDOUT) error occurs"""
    retry_connect_reset: NotRequired[bool]
    r"""Retry request when a connection reset (ECONNRESET) error occurs"""


class RestAuthenticationBasicSecretRestRetryRulesTypeStaticEnableHeaderFalse(BaseModel):
    type: RetryTypeOptionsHealthCheckCollectorConfRetryRules
    r"""The algorithm to use when performing HTTP retries"""

    enable_header: Annotated[Optional[bool], pydantic.Field(alias="enableHeader")] = (
        None
    )
    r"""Honor any Retry-After header that specifies a delay (in seconds) or a timestamp after which to retry the request. The delay is limited to the `Longest interval between retries (ms)` value, even if the Retry-After header specifies a longer delay. When disabled, all Retry-After headers are ignored."""

    interval: Optional[float] = None
    r"""Time interval between retries. Maximum allowed value is 20,000 ms (1/3 minute)."""

    limit: Optional[float] = None
    r"""Maximum number of times to retry a failed HTTP request"""

    codes: Optional[List[float]] = None
    r"""List of HTTP codes that trigger a retry. Leave empty to use the default list of 429 and 503."""

    retry_connect_timeout: Annotated[
        Optional[bool], pydantic.Field(alias="retryConnectTimeout")
    ] = None
    r"""Make a single retry attempt when a connection timeout (ETIMEDOUT) error occurs"""

    retry_connect_reset: Annotated[
        Optional[bool], pydantic.Field(alias="retryConnectReset")
    ] = None
    r"""Retry request when a connection reset (ECONNRESET) error occurs"""

    @field_serializer("type")
    def serialize_type(self, value):
        if isinstance(value, str):
            try:
                return models.RetryTypeOptionsHealthCheckCollectorConfRetryRules(value)
            except ValueError:
                return value
        return value

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(
            [
                "enableHeader",
                "interval",
                "limit",
                "codes",
                "retryConnectTimeout",
                "retryConnectReset",
            ]
        )
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


RestAuthenticationBasicSecretRestRetryRulesTypeStaticTypedDict = TypeAliasType(
    "RestAuthenticationBasicSecretRestRetryRulesTypeStaticTypedDict",
    Union[
        RestAuthenticationBasicSecretRestRetryRulesTypeStaticEnableHeaderFalseTypedDict,
        RestAuthenticationBasicSecretRestRetryRulesTypeStaticEnableHeaderTrueTypedDict,
    ],
)


RestAuthenticationBasicSecretRestRetryRulesTypeStatic = TypeAliasType(
    "RestAuthenticationBasicSecretRestRetryRulesTypeStatic",
    Union[
        RestAuthenticationBasicSecretRestRetryRulesTypeStaticEnableHeaderFalse,
        RestAuthenticationBasicSecretRestRetryRulesTypeStaticEnableHeaderTrue,
    ],
)


class RestAuthenticationBasicSecretRestRetryRulesTypeNoneTypedDict(TypedDict):
    type: RetryTypeOptionsHealthCheckCollectorConfRetryRules
    r"""The algorithm to use when performing HTTP retries"""


class RestAuthenticationBasicSecretRestRetryRulesTypeNone(BaseModel):
    type: RetryTypeOptionsHealthCheckCollectorConfRetryRules
    r"""The algorithm to use when performing HTTP retries"""

    @field_serializer("type")
    def serialize_type(self, value):
        if isinstance(value, str):
            try:
                return models.RetryTypeOptionsHealthCheckCollectorConfRetryRules(value)
            except ValueError:
                return value
        return value


RestAuthenticationBasicSecretRetryRulesTypedDict = TypeAliasType(
    "RestAuthenticationBasicSecretRetryRulesTypedDict",
    Union[
        RestAuthenticationBasicSecretRestRetryRulesTypeNoneTypedDict,
        RestAuthenticationBasicSecretRestRetryRulesTypeStaticTypedDict,
        RestAuthenticationBasicSecretRestRetryRulesTypeBackoffTypedDict,
    ],
)


class UnknownRestAuthenticationBasicSecretRetryRules(BaseModel):
    r"""A RestAuthenticationBasicSecretRetryRules variant the SDK doesn't recognize. Preserves the raw payload."""

    type: Literal["UNKNOWN"] = "UNKNOWN"
    raw: Any
    is_unknown: Literal[True] = True

    model_config = ConfigDict(frozen=True)


_REST_AUTHENTICATION_BASIC_SECRET_RETRY_RULES_VARIANTS: dict[str, Any] = {
    "none": RestAuthenticationBasicSecretRestRetryRulesTypeNone,
    "static": RestAuthenticationBasicSecretRestRetryRulesTypeStatic,
    "backoff": RestAuthenticationBasicSecretRestRetryRulesTypeBackoff,
}


RestAuthenticationBasicSecretRetryRules = Annotated[
    Union[
        RestAuthenticationBasicSecretRestRetryRulesTypeNone,
        RestAuthenticationBasicSecretRestRetryRulesTypeStatic,
        RestAuthenticationBasicSecretRestRetryRulesTypeBackoff,
        UnknownRestAuthenticationBasicSecretRetryRules,
    ],
    BeforeValidator(
        partial(
            parse_open_union,
            disc_key="type",
            variants=_REST_AUTHENTICATION_BASIC_SECRET_RETRY_RULES_VARIANTS,
            unknown_cls=UnknownRestAuthenticationBasicSecretRetryRules,
            union_name="RestAuthenticationBasicSecretRetryRules",
        )
    ),
]


class RestAuthenticationBasicSecretStateTrackingTypedDict(TypedDict):
    enabled: NotRequired[bool]
    r"""Track collection progress between consecutive scheduled executions"""


class RestAuthenticationBasicSecretStateTracking(BaseModel):
    enabled: Optional[bool] = None
    r"""Track collection progress between consecutive scheduled executions"""

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(["enabled"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


try:
    RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHTTPEnableDiscoverCodeFalse.model_rebuild()
except NameError:
    pass
try:
    RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHTTPEnableStrictDiscoverParsingTrue.model_rebuild()
except NameError:
    pass
try:
    RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHTTPEnableStrictDiscoverParsingFalse.model_rebuild()
except NameError:
    pass
try:
    RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestPaginationTypeRequestPage.model_rebuild()
except NameError:
    pass
try:
    RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestPaginationTypeRequestOffset.model_rebuild()
except NameError:
    pass
try:
    RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestPaginationTypeResponseHeaderLink.model_rebuild()
except NameError:
    pass
try:
    RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestPaginationTypeResponseHeader.model_rebuild()
except NameError:
    pass
try:
    RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestPaginationTypeResponseBody.model_rebuild()
except NameError:
    pass
try:
    RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestRetryRulesTypeBackoffEnableHeaderTrue.model_rebuild()
except NameError:
    pass
try:
    RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestRetryRulesTypeBackoffEnableHeaderFalse.model_rebuild()
except NameError:
    pass
try:
    RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestRetryRulesTypeStaticEnableHeaderTrue.model_rebuild()
except NameError:
    pass
try:
    RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestRetryRulesTypeStaticEnableHeaderFalse.model_rebuild()
except NameError:
    pass
try:
    RestAuthenticationLoginGetAuthTokenFromHeaderTrueScheduling.model_rebuild()
except NameError:
    pass
try:
    RestAuthenticationLoginGetAuthTokenFromHeaderTrue.model_rebuild()
except NameError:
    pass
try:
    RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeNone.model_rebuild()
except NameError:
    pass
try:
    RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeList.model_rebuild()
except NameError:
    pass
try:
    RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeJSON.model_rebuild()
except NameError:
    pass
try:
    RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHTTPDiscoverMethodOther.model_rebuild()
except NameError:
    pass
try:
    RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHTTPDiscoverMethodPostWithBody.model_rebuild()
except NameError:
    pass
try:
    RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHTTPDiscoverMethodPost.model_rebuild()
except NameError:
    pass
try:
    RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHTTPDiscoverMethodGet.model_rebuild()
except NameError:
    pass
try:
    RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHTTPEnableDiscoverCodeTrue.model_rebuild()
except NameError:
    pass
try:
    RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHTTPEnableDiscoverCodeFalse.model_rebuild()
except NameError:
    pass
try:
    RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHTTPEnableStrictDiscoverParsingTrue.model_rebuild()
except NameError:
    pass
try:
    RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHTTPEnableStrictDiscoverParsingFalse.model_rebuild()
except NameError:
    pass
try:
    RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestPaginationTypeRequestPage.model_rebuild()
except NameError:
    pass
try:
    RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestPaginationTypeRequestOffset.model_rebuild()
except NameError:
    pass
try:
    RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestPaginationTypeResponseHeaderLink.model_rebuild()
except NameError:
    pass
try:
    RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestPaginationTypeResponseHeader.model_rebuild()
except NameError:
    pass
try:
    RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestPaginationTypeResponseBody.model_rebuild()
except NameError:
    pass
try:
    RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestRetryRulesTypeBackoffEnableHeaderTrue.model_rebuild()
except NameError:
    pass
try:
    RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestRetryRulesTypeBackoffEnableHeaderFalse.model_rebuild()
except NameError:
    pass
try:
    RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestRetryRulesTypeStaticEnableHeaderTrue.model_rebuild()
except NameError:
    pass
try:
    RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestRetryRulesTypeStaticEnableHeaderFalse.model_rebuild()
except NameError:
    pass
try:
    RestAuthenticationLoginGetAuthTokenFromHeaderFalseScheduling.model_rebuild()
except NameError:
    pass
try:
    RestAuthenticationLoginGetAuthTokenFromHeaderFalse.model_rebuild()
except NameError:
    pass
try:
    RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeNone.model_rebuild()
except NameError:
    pass
try:
    RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeList.model_rebuild()
except NameError:
    pass
try:
    RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeJSON.model_rebuild()
except NameError:
    pass
try:
    RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHTTPDiscoverMethodOther.model_rebuild()
except NameError:
    pass
try:
    RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHTTPDiscoverMethodPostWithBody.model_rebuild()
except NameError:
    pass
try:
    RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHTTPDiscoverMethodPost.model_rebuild()
except NameError:
    pass
try:
    RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHTTPDiscoverMethodGet.model_rebuild()
except NameError:
    pass
try:
    RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHTTPEnableDiscoverCodeTrue.model_rebuild()
except NameError:
    pass
try:
    RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHTTPEnableDiscoverCodeFalse.model_rebuild()
except NameError:
    pass
try:
    RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHTTPEnableStrictDiscoverParsingTrue.model_rebuild()
except NameError:
    pass
try:
    RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHTTPEnableStrictDiscoverParsingFalse.model_rebuild()
except NameError:
    pass
try:
    RestAuthenticationBasicSecretRestPaginationTypeRequestPage.model_rebuild()
except NameError:
    pass
try:
    RestAuthenticationBasicSecretRestPaginationTypeRequestOffset.model_rebuild()
except NameError:
    pass
try:
    RestAuthenticationBasicSecretRestPaginationTypeResponseHeaderLink.model_rebuild()
except NameError:
    pass
try:
    RestAuthenticationBasicSecretRestPaginationTypeResponseHeader.model_rebuild()
except NameError:
    pass
try:
    RestAuthenticationBasicSecretRestPaginationTypeResponseBody.model_rebuild()
except NameError:
    pass
try:
    RestAuthenticationBasicSecretRestRetryRulesTypeBackoffEnableHeaderTrue.model_rebuild()
except NameError:
    pass
try:
    RestAuthenticationBasicSecretRestRetryRulesTypeBackoffEnableHeaderFalse.model_rebuild()
except NameError:
    pass
try:
    RestAuthenticationBasicSecretRestRetryRulesTypeStaticEnableHeaderTrue.model_rebuild()
except NameError:
    pass
try:
    RestAuthenticationBasicSecretRestRetryRulesTypeStaticEnableHeaderFalse.model_rebuild()
except NameError:
    pass
