"""Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT."""

from __future__ import annotations
from .itemstyperestcollectmethodgetcollectrequestparams import (
    ItemsTypeRestCollectMethodGetCollectRequestParams,
    ItemsTypeRestCollectMethodGetCollectRequestParamsTypedDict,
)
from .paginationoptionsrestdiscoverydiscovertypehttppagination import (
    PaginationOptionsRestDiscoveryDiscoverTypeHTTPPagination,
)
from .retrytypeoptionshealthcheckcollectorconfretryrules import (
    RetryTypeOptionsHealthCheckCollectorConfRetryRules,
)
from cribl_control_plane import models, utils
from cribl_control_plane.types import BaseModel, UNSET_SENTINEL
from cribl_control_plane.utils.unions import parse_open_union
from enum import Enum
from functools import partial
import pydantic
from pydantic import ConfigDict, field_serializer, model_serializer
from pydantic.functional_validators import BeforeValidator
from typing import Any, List, Literal, Optional, Union
from typing_extensions import Annotated, NotRequired, TypeAliasType, TypedDict


class RestAuthenticationHmacAuthentication(str, Enum, metaclass=utils.OpenEnumMeta):
    r"""Authentication method for Discover and Collect REST calls. You can specify API key–based authentication by adding the appropriate Collect headers."""

    NONE = "none"
    BASIC = "basic"
    BASIC_SECRET = "basicSecret"
    LOGIN = "login"
    LOGIN_SECRET = "loginSecret"
    OAUTH = "oauth"
    OAUTH_SECRET = "oauthSecret"
    GOOGLE_OAUTH = "google_oauth"
    GOOGLE_OAUTH_SECRET = "google_oauthSecret"
    HMAC = "hmac"


class RestAuthenticationHmacRestDiscoveryDiscoverTypeNoneDiscoverType(
    str, Enum, metaclass=utils.OpenEnumMeta
):
    r"""Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task."""

    HTTP = "http"
    JSON = "json"
    LIST = "list"
    NONE = "none"


class RestAuthenticationHmacRestDiscoveryDiscoverTypeNoneTypedDict(TypedDict):
    discover_type: RestAuthenticationHmacRestDiscoveryDiscoverTypeNoneDiscoverType
    r"""Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task."""


class RestAuthenticationHmacRestDiscoveryDiscoverTypeNone(BaseModel):
    discover_type: Annotated[
        RestAuthenticationHmacRestDiscoveryDiscoverTypeNoneDiscoverType,
        pydantic.Field(alias="discoverType"),
    ]
    r"""Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task."""

    @field_serializer("discover_type")
    def serialize_discover_type(self, value):
        if isinstance(value, str):
            try:
                return models.RestAuthenticationHmacRestDiscoveryDiscoverTypeNoneDiscoverType(
                    value
                )
            except ValueError:
                return value
        return value


class RestAuthenticationHmacRestDiscoveryDiscoverTypeListDiscoverType(
    str, Enum, metaclass=utils.OpenEnumMeta
):
    r"""Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task."""

    HTTP = "http"
    JSON = "json"
    LIST = "list"
    NONE = "none"


class RestAuthenticationHmacRestDiscoveryDiscoverTypeListTypedDict(TypedDict):
    discover_type: RestAuthenticationHmacRestDiscoveryDiscoverTypeListDiscoverType
    r"""Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task."""
    item_list: List[str]
    r"""Comma-separated list of items to return from the Discover task. Each item returned generates a Collect task and can be referenced using `${id}` in the Collect URL, headers, or parameters."""


class RestAuthenticationHmacRestDiscoveryDiscoverTypeList(BaseModel):
    discover_type: Annotated[
        RestAuthenticationHmacRestDiscoveryDiscoverTypeListDiscoverType,
        pydantic.Field(alias="discoverType"),
    ]
    r"""Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task."""

    item_list: Annotated[List[str], pydantic.Field(alias="itemList")]
    r"""Comma-separated list of items to return from the Discover task. Each item returned generates a Collect task and can be referenced using `${id}` in the Collect URL, headers, or parameters."""

    @field_serializer("discover_type")
    def serialize_discover_type(self, value):
        if isinstance(value, str):
            try:
                return models.RestAuthenticationHmacRestDiscoveryDiscoverTypeListDiscoverType(
                    value
                )
            except ValueError:
                return value
        return value


class RestAuthenticationHmacRestDiscoveryDiscoverTypeJSONDiscoverType(
    str, Enum, metaclass=utils.OpenEnumMeta
):
    r"""Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task."""

    HTTP = "http"
    JSON = "json"
    LIST = "list"
    NONE = "none"


class RestAuthenticationHmacRestDiscoveryDiscoverTypeJSONTypedDict(TypedDict):
    discover_type: RestAuthenticationHmacRestDiscoveryDiscoverTypeJSONDiscoverType
    r"""Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task."""
    manual_discover_result: str
    r"""Allows hard-coding the Discover result. Must be a JSON object or array. Works with Discover data field."""
    discover_data_field: NotRequired[str]
    r"""Within the response JSON, the name of the field to pull results from, typically a JSON array. Leave blank if the result itself is an array of values. Sample entry: items, json: { items: [{id: 'first'},{id: 'second'}] }"""


class RestAuthenticationHmacRestDiscoveryDiscoverTypeJSON(BaseModel):
    discover_type: Annotated[
        RestAuthenticationHmacRestDiscoveryDiscoverTypeJSONDiscoverType,
        pydantic.Field(alias="discoverType"),
    ]
    r"""Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task."""

    manual_discover_result: Annotated[str, pydantic.Field(alias="manualDiscoverResult")]
    r"""Allows hard-coding the Discover result. Must be a JSON object or array. Works with Discover data field."""

    discover_data_field: Annotated[
        Optional[str], pydantic.Field(alias="discoverDataField")
    ] = None
    r"""Within the response JSON, the name of the field to pull results from, typically a JSON array. Leave blank if the result itself is an array of values. Sample entry: items, json: { items: [{id: 'first'},{id: 'second'}] }"""

    @field_serializer("discover_type")
    def serialize_discover_type(self, value):
        if isinstance(value, str):
            try:
                return models.RestAuthenticationHmacRestDiscoveryDiscoverTypeJSONDiscoverType(
                    value
                )
            except ValueError:
                return value
        return value

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(["discoverDataField"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


class RestAuthenticationHmacRestDiscoveryDiscoverTypeHTTPDiscoverMethodOtherDiscoverMethod(
    str, Enum, metaclass=utils.OpenEnumMeta
):
    # GET
    GET = "get"
    # POST
    POST = "post"
    # POST with Body
    POST_WITH_BODY = "post_with_body"
    # Other
    OTHER = "other"


class RestAuthenticationHmacRestDiscoveryDiscoverTypeHTTPDiscoverMethodOtherDiscoverType(
    str, Enum, metaclass=utils.OpenEnumMeta
):
    r"""Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task."""

    HTTP = "http"
    JSON = "json"
    LIST = "list"
    NONE = "none"


class RestAuthenticationHmacRestDiscoveryDiscoverTypeHTTPDiscoverMethodOtherPaginationTypedDict(
    TypedDict
):
    type: PaginationOptionsRestDiscoveryDiscoverTypeHTTPPagination


class RestAuthenticationHmacRestDiscoveryDiscoverTypeHTTPDiscoverMethodOtherPagination(
    BaseModel
):
    type: PaginationOptionsRestDiscoveryDiscoverTypeHTTPPagination

    @field_serializer("type")
    def serialize_type(self, value):
        if isinstance(value, str):
            try:
                return models.PaginationOptionsRestDiscoveryDiscoverTypeHTTPPagination(
                    value
                )
            except ValueError:
                return value
        return value


class RestAuthenticationHmacRestDiscoveryDiscoverTypeHTTPDiscoverMethodOtherTypedDict(
    TypedDict
):
    discover_method: RestAuthenticationHmacRestDiscoveryDiscoverTypeHTTPDiscoverMethodOtherDiscoverMethod
    discover_verb: str
    r"""Custom HTTP method to use for the Discover operation"""
    discover_type: RestAuthenticationHmacRestDiscoveryDiscoverTypeHTTPDiscoverMethodOtherDiscoverType
    r"""Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task."""
    discover_url: str
    r"""URL to use for the Discover operation. Can be a constant URL, or a JavaScript expression to derive the URL."""
    discover_body: NotRequired[str]
    r"""Template for body to send with the discover request"""
    discover_request_params: NotRequired[
        List[ItemsTypeRestCollectMethodGetCollectRequestParamsTypedDict]
    ]
    discover_request_headers: NotRequired[
        List[ItemsTypeRestCollectMethodGetCollectRequestParamsTypedDict]
    ]
    pagination: NotRequired[
        RestAuthenticationHmacRestDiscoveryDiscoverTypeHTTPDiscoverMethodOtherPaginationTypedDict
    ]
    discover_data_field: NotRequired[str]
    r"""Path to field in the response object that contains discovery results (ex: level1.name). Leave blank if the result is an array."""
    enable_strict_discover_parsing: NotRequired[bool]
    r"""Explicitly set the discover response format. When disabled, best effort parsing is used."""
    enable_discover_code: NotRequired[bool]


class RestAuthenticationHmacRestDiscoveryDiscoverTypeHTTPDiscoverMethodOther(BaseModel):
    discover_method: Annotated[
        RestAuthenticationHmacRestDiscoveryDiscoverTypeHTTPDiscoverMethodOtherDiscoverMethod,
        pydantic.Field(alias="discoverMethod"),
    ]

    discover_verb: Annotated[str, pydantic.Field(alias="discoverVerb")]
    r"""Custom HTTP method to use for the Discover operation"""

    discover_type: Annotated[
        RestAuthenticationHmacRestDiscoveryDiscoverTypeHTTPDiscoverMethodOtherDiscoverType,
        pydantic.Field(alias="discoverType"),
    ]
    r"""Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task."""

    discover_url: Annotated[str, pydantic.Field(alias="discoverUrl")]
    r"""URL to use for the Discover operation. Can be a constant URL, or a JavaScript expression to derive the URL."""

    discover_body: Annotated[Optional[str], pydantic.Field(alias="discoverBody")] = None
    r"""Template for body to send with the discover request"""

    discover_request_params: Annotated[
        Optional[List[ItemsTypeRestCollectMethodGetCollectRequestParams]],
        pydantic.Field(alias="discoverRequestParams"),
    ] = None

    discover_request_headers: Annotated[
        Optional[List[ItemsTypeRestCollectMethodGetCollectRequestParams]],
        pydantic.Field(alias="discoverRequestHeaders"),
    ] = None

    pagination: Optional[
        RestAuthenticationHmacRestDiscoveryDiscoverTypeHTTPDiscoverMethodOtherPagination
    ] = None

    discover_data_field: Annotated[
        Optional[str], pydantic.Field(alias="discoverDataField")
    ] = None
    r"""Path to field in the response object that contains discovery results (ex: level1.name). Leave blank if the result is an array."""

    enable_strict_discover_parsing: Annotated[
        Optional[bool], pydantic.Field(alias="enableStrictDiscoverParsing")
    ] = None
    r"""Explicitly set the discover response format. When disabled, best effort parsing is used."""

    enable_discover_code: Annotated[
        Optional[bool], pydantic.Field(alias="enableDiscoverCode")
    ] = None

    @field_serializer("discover_method")
    def serialize_discover_method(self, value):
        if isinstance(value, str):
            try:
                return models.RestAuthenticationHmacRestDiscoveryDiscoverTypeHTTPDiscoverMethodOtherDiscoverMethod(
                    value
                )
            except ValueError:
                return value
        return value

    @field_serializer("discover_type")
    def serialize_discover_type(self, value):
        if isinstance(value, str):
            try:
                return models.RestAuthenticationHmacRestDiscoveryDiscoverTypeHTTPDiscoverMethodOtherDiscoverType(
                    value
                )
            except ValueError:
                return value
        return value

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(
            [
                "discoverBody",
                "discoverRequestParams",
                "discoverRequestHeaders",
                "pagination",
                "discoverDataField",
                "enableStrictDiscoverParsing",
                "enableDiscoverCode",
            ]
        )
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


class RestAuthenticationHmacRestDiscoveryDiscoverTypeHTTPDiscoverMethodPostWithBodyDiscoverMethod(
    str, Enum, metaclass=utils.OpenEnumMeta
):
    # GET
    GET = "get"
    # POST
    POST = "post"
    # POST with Body
    POST_WITH_BODY = "post_with_body"
    # Other
    OTHER = "other"


class RestAuthenticationHmacRestDiscoveryDiscoverTypeHTTPDiscoverMethodPostWithBodyDiscoverType(
    str, Enum, metaclass=utils.OpenEnumMeta
):
    r"""Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task."""

    HTTP = "http"
    JSON = "json"
    LIST = "list"
    NONE = "none"


class RestAuthenticationHmacRestDiscoveryDiscoverTypeHTTPDiscoverMethodPostWithBodyPaginationTypedDict(
    TypedDict
):
    type: PaginationOptionsRestDiscoveryDiscoverTypeHTTPPagination


class RestAuthenticationHmacRestDiscoveryDiscoverTypeHTTPDiscoverMethodPostWithBodyPagination(
    BaseModel
):
    type: PaginationOptionsRestDiscoveryDiscoverTypeHTTPPagination

    @field_serializer("type")
    def serialize_type(self, value):
        if isinstance(value, str):
            try:
                return models.PaginationOptionsRestDiscoveryDiscoverTypeHTTPPagination(
                    value
                )
            except ValueError:
                return value
        return value


class RestAuthenticationHmacRestDiscoveryDiscoverTypeHTTPDiscoverMethodPostWithBodyTypedDict(
    TypedDict
):
    discover_method: RestAuthenticationHmacRestDiscoveryDiscoverTypeHTTPDiscoverMethodPostWithBodyDiscoverMethod
    discover_body: str
    r"""Template for POST body to send with the discover request. To reference global variables or functions, use template parameters: `{ myVar: ${C.vars.myVar}, secret: ${C.Secret('mySecret','text').value} }`"""
    discover_type: RestAuthenticationHmacRestDiscoveryDiscoverTypeHTTPDiscoverMethodPostWithBodyDiscoverType
    r"""Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task."""
    discover_url: str
    r"""URL to use for the Discover operation. Can be a constant URL, or a JavaScript expression to derive the URL."""
    discover_request_headers: NotRequired[
        List[ItemsTypeRestCollectMethodGetCollectRequestParamsTypedDict]
    ]
    pagination: NotRequired[
        RestAuthenticationHmacRestDiscoveryDiscoverTypeHTTPDiscoverMethodPostWithBodyPaginationTypedDict
    ]
    discover_data_field: NotRequired[str]
    r"""Path to field in the response object that contains discovery results (ex: level1.name). Leave blank if the result is an array."""
    enable_strict_discover_parsing: NotRequired[bool]
    r"""Explicitly set the discover response format. When disabled, best effort parsing is used."""
    enable_discover_code: NotRequired[bool]


class RestAuthenticationHmacRestDiscoveryDiscoverTypeHTTPDiscoverMethodPostWithBody(
    BaseModel
):
    discover_method: Annotated[
        RestAuthenticationHmacRestDiscoveryDiscoverTypeHTTPDiscoverMethodPostWithBodyDiscoverMethod,
        pydantic.Field(alias="discoverMethod"),
    ]

    discover_body: Annotated[str, pydantic.Field(alias="discoverBody")]
    r"""Template for POST body to send with the discover request. To reference global variables or functions, use template parameters: `{ myVar: ${C.vars.myVar}, secret: ${C.Secret('mySecret','text').value} }`"""

    discover_type: Annotated[
        RestAuthenticationHmacRestDiscoveryDiscoverTypeHTTPDiscoverMethodPostWithBodyDiscoverType,
        pydantic.Field(alias="discoverType"),
    ]
    r"""Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task."""

    discover_url: Annotated[str, pydantic.Field(alias="discoverUrl")]
    r"""URL to use for the Discover operation. Can be a constant URL, or a JavaScript expression to derive the URL."""

    discover_request_headers: Annotated[
        Optional[List[ItemsTypeRestCollectMethodGetCollectRequestParams]],
        pydantic.Field(alias="discoverRequestHeaders"),
    ] = None

    pagination: Optional[
        RestAuthenticationHmacRestDiscoveryDiscoverTypeHTTPDiscoverMethodPostWithBodyPagination
    ] = None

    discover_data_field: Annotated[
        Optional[str], pydantic.Field(alias="discoverDataField")
    ] = None
    r"""Path to field in the response object that contains discovery results (ex: level1.name). Leave blank if the result is an array."""

    enable_strict_discover_parsing: Annotated[
        Optional[bool], pydantic.Field(alias="enableStrictDiscoverParsing")
    ] = None
    r"""Explicitly set the discover response format. When disabled, best effort parsing is used."""

    enable_discover_code: Annotated[
        Optional[bool], pydantic.Field(alias="enableDiscoverCode")
    ] = None

    @field_serializer("discover_method")
    def serialize_discover_method(self, value):
        if isinstance(value, str):
            try:
                return models.RestAuthenticationHmacRestDiscoveryDiscoverTypeHTTPDiscoverMethodPostWithBodyDiscoverMethod(
                    value
                )
            except ValueError:
                return value
        return value

    @field_serializer("discover_type")
    def serialize_discover_type(self, value):
        if isinstance(value, str):
            try:
                return models.RestAuthenticationHmacRestDiscoveryDiscoverTypeHTTPDiscoverMethodPostWithBodyDiscoverType(
                    value
                )
            except ValueError:
                return value
        return value

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(
            [
                "discoverRequestHeaders",
                "pagination",
                "discoverDataField",
                "enableStrictDiscoverParsing",
                "enableDiscoverCode",
            ]
        )
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


class RestAuthenticationHmacRestDiscoveryDiscoverTypeHTTPDiscoverMethodPostDiscoverMethod(
    str, Enum, metaclass=utils.OpenEnumMeta
):
    # GET
    GET = "get"
    # POST
    POST = "post"
    # POST with Body
    POST_WITH_BODY = "post_with_body"
    # Other
    OTHER = "other"


class RestAuthenticationHmacRestDiscoveryDiscoverTypeHTTPDiscoverMethodPostDiscoverType(
    str, Enum, metaclass=utils.OpenEnumMeta
):
    r"""Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task."""

    HTTP = "http"
    JSON = "json"
    LIST = "list"
    NONE = "none"


class RestAuthenticationHmacRestDiscoveryDiscoverTypeHTTPDiscoverMethodPostPaginationTypedDict(
    TypedDict
):
    type: PaginationOptionsRestDiscoveryDiscoverTypeHTTPPagination


class RestAuthenticationHmacRestDiscoveryDiscoverTypeHTTPDiscoverMethodPostPagination(
    BaseModel
):
    type: PaginationOptionsRestDiscoveryDiscoverTypeHTTPPagination

    @field_serializer("type")
    def serialize_type(self, value):
        if isinstance(value, str):
            try:
                return models.PaginationOptionsRestDiscoveryDiscoverTypeHTTPPagination(
                    value
                )
            except ValueError:
                return value
        return value


class RestAuthenticationHmacRestDiscoveryDiscoverTypeHTTPDiscoverMethodPostTypedDict(
    TypedDict
):
    discover_method: RestAuthenticationHmacRestDiscoveryDiscoverTypeHTTPDiscoverMethodPostDiscoverMethod
    discover_type: RestAuthenticationHmacRestDiscoveryDiscoverTypeHTTPDiscoverMethodPostDiscoverType
    r"""Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task."""
    discover_url: str
    r"""URL to use for the Discover operation. Can be a constant URL, or a JavaScript expression to derive the URL."""
    discover_request_params: NotRequired[
        List[ItemsTypeRestCollectMethodGetCollectRequestParamsTypedDict]
    ]
    discover_request_headers: NotRequired[
        List[ItemsTypeRestCollectMethodGetCollectRequestParamsTypedDict]
    ]
    pagination: NotRequired[
        RestAuthenticationHmacRestDiscoveryDiscoverTypeHTTPDiscoverMethodPostPaginationTypedDict
    ]
    discover_data_field: NotRequired[str]
    r"""Path to field in the response object that contains discovery results (ex: level1.name). Leave blank if the result is an array."""
    enable_strict_discover_parsing: NotRequired[bool]
    r"""Explicitly set the discover response format. When disabled, best effort parsing is used."""
    enable_discover_code: NotRequired[bool]


class RestAuthenticationHmacRestDiscoveryDiscoverTypeHTTPDiscoverMethodPost(BaseModel):
    discover_method: Annotated[
        RestAuthenticationHmacRestDiscoveryDiscoverTypeHTTPDiscoverMethodPostDiscoverMethod,
        pydantic.Field(alias="discoverMethod"),
    ]

    discover_type: Annotated[
        RestAuthenticationHmacRestDiscoveryDiscoverTypeHTTPDiscoverMethodPostDiscoverType,
        pydantic.Field(alias="discoverType"),
    ]
    r"""Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task."""

    discover_url: Annotated[str, pydantic.Field(alias="discoverUrl")]
    r"""URL to use for the Discover operation. Can be a constant URL, or a JavaScript expression to derive the URL."""

    discover_request_params: Annotated[
        Optional[List[ItemsTypeRestCollectMethodGetCollectRequestParams]],
        pydantic.Field(alias="discoverRequestParams"),
    ] = None

    discover_request_headers: Annotated[
        Optional[List[ItemsTypeRestCollectMethodGetCollectRequestParams]],
        pydantic.Field(alias="discoverRequestHeaders"),
    ] = None

    pagination: Optional[
        RestAuthenticationHmacRestDiscoveryDiscoverTypeHTTPDiscoverMethodPostPagination
    ] = None

    discover_data_field: Annotated[
        Optional[str], pydantic.Field(alias="discoverDataField")
    ] = None
    r"""Path to field in the response object that contains discovery results (ex: level1.name). Leave blank if the result is an array."""

    enable_strict_discover_parsing: Annotated[
        Optional[bool], pydantic.Field(alias="enableStrictDiscoverParsing")
    ] = None
    r"""Explicitly set the discover response format. When disabled, best effort parsing is used."""

    enable_discover_code: Annotated[
        Optional[bool], pydantic.Field(alias="enableDiscoverCode")
    ] = None

    @field_serializer("discover_method")
    def serialize_discover_method(self, value):
        if isinstance(value, str):
            try:
                return models.RestAuthenticationHmacRestDiscoveryDiscoverTypeHTTPDiscoverMethodPostDiscoverMethod(
                    value
                )
            except ValueError:
                return value
        return value

    @field_serializer("discover_type")
    def serialize_discover_type(self, value):
        if isinstance(value, str):
            try:
                return models.RestAuthenticationHmacRestDiscoveryDiscoverTypeHTTPDiscoverMethodPostDiscoverType(
                    value
                )
            except ValueError:
                return value
        return value

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(
            [
                "discoverRequestParams",
                "discoverRequestHeaders",
                "pagination",
                "discoverDataField",
                "enableStrictDiscoverParsing",
                "enableDiscoverCode",
            ]
        )
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


class RestAuthenticationHmacRestDiscoveryDiscoverTypeHTTPDiscoverMethodGetDiscoverMethod(
    str, Enum, metaclass=utils.OpenEnumMeta
):
    # GET
    GET = "get"
    # POST
    POST = "post"
    # POST with Body
    POST_WITH_BODY = "post_with_body"
    # Other
    OTHER = "other"


class RestAuthenticationHmacRestDiscoveryDiscoverTypeHTTPDiscoverMethodGetDiscoverType(
    str, Enum, metaclass=utils.OpenEnumMeta
):
    r"""Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task."""

    HTTP = "http"
    JSON = "json"
    LIST = "list"
    NONE = "none"


class RestAuthenticationHmacRestDiscoveryDiscoverTypeHTTPDiscoverMethodGetPaginationTypedDict(
    TypedDict
):
    type: PaginationOptionsRestDiscoveryDiscoverTypeHTTPPagination


class RestAuthenticationHmacRestDiscoveryDiscoverTypeHTTPDiscoverMethodGetPagination(
    BaseModel
):
    type: PaginationOptionsRestDiscoveryDiscoverTypeHTTPPagination

    @field_serializer("type")
    def serialize_type(self, value):
        if isinstance(value, str):
            try:
                return models.PaginationOptionsRestDiscoveryDiscoverTypeHTTPPagination(
                    value
                )
            except ValueError:
                return value
        return value


class RestAuthenticationHmacRestDiscoveryDiscoverTypeHTTPDiscoverMethodGetTypedDict(
    TypedDict
):
    discover_method: RestAuthenticationHmacRestDiscoveryDiscoverTypeHTTPDiscoverMethodGetDiscoverMethod
    discover_type: (
        RestAuthenticationHmacRestDiscoveryDiscoverTypeHTTPDiscoverMethodGetDiscoverType
    )
    r"""Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task."""
    discover_url: str
    r"""URL to use for the Discover operation. Can be a constant URL, or a JavaScript expression to derive the URL."""
    discover_request_params: NotRequired[
        List[ItemsTypeRestCollectMethodGetCollectRequestParamsTypedDict]
    ]
    discover_request_headers: NotRequired[
        List[ItemsTypeRestCollectMethodGetCollectRequestParamsTypedDict]
    ]
    pagination: NotRequired[
        RestAuthenticationHmacRestDiscoveryDiscoverTypeHTTPDiscoverMethodGetPaginationTypedDict
    ]
    discover_data_field: NotRequired[str]
    r"""Path to field in the response object that contains discovery results (ex: level1.name). Leave blank if the result is an array."""
    enable_strict_discover_parsing: NotRequired[bool]
    r"""Explicitly set the discover response format. When disabled, best effort parsing is used."""
    enable_discover_code: NotRequired[bool]


class RestAuthenticationHmacRestDiscoveryDiscoverTypeHTTPDiscoverMethodGet(BaseModel):
    discover_method: Annotated[
        RestAuthenticationHmacRestDiscoveryDiscoverTypeHTTPDiscoverMethodGetDiscoverMethod,
        pydantic.Field(alias="discoverMethod"),
    ]

    discover_type: Annotated[
        RestAuthenticationHmacRestDiscoveryDiscoverTypeHTTPDiscoverMethodGetDiscoverType,
        pydantic.Field(alias="discoverType"),
    ]
    r"""Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task."""

    discover_url: Annotated[str, pydantic.Field(alias="discoverUrl")]
    r"""URL to use for the Discover operation. Can be a constant URL, or a JavaScript expression to derive the URL."""

    discover_request_params: Annotated[
        Optional[List[ItemsTypeRestCollectMethodGetCollectRequestParams]],
        pydantic.Field(alias="discoverRequestParams"),
    ] = None

    discover_request_headers: Annotated[
        Optional[List[ItemsTypeRestCollectMethodGetCollectRequestParams]],
        pydantic.Field(alias="discoverRequestHeaders"),
    ] = None

    pagination: Optional[
        RestAuthenticationHmacRestDiscoveryDiscoverTypeHTTPDiscoverMethodGetPagination
    ] = None

    discover_data_field: Annotated[
        Optional[str], pydantic.Field(alias="discoverDataField")
    ] = None
    r"""Path to field in the response object that contains discovery results (ex: level1.name). Leave blank if the result is an array."""

    enable_strict_discover_parsing: Annotated[
        Optional[bool], pydantic.Field(alias="enableStrictDiscoverParsing")
    ] = None
    r"""Explicitly set the discover response format. When disabled, best effort parsing is used."""

    enable_discover_code: Annotated[
        Optional[bool], pydantic.Field(alias="enableDiscoverCode")
    ] = None

    @field_serializer("discover_method")
    def serialize_discover_method(self, value):
        if isinstance(value, str):
            try:
                return models.RestAuthenticationHmacRestDiscoveryDiscoverTypeHTTPDiscoverMethodGetDiscoverMethod(
                    value
                )
            except ValueError:
                return value
        return value

    @field_serializer("discover_type")
    def serialize_discover_type(self, value):
        if isinstance(value, str):
            try:
                return models.RestAuthenticationHmacRestDiscoveryDiscoverTypeHTTPDiscoverMethodGetDiscoverType(
                    value
                )
            except ValueError:
                return value
        return value

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(
            [
                "discoverRequestParams",
                "discoverRequestHeaders",
                "pagination",
                "discoverDataField",
                "enableStrictDiscoverParsing",
                "enableDiscoverCode",
            ]
        )
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


class RestAuthenticationHmacRestDiscoveryDiscoverTypeHTTPEnableDiscoverCodeTrueDiscoverType(
    str, Enum, metaclass=utils.OpenEnumMeta
):
    r"""Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task."""

    HTTP = "http"
    JSON = "json"
    LIST = "list"
    NONE = "none"


class RestAuthenticationHmacRestDiscoveryDiscoverTypeHTTPEnableDiscoverCodeTrueDiscoverMethod(
    str, Enum, metaclass=utils.OpenEnumMeta
):
    # GET
    GET = "get"
    # POST
    POST = "post"
    # POST with Body
    POST_WITH_BODY = "post_with_body"
    # Other
    OTHER = "other"


class RestAuthenticationHmacRestDiscoveryDiscoverTypeHTTPEnableDiscoverCodeTruePaginationTypedDict(
    TypedDict
):
    type: PaginationOptionsRestDiscoveryDiscoverTypeHTTPPagination


class RestAuthenticationHmacRestDiscoveryDiscoverTypeHTTPEnableDiscoverCodeTruePagination(
    BaseModel
):
    type: PaginationOptionsRestDiscoveryDiscoverTypeHTTPPagination

    @field_serializer("type")
    def serialize_type(self, value):
        if isinstance(value, str):
            try:
                return models.PaginationOptionsRestDiscoveryDiscoverTypeHTTPPagination(
                    value
                )
            except ValueError:
                return value
        return value


class RestAuthenticationHmacRestDiscoveryDiscoverTypeHTTPEnableDiscoverCodeTrueTypedDict(
    TypedDict
):
    discover_type: RestAuthenticationHmacRestDiscoveryDiscoverTypeHTTPEnableDiscoverCodeTrueDiscoverType
    r"""Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task."""
    discover_url: str
    r"""URL to use for the Discover operation. Can be a constant URL, or a JavaScript expression to derive the URL."""
    discover_method: RestAuthenticationHmacRestDiscoveryDiscoverTypeHTTPEnableDiscoverCodeTrueDiscoverMethod
    enable_discover_code: NotRequired[bool]
    format_result_code: NotRequired[str]
    r"""Custom JavaScript code to format the discover result through the __e variable which is a JSON object or array containing the original discover results. The object or array passed should be manipulated to contain the desired discover results, i.e.: __e['myResult'] = [{lat: -1.1234, long: 2.345, zip: 11111},{lat: -1.235, long 2.346, zip: 22222}] or ['11111','22222']. Caution: This function is evaluated in an unprotected context, allowing you to execute almost any JavaScript code."""
    discover_request_headers: NotRequired[
        List[ItemsTypeRestCollectMethodGetCollectRequestParamsTypedDict]
    ]
    pagination: NotRequired[
        RestAuthenticationHmacRestDiscoveryDiscoverTypeHTTPEnableDiscoverCodeTruePaginationTypedDict
    ]
    discover_data_field: NotRequired[str]
    r"""Path to field in the response object that contains discovery results (ex: level1.name). Leave blank if the result is an array."""
    enable_strict_discover_parsing: NotRequired[bool]
    r"""Explicitly set the discover response format. When disabled, best effort parsing is used."""


class RestAuthenticationHmacRestDiscoveryDiscoverTypeHTTPEnableDiscoverCodeTrue(
    BaseModel
):
    discover_type: Annotated[
        RestAuthenticationHmacRestDiscoveryDiscoverTypeHTTPEnableDiscoverCodeTrueDiscoverType,
        pydantic.Field(alias="discoverType"),
    ]
    r"""Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task."""

    discover_url: Annotated[str, pydantic.Field(alias="discoverUrl")]
    r"""URL to use for the Discover operation. Can be a constant URL, or a JavaScript expression to derive the URL."""

    discover_method: Annotated[
        RestAuthenticationHmacRestDiscoveryDiscoverTypeHTTPEnableDiscoverCodeTrueDiscoverMethod,
        pydantic.Field(alias="discoverMethod"),
    ]

    enable_discover_code: Annotated[
        Optional[bool], pydantic.Field(alias="enableDiscoverCode")
    ] = None

    format_result_code: Annotated[
        Optional[str], pydantic.Field(alias="formatResultCode")
    ] = None
    r"""Custom JavaScript code to format the discover result through the __e variable which is a JSON object or array containing the original discover results. The object or array passed should be manipulated to contain the desired discover results, i.e.: __e['myResult'] = [{lat: -1.1234, long: 2.345, zip: 11111},{lat: -1.235, long 2.346, zip: 22222}] or ['11111','22222']. Caution: This function is evaluated in an unprotected context, allowing you to execute almost any JavaScript code."""

    discover_request_headers: Annotated[
        Optional[List[ItemsTypeRestCollectMethodGetCollectRequestParams]],
        pydantic.Field(alias="discoverRequestHeaders"),
    ] = None

    pagination: Optional[
        RestAuthenticationHmacRestDiscoveryDiscoverTypeHTTPEnableDiscoverCodeTruePagination
    ] = None

    discover_data_field: Annotated[
        Optional[str], pydantic.Field(alias="discoverDataField")
    ] = None
    r"""Path to field in the response object that contains discovery results (ex: level1.name). Leave blank if the result is an array."""

    enable_strict_discover_parsing: Annotated[
        Optional[bool], pydantic.Field(alias="enableStrictDiscoverParsing")
    ] = None
    r"""Explicitly set the discover response format. When disabled, best effort parsing is used."""

    @field_serializer("discover_type")
    def serialize_discover_type(self, value):
        if isinstance(value, str):
            try:
                return models.RestAuthenticationHmacRestDiscoveryDiscoverTypeHTTPEnableDiscoverCodeTrueDiscoverType(
                    value
                )
            except ValueError:
                return value
        return value

    @field_serializer("discover_method")
    def serialize_discover_method(self, value):
        if isinstance(value, str):
            try:
                return models.RestAuthenticationHmacRestDiscoveryDiscoverTypeHTTPEnableDiscoverCodeTrueDiscoverMethod(
                    value
                )
            except ValueError:
                return value
        return value

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(
            [
                "enableDiscoverCode",
                "formatResultCode",
                "discoverRequestHeaders",
                "pagination",
                "discoverDataField",
                "enableStrictDiscoverParsing",
            ]
        )
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


class RestAuthenticationHmacRestDiscoveryDiscoverTypeHTTPEnableDiscoverCodeFalseDiscoverType(
    str, Enum, metaclass=utils.OpenEnumMeta
):
    r"""Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task."""

    HTTP = "http"
    JSON = "json"
    LIST = "list"
    NONE = "none"


class RestAuthenticationHmacRestDiscoveryDiscoverTypeHTTPEnableDiscoverCodeFalseDiscoverMethod(
    str, Enum, metaclass=utils.OpenEnumMeta
):
    # GET
    GET = "get"
    # POST
    POST = "post"
    # POST with Body
    POST_WITH_BODY = "post_with_body"
    # Other
    OTHER = "other"


class RestAuthenticationHmacRestDiscoveryDiscoverTypeHTTPEnableDiscoverCodeFalsePaginationTypedDict(
    TypedDict
):
    type: PaginationOptionsRestDiscoveryDiscoverTypeHTTPPagination


class RestAuthenticationHmacRestDiscoveryDiscoverTypeHTTPEnableDiscoverCodeFalsePagination(
    BaseModel
):
    type: PaginationOptionsRestDiscoveryDiscoverTypeHTTPPagination

    @field_serializer("type")
    def serialize_type(self, value):
        if isinstance(value, str):
            try:
                return models.PaginationOptionsRestDiscoveryDiscoverTypeHTTPPagination(
                    value
                )
            except ValueError:
                return value
        return value


class RestAuthenticationHmacRestDiscoveryDiscoverTypeHTTPEnableDiscoverCodeFalseTypedDict(
    TypedDict
):
    discover_type: RestAuthenticationHmacRestDiscoveryDiscoverTypeHTTPEnableDiscoverCodeFalseDiscoverType
    r"""Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task."""
    discover_url: str
    r"""URL to use for the Discover operation. Can be a constant URL, or a JavaScript expression to derive the URL."""
    discover_method: RestAuthenticationHmacRestDiscoveryDiscoverTypeHTTPEnableDiscoverCodeFalseDiscoverMethod
    enable_discover_code: NotRequired[bool]
    discover_request_headers: NotRequired[
        List[ItemsTypeRestCollectMethodGetCollectRequestParamsTypedDict]
    ]
    pagination: NotRequired[
        RestAuthenticationHmacRestDiscoveryDiscoverTypeHTTPEnableDiscoverCodeFalsePaginationTypedDict
    ]
    discover_data_field: NotRequired[str]
    r"""Path to field in the response object that contains discovery results (ex: level1.name). Leave blank if the result is an array."""
    enable_strict_discover_parsing: NotRequired[bool]
    r"""Explicitly set the discover response format. When disabled, best effort parsing is used."""


class RestAuthenticationHmacRestDiscoveryDiscoverTypeHTTPEnableDiscoverCodeFalse(
    BaseModel
):
    discover_type: Annotated[
        RestAuthenticationHmacRestDiscoveryDiscoverTypeHTTPEnableDiscoverCodeFalseDiscoverType,
        pydantic.Field(alias="discoverType"),
    ]
    r"""Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task."""

    discover_url: Annotated[str, pydantic.Field(alias="discoverUrl")]
    r"""URL to use for the Discover operation. Can be a constant URL, or a JavaScript expression to derive the URL."""

    discover_method: Annotated[
        RestAuthenticationHmacRestDiscoveryDiscoverTypeHTTPEnableDiscoverCodeFalseDiscoverMethod,
        pydantic.Field(alias="discoverMethod"),
    ]

    enable_discover_code: Annotated[
        Optional[bool], pydantic.Field(alias="enableDiscoverCode")
    ] = None

    discover_request_headers: Annotated[
        Optional[List[ItemsTypeRestCollectMethodGetCollectRequestParams]],
        pydantic.Field(alias="discoverRequestHeaders"),
    ] = None

    pagination: Optional[
        RestAuthenticationHmacRestDiscoveryDiscoverTypeHTTPEnableDiscoverCodeFalsePagination
    ] = None

    discover_data_field: Annotated[
        Optional[str], pydantic.Field(alias="discoverDataField")
    ] = None
    r"""Path to field in the response object that contains discovery results (ex: level1.name). Leave blank if the result is an array."""

    enable_strict_discover_parsing: Annotated[
        Optional[bool], pydantic.Field(alias="enableStrictDiscoverParsing")
    ] = None
    r"""Explicitly set the discover response format. When disabled, best effort parsing is used."""

    @field_serializer("discover_type")
    def serialize_discover_type(self, value):
        if isinstance(value, str):
            try:
                return models.RestAuthenticationHmacRestDiscoveryDiscoverTypeHTTPEnableDiscoverCodeFalseDiscoverType(
                    value
                )
            except ValueError:
                return value
        return value

    @field_serializer("discover_method")
    def serialize_discover_method(self, value):
        if isinstance(value, str):
            try:
                return models.RestAuthenticationHmacRestDiscoveryDiscoverTypeHTTPEnableDiscoverCodeFalseDiscoverMethod(
                    value
                )
            except ValueError:
                return value
        return value

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(
            [
                "enableDiscoverCode",
                "discoverRequestHeaders",
                "pagination",
                "discoverDataField",
                "enableStrictDiscoverParsing",
            ]
        )
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


class RestAuthenticationHmacRestDiscoveryDiscoverTypeHTTPEnableStrictDiscoverParsingTrueDiscoverType(
    str, Enum, metaclass=utils.OpenEnumMeta
):
    r"""Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task."""

    HTTP = "http"
    JSON = "json"
    LIST = "list"
    NONE = "none"


class RestAuthenticationHmacRestDiscoveryDiscoverTypeHTTPEnableStrictDiscoverParsingTrueDiscoverMethod(
    str, Enum, metaclass=utils.OpenEnumMeta
):
    # GET
    GET = "get"
    # POST
    POST = "post"
    # POST with Body
    POST_WITH_BODY = "post_with_body"
    # Other
    OTHER = "other"


class RestAuthenticationHmacRestDiscoveryDiscoverTypeHTTPEnableStrictDiscoverParsingTruePaginationTypedDict(
    TypedDict
):
    type: PaginationOptionsRestDiscoveryDiscoverTypeHTTPPagination


class RestAuthenticationHmacRestDiscoveryDiscoverTypeHTTPEnableStrictDiscoverParsingTruePagination(
    BaseModel
):
    type: PaginationOptionsRestDiscoveryDiscoverTypeHTTPPagination

    @field_serializer("type")
    def serialize_type(self, value):
        if isinstance(value, str):
            try:
                return models.PaginationOptionsRestDiscoveryDiscoverTypeHTTPPagination(
                    value
                )
            except ValueError:
                return value
        return value


class RestAuthenticationHmacRestDiscoveryDiscoverTypeHTTPEnableStrictDiscoverParsingTrueTypedDict(
    TypedDict
):
    discover_response_format: str
    r"""If 'Strict discover response parsing' parsing is enabled, provide the response format"""
    discover_type: RestAuthenticationHmacRestDiscoveryDiscoverTypeHTTPEnableStrictDiscoverParsingTrueDiscoverType
    r"""Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task."""
    discover_url: str
    r"""URL to use for the Discover operation. Can be a constant URL, or a JavaScript expression to derive the URL."""
    discover_method: RestAuthenticationHmacRestDiscoveryDiscoverTypeHTTPEnableStrictDiscoverParsingTrueDiscoverMethod
    enable_strict_discover_parsing: NotRequired[bool]
    r"""Explicitly set the discover response format. When disabled, best effort parsing is used."""
    discover_request_headers: NotRequired[
        List[ItemsTypeRestCollectMethodGetCollectRequestParamsTypedDict]
    ]
    pagination: NotRequired[
        RestAuthenticationHmacRestDiscoveryDiscoverTypeHTTPEnableStrictDiscoverParsingTruePaginationTypedDict
    ]
    discover_data_field: NotRequired[str]
    r"""Path to field in the response object that contains discovery results (ex: level1.name). Leave blank if the result is an array."""
    enable_discover_code: NotRequired[bool]


class RestAuthenticationHmacRestDiscoveryDiscoverTypeHTTPEnableStrictDiscoverParsingTrue(
    BaseModel
):
    discover_response_format: Annotated[
        str, pydantic.Field(alias="discoverResponseFormat")
    ]
    r"""If 'Strict discover response parsing' parsing is enabled, provide the response format"""

    discover_type: Annotated[
        RestAuthenticationHmacRestDiscoveryDiscoverTypeHTTPEnableStrictDiscoverParsingTrueDiscoverType,
        pydantic.Field(alias="discoverType"),
    ]
    r"""Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task."""

    discover_url: Annotated[str, pydantic.Field(alias="discoverUrl")]
    r"""URL to use for the Discover operation. Can be a constant URL, or a JavaScript expression to derive the URL."""

    discover_method: Annotated[
        RestAuthenticationHmacRestDiscoveryDiscoverTypeHTTPEnableStrictDiscoverParsingTrueDiscoverMethod,
        pydantic.Field(alias="discoverMethod"),
    ]

    enable_strict_discover_parsing: Annotated[
        Optional[bool], pydantic.Field(alias="enableStrictDiscoverParsing")
    ] = None
    r"""Explicitly set the discover response format. When disabled, best effort parsing is used."""

    discover_request_headers: Annotated[
        Optional[List[ItemsTypeRestCollectMethodGetCollectRequestParams]],
        pydantic.Field(alias="discoverRequestHeaders"),
    ] = None

    pagination: Optional[
        RestAuthenticationHmacRestDiscoveryDiscoverTypeHTTPEnableStrictDiscoverParsingTruePagination
    ] = None

    discover_data_field: Annotated[
        Optional[str], pydantic.Field(alias="discoverDataField")
    ] = None
    r"""Path to field in the response object that contains discovery results (ex: level1.name). Leave blank if the result is an array."""

    enable_discover_code: Annotated[
        Optional[bool], pydantic.Field(alias="enableDiscoverCode")
    ] = None

    @field_serializer("discover_type")
    def serialize_discover_type(self, value):
        if isinstance(value, str):
            try:
                return models.RestAuthenticationHmacRestDiscoveryDiscoverTypeHTTPEnableStrictDiscoverParsingTrueDiscoverType(
                    value
                )
            except ValueError:
                return value
        return value

    @field_serializer("discover_method")
    def serialize_discover_method(self, value):
        if isinstance(value, str):
            try:
                return models.RestAuthenticationHmacRestDiscoveryDiscoverTypeHTTPEnableStrictDiscoverParsingTrueDiscoverMethod(
                    value
                )
            except ValueError:
                return value
        return value

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(
            [
                "enableStrictDiscoverParsing",
                "discoverRequestHeaders",
                "pagination",
                "discoverDataField",
                "enableDiscoverCode",
            ]
        )
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


class RestAuthenticationHmacRestDiscoveryDiscoverTypeHTTPEnableStrictDiscoverParsingFalseDiscoverType(
    str, Enum, metaclass=utils.OpenEnumMeta
):
    r"""Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task."""

    HTTP = "http"
    JSON = "json"
    LIST = "list"
    NONE = "none"


class RestAuthenticationHmacRestDiscoveryDiscoverTypeHTTPEnableStrictDiscoverParsingFalseDiscoverMethod(
    str, Enum, metaclass=utils.OpenEnumMeta
):
    # GET
    GET = "get"
    # POST
    POST = "post"
    # POST with Body
    POST_WITH_BODY = "post_with_body"
    # Other
    OTHER = "other"


class RestAuthenticationHmacRestDiscoveryDiscoverTypeHTTPEnableStrictDiscoverParsingFalsePaginationTypedDict(
    TypedDict
):
    type: PaginationOptionsRestDiscoveryDiscoverTypeHTTPPagination


class RestAuthenticationHmacRestDiscoveryDiscoverTypeHTTPEnableStrictDiscoverParsingFalsePagination(
    BaseModel
):
    type: PaginationOptionsRestDiscoveryDiscoverTypeHTTPPagination

    @field_serializer("type")
    def serialize_type(self, value):
        if isinstance(value, str):
            try:
                return models.PaginationOptionsRestDiscoveryDiscoverTypeHTTPPagination(
                    value
                )
            except ValueError:
                return value
        return value


class RestAuthenticationHmacRestDiscoveryDiscoverTypeHTTPEnableStrictDiscoverParsingFalseTypedDict(
    TypedDict
):
    discover_type: RestAuthenticationHmacRestDiscoveryDiscoverTypeHTTPEnableStrictDiscoverParsingFalseDiscoverType
    r"""Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task."""
    discover_url: str
    r"""URL to use for the Discover operation. Can be a constant URL, or a JavaScript expression to derive the URL."""
    discover_method: RestAuthenticationHmacRestDiscoveryDiscoverTypeHTTPEnableStrictDiscoverParsingFalseDiscoverMethod
    enable_strict_discover_parsing: NotRequired[bool]
    r"""Explicitly set the discover response format. When disabled, best effort parsing is used."""
    discover_request_headers: NotRequired[
        List[ItemsTypeRestCollectMethodGetCollectRequestParamsTypedDict]
    ]
    pagination: NotRequired[
        RestAuthenticationHmacRestDiscoveryDiscoverTypeHTTPEnableStrictDiscoverParsingFalsePaginationTypedDict
    ]
    discover_data_field: NotRequired[str]
    r"""Path to field in the response object that contains discovery results (ex: level1.name). Leave blank if the result is an array."""
    enable_discover_code: NotRequired[bool]


class RestAuthenticationHmacRestDiscoveryDiscoverTypeHTTPEnableStrictDiscoverParsingFalse(
    BaseModel
):
    discover_type: Annotated[
        RestAuthenticationHmacRestDiscoveryDiscoverTypeHTTPEnableStrictDiscoverParsingFalseDiscoverType,
        pydantic.Field(alias="discoverType"),
    ]
    r"""Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task."""

    discover_url: Annotated[str, pydantic.Field(alias="discoverUrl")]
    r"""URL to use for the Discover operation. Can be a constant URL, or a JavaScript expression to derive the URL."""

    discover_method: Annotated[
        RestAuthenticationHmacRestDiscoveryDiscoverTypeHTTPEnableStrictDiscoverParsingFalseDiscoverMethod,
        pydantic.Field(alias="discoverMethod"),
    ]

    enable_strict_discover_parsing: Annotated[
        Optional[bool], pydantic.Field(alias="enableStrictDiscoverParsing")
    ] = None
    r"""Explicitly set the discover response format. When disabled, best effort parsing is used."""

    discover_request_headers: Annotated[
        Optional[List[ItemsTypeRestCollectMethodGetCollectRequestParams]],
        pydantic.Field(alias="discoverRequestHeaders"),
    ] = None

    pagination: Optional[
        RestAuthenticationHmacRestDiscoveryDiscoverTypeHTTPEnableStrictDiscoverParsingFalsePagination
    ] = None

    discover_data_field: Annotated[
        Optional[str], pydantic.Field(alias="discoverDataField")
    ] = None
    r"""Path to field in the response object that contains discovery results (ex: level1.name). Leave blank if the result is an array."""

    enable_discover_code: Annotated[
        Optional[bool], pydantic.Field(alias="enableDiscoverCode")
    ] = None

    @field_serializer("discover_type")
    def serialize_discover_type(self, value):
        if isinstance(value, str):
            try:
                return models.RestAuthenticationHmacRestDiscoveryDiscoverTypeHTTPEnableStrictDiscoverParsingFalseDiscoverType(
                    value
                )
            except ValueError:
                return value
        return value

    @field_serializer("discover_method")
    def serialize_discover_method(self, value):
        if isinstance(value, str):
            try:
                return models.RestAuthenticationHmacRestDiscoveryDiscoverTypeHTTPEnableStrictDiscoverParsingFalseDiscoverMethod(
                    value
                )
            except ValueError:
                return value
        return value

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(
            [
                "enableStrictDiscoverParsing",
                "discoverRequestHeaders",
                "pagination",
                "discoverDataField",
                "enableDiscoverCode",
            ]
        )
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


RestAuthenticationHmacRestDiscoveryDiscoverTypeHTTPTypedDict = TypeAliasType(
    "RestAuthenticationHmacRestDiscoveryDiscoverTypeHTTPTypedDict",
    Union[
        RestAuthenticationHmacRestDiscoveryDiscoverTypeHTTPEnableStrictDiscoverParsingFalseTypedDict,
        RestAuthenticationHmacRestDiscoveryDiscoverTypeHTTPEnableDiscoverCodeFalseTypedDict,
        RestAuthenticationHmacRestDiscoveryDiscoverTypeHTTPEnableStrictDiscoverParsingTrueTypedDict,
        RestAuthenticationHmacRestDiscoveryDiscoverTypeHTTPEnableDiscoverCodeTrueTypedDict,
        RestAuthenticationHmacRestDiscoveryDiscoverTypeHTTPDiscoverMethodGetTypedDict,
        RestAuthenticationHmacRestDiscoveryDiscoverTypeHTTPDiscoverMethodPostTypedDict,
        RestAuthenticationHmacRestDiscoveryDiscoverTypeHTTPDiscoverMethodPostWithBodyTypedDict,
        RestAuthenticationHmacRestDiscoveryDiscoverTypeHTTPDiscoverMethodOtherTypedDict,
    ],
)


class UnknownRestAuthenticationHmacRestDiscoveryDiscoverTypeHTTP(BaseModel):
    r"""A RestAuthenticationHmacRestDiscoveryDiscoverTypeHTTP variant the SDK doesn't recognize. Preserves the raw payload."""

    discover_method: Literal["UNKNOWN"] = "UNKNOWN"
    raw: Any
    is_unknown: Literal[True] = True

    model_config = ConfigDict(frozen=True)


_REST_AUTHENTICATION_HMAC_REST_DISCOVERY_DISCOVER_TYPE_HTTP_VARIANTS: dict[str, Any] = {
    "get": RestAuthenticationHmacRestDiscoveryDiscoverTypeHTTPDiscoverMethodGet,
    "post": RestAuthenticationHmacRestDiscoveryDiscoverTypeHTTPDiscoverMethodPost,
    "post_with_body": RestAuthenticationHmacRestDiscoveryDiscoverTypeHTTPDiscoverMethodPostWithBody,
    "other": RestAuthenticationHmacRestDiscoveryDiscoverTypeHTTPDiscoverMethodOther,
}


RestAuthenticationHmacRestDiscoveryDiscoverTypeHTTP = Annotated[
    Union[
        RestAuthenticationHmacRestDiscoveryDiscoverTypeHTTPDiscoverMethodGet,
        RestAuthenticationHmacRestDiscoveryDiscoverTypeHTTPDiscoverMethodPost,
        RestAuthenticationHmacRestDiscoveryDiscoverTypeHTTPDiscoverMethodPostWithBody,
        RestAuthenticationHmacRestDiscoveryDiscoverTypeHTTPDiscoverMethodOther,
        UnknownRestAuthenticationHmacRestDiscoveryDiscoverTypeHTTP,
    ],
    BeforeValidator(
        partial(
            parse_open_union,
            disc_key="discoverMethod",
            variants=_REST_AUTHENTICATION_HMAC_REST_DISCOVERY_DISCOVER_TYPE_HTTP_VARIANTS,
            unknown_cls=UnknownRestAuthenticationHmacRestDiscoveryDiscoverTypeHTTP,
            union_name="RestAuthenticationHmacRestDiscoveryDiscoverTypeHTTP",
        )
    ),
]


RestAuthenticationHmacDiscoveryTypedDict = TypeAliasType(
    "RestAuthenticationHmacDiscoveryTypedDict",
    Union[
        RestAuthenticationHmacRestDiscoveryDiscoverTypeNoneTypedDict,
        RestAuthenticationHmacRestDiscoveryDiscoverTypeListTypedDict,
        RestAuthenticationHmacRestDiscoveryDiscoverTypeJSONTypedDict,
        RestAuthenticationHmacRestDiscoveryDiscoverTypeHTTPTypedDict,
    ],
)


class UnknownRestAuthenticationHmacDiscovery(BaseModel):
    r"""A RestAuthenticationHmacDiscovery variant the SDK doesn't recognize. Preserves the raw payload."""

    discover_type: Literal["UNKNOWN"] = "UNKNOWN"
    raw: Any
    is_unknown: Literal[True] = True

    model_config = ConfigDict(frozen=True)


_REST_AUTHENTICATION_HMAC_DISCOVERY_VARIANTS: dict[str, Any] = {
    "http": RestAuthenticationHmacRestDiscoveryDiscoverTypeHTTP,
    "json": RestAuthenticationHmacRestDiscoveryDiscoverTypeJSON,
    "list": RestAuthenticationHmacRestDiscoveryDiscoverTypeList,
    "none": RestAuthenticationHmacRestDiscoveryDiscoverTypeNone,
}


RestAuthenticationHmacDiscovery = Annotated[
    Union[
        RestAuthenticationHmacRestDiscoveryDiscoverTypeHTTP,
        RestAuthenticationHmacRestDiscoveryDiscoverTypeJSON,
        RestAuthenticationHmacRestDiscoveryDiscoverTypeList,
        RestAuthenticationHmacRestDiscoveryDiscoverTypeNone,
        UnknownRestAuthenticationHmacDiscovery,
    ],
    BeforeValidator(
        partial(
            parse_open_union,
            disc_key="discoverType",
            variants=_REST_AUTHENTICATION_HMAC_DISCOVERY_VARIANTS,
            unknown_cls=UnknownRestAuthenticationHmacDiscovery,
            union_name="RestAuthenticationHmacDiscovery",
        )
    ),
]


class RestAuthenticationHmacCollectMethod(str, Enum, metaclass=utils.OpenEnumMeta):
    # GET
    GET = "get"
    # POST
    POST = "post"
    # POST with Body
    POST_WITH_BODY = "post_with_body"
    # Other
    OTHER = "other"


class RestAuthenticationHmacRestPaginationTypeRequestPageTypedDict(TypedDict):
    type: PaginationOptionsRestDiscoveryDiscoverTypeHTTPPagination
    page_field: str
    r"""Query string parameter that sets the page index to be returned. Example: /api/v1/query?term=cribl&page_size=100&page_number=0"""
    size_field: str
    r"""Query string parameter that sets the number of records retrieved per request. Example: /api/v1/query?term=cribl&page_size=100&page_number=0"""
    size: float
    r"""Maximum number of records to collect per page"""
    max_pages: float
    r"""Maximum number of pages to retrieve per collection task. Defaults to 50 pages. Set to 0 to retrieve all pages."""
    zero_indexed: bool
    r"""Enable to indicate that the first page in the requested data is at index 0. Disabled by default, which indicates index 1."""
    page: NotRequired[float]
    r"""Page number from which to start request. Defaults to undefined, which will start collection from the first page."""
    total_page_field: NotRequired[str]
    r"""Name of the attribute in the response that contains the total number of pages for the query"""
    total_record_field: NotRequired[str]
    r"""Name of the attribute in the response that contains the total number of records for the query"""


class RestAuthenticationHmacRestPaginationTypeRequestPage(BaseModel):
    type: PaginationOptionsRestDiscoveryDiscoverTypeHTTPPagination

    page_field: Annotated[str, pydantic.Field(alias="pageField")]
    r"""Query string parameter that sets the page index to be returned. Example: /api/v1/query?term=cribl&page_size=100&page_number=0"""

    size_field: Annotated[str, pydantic.Field(alias="sizeField")]
    r"""Query string parameter that sets the number of records retrieved per request. Example: /api/v1/query?term=cribl&page_size=100&page_number=0"""

    size: float
    r"""Maximum number of records to collect per page"""

    max_pages: Annotated[float, pydantic.Field(alias="maxPages")]
    r"""Maximum number of pages to retrieve per collection task. Defaults to 50 pages. Set to 0 to retrieve all pages."""

    zero_indexed: Annotated[bool, pydantic.Field(alias="zeroIndexed")]
    r"""Enable to indicate that the first page in the requested data is at index 0. Disabled by default, which indicates index 1."""

    page: Optional[float] = None
    r"""Page number from which to start request. Defaults to undefined, which will start collection from the first page."""

    total_page_field: Annotated[
        Optional[str], pydantic.Field(alias="totalPageField")
    ] = None
    r"""Name of the attribute in the response that contains the total number of pages for the query"""

    total_record_field: Annotated[
        Optional[str], pydantic.Field(alias="totalRecordField")
    ] = None
    r"""Name of the attribute in the response that contains the total number of records for the query"""

    @field_serializer("type")
    def serialize_type(self, value):
        if isinstance(value, str):
            try:
                return models.PaginationOptionsRestDiscoveryDiscoverTypeHTTPPagination(
                    value
                )
            except ValueError:
                return value
        return value

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(["page", "totalPageField", "totalRecordField"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


class RestAuthenticationHmacRestPaginationTypeRequestOffsetTypedDict(TypedDict):
    type: PaginationOptionsRestDiscoveryDiscoverTypeHTTPPagination
    offset_field: str
    r"""Query string parameter that sets the index from which to begin returning records. Example: /api/v1/query?term=cribl&limit=100&offset=0"""
    limit_field: str
    r"""Query string parameter that sets the number of records retrieved per request. Example: /api/v1/query?term=cribl&limit=100&offset=0"""
    limit: float
    r"""Maximum number of records to collect per request"""
    max_pages: float
    r"""Maximum number of pages to retrieve per collection task. Defaults to 50 pages. Set to 0 to retrieve all pages."""
    zero_indexed: bool
    r"""Enable to indicate that the first page in the requested data is at index 0. Disabled by default, which indicates index 1."""
    offset: NotRequired[float]
    r"""Offset index from which to start request. Defaults to undefined, which will start collection from the first record."""
    total_record_field: NotRequired[str]
    r"""Name of the attribute in the response that contains the total number of records for the query"""


class RestAuthenticationHmacRestPaginationTypeRequestOffset(BaseModel):
    type: PaginationOptionsRestDiscoveryDiscoverTypeHTTPPagination

    offset_field: Annotated[str, pydantic.Field(alias="offsetField")]
    r"""Query string parameter that sets the index from which to begin returning records. Example: /api/v1/query?term=cribl&limit=100&offset=0"""

    limit_field: Annotated[str, pydantic.Field(alias="limitField")]
    r"""Query string parameter that sets the number of records retrieved per request. Example: /api/v1/query?term=cribl&limit=100&offset=0"""

    limit: float
    r"""Maximum number of records to collect per request"""

    max_pages: Annotated[float, pydantic.Field(alias="maxPages")]
    r"""Maximum number of pages to retrieve per collection task. Defaults to 50 pages. Set to 0 to retrieve all pages."""

    zero_indexed: Annotated[bool, pydantic.Field(alias="zeroIndexed")]
    r"""Enable to indicate that the first page in the requested data is at index 0. Disabled by default, which indicates index 1."""

    offset: Optional[float] = None
    r"""Offset index from which to start request. Defaults to undefined, which will start collection from the first record."""

    total_record_field: Annotated[
        Optional[str], pydantic.Field(alias="totalRecordField")
    ] = None
    r"""Name of the attribute in the response that contains the total number of records for the query"""

    @field_serializer("type")
    def serialize_type(self, value):
        if isinstance(value, str):
            try:
                return models.PaginationOptionsRestDiscoveryDiscoverTypeHTTPPagination(
                    value
                )
            except ValueError:
                return value
        return value

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(["offset", "totalRecordField"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


class RestAuthenticationHmacRestPaginationTypeResponseHeaderLinkTypedDict(TypedDict):
    type: PaginationOptionsRestDiscoveryDiscoverTypeHTTPPagination
    next_relation_attribute: str
    r"""Relation name used in the link header that refers to the next page in the result set. Example: rel=\"next\" refers to the next page of results: <https://myHost/nextPage>; rel=\"next\" """
    max_pages: float
    r"""Maximum number of pages to retrieve per collection task. Defaults to 50 pages. Set to 0 to retrieve all pages."""
    cur_relation_attribute: NotRequired[str]
    r"""Relation name used in the link header that refers to the current result set. Example: rel=\"self\" refers to the current page of results: <https://myHost/curPage>; rel=\"self\" """


class RestAuthenticationHmacRestPaginationTypeResponseHeaderLink(BaseModel):
    type: PaginationOptionsRestDiscoveryDiscoverTypeHTTPPagination

    next_relation_attribute: Annotated[
        str, pydantic.Field(alias="nextRelationAttribute")
    ]
    r"""Relation name used in the link header that refers to the next page in the result set. Example: rel=\"next\" refers to the next page of results: <https://myHost/nextPage>; rel=\"next\" """

    max_pages: Annotated[float, pydantic.Field(alias="maxPages")]
    r"""Maximum number of pages to retrieve per collection task. Defaults to 50 pages. Set to 0 to retrieve all pages."""

    cur_relation_attribute: Annotated[
        Optional[str], pydantic.Field(alias="curRelationAttribute")
    ] = None
    r"""Relation name used in the link header that refers to the current result set. Example: rel=\"self\" refers to the current page of results: <https://myHost/curPage>; rel=\"self\" """

    @field_serializer("type")
    def serialize_type(self, value):
        if isinstance(value, str):
            try:
                return models.PaginationOptionsRestDiscoveryDiscoverTypeHTTPPagination(
                    value
                )
            except ValueError:
                return value
        return value

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(["curRelationAttribute"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


class RestAuthenticationHmacRestPaginationTypeResponseHeaderTypedDict(TypedDict):
    type: PaginationOptionsRestDiscoveryDiscoverTypeHTTPPagination
    attribute: List[str]
    r"""Names of attributes within the response that contain next-page information"""
    max_pages: float
    r"""Maximum number of pages to retrieve per collection task. Defaults to 50 pages. Set to 0 to retrieve all pages."""


class RestAuthenticationHmacRestPaginationTypeResponseHeader(BaseModel):
    type: PaginationOptionsRestDiscoveryDiscoverTypeHTTPPagination

    attribute: List[str]
    r"""Names of attributes within the response that contain next-page information"""

    max_pages: Annotated[float, pydantic.Field(alias="maxPages")]
    r"""Maximum number of pages to retrieve per collection task. Defaults to 50 pages. Set to 0 to retrieve all pages."""

    @field_serializer("type")
    def serialize_type(self, value):
        if isinstance(value, str):
            try:
                return models.PaginationOptionsRestDiscoveryDiscoverTypeHTTPPagination(
                    value
                )
            except ValueError:
                return value
        return value


class RestAuthenticationHmacRestPaginationTypeResponseBodyTypedDict(TypedDict):
    type: PaginationOptionsRestDiscoveryDiscoverTypeHTTPPagination
    attribute: List[str]
    r"""Names of attributes within the response that contain next-page information"""
    max_pages: float
    r"""Maximum number of pages to retrieve per collection task. Defaults to 50 pages. Set to 0 to retrieve all pages."""
    last_page_expr: NotRequired[str]
    r"""JavaScript expression used to determine when the last page has been reached. The values tested by this expression must be in the Response attributes section."""


class RestAuthenticationHmacRestPaginationTypeResponseBody(BaseModel):
    type: PaginationOptionsRestDiscoveryDiscoverTypeHTTPPagination

    attribute: List[str]
    r"""Names of attributes within the response that contain next-page information"""

    max_pages: Annotated[float, pydantic.Field(alias="maxPages")]
    r"""Maximum number of pages to retrieve per collection task. Defaults to 50 pages. Set to 0 to retrieve all pages."""

    last_page_expr: Annotated[Optional[str], pydantic.Field(alias="lastPageExpr")] = (
        None
    )
    r"""JavaScript expression used to determine when the last page has been reached. The values tested by this expression must be in the Response attributes section."""

    @field_serializer("type")
    def serialize_type(self, value):
        if isinstance(value, str):
            try:
                return models.PaginationOptionsRestDiscoveryDiscoverTypeHTTPPagination(
                    value
                )
            except ValueError:
                return value
        return value

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(["lastPageExpr"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


class RestAuthenticationHmacRestPaginationTypeNoneTypedDict(TypedDict):
    type: PaginationOptionsRestDiscoveryDiscoverTypeHTTPPagination


class RestAuthenticationHmacRestPaginationTypeNone(BaseModel):
    type: PaginationOptionsRestDiscoveryDiscoverTypeHTTPPagination

    @field_serializer("type")
    def serialize_type(self, value):
        if isinstance(value, str):
            try:
                return models.PaginationOptionsRestDiscoveryDiscoverTypeHTTPPagination(
                    value
                )
            except ValueError:
                return value
        return value


RestAuthenticationHmacPaginationUnionTypedDict = TypeAliasType(
    "RestAuthenticationHmacPaginationUnionTypedDict",
    Union[
        RestAuthenticationHmacRestPaginationTypeNoneTypedDict,
        RestAuthenticationHmacRestPaginationTypeResponseHeaderTypedDict,
        RestAuthenticationHmacRestPaginationTypeResponseBodyTypedDict,
        RestAuthenticationHmacRestPaginationTypeResponseHeaderLinkTypedDict,
        RestAuthenticationHmacRestPaginationTypeRequestOffsetTypedDict,
        RestAuthenticationHmacRestPaginationTypeRequestPageTypedDict,
    ],
)


class UnknownRestAuthenticationHmacPaginationUnion(BaseModel):
    r"""A RestAuthenticationHmacPaginationUnion variant the SDK doesn't recognize. Preserves the raw payload."""

    type: Literal["UNKNOWN"] = "UNKNOWN"
    raw: Any
    is_unknown: Literal[True] = True

    model_config = ConfigDict(frozen=True)


_REST_AUTHENTICATION_HMAC_PAGINATION_UNION_VARIANTS: dict[str, Any] = {
    "none": RestAuthenticationHmacRestPaginationTypeNone,
    "response_body": RestAuthenticationHmacRestPaginationTypeResponseBody,
    "response_header": RestAuthenticationHmacRestPaginationTypeResponseHeader,
    "response_header_link": RestAuthenticationHmacRestPaginationTypeResponseHeaderLink,
    "request_offset": RestAuthenticationHmacRestPaginationTypeRequestOffset,
    "request_page": RestAuthenticationHmacRestPaginationTypeRequestPage,
}


RestAuthenticationHmacPaginationUnion = Annotated[
    Union[
        RestAuthenticationHmacRestPaginationTypeNone,
        RestAuthenticationHmacRestPaginationTypeResponseBody,
        RestAuthenticationHmacRestPaginationTypeResponseHeader,
        RestAuthenticationHmacRestPaginationTypeResponseHeaderLink,
        RestAuthenticationHmacRestPaginationTypeRequestOffset,
        RestAuthenticationHmacRestPaginationTypeRequestPage,
        UnknownRestAuthenticationHmacPaginationUnion,
    ],
    BeforeValidator(
        partial(
            parse_open_union,
            disc_key="type",
            variants=_REST_AUTHENTICATION_HMAC_PAGINATION_UNION_VARIANTS,
            unknown_cls=UnknownRestAuthenticationHmacPaginationUnion,
            union_name="RestAuthenticationHmacPaginationUnion",
        )
    ),
]


class RestAuthenticationHmacRestRetryRulesTypeBackoffEnableHeaderTrueTypedDict(
    TypedDict
):
    type: RetryTypeOptionsHealthCheckCollectorConfRetryRules
    r"""The algorithm to use when performing HTTP retries"""
    enable_header: NotRequired[bool]
    r"""Honor any Retry-After header that specifies a delay (in seconds) or a timestamp after which to retry the request. The delay is limited to the `Longest interval between retries (ms)` value, even if the Retry-After header specifies a longer delay. When disabled, all Retry-After headers are ignored."""
    retry_header_name: NotRequired[str]
    interval: NotRequired[float]
    r"""Time interval between a failed request and the first retry"""
    limit: NotRequired[float]
    r"""Maximum number of times to retry a failed HTTP request"""
    multiplier: NotRequired[float]
    r"""Base for exponential backoff. Example: base 2 means that retries will occur after 2, then 4, then 8 seconds, and so on."""
    max_interval_ms: NotRequired[float]
    codes: NotRequired[List[float]]
    r"""List of HTTP codes that trigger a retry. Leave empty to use the default list of 429 and 503."""
    retry_connect_timeout: NotRequired[bool]
    r"""Make a single retry attempt when a connection timeout (ETIMEDOUT) error occurs"""
    retry_connect_reset: NotRequired[bool]
    r"""Retry request when a connection reset (ECONNRESET) error occurs"""


class RestAuthenticationHmacRestRetryRulesTypeBackoffEnableHeaderTrue(BaseModel):
    type: RetryTypeOptionsHealthCheckCollectorConfRetryRules
    r"""The algorithm to use when performing HTTP retries"""

    enable_header: Annotated[Optional[bool], pydantic.Field(alias="enableHeader")] = (
        None
    )
    r"""Honor any Retry-After header that specifies a delay (in seconds) or a timestamp after which to retry the request. The delay is limited to the `Longest interval between retries (ms)` value, even if the Retry-After header specifies a longer delay. When disabled, all Retry-After headers are ignored."""

    retry_header_name: Annotated[
        Optional[str], pydantic.Field(alias="retryHeaderName")
    ] = None

    interval: Optional[float] = None
    r"""Time interval between a failed request and the first retry"""

    limit: Optional[float] = None
    r"""Maximum number of times to retry a failed HTTP request"""

    multiplier: Optional[float] = None
    r"""Base for exponential backoff. Example: base 2 means that retries will occur after 2, then 4, then 8 seconds, and so on."""

    max_interval_ms: Annotated[
        Optional[float], pydantic.Field(alias="maxIntervalMs")
    ] = None

    codes: Optional[List[float]] = None
    r"""List of HTTP codes that trigger a retry. Leave empty to use the default list of 429 and 503."""

    retry_connect_timeout: Annotated[
        Optional[bool], pydantic.Field(alias="retryConnectTimeout")
    ] = None
    r"""Make a single retry attempt when a connection timeout (ETIMEDOUT) error occurs"""

    retry_connect_reset: Annotated[
        Optional[bool], pydantic.Field(alias="retryConnectReset")
    ] = None
    r"""Retry request when a connection reset (ECONNRESET) error occurs"""

    @field_serializer("type")
    def serialize_type(self, value):
        if isinstance(value, str):
            try:
                return models.RetryTypeOptionsHealthCheckCollectorConfRetryRules(value)
            except ValueError:
                return value
        return value

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(
            [
                "enableHeader",
                "retryHeaderName",
                "interval",
                "limit",
                "multiplier",
                "maxIntervalMs",
                "codes",
                "retryConnectTimeout",
                "retryConnectReset",
            ]
        )
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


class RestAuthenticationHmacRestRetryRulesTypeBackoffEnableHeaderFalseTypedDict(
    TypedDict
):
    type: RetryTypeOptionsHealthCheckCollectorConfRetryRules
    r"""The algorithm to use when performing HTTP retries"""
    enable_header: NotRequired[bool]
    r"""Honor any Retry-After header that specifies a delay (in seconds) or a timestamp after which to retry the request. The delay is limited to the `Longest interval between retries (ms)` value, even if the Retry-After header specifies a longer delay. When disabled, all Retry-After headers are ignored."""
    interval: NotRequired[float]
    r"""Time interval between a failed request and the first retry"""
    limit: NotRequired[float]
    r"""Maximum number of times to retry a failed HTTP request"""
    multiplier: NotRequired[float]
    r"""Base for exponential backoff. Example: base 2 means that retries will occur after 2, then 4, then 8 seconds, and so on."""
    max_interval_ms: NotRequired[float]
    codes: NotRequired[List[float]]
    r"""List of HTTP codes that trigger a retry. Leave empty to use the default list of 429 and 503."""
    retry_connect_timeout: NotRequired[bool]
    r"""Make a single retry attempt when a connection timeout (ETIMEDOUT) error occurs"""
    retry_connect_reset: NotRequired[bool]
    r"""Retry request when a connection reset (ECONNRESET) error occurs"""


class RestAuthenticationHmacRestRetryRulesTypeBackoffEnableHeaderFalse(BaseModel):
    type: RetryTypeOptionsHealthCheckCollectorConfRetryRules
    r"""The algorithm to use when performing HTTP retries"""

    enable_header: Annotated[Optional[bool], pydantic.Field(alias="enableHeader")] = (
        None
    )
    r"""Honor any Retry-After header that specifies a delay (in seconds) or a timestamp after which to retry the request. The delay is limited to the `Longest interval between retries (ms)` value, even if the Retry-After header specifies a longer delay. When disabled, all Retry-After headers are ignored."""

    interval: Optional[float] = None
    r"""Time interval between a failed request and the first retry"""

    limit: Optional[float] = None
    r"""Maximum number of times to retry a failed HTTP request"""

    multiplier: Optional[float] = None
    r"""Base for exponential backoff. Example: base 2 means that retries will occur after 2, then 4, then 8 seconds, and so on."""

    max_interval_ms: Annotated[
        Optional[float], pydantic.Field(alias="maxIntervalMs")
    ] = None

    codes: Optional[List[float]] = None
    r"""List of HTTP codes that trigger a retry. Leave empty to use the default list of 429 and 503."""

    retry_connect_timeout: Annotated[
        Optional[bool], pydantic.Field(alias="retryConnectTimeout")
    ] = None
    r"""Make a single retry attempt when a connection timeout (ETIMEDOUT) error occurs"""

    retry_connect_reset: Annotated[
        Optional[bool], pydantic.Field(alias="retryConnectReset")
    ] = None
    r"""Retry request when a connection reset (ECONNRESET) error occurs"""

    @field_serializer("type")
    def serialize_type(self, value):
        if isinstance(value, str):
            try:
                return models.RetryTypeOptionsHealthCheckCollectorConfRetryRules(value)
            except ValueError:
                return value
        return value

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(
            [
                "enableHeader",
                "interval",
                "limit",
                "multiplier",
                "maxIntervalMs",
                "codes",
                "retryConnectTimeout",
                "retryConnectReset",
            ]
        )
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


RestAuthenticationHmacRestRetryRulesTypeBackoffTypedDict = TypeAliasType(
    "RestAuthenticationHmacRestRetryRulesTypeBackoffTypedDict",
    Union[
        RestAuthenticationHmacRestRetryRulesTypeBackoffEnableHeaderFalseTypedDict,
        RestAuthenticationHmacRestRetryRulesTypeBackoffEnableHeaderTrueTypedDict,
    ],
)


RestAuthenticationHmacRestRetryRulesTypeBackoff = TypeAliasType(
    "RestAuthenticationHmacRestRetryRulesTypeBackoff",
    Union[
        RestAuthenticationHmacRestRetryRulesTypeBackoffEnableHeaderFalse,
        RestAuthenticationHmacRestRetryRulesTypeBackoffEnableHeaderTrue,
    ],
)


class RestAuthenticationHmacRestRetryRulesTypeStaticEnableHeaderTrueTypedDict(
    TypedDict
):
    type: RetryTypeOptionsHealthCheckCollectorConfRetryRules
    r"""The algorithm to use when performing HTTP retries"""
    enable_header: NotRequired[bool]
    r"""Honor any Retry-After header that specifies a delay (in seconds) or a timestamp after which to retry the request. The delay is limited to the `Longest interval between retries (ms)` value, even if the Retry-After header specifies a longer delay. When disabled, all Retry-After headers are ignored."""
    retry_header_name: NotRequired[str]
    interval: NotRequired[float]
    r"""Time interval between retries. Maximum allowed value is 20,000 ms (1/3 minute)."""
    limit: NotRequired[float]
    r"""Maximum number of times to retry a failed HTTP request"""
    codes: NotRequired[List[float]]
    r"""List of HTTP codes that trigger a retry. Leave empty to use the default list of 429 and 503."""
    retry_connect_timeout: NotRequired[bool]
    r"""Make a single retry attempt when a connection timeout (ETIMEDOUT) error occurs"""
    retry_connect_reset: NotRequired[bool]
    r"""Retry request when a connection reset (ECONNRESET) error occurs"""


class RestAuthenticationHmacRestRetryRulesTypeStaticEnableHeaderTrue(BaseModel):
    type: RetryTypeOptionsHealthCheckCollectorConfRetryRules
    r"""The algorithm to use when performing HTTP retries"""

    enable_header: Annotated[Optional[bool], pydantic.Field(alias="enableHeader")] = (
        None
    )
    r"""Honor any Retry-After header that specifies a delay (in seconds) or a timestamp after which to retry the request. The delay is limited to the `Longest interval between retries (ms)` value, even if the Retry-After header specifies a longer delay. When disabled, all Retry-After headers are ignored."""

    retry_header_name: Annotated[
        Optional[str], pydantic.Field(alias="retryHeaderName")
    ] = None

    interval: Optional[float] = None
    r"""Time interval between retries. Maximum allowed value is 20,000 ms (1/3 minute)."""

    limit: Optional[float] = None
    r"""Maximum number of times to retry a failed HTTP request"""

    codes: Optional[List[float]] = None
    r"""List of HTTP codes that trigger a retry. Leave empty to use the default list of 429 and 503."""

    retry_connect_timeout: Annotated[
        Optional[bool], pydantic.Field(alias="retryConnectTimeout")
    ] = None
    r"""Make a single retry attempt when a connection timeout (ETIMEDOUT) error occurs"""

    retry_connect_reset: Annotated[
        Optional[bool], pydantic.Field(alias="retryConnectReset")
    ] = None
    r"""Retry request when a connection reset (ECONNRESET) error occurs"""

    @field_serializer("type")
    def serialize_type(self, value):
        if isinstance(value, str):
            try:
                return models.RetryTypeOptionsHealthCheckCollectorConfRetryRules(value)
            except ValueError:
                return value
        return value

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(
            [
                "enableHeader",
                "retryHeaderName",
                "interval",
                "limit",
                "codes",
                "retryConnectTimeout",
                "retryConnectReset",
            ]
        )
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


class RestAuthenticationHmacRestRetryRulesTypeStaticEnableHeaderFalseTypedDict(
    TypedDict
):
    type: RetryTypeOptionsHealthCheckCollectorConfRetryRules
    r"""The algorithm to use when performing HTTP retries"""
    enable_header: NotRequired[bool]
    r"""Honor any Retry-After header that specifies a delay (in seconds) or a timestamp after which to retry the request. The delay is limited to the `Longest interval between retries (ms)` value, even if the Retry-After header specifies a longer delay. When disabled, all Retry-After headers are ignored."""
    interval: NotRequired[float]
    r"""Time interval between retries. Maximum allowed value is 20,000 ms (1/3 minute)."""
    limit: NotRequired[float]
    r"""Maximum number of times to retry a failed HTTP request"""
    codes: NotRequired[List[float]]
    r"""List of HTTP codes that trigger a retry. Leave empty to use the default list of 429 and 503."""
    retry_connect_timeout: NotRequired[bool]
    r"""Make a single retry attempt when a connection timeout (ETIMEDOUT) error occurs"""
    retry_connect_reset: NotRequired[bool]
    r"""Retry request when a connection reset (ECONNRESET) error occurs"""


class RestAuthenticationHmacRestRetryRulesTypeStaticEnableHeaderFalse(BaseModel):
    type: RetryTypeOptionsHealthCheckCollectorConfRetryRules
    r"""The algorithm to use when performing HTTP retries"""

    enable_header: Annotated[Optional[bool], pydantic.Field(alias="enableHeader")] = (
        None
    )
    r"""Honor any Retry-After header that specifies a delay (in seconds) or a timestamp after which to retry the request. The delay is limited to the `Longest interval between retries (ms)` value, even if the Retry-After header specifies a longer delay. When disabled, all Retry-After headers are ignored."""

    interval: Optional[float] = None
    r"""Time interval between retries. Maximum allowed value is 20,000 ms (1/3 minute)."""

    limit: Optional[float] = None
    r"""Maximum number of times to retry a failed HTTP request"""

    codes: Optional[List[float]] = None
    r"""List of HTTP codes that trigger a retry. Leave empty to use the default list of 429 and 503."""

    retry_connect_timeout: Annotated[
        Optional[bool], pydantic.Field(alias="retryConnectTimeout")
    ] = None
    r"""Make a single retry attempt when a connection timeout (ETIMEDOUT) error occurs"""

    retry_connect_reset: Annotated[
        Optional[bool], pydantic.Field(alias="retryConnectReset")
    ] = None
    r"""Retry request when a connection reset (ECONNRESET) error occurs"""

    @field_serializer("type")
    def serialize_type(self, value):
        if isinstance(value, str):
            try:
                return models.RetryTypeOptionsHealthCheckCollectorConfRetryRules(value)
            except ValueError:
                return value
        return value

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(
            [
                "enableHeader",
                "interval",
                "limit",
                "codes",
                "retryConnectTimeout",
                "retryConnectReset",
            ]
        )
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


RestAuthenticationHmacRestRetryRulesTypeStaticTypedDict = TypeAliasType(
    "RestAuthenticationHmacRestRetryRulesTypeStaticTypedDict",
    Union[
        RestAuthenticationHmacRestRetryRulesTypeStaticEnableHeaderFalseTypedDict,
        RestAuthenticationHmacRestRetryRulesTypeStaticEnableHeaderTrueTypedDict,
    ],
)


RestAuthenticationHmacRestRetryRulesTypeStatic = TypeAliasType(
    "RestAuthenticationHmacRestRetryRulesTypeStatic",
    Union[
        RestAuthenticationHmacRestRetryRulesTypeStaticEnableHeaderFalse,
        RestAuthenticationHmacRestRetryRulesTypeStaticEnableHeaderTrue,
    ],
)


class RestAuthenticationHmacRestRetryRulesTypeNoneTypedDict(TypedDict):
    type: RetryTypeOptionsHealthCheckCollectorConfRetryRules
    r"""The algorithm to use when performing HTTP retries"""


class RestAuthenticationHmacRestRetryRulesTypeNone(BaseModel):
    type: RetryTypeOptionsHealthCheckCollectorConfRetryRules
    r"""The algorithm to use when performing HTTP retries"""

    @field_serializer("type")
    def serialize_type(self, value):
        if isinstance(value, str):
            try:
                return models.RetryTypeOptionsHealthCheckCollectorConfRetryRules(value)
            except ValueError:
                return value
        return value


RestAuthenticationHmacRetryRulesTypedDict = TypeAliasType(
    "RestAuthenticationHmacRetryRulesTypedDict",
    Union[
        RestAuthenticationHmacRestRetryRulesTypeNoneTypedDict,
        RestAuthenticationHmacRestRetryRulesTypeStaticTypedDict,
        RestAuthenticationHmacRestRetryRulesTypeBackoffTypedDict,
    ],
)


class UnknownRestAuthenticationHmacRetryRules(BaseModel):
    r"""A RestAuthenticationHmacRetryRules variant the SDK doesn't recognize. Preserves the raw payload."""

    type: Literal["UNKNOWN"] = "UNKNOWN"
    raw: Any
    is_unknown: Literal[True] = True

    model_config = ConfigDict(frozen=True)


_REST_AUTHENTICATION_HMAC_RETRY_RULES_VARIANTS: dict[str, Any] = {
    "none": RestAuthenticationHmacRestRetryRulesTypeNone,
    "static": RestAuthenticationHmacRestRetryRulesTypeStatic,
    "backoff": RestAuthenticationHmacRestRetryRulesTypeBackoff,
}


RestAuthenticationHmacRetryRules = Annotated[
    Union[
        RestAuthenticationHmacRestRetryRulesTypeNone,
        RestAuthenticationHmacRestRetryRulesTypeStatic,
        RestAuthenticationHmacRestRetryRulesTypeBackoff,
        UnknownRestAuthenticationHmacRetryRules,
    ],
    BeforeValidator(
        partial(
            parse_open_union,
            disc_key="type",
            variants=_REST_AUTHENTICATION_HMAC_RETRY_RULES_VARIANTS,
            unknown_cls=UnknownRestAuthenticationHmacRetryRules,
            union_name="RestAuthenticationHmacRetryRules",
        )
    ),
]


class RestAuthenticationHmacStateTrackingTypedDict(TypedDict):
    enabled: NotRequired[bool]
    r"""Track collection progress between consecutive scheduled executions"""


class RestAuthenticationHmacStateTracking(BaseModel):
    enabled: Optional[bool] = None
    r"""Track collection progress between consecutive scheduled executions"""

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(["enabled"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


class RestAuthenticationHmacSchedulingTypedDict(TypedDict):
    state_tracking: NotRequired[RestAuthenticationHmacStateTrackingTypedDict]


class RestAuthenticationHmacScheduling(BaseModel):
    state_tracking: Annotated[
        Optional[RestAuthenticationHmacStateTracking],
        pydantic.Field(alias="stateTracking"),
    ] = None

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(["stateTracking"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


class RestAuthenticationHmacTypedDict(TypedDict):
    authentication: RestAuthenticationHmacAuthentication
    r"""Authentication method for Discover and Collect REST calls. You can specify API key–based authentication by adding the appropriate Collect headers."""
    hmac_function_id: str
    r"""Select or create an HMAC Function to use with authentication"""
    collect_url: str
    r"""URL (constant or JavaScript expression) to use for the Collect operation"""
    collect_method: RestAuthenticationHmacCollectMethod
    discovery: NotRequired[RestAuthenticationHmacDiscoveryTypedDict]
    collect_request_headers: NotRequired[
        List[ItemsTypeRestCollectMethodGetCollectRequestParamsTypedDict]
    ]
    pagination: NotRequired[RestAuthenticationHmacPaginationUnionTypedDict]
    timeout: NotRequired[float]
    r"""HTTP request inactivity timeout. Use 0 to disable."""
    use_round_robin_dns: NotRequired[bool]
    r"""Use round-robin DNS lookup. Suitable when DNS server returns multiple addresses in sort order."""
    disable_time_filter: NotRequired[bool]
    r"""Disable Collector event time filtering when a date range is specified"""
    decode_url: NotRequired[bool]
    r"""Decode the URL before sending requests (including pagination requests)"""
    reject_unauthorized: NotRequired[bool]
    r"""Reject certificates that cannot be verified against a valid CA (such as self-signed certificates)"""
    capture_headers: NotRequired[bool]
    r"""Enable to add response headers to the resHeaders field under the __collectible object"""
    stop_on_empty_results: NotRequired[bool]
    r"""Stop pagination when the Event Breaker produces no events"""
    safe_headers: NotRequired[List[str]]
    r"""List of headers that are safe to log in plain text"""
    retry_rules: NotRequired[RestAuthenticationHmacRetryRulesTypedDict]
    scheduling: NotRequired[RestAuthenticationHmacSchedulingTypedDict]


class RestAuthenticationHmac(BaseModel):
    authentication: RestAuthenticationHmacAuthentication
    r"""Authentication method for Discover and Collect REST calls. You can specify API key–based authentication by adding the appropriate Collect headers."""

    hmac_function_id: Annotated[str, pydantic.Field(alias="hmacFunctionId")]
    r"""Select or create an HMAC Function to use with authentication"""

    collect_url: Annotated[str, pydantic.Field(alias="collectUrl")]
    r"""URL (constant or JavaScript expression) to use for the Collect operation"""

    collect_method: Annotated[
        RestAuthenticationHmacCollectMethod, pydantic.Field(alias="collectMethod")
    ]

    discovery: Optional[RestAuthenticationHmacDiscovery] = None

    collect_request_headers: Annotated[
        Optional[List[ItemsTypeRestCollectMethodGetCollectRequestParams]],
        pydantic.Field(alias="collectRequestHeaders"),
    ] = None

    pagination: Optional[RestAuthenticationHmacPaginationUnion] = None

    timeout: Optional[float] = None
    r"""HTTP request inactivity timeout. Use 0 to disable."""

    use_round_robin_dns: Annotated[
        Optional[bool], pydantic.Field(alias="useRoundRobinDns")
    ] = None
    r"""Use round-robin DNS lookup. Suitable when DNS server returns multiple addresses in sort order."""

    disable_time_filter: Annotated[
        Optional[bool], pydantic.Field(alias="disableTimeFilter")
    ] = None
    r"""Disable Collector event time filtering when a date range is specified"""

    decode_url: Annotated[Optional[bool], pydantic.Field(alias="decodeUrl")] = None
    r"""Decode the URL before sending requests (including pagination requests)"""

    reject_unauthorized: Annotated[
        Optional[bool], pydantic.Field(alias="rejectUnauthorized")
    ] = None
    r"""Reject certificates that cannot be verified against a valid CA (such as self-signed certificates)"""

    capture_headers: Annotated[
        Optional[bool], pydantic.Field(alias="captureHeaders")
    ] = None
    r"""Enable to add response headers to the resHeaders field under the __collectible object"""

    stop_on_empty_results: Annotated[
        Optional[bool], pydantic.Field(alias="stopOnEmptyResults")
    ] = None
    r"""Stop pagination when the Event Breaker produces no events"""

    safe_headers: Annotated[
        Optional[List[str]], pydantic.Field(alias="safeHeaders")
    ] = None
    r"""List of headers that are safe to log in plain text"""

    retry_rules: Annotated[
        Optional[RestAuthenticationHmacRetryRules], pydantic.Field(alias="retryRules")
    ] = None

    scheduling: Annotated[
        Optional[RestAuthenticationHmacScheduling], pydantic.Field(alias="__scheduling")
    ] = None

    @field_serializer("authentication")
    def serialize_authentication(self, value):
        if isinstance(value, str):
            try:
                return models.RestAuthenticationHmacAuthentication(value)
            except ValueError:
                return value
        return value

    @field_serializer("collect_method")
    def serialize_collect_method(self, value):
        if isinstance(value, str):
            try:
                return models.RestAuthenticationHmacCollectMethod(value)
            except ValueError:
                return value
        return value

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(
            [
                "discovery",
                "collectRequestHeaders",
                "pagination",
                "timeout",
                "useRoundRobinDns",
                "disableTimeFilter",
                "decodeUrl",
                "rejectUnauthorized",
                "captureHeaders",
                "stopOnEmptyResults",
                "safeHeaders",
                "retryRules",
                "__scheduling",
            ]
        )
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


class RestAuthenticationGoogleOauthSecretAuthentication(
    str, Enum, metaclass=utils.OpenEnumMeta
):
    r"""Authentication method for Discover and Collect REST calls. You can specify API key–based authentication by adding the appropriate Collect headers."""

    NONE = "none"
    BASIC = "basic"
    BASIC_SECRET = "basicSecret"
    LOGIN = "login"
    LOGIN_SECRET = "loginSecret"
    OAUTH = "oauth"
    OAUTH_SECRET = "oauthSecret"
    GOOGLE_OAUTH = "google_oauth"
    GOOGLE_OAUTH_SECRET = "google_oauthSecret"
    HMAC = "hmac"


class RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeNoneDiscoverType(
    str, Enum, metaclass=utils.OpenEnumMeta
):
    r"""Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task."""

    HTTP = "http"
    JSON = "json"
    LIST = "list"
    NONE = "none"


class RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeNoneTypedDict(
    TypedDict
):
    discover_type: (
        RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeNoneDiscoverType
    )
    r"""Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task."""


class RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeNone(BaseModel):
    discover_type: Annotated[
        RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeNoneDiscoverType,
        pydantic.Field(alias="discoverType"),
    ]
    r"""Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task."""

    @field_serializer("discover_type")
    def serialize_discover_type(self, value):
        if isinstance(value, str):
            try:
                return models.RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeNoneDiscoverType(
                    value
                )
            except ValueError:
                return value
        return value


class RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeListDiscoverType(
    str, Enum, metaclass=utils.OpenEnumMeta
):
    r"""Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task."""

    HTTP = "http"
    JSON = "json"
    LIST = "list"
    NONE = "none"


class RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeListTypedDict(
    TypedDict
):
    discover_type: (
        RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeListDiscoverType
    )
    r"""Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task."""
    item_list: List[str]
    r"""Comma-separated list of items to return from the Discover task. Each item returned generates a Collect task and can be referenced using `${id}` in the Collect URL, headers, or parameters."""


class RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeList(BaseModel):
    discover_type: Annotated[
        RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeListDiscoverType,
        pydantic.Field(alias="discoverType"),
    ]
    r"""Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task."""

    item_list: Annotated[List[str], pydantic.Field(alias="itemList")]
    r"""Comma-separated list of items to return from the Discover task. Each item returned generates a Collect task and can be referenced using `${id}` in the Collect URL, headers, or parameters."""

    @field_serializer("discover_type")
    def serialize_discover_type(self, value):
        if isinstance(value, str):
            try:
                return models.RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeListDiscoverType(
                    value
                )
            except ValueError:
                return value
        return value


class RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeJSONDiscoverType(
    str, Enum, metaclass=utils.OpenEnumMeta
):
    r"""Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task."""

    HTTP = "http"
    JSON = "json"
    LIST = "list"
    NONE = "none"


class RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeJSONTypedDict(
    TypedDict
):
    discover_type: (
        RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeJSONDiscoverType
    )
    r"""Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task."""
    manual_discover_result: str
    r"""Allows hard-coding the Discover result. Must be a JSON object or array. Works with Discover data field."""
    discover_data_field: NotRequired[str]
    r"""Within the response JSON, the name of the field to pull results from, typically a JSON array. Leave blank if the result itself is an array of values. Sample entry: items, json: { items: [{id: 'first'},{id: 'second'}] }"""


class RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeJSON(BaseModel):
    discover_type: Annotated[
        RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeJSONDiscoverType,
        pydantic.Field(alias="discoverType"),
    ]
    r"""Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task."""

    manual_discover_result: Annotated[str, pydantic.Field(alias="manualDiscoverResult")]
    r"""Allows hard-coding the Discover result. Must be a JSON object or array. Works with Discover data field."""

    discover_data_field: Annotated[
        Optional[str], pydantic.Field(alias="discoverDataField")
    ] = None
    r"""Within the response JSON, the name of the field to pull results from, typically a JSON array. Leave blank if the result itself is an array of values. Sample entry: items, json: { items: [{id: 'first'},{id: 'second'}] }"""

    @field_serializer("discover_type")
    def serialize_discover_type(self, value):
        if isinstance(value, str):
            try:
                return models.RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeJSONDiscoverType(
                    value
                )
            except ValueError:
                return value
        return value

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(["discoverDataField"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


class RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHTTPDiscoverMethodOtherDiscoverMethod(
    str, Enum, metaclass=utils.OpenEnumMeta
):
    # GET
    GET = "get"
    # POST
    POST = "post"
    # POST with Body
    POST_WITH_BODY = "post_with_body"
    # Other
    OTHER = "other"


class RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHTTPDiscoverMethodOtherDiscoverType(
    str, Enum, metaclass=utils.OpenEnumMeta
):
    r"""Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task."""

    HTTP = "http"
    JSON = "json"
    LIST = "list"
    NONE = "none"


class RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHTTPDiscoverMethodOtherPaginationTypedDict(
    TypedDict
):
    type: PaginationOptionsRestDiscoveryDiscoverTypeHTTPPagination


class RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHTTPDiscoverMethodOtherPagination(
    BaseModel
):
    type: PaginationOptionsRestDiscoveryDiscoverTypeHTTPPagination

    @field_serializer("type")
    def serialize_type(self, value):
        if isinstance(value, str):
            try:
                return models.PaginationOptionsRestDiscoveryDiscoverTypeHTTPPagination(
                    value
                )
            except ValueError:
                return value
        return value


class RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHTTPDiscoverMethodOtherTypedDict(
    TypedDict
):
    discover_method: RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHTTPDiscoverMethodOtherDiscoverMethod
    discover_verb: str
    r"""Custom HTTP method to use for the Discover operation"""
    discover_type: RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHTTPDiscoverMethodOtherDiscoverType
    r"""Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task."""
    discover_url: str
    r"""URL to use for the Discover operation. Can be a constant URL, or a JavaScript expression to derive the URL."""
    discover_body: NotRequired[str]
    r"""Template for body to send with the discover request"""
    discover_request_params: NotRequired[
        List[ItemsTypeRestCollectMethodGetCollectRequestParamsTypedDict]
    ]
    discover_request_headers: NotRequired[
        List[ItemsTypeRestCollectMethodGetCollectRequestParamsTypedDict]
    ]
    pagination: NotRequired[
        RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHTTPDiscoverMethodOtherPaginationTypedDict
    ]
    discover_data_field: NotRequired[str]
    r"""Path to field in the response object that contains discovery results (ex: level1.name). Leave blank if the result is an array."""
    enable_strict_discover_parsing: NotRequired[bool]
    r"""Explicitly set the discover response format. When disabled, best effort parsing is used."""
    enable_discover_code: NotRequired[bool]


class RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHTTPDiscoverMethodOther(
    BaseModel
):
    discover_method: Annotated[
        RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHTTPDiscoverMethodOtherDiscoverMethod,
        pydantic.Field(alias="discoverMethod"),
    ]

    discover_verb: Annotated[str, pydantic.Field(alias="discoverVerb")]
    r"""Custom HTTP method to use for the Discover operation"""

    discover_type: Annotated[
        RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHTTPDiscoverMethodOtherDiscoverType,
        pydantic.Field(alias="discoverType"),
    ]
    r"""Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task."""

    discover_url: Annotated[str, pydantic.Field(alias="discoverUrl")]
    r"""URL to use for the Discover operation. Can be a constant URL, or a JavaScript expression to derive the URL."""

    discover_body: Annotated[Optional[str], pydantic.Field(alias="discoverBody")] = None
    r"""Template for body to send with the discover request"""

    discover_request_params: Annotated[
        Optional[List[ItemsTypeRestCollectMethodGetCollectRequestParams]],
        pydantic.Field(alias="discoverRequestParams"),
    ] = None

    discover_request_headers: Annotated[
        Optional[List[ItemsTypeRestCollectMethodGetCollectRequestParams]],
        pydantic.Field(alias="discoverRequestHeaders"),
    ] = None

    pagination: Optional[
        RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHTTPDiscoverMethodOtherPagination
    ] = None

    discover_data_field: Annotated[
        Optional[str], pydantic.Field(alias="discoverDataField")
    ] = None
    r"""Path to field in the response object that contains discovery results (ex: level1.name). Leave blank if the result is an array."""

    enable_strict_discover_parsing: Annotated[
        Optional[bool], pydantic.Field(alias="enableStrictDiscoverParsing")
    ] = None
    r"""Explicitly set the discover response format. When disabled, best effort parsing is used."""

    enable_discover_code: Annotated[
        Optional[bool], pydantic.Field(alias="enableDiscoverCode")
    ] = None

    @field_serializer("discover_method")
    def serialize_discover_method(self, value):
        if isinstance(value, str):
            try:
                return models.RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHTTPDiscoverMethodOtherDiscoverMethod(
                    value
                )
            except ValueError:
                return value
        return value

    @field_serializer("discover_type")
    def serialize_discover_type(self, value):
        if isinstance(value, str):
            try:
                return models.RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHTTPDiscoverMethodOtherDiscoverType(
                    value
                )
            except ValueError:
                return value
        return value

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(
            [
                "discoverBody",
                "discoverRequestParams",
                "discoverRequestHeaders",
                "pagination",
                "discoverDataField",
                "enableStrictDiscoverParsing",
                "enableDiscoverCode",
            ]
        )
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


class RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHTTPDiscoverMethodPostWithBodyDiscoverMethod(
    str, Enum, metaclass=utils.OpenEnumMeta
):
    # GET
    GET = "get"
    # POST
    POST = "post"
    # POST with Body
    POST_WITH_BODY = "post_with_body"
    # Other
    OTHER = "other"


class RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHTTPDiscoverMethodPostWithBodyDiscoverType(
    str, Enum, metaclass=utils.OpenEnumMeta
):
    r"""Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task."""

    HTTP = "http"
    JSON = "json"
    LIST = "list"
    NONE = "none"


class RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHTTPDiscoverMethodPostWithBodyPaginationTypedDict(
    TypedDict
):
    type: PaginationOptionsRestDiscoveryDiscoverTypeHTTPPagination


class RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHTTPDiscoverMethodPostWithBodyPagination(
    BaseModel
):
    type: PaginationOptionsRestDiscoveryDiscoverTypeHTTPPagination

    @field_serializer("type")
    def serialize_type(self, value):
        if isinstance(value, str):
            try:
                return models.PaginationOptionsRestDiscoveryDiscoverTypeHTTPPagination(
                    value
                )
            except ValueError:
                return value
        return value


class RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHTTPDiscoverMethodPostWithBodyTypedDict(
    TypedDict
):
    discover_method: RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHTTPDiscoverMethodPostWithBodyDiscoverMethod
    discover_body: str
    r"""Template for POST body to send with the discover request. To reference global variables or functions, use template parameters: `{ myVar: ${C.vars.myVar}, secret: ${C.Secret('mySecret','text').value} }`"""
    discover_type: RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHTTPDiscoverMethodPostWithBodyDiscoverType
    r"""Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task."""
    discover_url: str
    r"""URL to use for the Discover operation. Can be a constant URL, or a JavaScript expression to derive the URL."""
    discover_request_headers: NotRequired[
        List[ItemsTypeRestCollectMethodGetCollectRequestParamsTypedDict]
    ]
    pagination: NotRequired[
        RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHTTPDiscoverMethodPostWithBodyPaginationTypedDict
    ]
    discover_data_field: NotRequired[str]
    r"""Path to field in the response object that contains discovery results (ex: level1.name). Leave blank if the result is an array."""
    enable_strict_discover_parsing: NotRequired[bool]
    r"""Explicitly set the discover response format. When disabled, best effort parsing is used."""
    enable_discover_code: NotRequired[bool]


class RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHTTPDiscoverMethodPostWithBody(
    BaseModel
):
    discover_method: Annotated[
        RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHTTPDiscoverMethodPostWithBodyDiscoverMethod,
        pydantic.Field(alias="discoverMethod"),
    ]

    discover_body: Annotated[str, pydantic.Field(alias="discoverBody")]
    r"""Template for POST body to send with the discover request. To reference global variables or functions, use template parameters: `{ myVar: ${C.vars.myVar}, secret: ${C.Secret('mySecret','text').value} }`"""

    discover_type: Annotated[
        RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHTTPDiscoverMethodPostWithBodyDiscoverType,
        pydantic.Field(alias="discoverType"),
    ]
    r"""Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task."""

    discover_url: Annotated[str, pydantic.Field(alias="discoverUrl")]
    r"""URL to use for the Discover operation. Can be a constant URL, or a JavaScript expression to derive the URL."""

    discover_request_headers: Annotated[
        Optional[List[ItemsTypeRestCollectMethodGetCollectRequestParams]],
        pydantic.Field(alias="discoverRequestHeaders"),
    ] = None

    pagination: Optional[
        RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHTTPDiscoverMethodPostWithBodyPagination
    ] = None

    discover_data_field: Annotated[
        Optional[str], pydantic.Field(alias="discoverDataField")
    ] = None
    r"""Path to field in the response object that contains discovery results (ex: level1.name). Leave blank if the result is an array."""

    enable_strict_discover_parsing: Annotated[
        Optional[bool], pydantic.Field(alias="enableStrictDiscoverParsing")
    ] = None
    r"""Explicitly set the discover response format. When disabled, best effort parsing is used."""

    enable_discover_code: Annotated[
        Optional[bool], pydantic.Field(alias="enableDiscoverCode")
    ] = None

    @field_serializer("discover_method")
    def serialize_discover_method(self, value):
        if isinstance(value, str):
            try:
                return models.RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHTTPDiscoverMethodPostWithBodyDiscoverMethod(
                    value
                )
            except ValueError:
                return value
        return value

    @field_serializer("discover_type")
    def serialize_discover_type(self, value):
        if isinstance(value, str):
            try:
                return models.RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHTTPDiscoverMethodPostWithBodyDiscoverType(
                    value
                )
            except ValueError:
                return value
        return value

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(
            [
                "discoverRequestHeaders",
                "pagination",
                "discoverDataField",
                "enableStrictDiscoverParsing",
                "enableDiscoverCode",
            ]
        )
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


class RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHTTPDiscoverMethodPostDiscoverMethod(
    str, Enum, metaclass=utils.OpenEnumMeta
):
    # GET
    GET = "get"
    # POST
    POST = "post"
    # POST with Body
    POST_WITH_BODY = "post_with_body"
    # Other
    OTHER = "other"


class RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHTTPDiscoverMethodPostDiscoverType(
    str, Enum, metaclass=utils.OpenEnumMeta
):
    r"""Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task."""

    HTTP = "http"
    JSON = "json"
    LIST = "list"
    NONE = "none"


class RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHTTPDiscoverMethodPostPaginationTypedDict(
    TypedDict
):
    type: PaginationOptionsRestDiscoveryDiscoverTypeHTTPPagination


class RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHTTPDiscoverMethodPostPagination(
    BaseModel
):
    type: PaginationOptionsRestDiscoveryDiscoverTypeHTTPPagination

    @field_serializer("type")
    def serialize_type(self, value):
        if isinstance(value, str):
            try:
                return models.PaginationOptionsRestDiscoveryDiscoverTypeHTTPPagination(
                    value
                )
            except ValueError:
                return value
        return value


class RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHTTPDiscoverMethodPostTypedDict(
    TypedDict
):
    discover_method: RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHTTPDiscoverMethodPostDiscoverMethod
    discover_type: RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHTTPDiscoverMethodPostDiscoverType
    r"""Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task."""
    discover_url: str
    r"""URL to use for the Discover operation. Can be a constant URL, or a JavaScript expression to derive the URL."""
    discover_request_params: NotRequired[
        List[ItemsTypeRestCollectMethodGetCollectRequestParamsTypedDict]
    ]
    discover_request_headers: NotRequired[
        List[ItemsTypeRestCollectMethodGetCollectRequestParamsTypedDict]
    ]
    pagination: NotRequired[
        RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHTTPDiscoverMethodPostPaginationTypedDict
    ]
    discover_data_field: NotRequired[str]
    r"""Path to field in the response object that contains discovery results (ex: level1.name). Leave blank if the result is an array."""
    enable_strict_discover_parsing: NotRequired[bool]
    r"""Explicitly set the discover response format. When disabled, best effort parsing is used."""
    enable_discover_code: NotRequired[bool]


class RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHTTPDiscoverMethodPost(
    BaseModel
):
    discover_method: Annotated[
        RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHTTPDiscoverMethodPostDiscoverMethod,
        pydantic.Field(alias="discoverMethod"),
    ]

    discover_type: Annotated[
        RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHTTPDiscoverMethodPostDiscoverType,
        pydantic.Field(alias="discoverType"),
    ]
    r"""Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task."""

    discover_url: Annotated[str, pydantic.Field(alias="discoverUrl")]
    r"""URL to use for the Discover operation. Can be a constant URL, or a JavaScript expression to derive the URL."""

    discover_request_params: Annotated[
        Optional[List[ItemsTypeRestCollectMethodGetCollectRequestParams]],
        pydantic.Field(alias="discoverRequestParams"),
    ] = None

    discover_request_headers: Annotated[
        Optional[List[ItemsTypeRestCollectMethodGetCollectRequestParams]],
        pydantic.Field(alias="discoverRequestHeaders"),
    ] = None

    pagination: Optional[
        RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHTTPDiscoverMethodPostPagination
    ] = None

    discover_data_field: Annotated[
        Optional[str], pydantic.Field(alias="discoverDataField")
    ] = None
    r"""Path to field in the response object that contains discovery results (ex: level1.name). Leave blank if the result is an array."""

    enable_strict_discover_parsing: Annotated[
        Optional[bool], pydantic.Field(alias="enableStrictDiscoverParsing")
    ] = None
    r"""Explicitly set the discover response format. When disabled, best effort parsing is used."""

    enable_discover_code: Annotated[
        Optional[bool], pydantic.Field(alias="enableDiscoverCode")
    ] = None

    @field_serializer("discover_method")
    def serialize_discover_method(self, value):
        if isinstance(value, str):
            try:
                return models.RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHTTPDiscoverMethodPostDiscoverMethod(
                    value
                )
            except ValueError:
                return value
        return value

    @field_serializer("discover_type")
    def serialize_discover_type(self, value):
        if isinstance(value, str):
            try:
                return models.RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHTTPDiscoverMethodPostDiscoverType(
                    value
                )
            except ValueError:
                return value
        return value

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(
            [
                "discoverRequestParams",
                "discoverRequestHeaders",
                "pagination",
                "discoverDataField",
                "enableStrictDiscoverParsing",
                "enableDiscoverCode",
            ]
        )
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


class RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHTTPDiscoverMethodGetDiscoverMethod(
    str, Enum, metaclass=utils.OpenEnumMeta
):
    # GET
    GET = "get"
    # POST
    POST = "post"
    # POST with Body
    POST_WITH_BODY = "post_with_body"
    # Other
    OTHER = "other"


class RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHTTPDiscoverMethodGetDiscoverType(
    str, Enum, metaclass=utils.OpenEnumMeta
):
    r"""Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task."""

    HTTP = "http"
    JSON = "json"
    LIST = "list"
    NONE = "none"


class RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHTTPDiscoverMethodGetPaginationTypedDict(
    TypedDict
):
    type: PaginationOptionsRestDiscoveryDiscoverTypeHTTPPagination


class RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHTTPDiscoverMethodGetPagination(
    BaseModel
):
    type: PaginationOptionsRestDiscoveryDiscoverTypeHTTPPagination

    @field_serializer("type")
    def serialize_type(self, value):
        if isinstance(value, str):
            try:
                return models.PaginationOptionsRestDiscoveryDiscoverTypeHTTPPagination(
                    value
                )
            except ValueError:
                return value
        return value


class RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHTTPDiscoverMethodGetTypedDict(
    TypedDict
):
    discover_method: RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHTTPDiscoverMethodGetDiscoverMethod
    discover_type: RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHTTPDiscoverMethodGetDiscoverType
    r"""Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task."""
    discover_url: str
    r"""URL to use for the Discover operation. Can be a constant URL, or a JavaScript expression to derive the URL."""
    discover_request_params: NotRequired[
        List[ItemsTypeRestCollectMethodGetCollectRequestParamsTypedDict]
    ]
    discover_request_headers: NotRequired[
        List[ItemsTypeRestCollectMethodGetCollectRequestParamsTypedDict]
    ]
    pagination: NotRequired[
        RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHTTPDiscoverMethodGetPaginationTypedDict
    ]
    discover_data_field: NotRequired[str]
    r"""Path to field in the response object that contains discovery results (ex: level1.name). Leave blank if the result is an array."""
    enable_strict_discover_parsing: NotRequired[bool]
    r"""Explicitly set the discover response format. When disabled, best effort parsing is used."""
    enable_discover_code: NotRequired[bool]


class RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHTTPDiscoverMethodGet(
    BaseModel
):
    discover_method: Annotated[
        RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHTTPDiscoverMethodGetDiscoverMethod,
        pydantic.Field(alias="discoverMethod"),
    ]

    discover_type: Annotated[
        RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHTTPDiscoverMethodGetDiscoverType,
        pydantic.Field(alias="discoverType"),
    ]
    r"""Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task."""

    discover_url: Annotated[str, pydantic.Field(alias="discoverUrl")]
    r"""URL to use for the Discover operation. Can be a constant URL, or a JavaScript expression to derive the URL."""

    discover_request_params: Annotated[
        Optional[List[ItemsTypeRestCollectMethodGetCollectRequestParams]],
        pydantic.Field(alias="discoverRequestParams"),
    ] = None

    discover_request_headers: Annotated[
        Optional[List[ItemsTypeRestCollectMethodGetCollectRequestParams]],
        pydantic.Field(alias="discoverRequestHeaders"),
    ] = None

    pagination: Optional[
        RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHTTPDiscoverMethodGetPagination
    ] = None

    discover_data_field: Annotated[
        Optional[str], pydantic.Field(alias="discoverDataField")
    ] = None
    r"""Path to field in the response object that contains discovery results (ex: level1.name). Leave blank if the result is an array."""

    enable_strict_discover_parsing: Annotated[
        Optional[bool], pydantic.Field(alias="enableStrictDiscoverParsing")
    ] = None
    r"""Explicitly set the discover response format. When disabled, best effort parsing is used."""

    enable_discover_code: Annotated[
        Optional[bool], pydantic.Field(alias="enableDiscoverCode")
    ] = None

    @field_serializer("discover_method")
    def serialize_discover_method(self, value):
        if isinstance(value, str):
            try:
                return models.RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHTTPDiscoverMethodGetDiscoverMethod(
                    value
                )
            except ValueError:
                return value
        return value

    @field_serializer("discover_type")
    def serialize_discover_type(self, value):
        if isinstance(value, str):
            try:
                return models.RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHTTPDiscoverMethodGetDiscoverType(
                    value
                )
            except ValueError:
                return value
        return value

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(
            [
                "discoverRequestParams",
                "discoverRequestHeaders",
                "pagination",
                "discoverDataField",
                "enableStrictDiscoverParsing",
                "enableDiscoverCode",
            ]
        )
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


class RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHTTPEnableDiscoverCodeTrueDiscoverType(
    str, Enum, metaclass=utils.OpenEnumMeta
):
    r"""Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task."""

    HTTP = "http"
    JSON = "json"
    LIST = "list"
    NONE = "none"


class RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHTTPEnableDiscoverCodeTrueDiscoverMethod(
    str, Enum, metaclass=utils.OpenEnumMeta
):
    # GET
    GET = "get"
    # POST
    POST = "post"
    # POST with Body
    POST_WITH_BODY = "post_with_body"
    # Other
    OTHER = "other"


class RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHTTPEnableDiscoverCodeTruePaginationTypedDict(
    TypedDict
):
    type: PaginationOptionsRestDiscoveryDiscoverTypeHTTPPagination


class RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHTTPEnableDiscoverCodeTruePagination(
    BaseModel
):
    type: PaginationOptionsRestDiscoveryDiscoverTypeHTTPPagination

    @field_serializer("type")
    def serialize_type(self, value):
        if isinstance(value, str):
            try:
                return models.PaginationOptionsRestDiscoveryDiscoverTypeHTTPPagination(
                    value
                )
            except ValueError:
                return value
        return value


class RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHTTPEnableDiscoverCodeTrueTypedDict(
    TypedDict
):
    discover_type: RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHTTPEnableDiscoverCodeTrueDiscoverType
    r"""Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task."""
    discover_url: str
    r"""URL to use for the Discover operation. Can be a constant URL, or a JavaScript expression to derive the URL."""
    discover_method: RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHTTPEnableDiscoverCodeTrueDiscoverMethod
    enable_discover_code: NotRequired[bool]
    format_result_code: NotRequired[str]
    r"""Custom JavaScript code to format the discover result through the __e variable which is a JSON object or array containing the original discover results. The object or array passed should be manipulated to contain the desired discover results, i.e.: __e['myResult'] = [{lat: -1.1234, long: 2.345, zip: 11111},{lat: -1.235, long 2.346, zip: 22222}] or ['11111','22222']. Caution: This function is evaluated in an unprotected context, allowing you to execute almost any JavaScript code."""
    discover_request_headers: NotRequired[
        List[ItemsTypeRestCollectMethodGetCollectRequestParamsTypedDict]
    ]
    pagination: NotRequired[
        RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHTTPEnableDiscoverCodeTruePaginationTypedDict
    ]
    discover_data_field: NotRequired[str]
    r"""Path to field in the response object that contains discovery results (ex: level1.name). Leave blank if the result is an array."""
    enable_strict_discover_parsing: NotRequired[bool]
    r"""Explicitly set the discover response format. When disabled, best effort parsing is used."""


class RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHTTPEnableDiscoverCodeTrue(
    BaseModel
):
    discover_type: Annotated[
        RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHTTPEnableDiscoverCodeTrueDiscoverType,
        pydantic.Field(alias="discoverType"),
    ]
    r"""Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task."""

    discover_url: Annotated[str, pydantic.Field(alias="discoverUrl")]
    r"""URL to use for the Discover operation. Can be a constant URL, or a JavaScript expression to derive the URL."""

    discover_method: Annotated[
        RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHTTPEnableDiscoverCodeTrueDiscoverMethod,
        pydantic.Field(alias="discoverMethod"),
    ]

    enable_discover_code: Annotated[
        Optional[bool], pydantic.Field(alias="enableDiscoverCode")
    ] = None

    format_result_code: Annotated[
        Optional[str], pydantic.Field(alias="formatResultCode")
    ] = None
    r"""Custom JavaScript code to format the discover result through the __e variable which is a JSON object or array containing the original discover results. The object or array passed should be manipulated to contain the desired discover results, i.e.: __e['myResult'] = [{lat: -1.1234, long: 2.345, zip: 11111},{lat: -1.235, long 2.346, zip: 22222}] or ['11111','22222']. Caution: This function is evaluated in an unprotected context, allowing you to execute almost any JavaScript code."""

    discover_request_headers: Annotated[
        Optional[List[ItemsTypeRestCollectMethodGetCollectRequestParams]],
        pydantic.Field(alias="discoverRequestHeaders"),
    ] = None

    pagination: Optional[
        RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHTTPEnableDiscoverCodeTruePagination
    ] = None

    discover_data_field: Annotated[
        Optional[str], pydantic.Field(alias="discoverDataField")
    ] = None
    r"""Path to field in the response object that contains discovery results (ex: level1.name). Leave blank if the result is an array."""

    enable_strict_discover_parsing: Annotated[
        Optional[bool], pydantic.Field(alias="enableStrictDiscoverParsing")
    ] = None
    r"""Explicitly set the discover response format. When disabled, best effort parsing is used."""

    @field_serializer("discover_type")
    def serialize_discover_type(self, value):
        if isinstance(value, str):
            try:
                return models.RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHTTPEnableDiscoverCodeTrueDiscoverType(
                    value
                )
            except ValueError:
                return value
        return value

    @field_serializer("discover_method")
    def serialize_discover_method(self, value):
        if isinstance(value, str):
            try:
                return models.RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHTTPEnableDiscoverCodeTrueDiscoverMethod(
                    value
                )
            except ValueError:
                return value
        return value

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(
            [
                "enableDiscoverCode",
                "formatResultCode",
                "discoverRequestHeaders",
                "pagination",
                "discoverDataField",
                "enableStrictDiscoverParsing",
            ]
        )
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


class RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHTTPEnableDiscoverCodeFalseDiscoverType(
    str, Enum, metaclass=utils.OpenEnumMeta
):
    r"""Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task."""

    HTTP = "http"
    JSON = "json"
    LIST = "list"
    NONE = "none"


class RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHTTPEnableDiscoverCodeFalseDiscoverMethod(
    str, Enum, metaclass=utils.OpenEnumMeta
):
    # GET
    GET = "get"
    # POST
    POST = "post"
    # POST with Body
    POST_WITH_BODY = "post_with_body"
    # Other
    OTHER = "other"


class RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHTTPEnableDiscoverCodeFalsePaginationTypedDict(
    TypedDict
):
    type: PaginationOptionsRestDiscoveryDiscoverTypeHTTPPagination


class RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHTTPEnableDiscoverCodeFalsePagination(
    BaseModel
):
    type: PaginationOptionsRestDiscoveryDiscoverTypeHTTPPagination

    @field_serializer("type")
    def serialize_type(self, value):
        if isinstance(value, str):
            try:
                return models.PaginationOptionsRestDiscoveryDiscoverTypeHTTPPagination(
                    value
                )
            except ValueError:
                return value
        return value


class RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHTTPEnableDiscoverCodeFalseTypedDict(
    TypedDict
):
    discover_type: RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHTTPEnableDiscoverCodeFalseDiscoverType
    r"""Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task."""
    discover_url: str
    r"""URL to use for the Discover operation. Can be a constant URL, or a JavaScript expression to derive the URL."""
    discover_method: RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHTTPEnableDiscoverCodeFalseDiscoverMethod
    enable_discover_code: NotRequired[bool]
    discover_request_headers: NotRequired[
        List[ItemsTypeRestCollectMethodGetCollectRequestParamsTypedDict]
    ]
    pagination: NotRequired[
        RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHTTPEnableDiscoverCodeFalsePaginationTypedDict
    ]
    discover_data_field: NotRequired[str]
    r"""Path to field in the response object that contains discovery results (ex: level1.name). Leave blank if the result is an array."""
    enable_strict_discover_parsing: NotRequired[bool]
    r"""Explicitly set the discover response format. When disabled, best effort parsing is used."""


class RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHTTPEnableDiscoverCodeFalse(
    BaseModel
):
    discover_type: Annotated[
        RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHTTPEnableDiscoverCodeFalseDiscoverType,
        pydantic.Field(alias="discoverType"),
    ]
    r"""Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task."""

    discover_url: Annotated[str, pydantic.Field(alias="discoverUrl")]
    r"""URL to use for the Discover operation. Can be a constant URL, or a JavaScript expression to derive the URL."""

    discover_method: Annotated[
        RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHTTPEnableDiscoverCodeFalseDiscoverMethod,
        pydantic.Field(alias="discoverMethod"),
    ]

    enable_discover_code: Annotated[
        Optional[bool], pydantic.Field(alias="enableDiscoverCode")
    ] = None

    discover_request_headers: Annotated[
        Optional[List[ItemsTypeRestCollectMethodGetCollectRequestParams]],
        pydantic.Field(alias="discoverRequestHeaders"),
    ] = None

    pagination: Optional[
        RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHTTPEnableDiscoverCodeFalsePagination
    ] = None

    discover_data_field: Annotated[
        Optional[str], pydantic.Field(alias="discoverDataField")
    ] = None
    r"""Path to field in the response object that contains discovery results (ex: level1.name). Leave blank if the result is an array."""

    enable_strict_discover_parsing: Annotated[
        Optional[bool], pydantic.Field(alias="enableStrictDiscoverParsing")
    ] = None
    r"""Explicitly set the discover response format. When disabled, best effort parsing is used."""

    @field_serializer("discover_type")
    def serialize_discover_type(self, value):
        if isinstance(value, str):
            try:
                return models.RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHTTPEnableDiscoverCodeFalseDiscoverType(
                    value
                )
            except ValueError:
                return value
        return value

    @field_serializer("discover_method")
    def serialize_discover_method(self, value):
        if isinstance(value, str):
            try:
                return models.RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHTTPEnableDiscoverCodeFalseDiscoverMethod(
                    value
                )
            except ValueError:
                return value
        return value

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(
            [
                "enableDiscoverCode",
                "discoverRequestHeaders",
                "pagination",
                "discoverDataField",
                "enableStrictDiscoverParsing",
            ]
        )
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


class RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHTTPEnableStrictDiscoverParsingTrueDiscoverType(
    str, Enum, metaclass=utils.OpenEnumMeta
):
    r"""Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task."""

    HTTP = "http"
    JSON = "json"
    LIST = "list"
    NONE = "none"


class RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHTTPEnableStrictDiscoverParsingTrueDiscoverMethod(
    str, Enum, metaclass=utils.OpenEnumMeta
):
    # GET
    GET = "get"
    # POST
    POST = "post"
    # POST with Body
    POST_WITH_BODY = "post_with_body"
    # Other
    OTHER = "other"


class RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHTTPEnableStrictDiscoverParsingTruePaginationTypedDict(
    TypedDict
):
    type: PaginationOptionsRestDiscoveryDiscoverTypeHTTPPagination


class RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHTTPEnableStrictDiscoverParsingTruePagination(
    BaseModel
):
    type: PaginationOptionsRestDiscoveryDiscoverTypeHTTPPagination

    @field_serializer("type")
    def serialize_type(self, value):
        if isinstance(value, str):
            try:
                return models.PaginationOptionsRestDiscoveryDiscoverTypeHTTPPagination(
                    value
                )
            except ValueError:
                return value
        return value


class RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHTTPEnableStrictDiscoverParsingTrueTypedDict(
    TypedDict
):
    discover_response_format: str
    r"""If 'Strict discover response parsing' parsing is enabled, provide the response format"""
    discover_type: RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHTTPEnableStrictDiscoverParsingTrueDiscoverType
    r"""Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task."""
    discover_url: str
    r"""URL to use for the Discover operation. Can be a constant URL, or a JavaScript expression to derive the URL."""
    discover_method: RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHTTPEnableStrictDiscoverParsingTrueDiscoverMethod
    enable_strict_discover_parsing: NotRequired[bool]
    r"""Explicitly set the discover response format. When disabled, best effort parsing is used."""
    discover_request_headers: NotRequired[
        List[ItemsTypeRestCollectMethodGetCollectRequestParamsTypedDict]
    ]
    pagination: NotRequired[
        RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHTTPEnableStrictDiscoverParsingTruePaginationTypedDict
    ]
    discover_data_field: NotRequired[str]
    r"""Path to field in the response object that contains discovery results (ex: level1.name). Leave blank if the result is an array."""
    enable_discover_code: NotRequired[bool]


class RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHTTPEnableStrictDiscoverParsingTrue(
    BaseModel
):
    discover_response_format: Annotated[
        str, pydantic.Field(alias="discoverResponseFormat")
    ]
    r"""If 'Strict discover response parsing' parsing is enabled, provide the response format"""

    discover_type: Annotated[
        RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHTTPEnableStrictDiscoverParsingTrueDiscoverType,
        pydantic.Field(alias="discoverType"),
    ]
    r"""Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task."""

    discover_url: Annotated[str, pydantic.Field(alias="discoverUrl")]
    r"""URL to use for the Discover operation. Can be a constant URL, or a JavaScript expression to derive the URL."""

    discover_method: Annotated[
        RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHTTPEnableStrictDiscoverParsingTrueDiscoverMethod,
        pydantic.Field(alias="discoverMethod"),
    ]

    enable_strict_discover_parsing: Annotated[
        Optional[bool], pydantic.Field(alias="enableStrictDiscoverParsing")
    ] = None
    r"""Explicitly set the discover response format. When disabled, best effort parsing is used."""

    discover_request_headers: Annotated[
        Optional[List[ItemsTypeRestCollectMethodGetCollectRequestParams]],
        pydantic.Field(alias="discoverRequestHeaders"),
    ] = None

    pagination: Optional[
        RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHTTPEnableStrictDiscoverParsingTruePagination
    ] = None

    discover_data_field: Annotated[
        Optional[str], pydantic.Field(alias="discoverDataField")
    ] = None
    r"""Path to field in the response object that contains discovery results (ex: level1.name). Leave blank if the result is an array."""

    enable_discover_code: Annotated[
        Optional[bool], pydantic.Field(alias="enableDiscoverCode")
    ] = None

    @field_serializer("discover_type")
    def serialize_discover_type(self, value):
        if isinstance(value, str):
            try:
                return models.RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHTTPEnableStrictDiscoverParsingTrueDiscoverType(
                    value
                )
            except ValueError:
                return value
        return value

    @field_serializer("discover_method")
    def serialize_discover_method(self, value):
        if isinstance(value, str):
            try:
                return models.RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHTTPEnableStrictDiscoverParsingTrueDiscoverMethod(
                    value
                )
            except ValueError:
                return value
        return value

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(
            [
                "enableStrictDiscoverParsing",
                "discoverRequestHeaders",
                "pagination",
                "discoverDataField",
                "enableDiscoverCode",
            ]
        )
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


class RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHTTPEnableStrictDiscoverParsingFalseDiscoverType(
    str, Enum, metaclass=utils.OpenEnumMeta
):
    r"""Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task."""

    HTTP = "http"
    JSON = "json"
    LIST = "list"
    NONE = "none"


class RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHTTPEnableStrictDiscoverParsingFalseDiscoverMethod(
    str, Enum, metaclass=utils.OpenEnumMeta
):
    # GET
    GET = "get"
    # POST
    POST = "post"
    # POST with Body
    POST_WITH_BODY = "post_with_body"
    # Other
    OTHER = "other"


class RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHTTPEnableStrictDiscoverParsingFalsePaginationTypedDict(
    TypedDict
):
    type: PaginationOptionsRestDiscoveryDiscoverTypeHTTPPagination


class RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHTTPEnableStrictDiscoverParsingFalsePagination(
    BaseModel
):
    type: PaginationOptionsRestDiscoveryDiscoverTypeHTTPPagination

    @field_serializer("type")
    def serialize_type(self, value):
        if isinstance(value, str):
            try:
                return models.PaginationOptionsRestDiscoveryDiscoverTypeHTTPPagination(
                    value
                )
            except ValueError:
                return value
        return value


class RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHTTPEnableStrictDiscoverParsingFalseTypedDict(
    TypedDict
):
    discover_type: RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHTTPEnableStrictDiscoverParsingFalseDiscoverType
    r"""Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task."""
    discover_url: str
    r"""URL to use for the Discover operation. Can be a constant URL, or a JavaScript expression to derive the URL."""
    discover_method: RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHTTPEnableStrictDiscoverParsingFalseDiscoverMethod
    enable_strict_discover_parsing: NotRequired[bool]
    r"""Explicitly set the discover response format. When disabled, best effort parsing is used."""
    discover_request_headers: NotRequired[
        List[ItemsTypeRestCollectMethodGetCollectRequestParamsTypedDict]
    ]
    pagination: NotRequired[
        RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHTTPEnableStrictDiscoverParsingFalsePaginationTypedDict
    ]
    discover_data_field: NotRequired[str]
    r"""Path to field in the response object that contains discovery results (ex: level1.name). Leave blank if the result is an array."""
    enable_discover_code: NotRequired[bool]


class RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHTTPEnableStrictDiscoverParsingFalse(
    BaseModel
):
    discover_type: Annotated[
        RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHTTPEnableStrictDiscoverParsingFalseDiscoverType,
        pydantic.Field(alias="discoverType"),
    ]
    r"""Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task."""

    discover_url: Annotated[str, pydantic.Field(alias="discoverUrl")]
    r"""URL to use for the Discover operation. Can be a constant URL, or a JavaScript expression to derive the URL."""

    discover_method: Annotated[
        RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHTTPEnableStrictDiscoverParsingFalseDiscoverMethod,
        pydantic.Field(alias="discoverMethod"),
    ]

    enable_strict_discover_parsing: Annotated[
        Optional[bool], pydantic.Field(alias="enableStrictDiscoverParsing")
    ] = None
    r"""Explicitly set the discover response format. When disabled, best effort parsing is used."""

    discover_request_headers: Annotated[
        Optional[List[ItemsTypeRestCollectMethodGetCollectRequestParams]],
        pydantic.Field(alias="discoverRequestHeaders"),
    ] = None

    pagination: Optional[
        RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHTTPEnableStrictDiscoverParsingFalsePagination
    ] = None

    discover_data_field: Annotated[
        Optional[str], pydantic.Field(alias="discoverDataField")
    ] = None
    r"""Path to field in the response object that contains discovery results (ex: level1.name). Leave blank if the result is an array."""

    enable_discover_code: Annotated[
        Optional[bool], pydantic.Field(alias="enableDiscoverCode")
    ] = None

    @field_serializer("discover_type")
    def serialize_discover_type(self, value):
        if isinstance(value, str):
            try:
                return models.RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHTTPEnableStrictDiscoverParsingFalseDiscoverType(
                    value
                )
            except ValueError:
                return value
        return value

    @field_serializer("discover_method")
    def serialize_discover_method(self, value):
        if isinstance(value, str):
            try:
                return models.RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHTTPEnableStrictDiscoverParsingFalseDiscoverMethod(
                    value
                )
            except ValueError:
                return value
        return value

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(
            [
                "enableStrictDiscoverParsing",
                "discoverRequestHeaders",
                "pagination",
                "discoverDataField",
                "enableDiscoverCode",
            ]
        )
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHTTPTypedDict = TypeAliasType(
    "RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHTTPTypedDict",
    Union[
        RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHTTPEnableStrictDiscoverParsingFalseTypedDict,
        RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHTTPEnableDiscoverCodeFalseTypedDict,
        RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHTTPEnableStrictDiscoverParsingTrueTypedDict,
        RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHTTPEnableDiscoverCodeTrueTypedDict,
        RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHTTPDiscoverMethodGetTypedDict,
        RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHTTPDiscoverMethodPostTypedDict,
        RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHTTPDiscoverMethodPostWithBodyTypedDict,
        RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHTTPDiscoverMethodOtherTypedDict,
    ],
)


class UnknownRestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHTTP(
    BaseModel
):
    r"""A RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHTTP variant the SDK doesn't recognize. Preserves the raw payload."""

    discover_method: Literal["UNKNOWN"] = "UNKNOWN"
    raw: Any
    is_unknown: Literal[True] = True

    model_config = ConfigDict(frozen=True)


_REST_AUTHENTICATION_GOOGLE_OAUTH_SECRET_REST_DISCOVERY_DISCOVER_TYPE_HTTP_VARIANTS: dict[
    str, Any
] = {
    "get": RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHTTPDiscoverMethodGet,
    "post": RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHTTPDiscoverMethodPost,
    "post_with_body": RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHTTPDiscoverMethodPostWithBody,
    "other": RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHTTPDiscoverMethodOther,
}


RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHTTP = Annotated[
    Union[
        RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHTTPDiscoverMethodGet,
        RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHTTPDiscoverMethodPost,
        RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHTTPDiscoverMethodPostWithBody,
        RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHTTPDiscoverMethodOther,
        UnknownRestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHTTP,
    ],
    BeforeValidator(
        partial(
            parse_open_union,
            disc_key="discoverMethod",
            variants=_REST_AUTHENTICATION_GOOGLE_OAUTH_SECRET_REST_DISCOVERY_DISCOVER_TYPE_HTTP_VARIANTS,
            unknown_cls=UnknownRestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHTTP,
            union_name="RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHTTP",
        )
    ),
]


RestAuthenticationGoogleOauthSecretDiscoveryTypedDict = TypeAliasType(
    "RestAuthenticationGoogleOauthSecretDiscoveryTypedDict",
    Union[
        RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeNoneTypedDict,
        RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeListTypedDict,
        RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeJSONTypedDict,
        RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHTTPTypedDict,
    ],
)


class UnknownRestAuthenticationGoogleOauthSecretDiscovery(BaseModel):
    r"""A RestAuthenticationGoogleOauthSecretDiscovery variant the SDK doesn't recognize. Preserves the raw payload."""

    discover_type: Literal["UNKNOWN"] = "UNKNOWN"
    raw: Any
    is_unknown: Literal[True] = True

    model_config = ConfigDict(frozen=True)


_REST_AUTHENTICATION_GOOGLE_OAUTH_SECRET_DISCOVERY_VARIANTS: dict[str, Any] = {
    "http": RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHTTP,
    "json": RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeJSON,
    "list": RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeList,
    "none": RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeNone,
}


RestAuthenticationGoogleOauthSecretDiscovery = Annotated[
    Union[
        RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHTTP,
        RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeJSON,
        RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeList,
        RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeNone,
        UnknownRestAuthenticationGoogleOauthSecretDiscovery,
    ],
    BeforeValidator(
        partial(
            parse_open_union,
            disc_key="discoverType",
            variants=_REST_AUTHENTICATION_GOOGLE_OAUTH_SECRET_DISCOVERY_VARIANTS,
            unknown_cls=UnknownRestAuthenticationGoogleOauthSecretDiscovery,
            union_name="RestAuthenticationGoogleOauthSecretDiscovery",
        )
    ),
]


class RestAuthenticationGoogleOauthSecretCollectMethod(
    str, Enum, metaclass=utils.OpenEnumMeta
):
    # GET
    GET = "get"
    # POST
    POST = "post"
    # POST with Body
    POST_WITH_BODY = "post_with_body"
    # Other
    OTHER = "other"


class RestAuthenticationGoogleOauthSecretRestPaginationTypeRequestPageTypedDict(
    TypedDict
):
    type: PaginationOptionsRestDiscoveryDiscoverTypeHTTPPagination
    page_field: str
    r"""Query string parameter that sets the page index to be returned. Example: /api/v1/query?term=cribl&page_size=100&page_number=0"""
    size_field: str
    r"""Query string parameter that sets the number of records retrieved per request. Example: /api/v1/query?term=cribl&page_size=100&page_number=0"""
    size: float
    r"""Maximum number of records to collect per page"""
    max_pages: float
    r"""Maximum number of pages to retrieve per collection task. Defaults to 50 pages. Set to 0 to retrieve all pages."""
    zero_indexed: bool
    r"""Enable to indicate that the first page in the requested data is at index 0. Disabled by default, which indicates index 1."""
    page: NotRequired[float]
    r"""Page number from which to start request. Defaults to undefined, which will start collection from the first page."""
    total_page_field: NotRequired[str]
    r"""Name of the attribute in the response that contains the total number of pages for the query"""
    total_record_field: NotRequired[str]
    r"""Name of the attribute in the response that contains the total number of records for the query"""


class RestAuthenticationGoogleOauthSecretRestPaginationTypeRequestPage(BaseModel):
    type: PaginationOptionsRestDiscoveryDiscoverTypeHTTPPagination

    page_field: Annotated[str, pydantic.Field(alias="pageField")]
    r"""Query string parameter that sets the page index to be returned. Example: /api/v1/query?term=cribl&page_size=100&page_number=0"""

    size_field: Annotated[str, pydantic.Field(alias="sizeField")]
    r"""Query string parameter that sets the number of records retrieved per request. Example: /api/v1/query?term=cribl&page_size=100&page_number=0"""

    size: float
    r"""Maximum number of records to collect per page"""

    max_pages: Annotated[float, pydantic.Field(alias="maxPages")]
    r"""Maximum number of pages to retrieve per collection task. Defaults to 50 pages. Set to 0 to retrieve all pages."""

    zero_indexed: Annotated[bool, pydantic.Field(alias="zeroIndexed")]
    r"""Enable to indicate that the first page in the requested data is at index 0. Disabled by default, which indicates index 1."""

    page: Optional[float] = None
    r"""Page number from which to start request. Defaults to undefined, which will start collection from the first page."""

    total_page_field: Annotated[
        Optional[str], pydantic.Field(alias="totalPageField")
    ] = None
    r"""Name of the attribute in the response that contains the total number of pages for the query"""

    total_record_field: Annotated[
        Optional[str], pydantic.Field(alias="totalRecordField")
    ] = None
    r"""Name of the attribute in the response that contains the total number of records for the query"""

    @field_serializer("type")
    def serialize_type(self, value):
        if isinstance(value, str):
            try:
                return models.PaginationOptionsRestDiscoveryDiscoverTypeHTTPPagination(
                    value
                )
            except ValueError:
                return value
        return value

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(["page", "totalPageField", "totalRecordField"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


class RestAuthenticationGoogleOauthSecretRestPaginationTypeRequestOffsetTypedDict(
    TypedDict
):
    type: PaginationOptionsRestDiscoveryDiscoverTypeHTTPPagination
    offset_field: str
    r"""Query string parameter that sets the index from which to begin returning records. Example: /api/v1/query?term=cribl&limit=100&offset=0"""
    limit_field: str
    r"""Query string parameter that sets the number of records retrieved per request. Example: /api/v1/query?term=cribl&limit=100&offset=0"""
    limit: float
    r"""Maximum number of records to collect per request"""
    max_pages: float
    r"""Maximum number of pages to retrieve per collection task. Defaults to 50 pages. Set to 0 to retrieve all pages."""
    zero_indexed: bool
    r"""Enable to indicate that the first page in the requested data is at index 0. Disabled by default, which indicates index 1."""
    offset: NotRequired[float]
    r"""Offset index from which to start request. Defaults to undefined, which will start collection from the first record."""
    total_record_field: NotRequired[str]
    r"""Name of the attribute in the response that contains the total number of records for the query"""


class RestAuthenticationGoogleOauthSecretRestPaginationTypeRequestOffset(BaseModel):
    type: PaginationOptionsRestDiscoveryDiscoverTypeHTTPPagination

    offset_field: Annotated[str, pydantic.Field(alias="offsetField")]
    r"""Query string parameter that sets the index from which to begin returning records. Example: /api/v1/query?term=cribl&limit=100&offset=0"""

    limit_field: Annotated[str, pydantic.Field(alias="limitField")]
    r"""Query string parameter that sets the number of records retrieved per request. Example: /api/v1/query?term=cribl&limit=100&offset=0"""

    limit: float
    r"""Maximum number of records to collect per request"""

    max_pages: Annotated[float, pydantic.Field(alias="maxPages")]
    r"""Maximum number of pages to retrieve per collection task. Defaults to 50 pages. Set to 0 to retrieve all pages."""

    zero_indexed: Annotated[bool, pydantic.Field(alias="zeroIndexed")]
    r"""Enable to indicate that the first page in the requested data is at index 0. Disabled by default, which indicates index 1."""

    offset: Optional[float] = None
    r"""Offset index from which to start request. Defaults to undefined, which will start collection from the first record."""

    total_record_field: Annotated[
        Optional[str], pydantic.Field(alias="totalRecordField")
    ] = None
    r"""Name of the attribute in the response that contains the total number of records for the query"""

    @field_serializer("type")
    def serialize_type(self, value):
        if isinstance(value, str):
            try:
                return models.PaginationOptionsRestDiscoveryDiscoverTypeHTTPPagination(
                    value
                )
            except ValueError:
                return value
        return value

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(["offset", "totalRecordField"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


class RestAuthenticationGoogleOauthSecretRestPaginationTypeResponseHeaderLinkTypedDict(
    TypedDict
):
    type: PaginationOptionsRestDiscoveryDiscoverTypeHTTPPagination
    next_relation_attribute: str
    r"""Relation name used in the link header that refers to the next page in the result set. Example: rel=\"next\" refers to the next page of results: <https://myHost/nextPage>; rel=\"next\" """
    max_pages: float
    r"""Maximum number of pages to retrieve per collection task. Defaults to 50 pages. Set to 0 to retrieve all pages."""
    cur_relation_attribute: NotRequired[str]
    r"""Relation name used in the link header that refers to the current result set. Example: rel=\"self\" refers to the current page of results: <https://myHost/curPage>; rel=\"self\" """


class RestAuthenticationGoogleOauthSecretRestPaginationTypeResponseHeaderLink(
    BaseModel
):
    type: PaginationOptionsRestDiscoveryDiscoverTypeHTTPPagination

    next_relation_attribute: Annotated[
        str, pydantic.Field(alias="nextRelationAttribute")
    ]
    r"""Relation name used in the link header that refers to the next page in the result set. Example: rel=\"next\" refers to the next page of results: <https://myHost/nextPage>; rel=\"next\" """

    max_pages: Annotated[float, pydantic.Field(alias="maxPages")]
    r"""Maximum number of pages to retrieve per collection task. Defaults to 50 pages. Set to 0 to retrieve all pages."""

    cur_relation_attribute: Annotated[
        Optional[str], pydantic.Field(alias="curRelationAttribute")
    ] = None
    r"""Relation name used in the link header that refers to the current result set. Example: rel=\"self\" refers to the current page of results: <https://myHost/curPage>; rel=\"self\" """

    @field_serializer("type")
    def serialize_type(self, value):
        if isinstance(value, str):
            try:
                return models.PaginationOptionsRestDiscoveryDiscoverTypeHTTPPagination(
                    value
                )
            except ValueError:
                return value
        return value

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(["curRelationAttribute"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


class RestAuthenticationGoogleOauthSecretRestPaginationTypeResponseHeaderTypedDict(
    TypedDict
):
    type: PaginationOptionsRestDiscoveryDiscoverTypeHTTPPagination
    attribute: List[str]
    r"""Names of attributes within the response that contain next-page information"""
    max_pages: float
    r"""Maximum number of pages to retrieve per collection task. Defaults to 50 pages. Set to 0 to retrieve all pages."""


class RestAuthenticationGoogleOauthSecretRestPaginationTypeResponseHeader(BaseModel):
    type: PaginationOptionsRestDiscoveryDiscoverTypeHTTPPagination

    attribute: List[str]
    r"""Names of attributes within the response that contain next-page information"""

    max_pages: Annotated[float, pydantic.Field(alias="maxPages")]
    r"""Maximum number of pages to retrieve per collection task. Defaults to 50 pages. Set to 0 to retrieve all pages."""

    @field_serializer("type")
    def serialize_type(self, value):
        if isinstance(value, str):
            try:
                return models.PaginationOptionsRestDiscoveryDiscoverTypeHTTPPagination(
                    value
                )
            except ValueError:
                return value
        return value


class RestAuthenticationGoogleOauthSecretRestPaginationTypeResponseBodyTypedDict(
    TypedDict
):
    type: PaginationOptionsRestDiscoveryDiscoverTypeHTTPPagination
    attribute: List[str]
    r"""Names of attributes within the response that contain next-page information"""
    max_pages: float
    r"""Maximum number of pages to retrieve per collection task. Defaults to 50 pages. Set to 0 to retrieve all pages."""
    last_page_expr: NotRequired[str]
    r"""JavaScript expression used to determine when the last page has been reached. The values tested by this expression must be in the Response attributes section."""


class RestAuthenticationGoogleOauthSecretRestPaginationTypeResponseBody(BaseModel):
    type: PaginationOptionsRestDiscoveryDiscoverTypeHTTPPagination

    attribute: List[str]
    r"""Names of attributes within the response that contain next-page information"""

    max_pages: Annotated[float, pydantic.Field(alias="maxPages")]
    r"""Maximum number of pages to retrieve per collection task. Defaults to 50 pages. Set to 0 to retrieve all pages."""

    last_page_expr: Annotated[Optional[str], pydantic.Field(alias="lastPageExpr")] = (
        None
    )
    r"""JavaScript expression used to determine when the last page has been reached. The values tested by this expression must be in the Response attributes section."""

    @field_serializer("type")
    def serialize_type(self, value):
        if isinstance(value, str):
            try:
                return models.PaginationOptionsRestDiscoveryDiscoverTypeHTTPPagination(
                    value
                )
            except ValueError:
                return value
        return value

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(["lastPageExpr"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


class RestAuthenticationGoogleOauthSecretRestPaginationTypeNoneTypedDict(TypedDict):
    type: PaginationOptionsRestDiscoveryDiscoverTypeHTTPPagination


class RestAuthenticationGoogleOauthSecretRestPaginationTypeNone(BaseModel):
    type: PaginationOptionsRestDiscoveryDiscoverTypeHTTPPagination

    @field_serializer("type")
    def serialize_type(self, value):
        if isinstance(value, str):
            try:
                return models.PaginationOptionsRestDiscoveryDiscoverTypeHTTPPagination(
                    value
                )
            except ValueError:
                return value
        return value


RestAuthenticationGoogleOauthSecretPaginationUnionTypedDict = TypeAliasType(
    "RestAuthenticationGoogleOauthSecretPaginationUnionTypedDict",
    Union[
        RestAuthenticationGoogleOauthSecretRestPaginationTypeNoneTypedDict,
        RestAuthenticationGoogleOauthSecretRestPaginationTypeResponseHeaderTypedDict,
        RestAuthenticationGoogleOauthSecretRestPaginationTypeResponseBodyTypedDict,
        RestAuthenticationGoogleOauthSecretRestPaginationTypeResponseHeaderLinkTypedDict,
        RestAuthenticationGoogleOauthSecretRestPaginationTypeRequestOffsetTypedDict,
        RestAuthenticationGoogleOauthSecretRestPaginationTypeRequestPageTypedDict,
    ],
)


class UnknownRestAuthenticationGoogleOauthSecretPaginationUnion(BaseModel):
    r"""A RestAuthenticationGoogleOauthSecretPaginationUnion variant the SDK doesn't recognize. Preserves the raw payload."""

    type: Literal["UNKNOWN"] = "UNKNOWN"
    raw: Any
    is_unknown: Literal[True] = True

    model_config = ConfigDict(frozen=True)


_REST_AUTHENTICATION_GOOGLE_OAUTH_SECRET_PAGINATION_UNION_VARIANTS: dict[str, Any] = {
    "none": RestAuthenticationGoogleOauthSecretRestPaginationTypeNone,
    "response_body": RestAuthenticationGoogleOauthSecretRestPaginationTypeResponseBody,
    "response_header": RestAuthenticationGoogleOauthSecretRestPaginationTypeResponseHeader,
    "response_header_link": RestAuthenticationGoogleOauthSecretRestPaginationTypeResponseHeaderLink,
    "request_offset": RestAuthenticationGoogleOauthSecretRestPaginationTypeRequestOffset,
    "request_page": RestAuthenticationGoogleOauthSecretRestPaginationTypeRequestPage,
}


RestAuthenticationGoogleOauthSecretPaginationUnion = Annotated[
    Union[
        RestAuthenticationGoogleOauthSecretRestPaginationTypeNone,
        RestAuthenticationGoogleOauthSecretRestPaginationTypeResponseBody,
        RestAuthenticationGoogleOauthSecretRestPaginationTypeResponseHeader,
        RestAuthenticationGoogleOauthSecretRestPaginationTypeResponseHeaderLink,
        RestAuthenticationGoogleOauthSecretRestPaginationTypeRequestOffset,
        RestAuthenticationGoogleOauthSecretRestPaginationTypeRequestPage,
        UnknownRestAuthenticationGoogleOauthSecretPaginationUnion,
    ],
    BeforeValidator(
        partial(
            parse_open_union,
            disc_key="type",
            variants=_REST_AUTHENTICATION_GOOGLE_OAUTH_SECRET_PAGINATION_UNION_VARIANTS,
            unknown_cls=UnknownRestAuthenticationGoogleOauthSecretPaginationUnion,
            union_name="RestAuthenticationGoogleOauthSecretPaginationUnion",
        )
    ),
]


class RestAuthenticationGoogleOauthSecretRestRetryRulesTypeBackoffEnableHeaderTrueTypedDict(
    TypedDict
):
    type: RetryTypeOptionsHealthCheckCollectorConfRetryRules
    r"""The algorithm to use when performing HTTP retries"""
    enable_header: NotRequired[bool]
    r"""Honor any Retry-After header that specifies a delay (in seconds) or a timestamp after which to retry the request. The delay is limited to the `Longest interval between retries (ms)` value, even if the Retry-After header specifies a longer delay. When disabled, all Retry-After headers are ignored."""
    retry_header_name: NotRequired[str]
    interval: NotRequired[float]
    r"""Time interval between a failed request and the first retry"""
    limit: NotRequired[float]
    r"""Maximum number of times to retry a failed HTTP request"""
    multiplier: NotRequired[float]
    r"""Base for exponential backoff. Example: base 2 means that retries will occur after 2, then 4, then 8 seconds, and so on."""
    max_interval_ms: NotRequired[float]
    codes: NotRequired[List[float]]
    r"""List of HTTP codes that trigger a retry. Leave empty to use the default list of 429 and 503."""
    retry_connect_timeout: NotRequired[bool]
    r"""Make a single retry attempt when a connection timeout (ETIMEDOUT) error occurs"""
    retry_connect_reset: NotRequired[bool]
    r"""Retry request when a connection reset (ECONNRESET) error occurs"""


class RestAuthenticationGoogleOauthSecretRestRetryRulesTypeBackoffEnableHeaderTrue(
    BaseModel
):
    type: RetryTypeOptionsHealthCheckCollectorConfRetryRules
    r"""The algorithm to use when performing HTTP retries"""

    enable_header: Annotated[Optional[bool], pydantic.Field(alias="enableHeader")] = (
        None
    )
    r"""Honor any Retry-After header that specifies a delay (in seconds) or a timestamp after which to retry the request. The delay is limited to the `Longest interval between retries (ms)` value, even if the Retry-After header specifies a longer delay. When disabled, all Retry-After headers are ignored."""

    retry_header_name: Annotated[
        Optional[str], pydantic.Field(alias="retryHeaderName")
    ] = None

    interval: Optional[float] = None
    r"""Time interval between a failed request and the first retry"""

    limit: Optional[float] = None
    r"""Maximum number of times to retry a failed HTTP request"""

    multiplier: Optional[float] = None
    r"""Base for exponential backoff. Example: base 2 means that retries will occur after 2, then 4, then 8 seconds, and so on."""

    max_interval_ms: Annotated[
        Optional[float], pydantic.Field(alias="maxIntervalMs")
    ] = None

    codes: Optional[List[float]] = None
    r"""List of HTTP codes that trigger a retry. Leave empty to use the default list of 429 and 503."""

    retry_connect_timeout: Annotated[
        Optional[bool], pydantic.Field(alias="retryConnectTimeout")
    ] = None
    r"""Make a single retry attempt when a connection timeout (ETIMEDOUT) error occurs"""

    retry_connect_reset: Annotated[
        Optional[bool], pydantic.Field(alias="retryConnectReset")
    ] = None
    r"""Retry request when a connection reset (ECONNRESET) error occurs"""

    @field_serializer("type")
    def serialize_type(self, value):
        if isinstance(value, str):
            try:
                return models.RetryTypeOptionsHealthCheckCollectorConfRetryRules(value)
            except ValueError:
                return value
        return value

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(
            [
                "enableHeader",
                "retryHeaderName",
                "interval",
                "limit",
                "multiplier",
                "maxIntervalMs",
                "codes",
                "retryConnectTimeout",
                "retryConnectReset",
            ]
        )
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


class RestAuthenticationGoogleOauthSecretRestRetryRulesTypeBackoffEnableHeaderFalseTypedDict(
    TypedDict
):
    type: RetryTypeOptionsHealthCheckCollectorConfRetryRules
    r"""The algorithm to use when performing HTTP retries"""
    enable_header: NotRequired[bool]
    r"""Honor any Retry-After header that specifies a delay (in seconds) or a timestamp after which to retry the request. The delay is limited to the `Longest interval between retries (ms)` value, even if the Retry-After header specifies a longer delay. When disabled, all Retry-After headers are ignored."""
    interval: NotRequired[float]
    r"""Time interval between a failed request and the first retry"""
    limit: NotRequired[float]
    r"""Maximum number of times to retry a failed HTTP request"""
    multiplier: NotRequired[float]
    r"""Base for exponential backoff. Example: base 2 means that retries will occur after 2, then 4, then 8 seconds, and so on."""
    max_interval_ms: NotRequired[float]
    codes: NotRequired[List[float]]
    r"""List of HTTP codes that trigger a retry. Leave empty to use the default list of 429 and 503."""
    retry_connect_timeout: NotRequired[bool]
    r"""Make a single retry attempt when a connection timeout (ETIMEDOUT) error occurs"""
    retry_connect_reset: NotRequired[bool]
    r"""Retry request when a connection reset (ECONNRESET) error occurs"""


class RestAuthenticationGoogleOauthSecretRestRetryRulesTypeBackoffEnableHeaderFalse(
    BaseModel
):
    type: RetryTypeOptionsHealthCheckCollectorConfRetryRules
    r"""The algorithm to use when performing HTTP retries"""

    enable_header: Annotated[Optional[bool], pydantic.Field(alias="enableHeader")] = (
        None
    )
    r"""Honor any Retry-After header that specifies a delay (in seconds) or a timestamp after which to retry the request. The delay is limited to the `Longest interval between retries (ms)` value, even if the Retry-After header specifies a longer delay. When disabled, all Retry-After headers are ignored."""

    interval: Optional[float] = None
    r"""Time interval between a failed request and the first retry"""

    limit: Optional[float] = None
    r"""Maximum number of times to retry a failed HTTP request"""

    multiplier: Optional[float] = None
    r"""Base for exponential backoff. Example: base 2 means that retries will occur after 2, then 4, then 8 seconds, and so on."""

    max_interval_ms: Annotated[
        Optional[float], pydantic.Field(alias="maxIntervalMs")
    ] = None

    codes: Optional[List[float]] = None
    r"""List of HTTP codes that trigger a retry. Leave empty to use the default list of 429 and 503."""

    retry_connect_timeout: Annotated[
        Optional[bool], pydantic.Field(alias="retryConnectTimeout")
    ] = None
    r"""Make a single retry attempt when a connection timeout (ETIMEDOUT) error occurs"""

    retry_connect_reset: Annotated[
        Optional[bool], pydantic.Field(alias="retryConnectReset")
    ] = None
    r"""Retry request when a connection reset (ECONNRESET) error occurs"""

    @field_serializer("type")
    def serialize_type(self, value):
        if isinstance(value, str):
            try:
                return models.RetryTypeOptionsHealthCheckCollectorConfRetryRules(value)
            except ValueError:
                return value
        return value

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(
            [
                "enableHeader",
                "interval",
                "limit",
                "multiplier",
                "maxIntervalMs",
                "codes",
                "retryConnectTimeout",
                "retryConnectReset",
            ]
        )
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


RestAuthenticationGoogleOauthSecretRestRetryRulesTypeBackoffTypedDict = TypeAliasType(
    "RestAuthenticationGoogleOauthSecretRestRetryRulesTypeBackoffTypedDict",
    Union[
        RestAuthenticationGoogleOauthSecretRestRetryRulesTypeBackoffEnableHeaderFalseTypedDict,
        RestAuthenticationGoogleOauthSecretRestRetryRulesTypeBackoffEnableHeaderTrueTypedDict,
    ],
)


RestAuthenticationGoogleOauthSecretRestRetryRulesTypeBackoff = TypeAliasType(
    "RestAuthenticationGoogleOauthSecretRestRetryRulesTypeBackoff",
    Union[
        RestAuthenticationGoogleOauthSecretRestRetryRulesTypeBackoffEnableHeaderFalse,
        RestAuthenticationGoogleOauthSecretRestRetryRulesTypeBackoffEnableHeaderTrue,
    ],
)


class RestAuthenticationGoogleOauthSecretRestRetryRulesTypeStaticEnableHeaderTrueTypedDict(
    TypedDict
):
    type: RetryTypeOptionsHealthCheckCollectorConfRetryRules
    r"""The algorithm to use when performing HTTP retries"""
    enable_header: NotRequired[bool]
    r"""Honor any Retry-After header that specifies a delay (in seconds) or a timestamp after which to retry the request. The delay is limited to the `Longest interval between retries (ms)` value, even if the Retry-After header specifies a longer delay. When disabled, all Retry-After headers are ignored."""
    retry_header_name: NotRequired[str]
    interval: NotRequired[float]
    r"""Time interval between retries. Maximum allowed value is 20,000 ms (1/3 minute)."""
    limit: NotRequired[float]
    r"""Maximum number of times to retry a failed HTTP request"""
    codes: NotRequired[List[float]]
    r"""List of HTTP codes that trigger a retry. Leave empty to use the default list of 429 and 503."""
    retry_connect_timeout: NotRequired[bool]
    r"""Make a single retry attempt when a connection timeout (ETIMEDOUT) error occurs"""
    retry_connect_reset: NotRequired[bool]
    r"""Retry request when a connection reset (ECONNRESET) error occurs"""


class RestAuthenticationGoogleOauthSecretRestRetryRulesTypeStaticEnableHeaderTrue(
    BaseModel
):
    type: RetryTypeOptionsHealthCheckCollectorConfRetryRules
    r"""The algorithm to use when performing HTTP retries"""

    enable_header: Annotated[Optional[bool], pydantic.Field(alias="enableHeader")] = (
        None
    )
    r"""Honor any Retry-After header that specifies a delay (in seconds) or a timestamp after which to retry the request. The delay is limited to the `Longest interval between retries (ms)` value, even if the Retry-After header specifies a longer delay. When disabled, all Retry-After headers are ignored."""

    retry_header_name: Annotated[
        Optional[str], pydantic.Field(alias="retryHeaderName")
    ] = None

    interval: Optional[float] = None
    r"""Time interval between retries. Maximum allowed value is 20,000 ms (1/3 minute)."""

    limit: Optional[float] = None
    r"""Maximum number of times to retry a failed HTTP request"""

    codes: Optional[List[float]] = None
    r"""List of HTTP codes that trigger a retry. Leave empty to use the default list of 429 and 503."""

    retry_connect_timeout: Annotated[
        Optional[bool], pydantic.Field(alias="retryConnectTimeout")
    ] = None
    r"""Make a single retry attempt when a connection timeout (ETIMEDOUT) error occurs"""

    retry_connect_reset: Annotated[
        Optional[bool], pydantic.Field(alias="retryConnectReset")
    ] = None
    r"""Retry request when a connection reset (ECONNRESET) error occurs"""

    @field_serializer("type")
    def serialize_type(self, value):
        if isinstance(value, str):
            try:
                return models.RetryTypeOptionsHealthCheckCollectorConfRetryRules(value)
            except ValueError:
                return value
        return value

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(
            [
                "enableHeader",
                "retryHeaderName",
                "interval",
                "limit",
                "codes",
                "retryConnectTimeout",
                "retryConnectReset",
            ]
        )
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


class RestAuthenticationGoogleOauthSecretRestRetryRulesTypeStaticEnableHeaderFalseTypedDict(
    TypedDict
):
    type: RetryTypeOptionsHealthCheckCollectorConfRetryRules
    r"""The algorithm to use when performing HTTP retries"""
    enable_header: NotRequired[bool]
    r"""Honor any Retry-After header that specifies a delay (in seconds) or a timestamp after which to retry the request. The delay is limited to the `Longest interval between retries (ms)` value, even if the Retry-After header specifies a longer delay. When disabled, all Retry-After headers are ignored."""
    interval: NotRequired[float]
    r"""Time interval between retries. Maximum allowed value is 20,000 ms (1/3 minute)."""
    limit: NotRequired[float]
    r"""Maximum number of times to retry a failed HTTP request"""
    codes: NotRequired[List[float]]
    r"""List of HTTP codes that trigger a retry. Leave empty to use the default list of 429 and 503."""
    retry_connect_timeout: NotRequired[bool]
    r"""Make a single retry attempt when a connection timeout (ETIMEDOUT) error occurs"""
    retry_connect_reset: NotRequired[bool]
    r"""Retry request when a connection reset (ECONNRESET) error occurs"""


class RestAuthenticationGoogleOauthSecretRestRetryRulesTypeStaticEnableHeaderFalse(
    BaseModel
):
    type: RetryTypeOptionsHealthCheckCollectorConfRetryRules
    r"""The algorithm to use when performing HTTP retries"""

    enable_header: Annotated[Optional[bool], pydantic.Field(alias="enableHeader")] = (
        None
    )
    r"""Honor any Retry-After header that specifies a delay (in seconds) or a timestamp after which to retry the request. The delay is limited to the `Longest interval between retries (ms)` value, even if the Retry-After header specifies a longer delay. When disabled, all Retry-After headers are ignored."""

    interval: Optional[float] = None
    r"""Time interval between retries. Maximum allowed value is 20,000 ms (1/3 minute)."""

    limit: Optional[float] = None
    r"""Maximum number of times to retry a failed HTTP request"""

    codes: Optional[List[float]] = None
    r"""List of HTTP codes that trigger a retry. Leave empty to use the default list of 429 and 503."""

    retry_connect_timeout: Annotated[
        Optional[bool], pydantic.Field(alias="retryConnectTimeout")
    ] = None
    r"""Make a single retry attempt when a connection timeout (ETIMEDOUT) error occurs"""

    retry_connect_reset: Annotated[
        Optional[bool], pydantic.Field(alias="retryConnectReset")
    ] = None
    r"""Retry request when a connection reset (ECONNRESET) error occurs"""

    @field_serializer("type")
    def serialize_type(self, value):
        if isinstance(value, str):
            try:
                return models.RetryTypeOptionsHealthCheckCollectorConfRetryRules(value)
            except ValueError:
                return value
        return value

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(
            [
                "enableHeader",
                "interval",
                "limit",
                "codes",
                "retryConnectTimeout",
                "retryConnectReset",
            ]
        )
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


RestAuthenticationGoogleOauthSecretRestRetryRulesTypeStaticTypedDict = TypeAliasType(
    "RestAuthenticationGoogleOauthSecretRestRetryRulesTypeStaticTypedDict",
    Union[
        RestAuthenticationGoogleOauthSecretRestRetryRulesTypeStaticEnableHeaderFalseTypedDict,
        RestAuthenticationGoogleOauthSecretRestRetryRulesTypeStaticEnableHeaderTrueTypedDict,
    ],
)


RestAuthenticationGoogleOauthSecretRestRetryRulesTypeStatic = TypeAliasType(
    "RestAuthenticationGoogleOauthSecretRestRetryRulesTypeStatic",
    Union[
        RestAuthenticationGoogleOauthSecretRestRetryRulesTypeStaticEnableHeaderFalse,
        RestAuthenticationGoogleOauthSecretRestRetryRulesTypeStaticEnableHeaderTrue,
    ],
)


class RestAuthenticationGoogleOauthSecretRestRetryRulesTypeNoneTypedDict(TypedDict):
    type: RetryTypeOptionsHealthCheckCollectorConfRetryRules
    r"""The algorithm to use when performing HTTP retries"""


class RestAuthenticationGoogleOauthSecretRestRetryRulesTypeNone(BaseModel):
    type: RetryTypeOptionsHealthCheckCollectorConfRetryRules
    r"""The algorithm to use when performing HTTP retries"""

    @field_serializer("type")
    def serialize_type(self, value):
        if isinstance(value, str):
            try:
                return models.RetryTypeOptionsHealthCheckCollectorConfRetryRules(value)
            except ValueError:
                return value
        return value


RestAuthenticationGoogleOauthSecretRetryRulesTypedDict = TypeAliasType(
    "RestAuthenticationGoogleOauthSecretRetryRulesTypedDict",
    Union[
        RestAuthenticationGoogleOauthSecretRestRetryRulesTypeNoneTypedDict,
        RestAuthenticationGoogleOauthSecretRestRetryRulesTypeStaticTypedDict,
        RestAuthenticationGoogleOauthSecretRestRetryRulesTypeBackoffTypedDict,
    ],
)


class UnknownRestAuthenticationGoogleOauthSecretRetryRules(BaseModel):
    r"""A RestAuthenticationGoogleOauthSecretRetryRules variant the SDK doesn't recognize. Preserves the raw payload."""

    type: Literal["UNKNOWN"] = "UNKNOWN"
    raw: Any
    is_unknown: Literal[True] = True

    model_config = ConfigDict(frozen=True)


_REST_AUTHENTICATION_GOOGLE_OAUTH_SECRET_RETRY_RULES_VARIANTS: dict[str, Any] = {
    "none": RestAuthenticationGoogleOauthSecretRestRetryRulesTypeNone,
    "static": RestAuthenticationGoogleOauthSecretRestRetryRulesTypeStatic,
    "backoff": RestAuthenticationGoogleOauthSecretRestRetryRulesTypeBackoff,
}


RestAuthenticationGoogleOauthSecretRetryRules = Annotated[
    Union[
        RestAuthenticationGoogleOauthSecretRestRetryRulesTypeNone,
        RestAuthenticationGoogleOauthSecretRestRetryRulesTypeStatic,
        RestAuthenticationGoogleOauthSecretRestRetryRulesTypeBackoff,
        UnknownRestAuthenticationGoogleOauthSecretRetryRules,
    ],
    BeforeValidator(
        partial(
            parse_open_union,
            disc_key="type",
            variants=_REST_AUTHENTICATION_GOOGLE_OAUTH_SECRET_RETRY_RULES_VARIANTS,
            unknown_cls=UnknownRestAuthenticationGoogleOauthSecretRetryRules,
            union_name="RestAuthenticationGoogleOauthSecretRetryRules",
        )
    ),
]


class RestAuthenticationGoogleOauthSecretStateTrackingTypedDict(TypedDict):
    enabled: NotRequired[bool]
    r"""Track collection progress between consecutive scheduled executions"""


class RestAuthenticationGoogleOauthSecretStateTracking(BaseModel):
    enabled: Optional[bool] = None
    r"""Track collection progress between consecutive scheduled executions"""

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(["enabled"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


class RestAuthenticationGoogleOauthSecretSchedulingTypedDict(TypedDict):
    state_tracking: NotRequired[
        RestAuthenticationGoogleOauthSecretStateTrackingTypedDict
    ]


class RestAuthenticationGoogleOauthSecretScheduling(BaseModel):
    state_tracking: Annotated[
        Optional[RestAuthenticationGoogleOauthSecretStateTracking],
        pydantic.Field(alias="stateTracking"),
    ] = None

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(["stateTracking"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


class RestAuthenticationGoogleOauthSecretTypedDict(TypedDict):
    authentication: RestAuthenticationGoogleOauthSecretAuthentication
    r"""Authentication method for Discover and Collect REST calls. You can specify API key–based authentication by adding the appropriate Collect headers."""
    scopes: List[str]
    r"""Scopes to use during authentication. See [Google's docs](https://developers.google.com/identity/protocols/oauth2/scopes) for more information."""
    text_secret: str
    r"""Select or create a text secret that contains the Google service account credentials value"""
    subject: str
    r"""Email address of a user account with Super Admin permissions to the resources the collector will retrieve"""
    collect_url: str
    r"""URL (constant or JavaScript expression) to use for the Collect operation"""
    collect_method: RestAuthenticationGoogleOauthSecretCollectMethod
    discovery: NotRequired[RestAuthenticationGoogleOauthSecretDiscoveryTypedDict]
    collect_request_headers: NotRequired[
        List[ItemsTypeRestCollectMethodGetCollectRequestParamsTypedDict]
    ]
    pagination: NotRequired[RestAuthenticationGoogleOauthSecretPaginationUnionTypedDict]
    timeout: NotRequired[float]
    r"""HTTP request inactivity timeout. Use 0 to disable."""
    use_round_robin_dns: NotRequired[bool]
    r"""Use round-robin DNS lookup. Suitable when DNS server returns multiple addresses in sort order."""
    disable_time_filter: NotRequired[bool]
    r"""Disable Collector event time filtering when a date range is specified"""
    decode_url: NotRequired[bool]
    r"""Decode the URL before sending requests (including pagination requests)"""
    reject_unauthorized: NotRequired[bool]
    r"""Reject certificates that cannot be verified against a valid CA (such as self-signed certificates)"""
    capture_headers: NotRequired[bool]
    r"""Enable to add response headers to the resHeaders field under the __collectible object"""
    stop_on_empty_results: NotRequired[bool]
    r"""Stop pagination when the Event Breaker produces no events"""
    safe_headers: NotRequired[List[str]]
    r"""List of headers that are safe to log in plain text"""
    retry_rules: NotRequired[RestAuthenticationGoogleOauthSecretRetryRulesTypedDict]
    scheduling: NotRequired[RestAuthenticationGoogleOauthSecretSchedulingTypedDict]


class RestAuthenticationGoogleOauthSecret(BaseModel):
    authentication: RestAuthenticationGoogleOauthSecretAuthentication
    r"""Authentication method for Discover and Collect REST calls. You can specify API key–based authentication by adding the appropriate Collect headers."""

    scopes: List[str]
    r"""Scopes to use during authentication. See [Google's docs](https://developers.google.com/identity/protocols/oauth2/scopes) for more information."""

    text_secret: Annotated[str, pydantic.Field(alias="textSecret")]
    r"""Select or create a text secret that contains the Google service account credentials value"""

    subject: str
    r"""Email address of a user account with Super Admin permissions to the resources the collector will retrieve"""

    collect_url: Annotated[str, pydantic.Field(alias="collectUrl")]
    r"""URL (constant or JavaScript expression) to use for the Collect operation"""

    collect_method: Annotated[
        RestAuthenticationGoogleOauthSecretCollectMethod,
        pydantic.Field(alias="collectMethod"),
    ]

    discovery: Optional[RestAuthenticationGoogleOauthSecretDiscovery] = None

    collect_request_headers: Annotated[
        Optional[List[ItemsTypeRestCollectMethodGetCollectRequestParams]],
        pydantic.Field(alias="collectRequestHeaders"),
    ] = None

    pagination: Optional[RestAuthenticationGoogleOauthSecretPaginationUnion] = None

    timeout: Optional[float] = None
    r"""HTTP request inactivity timeout. Use 0 to disable."""

    use_round_robin_dns: Annotated[
        Optional[bool], pydantic.Field(alias="useRoundRobinDns")
    ] = None
    r"""Use round-robin DNS lookup. Suitable when DNS server returns multiple addresses in sort order."""

    disable_time_filter: Annotated[
        Optional[bool], pydantic.Field(alias="disableTimeFilter")
    ] = None
    r"""Disable Collector event time filtering when a date range is specified"""

    decode_url: Annotated[Optional[bool], pydantic.Field(alias="decodeUrl")] = None
    r"""Decode the URL before sending requests (including pagination requests)"""

    reject_unauthorized: Annotated[
        Optional[bool], pydantic.Field(alias="rejectUnauthorized")
    ] = None
    r"""Reject certificates that cannot be verified against a valid CA (such as self-signed certificates)"""

    capture_headers: Annotated[
        Optional[bool], pydantic.Field(alias="captureHeaders")
    ] = None
    r"""Enable to add response headers to the resHeaders field under the __collectible object"""

    stop_on_empty_results: Annotated[
        Optional[bool], pydantic.Field(alias="stopOnEmptyResults")
    ] = None
    r"""Stop pagination when the Event Breaker produces no events"""

    safe_headers: Annotated[
        Optional[List[str]], pydantic.Field(alias="safeHeaders")
    ] = None
    r"""List of headers that are safe to log in plain text"""

    retry_rules: Annotated[
        Optional[RestAuthenticationGoogleOauthSecretRetryRules],
        pydantic.Field(alias="retryRules"),
    ] = None

    scheduling: Annotated[
        Optional[RestAuthenticationGoogleOauthSecretScheduling],
        pydantic.Field(alias="__scheduling"),
    ] = None

    @field_serializer("authentication")
    def serialize_authentication(self, value):
        if isinstance(value, str):
            try:
                return models.RestAuthenticationGoogleOauthSecretAuthentication(value)
            except ValueError:
                return value
        return value

    @field_serializer("collect_method")
    def serialize_collect_method(self, value):
        if isinstance(value, str):
            try:
                return models.RestAuthenticationGoogleOauthSecretCollectMethod(value)
            except ValueError:
                return value
        return value

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(
            [
                "discovery",
                "collectRequestHeaders",
                "pagination",
                "timeout",
                "useRoundRobinDns",
                "disableTimeFilter",
                "decodeUrl",
                "rejectUnauthorized",
                "captureHeaders",
                "stopOnEmptyResults",
                "safeHeaders",
                "retryRules",
                "__scheduling",
            ]
        )
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


class RestAuthenticationGoogleOauthAuthentication(
    str, Enum, metaclass=utils.OpenEnumMeta
):
    r"""Authentication method for Discover and Collect REST calls. You can specify API key–based authentication by adding the appropriate Collect headers."""

    NONE = "none"
    BASIC = "basic"
    BASIC_SECRET = "basicSecret"
    LOGIN = "login"
    LOGIN_SECRET = "loginSecret"
    OAUTH = "oauth"
    OAUTH_SECRET = "oauthSecret"
    GOOGLE_OAUTH = "google_oauth"
    GOOGLE_OAUTH_SECRET = "google_oauthSecret"
    HMAC = "hmac"


class RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeNoneDiscoverType(
    str, Enum, metaclass=utils.OpenEnumMeta
):
    r"""Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task."""

    HTTP = "http"
    JSON = "json"
    LIST = "list"
    NONE = "none"


class RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeNoneTypedDict(TypedDict):
    discover_type: (
        RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeNoneDiscoverType
    )
    r"""Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task."""


class RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeNone(BaseModel):
    discover_type: Annotated[
        RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeNoneDiscoverType,
        pydantic.Field(alias="discoverType"),
    ]
    r"""Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task."""

    @field_serializer("discover_type")
    def serialize_discover_type(self, value):
        if isinstance(value, str):
            try:
                return models.RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeNoneDiscoverType(
                    value
                )
            except ValueError:
                return value
        return value


class RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeListDiscoverType(
    str, Enum, metaclass=utils.OpenEnumMeta
):
    r"""Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task."""

    HTTP = "http"
    JSON = "json"
    LIST = "list"
    NONE = "none"


class RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeListTypedDict(TypedDict):
    discover_type: (
        RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeListDiscoverType
    )
    r"""Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task."""
    item_list: List[str]
    r"""Comma-separated list of items to return from the Discover task. Each item returned generates a Collect task and can be referenced using `${id}` in the Collect URL, headers, or parameters."""


class RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeList(BaseModel):
    discover_type: Annotated[
        RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeListDiscoverType,
        pydantic.Field(alias="discoverType"),
    ]
    r"""Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task."""

    item_list: Annotated[List[str], pydantic.Field(alias="itemList")]
    r"""Comma-separated list of items to return from the Discover task. Each item returned generates a Collect task and can be referenced using `${id}` in the Collect URL, headers, or parameters."""

    @field_serializer("discover_type")
    def serialize_discover_type(self, value):
        if isinstance(value, str):
            try:
                return models.RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeListDiscoverType(
                    value
                )
            except ValueError:
                return value
        return value


class RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeJSONDiscoverType(
    str, Enum, metaclass=utils.OpenEnumMeta
):
    r"""Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task."""

    HTTP = "http"
    JSON = "json"
    LIST = "list"
    NONE = "none"


class RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeJSONTypedDict(TypedDict):
    discover_type: (
        RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeJSONDiscoverType
    )
    r"""Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task."""
    manual_discover_result: str
    r"""Allows hard-coding the Discover result. Must be a JSON object or array. Works with Discover data field."""
    discover_data_field: NotRequired[str]
    r"""Within the response JSON, the name of the field to pull results from, typically a JSON array. Leave blank if the result itself is an array of values. Sample entry: items, json: { items: [{id: 'first'},{id: 'second'}] }"""


class RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeJSON(BaseModel):
    discover_type: Annotated[
        RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeJSONDiscoverType,
        pydantic.Field(alias="discoverType"),
    ]
    r"""Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task."""

    manual_discover_result: Annotated[str, pydantic.Field(alias="manualDiscoverResult")]
    r"""Allows hard-coding the Discover result. Must be a JSON object or array. Works with Discover data field."""

    discover_data_field: Annotated[
        Optional[str], pydantic.Field(alias="discoverDataField")
    ] = None
    r"""Within the response JSON, the name of the field to pull results from, typically a JSON array. Leave blank if the result itself is an array of values. Sample entry: items, json: { items: [{id: 'first'},{id: 'second'}] }"""

    @field_serializer("discover_type")
    def serialize_discover_type(self, value):
        if isinstance(value, str):
            try:
                return models.RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeJSONDiscoverType(
                    value
                )
            except ValueError:
                return value
        return value

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(["discoverDataField"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


class RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHTTPDiscoverMethodOtherDiscoverMethod(
    str, Enum, metaclass=utils.OpenEnumMeta
):
    # GET
    GET = "get"
    # POST
    POST = "post"
    # POST with Body
    POST_WITH_BODY = "post_with_body"
    # Other
    OTHER = "other"


class RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHTTPDiscoverMethodOtherDiscoverType(
    str, Enum, metaclass=utils.OpenEnumMeta
):
    r"""Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task."""

    HTTP = "http"
    JSON = "json"
    LIST = "list"
    NONE = "none"


class RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHTTPDiscoverMethodOtherPaginationTypedDict(
    TypedDict
):
    type: PaginationOptionsRestDiscoveryDiscoverTypeHTTPPagination


class RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHTTPDiscoverMethodOtherPagination(
    BaseModel
):
    type: PaginationOptionsRestDiscoveryDiscoverTypeHTTPPagination

    @field_serializer("type")
    def serialize_type(self, value):
        if isinstance(value, str):
            try:
                return models.PaginationOptionsRestDiscoveryDiscoverTypeHTTPPagination(
                    value
                )
            except ValueError:
                return value
        return value


class RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHTTPDiscoverMethodOtherTypedDict(
    TypedDict
):
    discover_method: RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHTTPDiscoverMethodOtherDiscoverMethod
    discover_verb: str
    r"""Custom HTTP method to use for the Discover operation"""
    discover_type: RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHTTPDiscoverMethodOtherDiscoverType
    r"""Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task."""
    discover_url: str
    r"""URL to use for the Discover operation. Can be a constant URL, or a JavaScript expression to derive the URL."""
    discover_body: NotRequired[str]
    r"""Template for body to send with the discover request"""
    discover_request_params: NotRequired[
        List[ItemsTypeRestCollectMethodGetCollectRequestParamsTypedDict]
    ]
    discover_request_headers: NotRequired[
        List[ItemsTypeRestCollectMethodGetCollectRequestParamsTypedDict]
    ]
    pagination: NotRequired[
        RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHTTPDiscoverMethodOtherPaginationTypedDict
    ]
    discover_data_field: NotRequired[str]
    r"""Path to field in the response object that contains discovery results (ex: level1.name). Leave blank if the result is an array."""
    enable_strict_discover_parsing: NotRequired[bool]
    r"""Explicitly set the discover response format. When disabled, best effort parsing is used."""
    enable_discover_code: NotRequired[bool]


class RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHTTPDiscoverMethodOther(
    BaseModel
):
    discover_method: Annotated[
        RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHTTPDiscoverMethodOtherDiscoverMethod,
        pydantic.Field(alias="discoverMethod"),
    ]

    discover_verb: Annotated[str, pydantic.Field(alias="discoverVerb")]
    r"""Custom HTTP method to use for the Discover operation"""

    discover_type: Annotated[
        RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHTTPDiscoverMethodOtherDiscoverType,
        pydantic.Field(alias="discoverType"),
    ]
    r"""Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task."""

    discover_url: Annotated[str, pydantic.Field(alias="discoverUrl")]
    r"""URL to use for the Discover operation. Can be a constant URL, or a JavaScript expression to derive the URL."""

    discover_body: Annotated[Optional[str], pydantic.Field(alias="discoverBody")] = None
    r"""Template for body to send with the discover request"""

    discover_request_params: Annotated[
        Optional[List[ItemsTypeRestCollectMethodGetCollectRequestParams]],
        pydantic.Field(alias="discoverRequestParams"),
    ] = None

    discover_request_headers: Annotated[
        Optional[List[ItemsTypeRestCollectMethodGetCollectRequestParams]],
        pydantic.Field(alias="discoverRequestHeaders"),
    ] = None

    pagination: Optional[
        RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHTTPDiscoverMethodOtherPagination
    ] = None

    discover_data_field: Annotated[
        Optional[str], pydantic.Field(alias="discoverDataField")
    ] = None
    r"""Path to field in the response object that contains discovery results (ex: level1.name). Leave blank if the result is an array."""

    enable_strict_discover_parsing: Annotated[
        Optional[bool], pydantic.Field(alias="enableStrictDiscoverParsing")
    ] = None
    r"""Explicitly set the discover response format. When disabled, best effort parsing is used."""

    enable_discover_code: Annotated[
        Optional[bool], pydantic.Field(alias="enableDiscoverCode")
    ] = None

    @field_serializer("discover_method")
    def serialize_discover_method(self, value):
        if isinstance(value, str):
            try:
                return models.RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHTTPDiscoverMethodOtherDiscoverMethod(
                    value
                )
            except ValueError:
                return value
        return value

    @field_serializer("discover_type")
    def serialize_discover_type(self, value):
        if isinstance(value, str):
            try:
                return models.RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHTTPDiscoverMethodOtherDiscoverType(
                    value
                )
            except ValueError:
                return value
        return value

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(
            [
                "discoverBody",
                "discoverRequestParams",
                "discoverRequestHeaders",
                "pagination",
                "discoverDataField",
                "enableStrictDiscoverParsing",
                "enableDiscoverCode",
            ]
        )
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


class RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHTTPDiscoverMethodPostWithBodyDiscoverMethod(
    str, Enum, metaclass=utils.OpenEnumMeta
):
    # GET
    GET = "get"
    # POST
    POST = "post"
    # POST with Body
    POST_WITH_BODY = "post_with_body"
    # Other
    OTHER = "other"


class RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHTTPDiscoverMethodPostWithBodyDiscoverType(
    str, Enum, metaclass=utils.OpenEnumMeta
):
    r"""Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task."""

    HTTP = "http"
    JSON = "json"
    LIST = "list"
    NONE = "none"


class RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHTTPDiscoverMethodPostWithBodyPaginationTypedDict(
    TypedDict
):
    type: PaginationOptionsRestDiscoveryDiscoverTypeHTTPPagination


class RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHTTPDiscoverMethodPostWithBodyPagination(
    BaseModel
):
    type: PaginationOptionsRestDiscoveryDiscoverTypeHTTPPagination

    @field_serializer("type")
    def serialize_type(self, value):
        if isinstance(value, str):
            try:
                return models.PaginationOptionsRestDiscoveryDiscoverTypeHTTPPagination(
                    value
                )
            except ValueError:
                return value
        return value


class RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHTTPDiscoverMethodPostWithBodyTypedDict(
    TypedDict
):
    discover_method: RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHTTPDiscoverMethodPostWithBodyDiscoverMethod
    discover_body: str
    r"""Template for POST body to send with the discover request. To reference global variables or functions, use template parameters: `{ myVar: ${C.vars.myVar}, secret: ${C.Secret('mySecret','text').value} }`"""
    discover_type: RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHTTPDiscoverMethodPostWithBodyDiscoverType
    r"""Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task."""
    discover_url: str
    r"""URL to use for the Discover operation. Can be a constant URL, or a JavaScript expression to derive the URL."""
    discover_request_headers: NotRequired[
        List[ItemsTypeRestCollectMethodGetCollectRequestParamsTypedDict]
    ]
    pagination: NotRequired[
        RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHTTPDiscoverMethodPostWithBodyPaginationTypedDict
    ]
    discover_data_field: NotRequired[str]
    r"""Path to field in the response object that contains discovery results (ex: level1.name). Leave blank if the result is an array."""
    enable_strict_discover_parsing: NotRequired[bool]
    r"""Explicitly set the discover response format. When disabled, best effort parsing is used."""
    enable_discover_code: NotRequired[bool]


class RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHTTPDiscoverMethodPostWithBody(
    BaseModel
):
    discover_method: Annotated[
        RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHTTPDiscoverMethodPostWithBodyDiscoverMethod,
        pydantic.Field(alias="discoverMethod"),
    ]

    discover_body: Annotated[str, pydantic.Field(alias="discoverBody")]
    r"""Template for POST body to send with the discover request. To reference global variables or functions, use template parameters: `{ myVar: ${C.vars.myVar}, secret: ${C.Secret('mySecret','text').value} }`"""

    discover_type: Annotated[
        RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHTTPDiscoverMethodPostWithBodyDiscoverType,
        pydantic.Field(alias="discoverType"),
    ]
    r"""Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task."""

    discover_url: Annotated[str, pydantic.Field(alias="discoverUrl")]
    r"""URL to use for the Discover operation. Can be a constant URL, or a JavaScript expression to derive the URL."""

    discover_request_headers: Annotated[
        Optional[List[ItemsTypeRestCollectMethodGetCollectRequestParams]],
        pydantic.Field(alias="discoverRequestHeaders"),
    ] = None

    pagination: Optional[
        RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHTTPDiscoverMethodPostWithBodyPagination
    ] = None

    discover_data_field: Annotated[
        Optional[str], pydantic.Field(alias="discoverDataField")
    ] = None
    r"""Path to field in the response object that contains discovery results (ex: level1.name). Leave blank if the result is an array."""

    enable_strict_discover_parsing: Annotated[
        Optional[bool], pydantic.Field(alias="enableStrictDiscoverParsing")
    ] = None
    r"""Explicitly set the discover response format. When disabled, best effort parsing is used."""

    enable_discover_code: Annotated[
        Optional[bool], pydantic.Field(alias="enableDiscoverCode")
    ] = None

    @field_serializer("discover_method")
    def serialize_discover_method(self, value):
        if isinstance(value, str):
            try:
                return models.RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHTTPDiscoverMethodPostWithBodyDiscoverMethod(
                    value
                )
            except ValueError:
                return value
        return value

    @field_serializer("discover_type")
    def serialize_discover_type(self, value):
        if isinstance(value, str):
            try:
                return models.RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHTTPDiscoverMethodPostWithBodyDiscoverType(
                    value
                )
            except ValueError:
                return value
        return value

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(
            [
                "discoverRequestHeaders",
                "pagination",
                "discoverDataField",
                "enableStrictDiscoverParsing",
                "enableDiscoverCode",
            ]
        )
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


class RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHTTPDiscoverMethodPostDiscoverMethod(
    str, Enum, metaclass=utils.OpenEnumMeta
):
    # GET
    GET = "get"
    # POST
    POST = "post"
    # POST with Body
    POST_WITH_BODY = "post_with_body"
    # Other
    OTHER = "other"


class RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHTTPDiscoverMethodPostDiscoverType(
    str, Enum, metaclass=utils.OpenEnumMeta
):
    r"""Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task."""

    HTTP = "http"
    JSON = "json"
    LIST = "list"
    NONE = "none"


class RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHTTPDiscoverMethodPostPaginationTypedDict(
    TypedDict
):
    type: PaginationOptionsRestDiscoveryDiscoverTypeHTTPPagination


class RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHTTPDiscoverMethodPostPagination(
    BaseModel
):
    type: PaginationOptionsRestDiscoveryDiscoverTypeHTTPPagination

    @field_serializer("type")
    def serialize_type(self, value):
        if isinstance(value, str):
            try:
                return models.PaginationOptionsRestDiscoveryDiscoverTypeHTTPPagination(
                    value
                )
            except ValueError:
                return value
        return value


class RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHTTPDiscoverMethodPostTypedDict(
    TypedDict
):
    discover_method: RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHTTPDiscoverMethodPostDiscoverMethod
    discover_type: RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHTTPDiscoverMethodPostDiscoverType
    r"""Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task."""
    discover_url: str
    r"""URL to use for the Discover operation. Can be a constant URL, or a JavaScript expression to derive the URL."""
    discover_request_params: NotRequired[
        List[ItemsTypeRestCollectMethodGetCollectRequestParamsTypedDict]
    ]
    discover_request_headers: NotRequired[
        List[ItemsTypeRestCollectMethodGetCollectRequestParamsTypedDict]
    ]
    pagination: NotRequired[
        RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHTTPDiscoverMethodPostPaginationTypedDict
    ]
    discover_data_field: NotRequired[str]
    r"""Path to field in the response object that contains discovery results (ex: level1.name). Leave blank if the result is an array."""
    enable_strict_discover_parsing: NotRequired[bool]
    r"""Explicitly set the discover response format. When disabled, best effort parsing is used."""
    enable_discover_code: NotRequired[bool]


class RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHTTPDiscoverMethodPost(
    BaseModel
):
    discover_method: Annotated[
        RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHTTPDiscoverMethodPostDiscoverMethod,
        pydantic.Field(alias="discoverMethod"),
    ]

    discover_type: Annotated[
        RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHTTPDiscoverMethodPostDiscoverType,
        pydantic.Field(alias="discoverType"),
    ]
    r"""Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task."""

    discover_url: Annotated[str, pydantic.Field(alias="discoverUrl")]
    r"""URL to use for the Discover operation. Can be a constant URL, or a JavaScript expression to derive the URL."""

    discover_request_params: Annotated[
        Optional[List[ItemsTypeRestCollectMethodGetCollectRequestParams]],
        pydantic.Field(alias="discoverRequestParams"),
    ] = None

    discover_request_headers: Annotated[
        Optional[List[ItemsTypeRestCollectMethodGetCollectRequestParams]],
        pydantic.Field(alias="discoverRequestHeaders"),
    ] = None

    pagination: Optional[
        RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHTTPDiscoverMethodPostPagination
    ] = None

    discover_data_field: Annotated[
        Optional[str], pydantic.Field(alias="discoverDataField")
    ] = None
    r"""Path to field in the response object that contains discovery results (ex: level1.name). Leave blank if the result is an array."""

    enable_strict_discover_parsing: Annotated[
        Optional[bool], pydantic.Field(alias="enableStrictDiscoverParsing")
    ] = None
    r"""Explicitly set the discover response format. When disabled, best effort parsing is used."""

    enable_discover_code: Annotated[
        Optional[bool], pydantic.Field(alias="enableDiscoverCode")
    ] = None

    @field_serializer("discover_method")
    def serialize_discover_method(self, value):
        if isinstance(value, str):
            try:
                return models.RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHTTPDiscoverMethodPostDiscoverMethod(
                    value
                )
            except ValueError:
                return value
        return value

    @field_serializer("discover_type")
    def serialize_discover_type(self, value):
        if isinstance(value, str):
            try:
                return models.RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHTTPDiscoverMethodPostDiscoverType(
                    value
                )
            except ValueError:
                return value
        return value

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(
            [
                "discoverRequestParams",
                "discoverRequestHeaders",
                "pagination",
                "discoverDataField",
                "enableStrictDiscoverParsing",
                "enableDiscoverCode",
            ]
        )
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


class RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHTTPDiscoverMethodGetDiscoverMethod(
    str, Enum, metaclass=utils.OpenEnumMeta
):
    # GET
    GET = "get"
    # POST
    POST = "post"
    # POST with Body
    POST_WITH_BODY = "post_with_body"
    # Other
    OTHER = "other"


class RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHTTPDiscoverMethodGetDiscoverType(
    str, Enum, metaclass=utils.OpenEnumMeta
):
    r"""Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task."""

    HTTP = "http"
    JSON = "json"
    LIST = "list"
    NONE = "none"


class RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHTTPDiscoverMethodGetPaginationTypedDict(
    TypedDict
):
    type: PaginationOptionsRestDiscoveryDiscoverTypeHTTPPagination


class RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHTTPDiscoverMethodGetPagination(
    BaseModel
):
    type: PaginationOptionsRestDiscoveryDiscoverTypeHTTPPagination

    @field_serializer("type")
    def serialize_type(self, value):
        if isinstance(value, str):
            try:
                return models.PaginationOptionsRestDiscoveryDiscoverTypeHTTPPagination(
                    value
                )
            except ValueError:
                return value
        return value


class RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHTTPDiscoverMethodGetTypedDict(
    TypedDict
):
    discover_method: RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHTTPDiscoverMethodGetDiscoverMethod
    discover_type: RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHTTPDiscoverMethodGetDiscoverType
    r"""Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task."""
    discover_url: str
    r"""URL to use for the Discover operation. Can be a constant URL, or a JavaScript expression to derive the URL."""
    discover_request_params: NotRequired[
        List[ItemsTypeRestCollectMethodGetCollectRequestParamsTypedDict]
    ]
    discover_request_headers: NotRequired[
        List[ItemsTypeRestCollectMethodGetCollectRequestParamsTypedDict]
    ]
    pagination: NotRequired[
        RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHTTPDiscoverMethodGetPaginationTypedDict
    ]
    discover_data_field: NotRequired[str]
    r"""Path to field in the response object that contains discovery results (ex: level1.name). Leave blank if the result is an array."""
    enable_strict_discover_parsing: NotRequired[bool]
    r"""Explicitly set the discover response format. When disabled, best effort parsing is used."""
    enable_discover_code: NotRequired[bool]


class RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHTTPDiscoverMethodGet(
    BaseModel
):
    discover_method: Annotated[
        RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHTTPDiscoverMethodGetDiscoverMethod,
        pydantic.Field(alias="discoverMethod"),
    ]

    discover_type: Annotated[
        RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHTTPDiscoverMethodGetDiscoverType,
        pydantic.Field(alias="discoverType"),
    ]
    r"""Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task."""

    discover_url: Annotated[str, pydantic.Field(alias="discoverUrl")]
    r"""URL to use for the Discover operation. Can be a constant URL, or a JavaScript expression to derive the URL."""

    discover_request_params: Annotated[
        Optional[List[ItemsTypeRestCollectMethodGetCollectRequestParams]],
        pydantic.Field(alias="discoverRequestParams"),
    ] = None

    discover_request_headers: Annotated[
        Optional[List[ItemsTypeRestCollectMethodGetCollectRequestParams]],
        pydantic.Field(alias="discoverRequestHeaders"),
    ] = None

    pagination: Optional[
        RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHTTPDiscoverMethodGetPagination
    ] = None

    discover_data_field: Annotated[
        Optional[str], pydantic.Field(alias="discoverDataField")
    ] = None
    r"""Path to field in the response object that contains discovery results (ex: level1.name). Leave blank if the result is an array."""

    enable_strict_discover_parsing: Annotated[
        Optional[bool], pydantic.Field(alias="enableStrictDiscoverParsing")
    ] = None
    r"""Explicitly set the discover response format. When disabled, best effort parsing is used."""

    enable_discover_code: Annotated[
        Optional[bool], pydantic.Field(alias="enableDiscoverCode")
    ] = None

    @field_serializer("discover_method")
    def serialize_discover_method(self, value):
        if isinstance(value, str):
            try:
                return models.RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHTTPDiscoverMethodGetDiscoverMethod(
                    value
                )
            except ValueError:
                return value
        return value

    @field_serializer("discover_type")
    def serialize_discover_type(self, value):
        if isinstance(value, str):
            try:
                return models.RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHTTPDiscoverMethodGetDiscoverType(
                    value
                )
            except ValueError:
                return value
        return value

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(
            [
                "discoverRequestParams",
                "discoverRequestHeaders",
                "pagination",
                "discoverDataField",
                "enableStrictDiscoverParsing",
                "enableDiscoverCode",
            ]
        )
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


class RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHTTPEnableDiscoverCodeTrueDiscoverType(
    str, Enum, metaclass=utils.OpenEnumMeta
):
    r"""Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task."""

    HTTP = "http"
    JSON = "json"
    LIST = "list"
    NONE = "none"


class RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHTTPEnableDiscoverCodeTrueDiscoverMethod(
    str, Enum, metaclass=utils.OpenEnumMeta
):
    # GET
    GET = "get"
    # POST
    POST = "post"
    # POST with Body
    POST_WITH_BODY = "post_with_body"
    # Other
    OTHER = "other"


class RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHTTPEnableDiscoverCodeTruePaginationTypedDict(
    TypedDict
):
    type: PaginationOptionsRestDiscoveryDiscoverTypeHTTPPagination


class RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHTTPEnableDiscoverCodeTruePagination(
    BaseModel
):
    type: PaginationOptionsRestDiscoveryDiscoverTypeHTTPPagination

    @field_serializer("type")
    def serialize_type(self, value):
        if isinstance(value, str):
            try:
                return models.PaginationOptionsRestDiscoveryDiscoverTypeHTTPPagination(
                    value
                )
            except ValueError:
                return value
        return value


class RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHTTPEnableDiscoverCodeTrueTypedDict(
    TypedDict
):
    discover_type: RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHTTPEnableDiscoverCodeTrueDiscoverType
    r"""Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task."""
    discover_url: str
    r"""URL to use for the Discover operation. Can be a constant URL, or a JavaScript expression to derive the URL."""
    discover_method: RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHTTPEnableDiscoverCodeTrueDiscoverMethod
    enable_discover_code: NotRequired[bool]
    format_result_code: NotRequired[str]
    r"""Custom JavaScript code to format the discover result through the __e variable which is a JSON object or array containing the original discover results. The object or array passed should be manipulated to contain the desired discover results, i.e.: __e['myResult'] = [{lat: -1.1234, long: 2.345, zip: 11111},{lat: -1.235, long 2.346, zip: 22222}] or ['11111','22222']. Caution: This function is evaluated in an unprotected context, allowing you to execute almost any JavaScript code."""
    discover_request_headers: NotRequired[
        List[ItemsTypeRestCollectMethodGetCollectRequestParamsTypedDict]
    ]
    pagination: NotRequired[
        RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHTTPEnableDiscoverCodeTruePaginationTypedDict
    ]
    discover_data_field: NotRequired[str]
    r"""Path to field in the response object that contains discovery results (ex: level1.name). Leave blank if the result is an array."""
    enable_strict_discover_parsing: NotRequired[bool]
    r"""Explicitly set the discover response format. When disabled, best effort parsing is used."""


class RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHTTPEnableDiscoverCodeTrue(
    BaseModel
):
    discover_type: Annotated[
        RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHTTPEnableDiscoverCodeTrueDiscoverType,
        pydantic.Field(alias="discoverType"),
    ]
    r"""Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task."""

    discover_url: Annotated[str, pydantic.Field(alias="discoverUrl")]
    r"""URL to use for the Discover operation. Can be a constant URL, or a JavaScript expression to derive the URL."""

    discover_method: Annotated[
        RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHTTPEnableDiscoverCodeTrueDiscoverMethod,
        pydantic.Field(alias="discoverMethod"),
    ]

    enable_discover_code: Annotated[
        Optional[bool], pydantic.Field(alias="enableDiscoverCode")
    ] = None

    format_result_code: Annotated[
        Optional[str], pydantic.Field(alias="formatResultCode")
    ] = None
    r"""Custom JavaScript code to format the discover result through the __e variable which is a JSON object or array containing the original discover results. The object or array passed should be manipulated to contain the desired discover results, i.e.: __e['myResult'] = [{lat: -1.1234, long: 2.345, zip: 11111},{lat: -1.235, long 2.346, zip: 22222}] or ['11111','22222']. Caution: This function is evaluated in an unprotected context, allowing you to execute almost any JavaScript code."""

    discover_request_headers: Annotated[
        Optional[List[ItemsTypeRestCollectMethodGetCollectRequestParams]],
        pydantic.Field(alias="discoverRequestHeaders"),
    ] = None

    pagination: Optional[
        RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHTTPEnableDiscoverCodeTruePagination
    ] = None

    discover_data_field: Annotated[
        Optional[str], pydantic.Field(alias="discoverDataField")
    ] = None
    r"""Path to field in the response object that contains discovery results (ex: level1.name). Leave blank if the result is an array."""

    enable_strict_discover_parsing: Annotated[
        Optional[bool], pydantic.Field(alias="enableStrictDiscoverParsing")
    ] = None
    r"""Explicitly set the discover response format. When disabled, best effort parsing is used."""

    @field_serializer("discover_type")
    def serialize_discover_type(self, value):
        if isinstance(value, str):
            try:
                return models.RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHTTPEnableDiscoverCodeTrueDiscoverType(
                    value
                )
            except ValueError:
                return value
        return value

    @field_serializer("discover_method")
    def serialize_discover_method(self, value):
        if isinstance(value, str):
            try:
                return models.RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHTTPEnableDiscoverCodeTrueDiscoverMethod(
                    value
                )
            except ValueError:
                return value
        return value

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(
            [
                "enableDiscoverCode",
                "formatResultCode",
                "discoverRequestHeaders",
                "pagination",
                "discoverDataField",
                "enableStrictDiscoverParsing",
            ]
        )
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


class RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHTTPEnableDiscoverCodeFalseDiscoverType(
    str, Enum, metaclass=utils.OpenEnumMeta
):
    r"""Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task."""

    HTTP = "http"
    JSON = "json"
    LIST = "list"
    NONE = "none"


class RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHTTPEnableDiscoverCodeFalseDiscoverMethod(
    str, Enum, metaclass=utils.OpenEnumMeta
):
    # GET
    GET = "get"
    # POST
    POST = "post"
    # POST with Body
    POST_WITH_BODY = "post_with_body"
    # Other
    OTHER = "other"


class RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHTTPEnableDiscoverCodeFalsePaginationTypedDict(
    TypedDict
):
    type: PaginationOptionsRestDiscoveryDiscoverTypeHTTPPagination


class RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHTTPEnableDiscoverCodeFalsePagination(
    BaseModel
):
    type: PaginationOptionsRestDiscoveryDiscoverTypeHTTPPagination

    @field_serializer("type")
    def serialize_type(self, value):
        if isinstance(value, str):
            try:
                return models.PaginationOptionsRestDiscoveryDiscoverTypeHTTPPagination(
                    value
                )
            except ValueError:
                return value
        return value


try:
    RestAuthenticationHmacRestDiscoveryDiscoverTypeNone.model_rebuild()
except NameError:
    pass
try:
    RestAuthenticationHmacRestDiscoveryDiscoverTypeList.model_rebuild()
except NameError:
    pass
try:
    RestAuthenticationHmacRestDiscoveryDiscoverTypeJSON.model_rebuild()
except NameError:
    pass
try:
    RestAuthenticationHmacRestDiscoveryDiscoverTypeHTTPDiscoverMethodOther.model_rebuild()
except NameError:
    pass
try:
    RestAuthenticationHmacRestDiscoveryDiscoverTypeHTTPDiscoverMethodPostWithBody.model_rebuild()
except NameError:
    pass
try:
    RestAuthenticationHmacRestDiscoveryDiscoverTypeHTTPDiscoverMethodPost.model_rebuild()
except NameError:
    pass
try:
    RestAuthenticationHmacRestDiscoveryDiscoverTypeHTTPDiscoverMethodGet.model_rebuild()
except NameError:
    pass
try:
    RestAuthenticationHmacRestDiscoveryDiscoverTypeHTTPEnableDiscoverCodeTrue.model_rebuild()
except NameError:
    pass
try:
    RestAuthenticationHmacRestDiscoveryDiscoverTypeHTTPEnableDiscoverCodeFalse.model_rebuild()
except NameError:
    pass
try:
    RestAuthenticationHmacRestDiscoveryDiscoverTypeHTTPEnableStrictDiscoverParsingTrue.model_rebuild()
except NameError:
    pass
try:
    RestAuthenticationHmacRestDiscoveryDiscoverTypeHTTPEnableStrictDiscoverParsingFalse.model_rebuild()
except NameError:
    pass
try:
    RestAuthenticationHmacRestPaginationTypeRequestPage.model_rebuild()
except NameError:
    pass
try:
    RestAuthenticationHmacRestPaginationTypeRequestOffset.model_rebuild()
except NameError:
    pass
try:
    RestAuthenticationHmacRestPaginationTypeResponseHeaderLink.model_rebuild()
except NameError:
    pass
try:
    RestAuthenticationHmacRestPaginationTypeResponseHeader.model_rebuild()
except NameError:
    pass
try:
    RestAuthenticationHmacRestPaginationTypeResponseBody.model_rebuild()
except NameError:
    pass
try:
    RestAuthenticationHmacRestRetryRulesTypeBackoffEnableHeaderTrue.model_rebuild()
except NameError:
    pass
try:
    RestAuthenticationHmacRestRetryRulesTypeBackoffEnableHeaderFalse.model_rebuild()
except NameError:
    pass
try:
    RestAuthenticationHmacRestRetryRulesTypeStaticEnableHeaderTrue.model_rebuild()
except NameError:
    pass
try:
    RestAuthenticationHmacRestRetryRulesTypeStaticEnableHeaderFalse.model_rebuild()
except NameError:
    pass
try:
    RestAuthenticationHmacScheduling.model_rebuild()
except NameError:
    pass
try:
    RestAuthenticationHmac.model_rebuild()
except NameError:
    pass
try:
    RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeNone.model_rebuild()
except NameError:
    pass
try:
    RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeList.model_rebuild()
except NameError:
    pass
try:
    RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeJSON.model_rebuild()
except NameError:
    pass
try:
    RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHTTPDiscoverMethodOther.model_rebuild()
except NameError:
    pass
try:
    RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHTTPDiscoverMethodPostWithBody.model_rebuild()
except NameError:
    pass
try:
    RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHTTPDiscoverMethodPost.model_rebuild()
except NameError:
    pass
try:
    RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHTTPDiscoverMethodGet.model_rebuild()
except NameError:
    pass
try:
    RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHTTPEnableDiscoverCodeTrue.model_rebuild()
except NameError:
    pass
try:
    RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHTTPEnableDiscoverCodeFalse.model_rebuild()
except NameError:
    pass
try:
    RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHTTPEnableStrictDiscoverParsingTrue.model_rebuild()
except NameError:
    pass
try:
    RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHTTPEnableStrictDiscoverParsingFalse.model_rebuild()
except NameError:
    pass
try:
    RestAuthenticationGoogleOauthSecretRestPaginationTypeRequestPage.model_rebuild()
except NameError:
    pass
try:
    RestAuthenticationGoogleOauthSecretRestPaginationTypeRequestOffset.model_rebuild()
except NameError:
    pass
try:
    RestAuthenticationGoogleOauthSecretRestPaginationTypeResponseHeaderLink.model_rebuild()
except NameError:
    pass
try:
    RestAuthenticationGoogleOauthSecretRestPaginationTypeResponseHeader.model_rebuild()
except NameError:
    pass
try:
    RestAuthenticationGoogleOauthSecretRestPaginationTypeResponseBody.model_rebuild()
except NameError:
    pass
try:
    RestAuthenticationGoogleOauthSecretRestRetryRulesTypeBackoffEnableHeaderTrue.model_rebuild()
except NameError:
    pass
try:
    RestAuthenticationGoogleOauthSecretRestRetryRulesTypeBackoffEnableHeaderFalse.model_rebuild()
except NameError:
    pass
try:
    RestAuthenticationGoogleOauthSecretRestRetryRulesTypeStaticEnableHeaderTrue.model_rebuild()
except NameError:
    pass
try:
    RestAuthenticationGoogleOauthSecretRestRetryRulesTypeStaticEnableHeaderFalse.model_rebuild()
except NameError:
    pass
try:
    RestAuthenticationGoogleOauthSecretScheduling.model_rebuild()
except NameError:
    pass
try:
    RestAuthenticationGoogleOauthSecret.model_rebuild()
except NameError:
    pass
try:
    RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeNone.model_rebuild()
except NameError:
    pass
try:
    RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeList.model_rebuild()
except NameError:
    pass
try:
    RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeJSON.model_rebuild()
except NameError:
    pass
try:
    RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHTTPDiscoverMethodOther.model_rebuild()
except NameError:
    pass
try:
    RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHTTPDiscoverMethodPostWithBody.model_rebuild()
except NameError:
    pass
try:
    RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHTTPDiscoverMethodPost.model_rebuild()
except NameError:
    pass
try:
    RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHTTPDiscoverMethodGet.model_rebuild()
except NameError:
    pass
try:
    RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHTTPEnableDiscoverCodeTrue.model_rebuild()
except NameError:
    pass
