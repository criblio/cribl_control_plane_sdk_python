"""Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT."""

from __future__ import annotations
from .itemstyperestcollectmethodgetcollectrequestparams import (
    ItemsTypeRestCollectMethodGetCollectRequestParams,
    ItemsTypeRestCollectMethodGetCollectRequestParamsTypedDict,
)
from .paginationoptionsrestdiscoverydiscovertypehttppagination import (
    PaginationOptionsRestDiscoveryDiscoverTypeHTTPPagination,
)
from .restauthenticationbasicsecret_restdiscoverydiscovertypehttpdiscovermethodget_discover_method import (
    RestAuthenticationBasicSecretAuthentication,
    RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHTTPDiscoverMethodGetDiscoverMethod,
    RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHTTPDiscoverMethodOther,
    RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHTTPDiscoverMethodOtherTypedDict,
    RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHTTPDiscoverMethodPost,
    RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHTTPDiscoverMethodPostTypedDict,
    RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHTTPDiscoverMethodPostWithBody,
    RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHTTPDiscoverMethodPostWithBodyTypedDict,
    RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeJSON,
    RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeJSONTypedDict,
    RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeList,
    RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeListTypedDict,
    RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeNone,
    RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeNoneTypedDict,
)
from .retrytypeoptionshealthcheckcollectorconfretryrules import (
    RetryTypeOptionsHealthCheckCollectorConfRetryRules,
)
from cribl_control_plane import models, utils
from cribl_control_plane.types import BaseModel, UNSET_SENTINEL
from cribl_control_plane.utils.unions import parse_open_union
from enum import Enum
from functools import partial
import pydantic
from pydantic import ConfigDict, field_serializer, model_serializer
from pydantic.functional_validators import BeforeValidator
from typing import Any, List, Literal, Optional, Union
from typing_extensions import Annotated, NotRequired, TypeAliasType, TypedDict


class RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHTTPDiscoverMethodGetDiscoverType(
    str, Enum, metaclass=utils.OpenEnumMeta
):
    r"""Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task."""

    HTTP = "http"
    JSON = "json"
    LIST = "list"
    NONE = "none"


class RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHTTPDiscoverMethodGetPaginationTypedDict(
    TypedDict
):
    type: PaginationOptionsRestDiscoveryDiscoverTypeHTTPPagination


class RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHTTPDiscoverMethodGetPagination(
    BaseModel
):
    type: PaginationOptionsRestDiscoveryDiscoverTypeHTTPPagination

    @field_serializer("type")
    def serialize_type(self, value):
        if isinstance(value, str):
            try:
                return models.PaginationOptionsRestDiscoveryDiscoverTypeHTTPPagination(
                    value
                )
            except ValueError:
                return value
        return value


class RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHTTPDiscoverMethodGetTypedDict(
    TypedDict
):
    discover_method: RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHTTPDiscoverMethodGetDiscoverMethod
    discover_type: RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHTTPDiscoverMethodGetDiscoverType
    r"""Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task."""
    discover_url: str
    r"""URL to use for the Discover operation. Can be a constant URL, or a JavaScript expression to derive the URL."""
    discover_request_params: NotRequired[Any]
    discover_verb: NotRequired[Any]
    discover_body: NotRequired[Any]
    discover_request_headers: NotRequired[
        List[ItemsTypeRestCollectMethodGetCollectRequestParamsTypedDict]
    ]
    pagination: NotRequired[
        RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHTTPDiscoverMethodGetPaginationTypedDict
    ]
    discover_data_field: NotRequired[str]
    r"""Path to field in the response object that contains discovery results (ex: level1.name). Leave blank if the result is an array."""
    enable_strict_discover_parsing: NotRequired[bool]
    r"""Explicitly set the discover response format. When disabled, best effort parsing is used."""
    discover_response_format: NotRequired[Any]
    enable_discover_code: NotRequired[bool]


class RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHTTPDiscoverMethodGet(
    BaseModel
):
    discover_method: Annotated[
        RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHTTPDiscoverMethodGetDiscoverMethod,
        pydantic.Field(alias="discoverMethod"),
    ]

    discover_type: Annotated[
        RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHTTPDiscoverMethodGetDiscoverType,
        pydantic.Field(alias="discoverType"),
    ]
    r"""Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task."""

    discover_url: Annotated[str, pydantic.Field(alias="discoverUrl")]
    r"""URL to use for the Discover operation. Can be a constant URL, or a JavaScript expression to derive the URL."""

    discover_request_params: Annotated[
        Optional[Any], pydantic.Field(alias="discoverRequestParams")
    ] = None

    discover_verb: Annotated[Optional[Any], pydantic.Field(alias="discoverVerb")] = None

    discover_body: Annotated[Optional[Any], pydantic.Field(alias="discoverBody")] = None

    discover_request_headers: Annotated[
        Optional[List[ItemsTypeRestCollectMethodGetCollectRequestParams]],
        pydantic.Field(alias="discoverRequestHeaders"),
    ] = None

    pagination: Optional[
        RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHTTPDiscoverMethodGetPagination
    ] = None

    discover_data_field: Annotated[
        Optional[str], pydantic.Field(alias="discoverDataField")
    ] = None
    r"""Path to field in the response object that contains discovery results (ex: level1.name). Leave blank if the result is an array."""

    enable_strict_discover_parsing: Annotated[
        Optional[bool], pydantic.Field(alias="enableStrictDiscoverParsing")
    ] = None
    r"""Explicitly set the discover response format. When disabled, best effort parsing is used."""

    discover_response_format: Annotated[
        Optional[Any], pydantic.Field(alias="discoverResponseFormat")
    ] = None

    enable_discover_code: Annotated[
        Optional[bool], pydantic.Field(alias="enableDiscoverCode")
    ] = None

    @field_serializer("discover_method")
    def serialize_discover_method(self, value):
        if isinstance(value, str):
            try:
                return models.RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHTTPDiscoverMethodGetDiscoverMethod(
                    value
                )
            except ValueError:
                return value
        return value

    @field_serializer("discover_type")
    def serialize_discover_type(self, value):
        if isinstance(value, str):
            try:
                return models.RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHTTPDiscoverMethodGetDiscoverType(
                    value
                )
            except ValueError:
                return value
        return value

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(
            [
                "discoverRequestParams",
                "discoverVerb",
                "discoverBody",
                "discoverRequestHeaders",
                "pagination",
                "discoverDataField",
                "enableStrictDiscoverParsing",
                "discoverResponseFormat",
                "enableDiscoverCode",
            ]
        )
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHTTPTypedDict = TypeAliasType(
    "RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHTTPTypedDict",
    Union[
        RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHTTPDiscoverMethodGetTypedDict,
        RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHTTPDiscoverMethodPostTypedDict,
        RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHTTPDiscoverMethodPostWithBodyTypedDict,
        RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHTTPDiscoverMethodOtherTypedDict,
    ],
)


class UnknownRestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHTTP(BaseModel):
    r"""A RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHTTP variant the SDK doesn't recognize. Preserves the raw payload."""

    discover_method: Literal["UNKNOWN"] = "UNKNOWN"
    raw: Any
    is_unknown: Literal[True] = True

    model_config = ConfigDict(frozen=True)


_REST_AUTHENTICATION_BASIC_SECRET_REST_DISCOVERY_DISCOVER_TYPE_HTTP_VARIANTS: dict[
    str, Any
] = {
    "get": RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHTTPDiscoverMethodGet,
    "post": RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHTTPDiscoverMethodPost,
    "post_with_body": RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHTTPDiscoverMethodPostWithBody,
    "other": RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHTTPDiscoverMethodOther,
}


RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHTTP = Annotated[
    Union[
        RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHTTPDiscoverMethodGet,
        RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHTTPDiscoverMethodPost,
        RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHTTPDiscoverMethodPostWithBody,
        RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHTTPDiscoverMethodOther,
        UnknownRestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHTTP,
    ],
    BeforeValidator(
        partial(
            parse_open_union,
            disc_key="discoverMethod",
            variants=_REST_AUTHENTICATION_BASIC_SECRET_REST_DISCOVERY_DISCOVER_TYPE_HTTP_VARIANTS,
            unknown_cls=UnknownRestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHTTP,
            union_name="RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHTTP",
        )
    ),
]


RestAuthenticationBasicSecretDiscoveryTypedDict = TypeAliasType(
    "RestAuthenticationBasicSecretDiscoveryTypedDict",
    Union[
        RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeNoneTypedDict,
        RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeListTypedDict,
        RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeJSONTypedDict,
        RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHTTPTypedDict,
    ],
)


class UnknownRestAuthenticationBasicSecretDiscovery(BaseModel):
    r"""A RestAuthenticationBasicSecretDiscovery variant the SDK doesn't recognize. Preserves the raw payload."""

    discover_type: Literal["UNKNOWN"] = "UNKNOWN"
    raw: Any
    is_unknown: Literal[True] = True

    model_config = ConfigDict(frozen=True)


_REST_AUTHENTICATION_BASIC_SECRET_DISCOVERY_VARIANTS: dict[str, Any] = {
    "http": RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHTTP,
    "json": RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeJSON,
    "list": RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeList,
    "none": RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeNone,
}


RestAuthenticationBasicSecretDiscovery = Annotated[
    Union[
        RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHTTP,
        RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeJSON,
        RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeList,
        RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeNone,
        UnknownRestAuthenticationBasicSecretDiscovery,
    ],
    BeforeValidator(
        partial(
            parse_open_union,
            disc_key="discoverType",
            variants=_REST_AUTHENTICATION_BASIC_SECRET_DISCOVERY_VARIANTS,
            unknown_cls=UnknownRestAuthenticationBasicSecretDiscovery,
            union_name="RestAuthenticationBasicSecretDiscovery",
        )
    ),
]


class RestAuthenticationBasicSecretCollectMethod(
    str, Enum, metaclass=utils.OpenEnumMeta
):
    # GET
    GET = "get"
    # POST
    POST = "post"
    # POST with Body
    POST_WITH_BODY = "post_with_body"
    # Other
    OTHER = "other"


class RestAuthenticationBasicSecretRestPaginationTypeRequestPageTypedDict(TypedDict):
    type: PaginationOptionsRestDiscoveryDiscoverTypeHTTPPagination
    page_field: str
    r"""Query string parameter that sets the page index to be returned. Example: /api/v1/query?term=cribl&page_size=100&page_number=0"""
    size_field: str
    r"""Query string parameter that sets the number of records retrieved per request. Example: /api/v1/query?term=cribl&page_size=100&page_number=0"""
    size: float
    r"""Maximum number of records to collect per page"""
    max_pages: float
    r"""Maximum number of pages to retrieve per collection task. Defaults to 50 pages. Set to 0 to retrieve all pages."""
    zero_indexed: bool
    r"""Enable to indicate that the first page in the requested data is at index 0. Disabled by default, which indicates index 1."""
    page: NotRequired[float]
    r"""Page number from which to start request. Defaults to undefined, which will start collection from the first page."""
    total_page_field: NotRequired[str]
    r"""Name of the attribute in the response that contains the total number of pages for the query"""
    total_record_field: NotRequired[str]
    r"""Name of the attribute in the response that contains the total number of records for the query"""


class RestAuthenticationBasicSecretRestPaginationTypeRequestPage(BaseModel):
    type: PaginationOptionsRestDiscoveryDiscoverTypeHTTPPagination

    page_field: Annotated[str, pydantic.Field(alias="pageField")]
    r"""Query string parameter that sets the page index to be returned. Example: /api/v1/query?term=cribl&page_size=100&page_number=0"""

    size_field: Annotated[str, pydantic.Field(alias="sizeField")]
    r"""Query string parameter that sets the number of records retrieved per request. Example: /api/v1/query?term=cribl&page_size=100&page_number=0"""

    size: float
    r"""Maximum number of records to collect per page"""

    max_pages: Annotated[float, pydantic.Field(alias="maxPages")]
    r"""Maximum number of pages to retrieve per collection task. Defaults to 50 pages. Set to 0 to retrieve all pages."""

    zero_indexed: Annotated[bool, pydantic.Field(alias="zeroIndexed")]
    r"""Enable to indicate that the first page in the requested data is at index 0. Disabled by default, which indicates index 1."""

    page: Optional[float] = None
    r"""Page number from which to start request. Defaults to undefined, which will start collection from the first page."""

    total_page_field: Annotated[
        Optional[str], pydantic.Field(alias="totalPageField")
    ] = None
    r"""Name of the attribute in the response that contains the total number of pages for the query"""

    total_record_field: Annotated[
        Optional[str], pydantic.Field(alias="totalRecordField")
    ] = None
    r"""Name of the attribute in the response that contains the total number of records for the query"""

    @field_serializer("type")
    def serialize_type(self, value):
        if isinstance(value, str):
            try:
                return models.PaginationOptionsRestDiscoveryDiscoverTypeHTTPPagination(
                    value
                )
            except ValueError:
                return value
        return value

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(["page", "totalPageField", "totalRecordField"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


class RestAuthenticationBasicSecretRestPaginationTypeRequestOffsetTypedDict(TypedDict):
    type: PaginationOptionsRestDiscoveryDiscoverTypeHTTPPagination
    offset_field: str
    r"""Query string parameter that sets the index from which to begin returning records. Example: /api/v1/query?term=cribl&limit=100&offset=0"""
    limit_field: str
    r"""Query string parameter that sets the number of records retrieved per request. Example: /api/v1/query?term=cribl&limit=100&offset=0"""
    limit: float
    r"""Maximum number of records to collect per request"""
    max_pages: float
    r"""Maximum number of pages to retrieve per collection task. Defaults to 50 pages. Set to 0 to retrieve all pages."""
    zero_indexed: bool
    r"""Enable to indicate that the first page in the requested data is at index 0. Disabled by default, which indicates index 1."""
    offset: NotRequired[float]
    r"""Offset index from which to start request. Defaults to undefined, which will start collection from the first record."""
    total_record_field: NotRequired[str]
    r"""Name of the attribute in the response that contains the total number of records for the query"""


class RestAuthenticationBasicSecretRestPaginationTypeRequestOffset(BaseModel):
    type: PaginationOptionsRestDiscoveryDiscoverTypeHTTPPagination

    offset_field: Annotated[str, pydantic.Field(alias="offsetField")]
    r"""Query string parameter that sets the index from which to begin returning records. Example: /api/v1/query?term=cribl&limit=100&offset=0"""

    limit_field: Annotated[str, pydantic.Field(alias="limitField")]
    r"""Query string parameter that sets the number of records retrieved per request. Example: /api/v1/query?term=cribl&limit=100&offset=0"""

    limit: float
    r"""Maximum number of records to collect per request"""

    max_pages: Annotated[float, pydantic.Field(alias="maxPages")]
    r"""Maximum number of pages to retrieve per collection task. Defaults to 50 pages. Set to 0 to retrieve all pages."""

    zero_indexed: Annotated[bool, pydantic.Field(alias="zeroIndexed")]
    r"""Enable to indicate that the first page in the requested data is at index 0. Disabled by default, which indicates index 1."""

    offset: Optional[float] = None
    r"""Offset index from which to start request. Defaults to undefined, which will start collection from the first record."""

    total_record_field: Annotated[
        Optional[str], pydantic.Field(alias="totalRecordField")
    ] = None
    r"""Name of the attribute in the response that contains the total number of records for the query"""

    @field_serializer("type")
    def serialize_type(self, value):
        if isinstance(value, str):
            try:
                return models.PaginationOptionsRestDiscoveryDiscoverTypeHTTPPagination(
                    value
                )
            except ValueError:
                return value
        return value

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(["offset", "totalRecordField"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


class RestAuthenticationBasicSecretRestPaginationTypeResponseHeaderLinkTypedDict(
    TypedDict
):
    type: PaginationOptionsRestDiscoveryDiscoverTypeHTTPPagination
    next_relation_attribute: str
    r"""Relation name used in the link header that refers to the next page in the result set. Example: rel=\"next\" refers to the next page of results: <https://myHost/nextPage>; rel=\"next\" """
    max_pages: float
    r"""Maximum number of pages to retrieve per collection task. Defaults to 50 pages. Set to 0 to retrieve all pages."""
    cur_relation_attribute: NotRequired[str]
    r"""Relation name used in the link header that refers to the current result set. Example: rel=\"self\" refers to the current page of results: <https://myHost/curPage>; rel=\"self\" """


class RestAuthenticationBasicSecretRestPaginationTypeResponseHeaderLink(BaseModel):
    type: PaginationOptionsRestDiscoveryDiscoverTypeHTTPPagination

    next_relation_attribute: Annotated[
        str, pydantic.Field(alias="nextRelationAttribute")
    ]
    r"""Relation name used in the link header that refers to the next page in the result set. Example: rel=\"next\" refers to the next page of results: <https://myHost/nextPage>; rel=\"next\" """

    max_pages: Annotated[float, pydantic.Field(alias="maxPages")]
    r"""Maximum number of pages to retrieve per collection task. Defaults to 50 pages. Set to 0 to retrieve all pages."""

    cur_relation_attribute: Annotated[
        Optional[str], pydantic.Field(alias="curRelationAttribute")
    ] = None
    r"""Relation name used in the link header that refers to the current result set. Example: rel=\"self\" refers to the current page of results: <https://myHost/curPage>; rel=\"self\" """

    @field_serializer("type")
    def serialize_type(self, value):
        if isinstance(value, str):
            try:
                return models.PaginationOptionsRestDiscoveryDiscoverTypeHTTPPagination(
                    value
                )
            except ValueError:
                return value
        return value

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(["curRelationAttribute"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


class RestAuthenticationBasicSecretRestPaginationTypeResponseHeaderTypedDict(TypedDict):
    type: PaginationOptionsRestDiscoveryDiscoverTypeHTTPPagination
    attribute: List[str]
    r"""Names of attributes within the response that contain next-page information"""
    max_pages: float
    r"""Maximum number of pages to retrieve per collection task. Defaults to 50 pages. Set to 0 to retrieve all pages."""


class RestAuthenticationBasicSecretRestPaginationTypeResponseHeader(BaseModel):
    type: PaginationOptionsRestDiscoveryDiscoverTypeHTTPPagination

    attribute: List[str]
    r"""Names of attributes within the response that contain next-page information"""

    max_pages: Annotated[float, pydantic.Field(alias="maxPages")]
    r"""Maximum number of pages to retrieve per collection task. Defaults to 50 pages. Set to 0 to retrieve all pages."""

    @field_serializer("type")
    def serialize_type(self, value):
        if isinstance(value, str):
            try:
                return models.PaginationOptionsRestDiscoveryDiscoverTypeHTTPPagination(
                    value
                )
            except ValueError:
                return value
        return value


class RestAuthenticationBasicSecretRestPaginationTypeResponseBodyTypedDict(TypedDict):
    type: PaginationOptionsRestDiscoveryDiscoverTypeHTTPPagination
    attribute: List[str]
    r"""Names of attributes within the response that contain next-page information"""
    max_pages: float
    r"""Maximum number of pages to retrieve per collection task. Defaults to 50 pages. Set to 0 to retrieve all pages."""
    last_page_expr: NotRequired[str]
    r"""JavaScript expression used to determine when the last page has been reached. The values tested by this expression must be in the Response attributes section."""


class RestAuthenticationBasicSecretRestPaginationTypeResponseBody(BaseModel):
    type: PaginationOptionsRestDiscoveryDiscoverTypeHTTPPagination

    attribute: List[str]
    r"""Names of attributes within the response that contain next-page information"""

    max_pages: Annotated[float, pydantic.Field(alias="maxPages")]
    r"""Maximum number of pages to retrieve per collection task. Defaults to 50 pages. Set to 0 to retrieve all pages."""

    last_page_expr: Annotated[Optional[str], pydantic.Field(alias="lastPageExpr")] = (
        None
    )
    r"""JavaScript expression used to determine when the last page has been reached. The values tested by this expression must be in the Response attributes section."""

    @field_serializer("type")
    def serialize_type(self, value):
        if isinstance(value, str):
            try:
                return models.PaginationOptionsRestDiscoveryDiscoverTypeHTTPPagination(
                    value
                )
            except ValueError:
                return value
        return value

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(["lastPageExpr"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


class RestAuthenticationBasicSecretRestPaginationTypeNoneTypedDict(TypedDict):
    type: PaginationOptionsRestDiscoveryDiscoverTypeHTTPPagination


class RestAuthenticationBasicSecretRestPaginationTypeNone(BaseModel):
    type: PaginationOptionsRestDiscoveryDiscoverTypeHTTPPagination

    @field_serializer("type")
    def serialize_type(self, value):
        if isinstance(value, str):
            try:
                return models.PaginationOptionsRestDiscoveryDiscoverTypeHTTPPagination(
                    value
                )
            except ValueError:
                return value
        return value


RestAuthenticationBasicSecretPaginationUnionTypedDict = TypeAliasType(
    "RestAuthenticationBasicSecretPaginationUnionTypedDict",
    Union[
        RestAuthenticationBasicSecretRestPaginationTypeNoneTypedDict,
        RestAuthenticationBasicSecretRestPaginationTypeResponseHeaderTypedDict,
        RestAuthenticationBasicSecretRestPaginationTypeResponseBodyTypedDict,
        RestAuthenticationBasicSecretRestPaginationTypeResponseHeaderLinkTypedDict,
        RestAuthenticationBasicSecretRestPaginationTypeRequestOffsetTypedDict,
        RestAuthenticationBasicSecretRestPaginationTypeRequestPageTypedDict,
    ],
)


class UnknownRestAuthenticationBasicSecretPaginationUnion(BaseModel):
    r"""A RestAuthenticationBasicSecretPaginationUnion variant the SDK doesn't recognize. Preserves the raw payload."""

    type: Literal["UNKNOWN"] = "UNKNOWN"
    raw: Any
    is_unknown: Literal[True] = True

    model_config = ConfigDict(frozen=True)


_REST_AUTHENTICATION_BASIC_SECRET_PAGINATION_UNION_VARIANTS: dict[str, Any] = {
    "none": RestAuthenticationBasicSecretRestPaginationTypeNone,
    "response_body": RestAuthenticationBasicSecretRestPaginationTypeResponseBody,
    "response_header": RestAuthenticationBasicSecretRestPaginationTypeResponseHeader,
    "response_header_link": RestAuthenticationBasicSecretRestPaginationTypeResponseHeaderLink,
    "request_offset": RestAuthenticationBasicSecretRestPaginationTypeRequestOffset,
    "request_page": RestAuthenticationBasicSecretRestPaginationTypeRequestPage,
}


RestAuthenticationBasicSecretPaginationUnion = Annotated[
    Union[
        RestAuthenticationBasicSecretRestPaginationTypeNone,
        RestAuthenticationBasicSecretRestPaginationTypeResponseBody,
        RestAuthenticationBasicSecretRestPaginationTypeResponseHeader,
        RestAuthenticationBasicSecretRestPaginationTypeResponseHeaderLink,
        RestAuthenticationBasicSecretRestPaginationTypeRequestOffset,
        RestAuthenticationBasicSecretRestPaginationTypeRequestPage,
        UnknownRestAuthenticationBasicSecretPaginationUnion,
    ],
    BeforeValidator(
        partial(
            parse_open_union,
            disc_key="type",
            variants=_REST_AUTHENTICATION_BASIC_SECRET_PAGINATION_UNION_VARIANTS,
            unknown_cls=UnknownRestAuthenticationBasicSecretPaginationUnion,
            union_name="RestAuthenticationBasicSecretPaginationUnion",
        )
    ),
]


class RestAuthenticationBasicSecretRestRetryRulesTypeBackoffTypedDict(TypedDict):
    type: RetryTypeOptionsHealthCheckCollectorConfRetryRules
    r"""The algorithm to use when performing HTTP retries"""
    interval: NotRequired[Any]
    limit: NotRequired[Any]
    multiplier: NotRequired[Any]
    max_interval_ms: NotRequired[Any]
    codes: NotRequired[Any]
    enable_header: NotRequired[Any]
    retry_connect_timeout: NotRequired[Any]
    retry_connect_reset: NotRequired[Any]


class RestAuthenticationBasicSecretRestRetryRulesTypeBackoff(BaseModel):
    type: RetryTypeOptionsHealthCheckCollectorConfRetryRules
    r"""The algorithm to use when performing HTTP retries"""

    interval: Optional[Any] = None

    limit: Optional[Any] = None

    multiplier: Optional[Any] = None

    max_interval_ms: Annotated[Optional[Any], pydantic.Field(alias="maxIntervalMs")] = (
        None
    )

    codes: Optional[Any] = None

    enable_header: Annotated[Optional[Any], pydantic.Field(alias="enableHeader")] = None

    retry_connect_timeout: Annotated[
        Optional[Any], pydantic.Field(alias="retryConnectTimeout")
    ] = None

    retry_connect_reset: Annotated[
        Optional[Any], pydantic.Field(alias="retryConnectReset")
    ] = None

    @field_serializer("type")
    def serialize_type(self, value):
        if isinstance(value, str):
            try:
                return models.RetryTypeOptionsHealthCheckCollectorConfRetryRules(value)
            except ValueError:
                return value
        return value

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(
            [
                "interval",
                "limit",
                "multiplier",
                "maxIntervalMs",
                "codes",
                "enableHeader",
                "retryConnectTimeout",
                "retryConnectReset",
            ]
        )
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


class RestAuthenticationBasicSecretRestRetryRulesTypeStaticTypedDict(TypedDict):
    type: RetryTypeOptionsHealthCheckCollectorConfRetryRules
    r"""The algorithm to use when performing HTTP retries"""
    interval: NotRequired[Any]
    limit: NotRequired[Any]
    codes: NotRequired[Any]
    enable_header: NotRequired[Any]
    retry_connect_timeout: NotRequired[Any]
    retry_connect_reset: NotRequired[Any]
    multiplier: NotRequired[Any]
    max_interval_ms: NotRequired[Any]


class RestAuthenticationBasicSecretRestRetryRulesTypeStatic(BaseModel):
    type: RetryTypeOptionsHealthCheckCollectorConfRetryRules
    r"""The algorithm to use when performing HTTP retries"""

    interval: Optional[Any] = None

    limit: Optional[Any] = None

    codes: Optional[Any] = None

    enable_header: Annotated[Optional[Any], pydantic.Field(alias="enableHeader")] = None

    retry_connect_timeout: Annotated[
        Optional[Any], pydantic.Field(alias="retryConnectTimeout")
    ] = None

    retry_connect_reset: Annotated[
        Optional[Any], pydantic.Field(alias="retryConnectReset")
    ] = None

    multiplier: Optional[Any] = None

    max_interval_ms: Annotated[Optional[Any], pydantic.Field(alias="maxIntervalMs")] = (
        None
    )

    @field_serializer("type")
    def serialize_type(self, value):
        if isinstance(value, str):
            try:
                return models.RetryTypeOptionsHealthCheckCollectorConfRetryRules(value)
            except ValueError:
                return value
        return value

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(
            [
                "interval",
                "limit",
                "codes",
                "enableHeader",
                "retryConnectTimeout",
                "retryConnectReset",
                "multiplier",
                "maxIntervalMs",
            ]
        )
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


class RestAuthenticationBasicSecretRestRetryRulesTypeNoneTypedDict(TypedDict):
    type: RetryTypeOptionsHealthCheckCollectorConfRetryRules
    r"""The algorithm to use when performing HTTP retries"""
    interval: NotRequired[Any]
    limit: NotRequired[Any]
    multiplier: NotRequired[Any]
    max_interval_ms: NotRequired[Any]
    codes: NotRequired[Any]
    enable_header: NotRequired[Any]
    retry_connect_timeout: NotRequired[Any]
    retry_connect_reset: NotRequired[Any]


class RestAuthenticationBasicSecretRestRetryRulesTypeNone(BaseModel):
    type: RetryTypeOptionsHealthCheckCollectorConfRetryRules
    r"""The algorithm to use when performing HTTP retries"""

    interval: Optional[Any] = None

    limit: Optional[Any] = None

    multiplier: Optional[Any] = None

    max_interval_ms: Annotated[Optional[Any], pydantic.Field(alias="maxIntervalMs")] = (
        None
    )

    codes: Optional[Any] = None

    enable_header: Annotated[Optional[Any], pydantic.Field(alias="enableHeader")] = None

    retry_connect_timeout: Annotated[
        Optional[Any], pydantic.Field(alias="retryConnectTimeout")
    ] = None

    retry_connect_reset: Annotated[
        Optional[Any], pydantic.Field(alias="retryConnectReset")
    ] = None

    @field_serializer("type")
    def serialize_type(self, value):
        if isinstance(value, str):
            try:
                return models.RetryTypeOptionsHealthCheckCollectorConfRetryRules(value)
            except ValueError:
                return value
        return value

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(
            [
                "interval",
                "limit",
                "multiplier",
                "maxIntervalMs",
                "codes",
                "enableHeader",
                "retryConnectTimeout",
                "retryConnectReset",
            ]
        )
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


RestAuthenticationBasicSecretRetryRulesTypedDict = TypeAliasType(
    "RestAuthenticationBasicSecretRetryRulesTypedDict",
    Union[
        RestAuthenticationBasicSecretRestRetryRulesTypeNoneTypedDict,
        RestAuthenticationBasicSecretRestRetryRulesTypeStaticTypedDict,
        RestAuthenticationBasicSecretRestRetryRulesTypeBackoffTypedDict,
    ],
)


class UnknownRestAuthenticationBasicSecretRetryRules(BaseModel):
    r"""A RestAuthenticationBasicSecretRetryRules variant the SDK doesn't recognize. Preserves the raw payload."""

    type: Literal["UNKNOWN"] = "UNKNOWN"
    raw: Any
    is_unknown: Literal[True] = True

    model_config = ConfigDict(frozen=True)


_REST_AUTHENTICATION_BASIC_SECRET_RETRY_RULES_VARIANTS: dict[str, Any] = {
    "none": RestAuthenticationBasicSecretRestRetryRulesTypeNone,
    "static": RestAuthenticationBasicSecretRestRetryRulesTypeStatic,
    "backoff": RestAuthenticationBasicSecretRestRetryRulesTypeBackoff,
}


RestAuthenticationBasicSecretRetryRules = Annotated[
    Union[
        RestAuthenticationBasicSecretRestRetryRulesTypeNone,
        RestAuthenticationBasicSecretRestRetryRulesTypeStatic,
        RestAuthenticationBasicSecretRestRetryRulesTypeBackoff,
        UnknownRestAuthenticationBasicSecretRetryRules,
    ],
    BeforeValidator(
        partial(
            parse_open_union,
            disc_key="type",
            variants=_REST_AUTHENTICATION_BASIC_SECRET_RETRY_RULES_VARIANTS,
            unknown_cls=UnknownRestAuthenticationBasicSecretRetryRules,
            union_name="RestAuthenticationBasicSecretRetryRules",
        )
    ),
]


class RestAuthenticationBasicSecretStateTrackingTypedDict(TypedDict):
    enabled: NotRequired[bool]
    r"""Track collection progress between consecutive scheduled executions"""


class RestAuthenticationBasicSecretStateTracking(BaseModel):
    enabled: Optional[bool] = None
    r"""Track collection progress between consecutive scheduled executions"""

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(["enabled"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


class RestAuthenticationBasicSecretSchedulingTypedDict(TypedDict):
    state_tracking: NotRequired[RestAuthenticationBasicSecretStateTrackingTypedDict]


class RestAuthenticationBasicSecretScheduling(BaseModel):
    state_tracking: Annotated[
        Optional[RestAuthenticationBasicSecretStateTracking],
        pydantic.Field(alias="stateTracking"),
    ] = None

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(["stateTracking"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


class RestAuthenticationBasicSecretTypedDict(TypedDict):
    authentication: RestAuthenticationBasicSecretAuthentication
    r"""Authentication method for Discover and Collect REST calls. You can specify API key–based authentication by adding the appropriate Collect headers."""
    credentials_secret: str
    r"""Select or create a stored secret that references your credentials"""
    collect_url: str
    r"""URL (constant or JavaScript expression) to use for the Collect operation"""
    collect_method: RestAuthenticationBasicSecretCollectMethod
    discovery: NotRequired[RestAuthenticationBasicSecretDiscoveryTypedDict]
    collect_verb: NotRequired[Any]
    collect_request_params: NotRequired[Any]
    collect_body: NotRequired[Any]
    collect_request_headers: NotRequired[
        List[ItemsTypeRestCollectMethodGetCollectRequestParamsTypedDict]
    ]
    pagination: NotRequired[RestAuthenticationBasicSecretPaginationUnionTypedDict]
    timeout: NotRequired[float]
    r"""HTTP request inactivity timeout. Use 0 to disable."""
    use_round_robin_dns: NotRequired[bool]
    r"""Use round-robin DNS lookup. Suitable when DNS server returns multiple addresses in sort order."""
    disable_time_filter: NotRequired[bool]
    r"""Disable Collector event time filtering when a date range is specified"""
    decode_url: NotRequired[bool]
    r"""Decode the URL before sending requests (including pagination requests)"""
    reject_unauthorized: NotRequired[bool]
    r"""Reject certificates that cannot be verified against a valid CA (such as self-signed certificates)"""
    capture_headers: NotRequired[bool]
    r"""Enable to add response headers to the resHeaders field under the __collectible object"""
    stop_on_empty_results: NotRequired[bool]
    r"""Stop pagination when the Event Breaker produces no events"""
    safe_headers: NotRequired[List[str]]
    r"""List of headers that are safe to log in plain text"""
    retry_rules: NotRequired[RestAuthenticationBasicSecretRetryRulesTypedDict]
    scheduling: NotRequired[RestAuthenticationBasicSecretSchedulingTypedDict]


class RestAuthenticationBasicSecret(BaseModel):
    authentication: RestAuthenticationBasicSecretAuthentication
    r"""Authentication method for Discover and Collect REST calls. You can specify API key–based authentication by adding the appropriate Collect headers."""

    credentials_secret: Annotated[str, pydantic.Field(alias="credentialsSecret")]
    r"""Select or create a stored secret that references your credentials"""

    collect_url: Annotated[str, pydantic.Field(alias="collectUrl")]
    r"""URL (constant or JavaScript expression) to use for the Collect operation"""

    collect_method: Annotated[
        RestAuthenticationBasicSecretCollectMethod,
        pydantic.Field(alias="collectMethod"),
    ]

    discovery: Optional[RestAuthenticationBasicSecretDiscovery] = None

    collect_verb: Annotated[Optional[Any], pydantic.Field(alias="collectVerb")] = None

    collect_request_params: Annotated[
        Optional[Any], pydantic.Field(alias="collectRequestParams")
    ] = None

    collect_body: Annotated[Optional[Any], pydantic.Field(alias="collectBody")] = None

    collect_request_headers: Annotated[
        Optional[List[ItemsTypeRestCollectMethodGetCollectRequestParams]],
        pydantic.Field(alias="collectRequestHeaders"),
    ] = None

    pagination: Optional[RestAuthenticationBasicSecretPaginationUnion] = None

    timeout: Optional[float] = None
    r"""HTTP request inactivity timeout. Use 0 to disable."""

    use_round_robin_dns: Annotated[
        Optional[bool], pydantic.Field(alias="useRoundRobinDns")
    ] = None
    r"""Use round-robin DNS lookup. Suitable when DNS server returns multiple addresses in sort order."""

    disable_time_filter: Annotated[
        Optional[bool], pydantic.Field(alias="disableTimeFilter")
    ] = None
    r"""Disable Collector event time filtering when a date range is specified"""

    decode_url: Annotated[Optional[bool], pydantic.Field(alias="decodeUrl")] = None
    r"""Decode the URL before sending requests (including pagination requests)"""

    reject_unauthorized: Annotated[
        Optional[bool], pydantic.Field(alias="rejectUnauthorized")
    ] = None
    r"""Reject certificates that cannot be verified against a valid CA (such as self-signed certificates)"""

    capture_headers: Annotated[
        Optional[bool], pydantic.Field(alias="captureHeaders")
    ] = None
    r"""Enable to add response headers to the resHeaders field under the __collectible object"""

    stop_on_empty_results: Annotated[
        Optional[bool], pydantic.Field(alias="stopOnEmptyResults")
    ] = None
    r"""Stop pagination when the Event Breaker produces no events"""

    safe_headers: Annotated[
        Optional[List[str]], pydantic.Field(alias="safeHeaders")
    ] = None
    r"""List of headers that are safe to log in plain text"""

    retry_rules: Annotated[
        Optional[RestAuthenticationBasicSecretRetryRules],
        pydantic.Field(alias="retryRules"),
    ] = None

    scheduling: Annotated[
        Optional[RestAuthenticationBasicSecretScheduling],
        pydantic.Field(alias="__scheduling"),
    ] = None

    @field_serializer("authentication")
    def serialize_authentication(self, value):
        if isinstance(value, str):
            try:
                return models.RestAuthenticationBasicSecretAuthentication(value)
            except ValueError:
                return value
        return value

    @field_serializer("collect_method")
    def serialize_collect_method(self, value):
        if isinstance(value, str):
            try:
                return models.RestAuthenticationBasicSecretCollectMethod(value)
            except ValueError:
                return value
        return value

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(
            [
                "discovery",
                "collectVerb",
                "collectRequestParams",
                "collectBody",
                "collectRequestHeaders",
                "pagination",
                "timeout",
                "useRoundRobinDns",
                "disableTimeFilter",
                "decodeUrl",
                "rejectUnauthorized",
                "captureHeaders",
                "stopOnEmptyResults",
                "safeHeaders",
                "retryRules",
                "__scheduling",
            ]
        )
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


class RestAuthenticationBasicAuthentication(str, Enum, metaclass=utils.OpenEnumMeta):
    r"""Authentication method for Discover and Collect REST calls. You can specify API key–based authentication by adding the appropriate Collect headers."""

    NONE = "none"
    BASIC = "basic"
    BASIC_SECRET = "basicSecret"
    LOGIN = "login"
    LOGIN_SECRET = "loginSecret"
    OAUTH = "oauth"
    OAUTH_SECRET = "oauthSecret"
    GOOGLE_OAUTH = "google_oauth"
    GOOGLE_OAUTH_SECRET = "google_oauthSecret"
    HMAC = "hmac"


class RestAuthenticationBasicRestDiscoveryDiscoverTypeNoneDiscoverType(
    str, Enum, metaclass=utils.OpenEnumMeta
):
    r"""Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task."""

    HTTP = "http"
    JSON = "json"
    LIST = "list"
    NONE = "none"


class RestAuthenticationBasicRestDiscoveryDiscoverTypeNoneTypedDict(TypedDict):
    discover_type: RestAuthenticationBasicRestDiscoveryDiscoverTypeNoneDiscoverType
    r"""Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task."""


class RestAuthenticationBasicRestDiscoveryDiscoverTypeNone(BaseModel):
    discover_type: Annotated[
        RestAuthenticationBasicRestDiscoveryDiscoverTypeNoneDiscoverType,
        pydantic.Field(alias="discoverType"),
    ]
    r"""Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task."""

    @field_serializer("discover_type")
    def serialize_discover_type(self, value):
        if isinstance(value, str):
            try:
                return models.RestAuthenticationBasicRestDiscoveryDiscoverTypeNoneDiscoverType(
                    value
                )
            except ValueError:
                return value
        return value


class RestAuthenticationBasicRestDiscoveryDiscoverTypeListDiscoverType(
    str, Enum, metaclass=utils.OpenEnumMeta
):
    r"""Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task."""

    HTTP = "http"
    JSON = "json"
    LIST = "list"
    NONE = "none"


class RestAuthenticationBasicRestDiscoveryDiscoverTypeListTypedDict(TypedDict):
    discover_type: RestAuthenticationBasicRestDiscoveryDiscoverTypeListDiscoverType
    r"""Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task."""
    item_list: List[str]
    r"""Comma-separated list of items to return from the Discover task. Each item returned generates a Collect task and can be referenced using `${id}` in the Collect URL, headers, or parameters."""


class RestAuthenticationBasicRestDiscoveryDiscoverTypeList(BaseModel):
    discover_type: Annotated[
        RestAuthenticationBasicRestDiscoveryDiscoverTypeListDiscoverType,
        pydantic.Field(alias="discoverType"),
    ]
    r"""Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task."""

    item_list: Annotated[List[str], pydantic.Field(alias="itemList")]
    r"""Comma-separated list of items to return from the Discover task. Each item returned generates a Collect task and can be referenced using `${id}` in the Collect URL, headers, or parameters."""

    @field_serializer("discover_type")
    def serialize_discover_type(self, value):
        if isinstance(value, str):
            try:
                return models.RestAuthenticationBasicRestDiscoveryDiscoverTypeListDiscoverType(
                    value
                )
            except ValueError:
                return value
        return value


class RestAuthenticationBasicRestDiscoveryDiscoverTypeJSONDiscoverType(
    str, Enum, metaclass=utils.OpenEnumMeta
):
    r"""Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task."""

    HTTP = "http"
    JSON = "json"
    LIST = "list"
    NONE = "none"


class RestAuthenticationBasicRestDiscoveryDiscoverTypeJSONTypedDict(TypedDict):
    discover_type: RestAuthenticationBasicRestDiscoveryDiscoverTypeJSONDiscoverType
    r"""Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task."""
    manual_discover_result: str
    r"""Allows hard-coding the Discover result. Must be a JSON object or array. Works with Discover data field."""
    discover_data_field: NotRequired[str]
    r"""Within the response JSON, the name of the field to pull results from, typically a JSON array. Leave blank if the result itself is an array of values. Sample entry: items, json: { items: [{id: 'first'},{id: 'second'}] }"""


class RestAuthenticationBasicRestDiscoveryDiscoverTypeJSON(BaseModel):
    discover_type: Annotated[
        RestAuthenticationBasicRestDiscoveryDiscoverTypeJSONDiscoverType,
        pydantic.Field(alias="discoverType"),
    ]
    r"""Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task."""

    manual_discover_result: Annotated[str, pydantic.Field(alias="manualDiscoverResult")]
    r"""Allows hard-coding the Discover result. Must be a JSON object or array. Works with Discover data field."""

    discover_data_field: Annotated[
        Optional[str], pydantic.Field(alias="discoverDataField")
    ] = None
    r"""Within the response JSON, the name of the field to pull results from, typically a JSON array. Leave blank if the result itself is an array of values. Sample entry: items, json: { items: [{id: 'first'},{id: 'second'}] }"""

    @field_serializer("discover_type")
    def serialize_discover_type(self, value):
        if isinstance(value, str):
            try:
                return models.RestAuthenticationBasicRestDiscoveryDiscoverTypeJSONDiscoverType(
                    value
                )
            except ValueError:
                return value
        return value

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(["discoverDataField"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


class RestAuthenticationBasicRestDiscoveryDiscoverTypeHTTPDiscoverMethodOtherDiscoverMethod(
    str, Enum, metaclass=utils.OpenEnumMeta
):
    # GET
    GET = "get"
    # POST
    POST = "post"
    # POST with Body
    POST_WITH_BODY = "post_with_body"
    # Other
    OTHER = "other"


class RestAuthenticationBasicRestDiscoveryDiscoverTypeHTTPDiscoverMethodOtherDiscoverType(
    str, Enum, metaclass=utils.OpenEnumMeta
):
    r"""Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task."""

    HTTP = "http"
    JSON = "json"
    LIST = "list"
    NONE = "none"


class RestAuthenticationBasicRestDiscoveryDiscoverTypeHTTPDiscoverMethodOtherPaginationTypedDict(
    TypedDict
):
    type: PaginationOptionsRestDiscoveryDiscoverTypeHTTPPagination


class RestAuthenticationBasicRestDiscoveryDiscoverTypeHTTPDiscoverMethodOtherPagination(
    BaseModel
):
    type: PaginationOptionsRestDiscoveryDiscoverTypeHTTPPagination

    @field_serializer("type")
    def serialize_type(self, value):
        if isinstance(value, str):
            try:
                return models.PaginationOptionsRestDiscoveryDiscoverTypeHTTPPagination(
                    value
                )
            except ValueError:
                return value
        return value


class RestAuthenticationBasicRestDiscoveryDiscoverTypeHTTPDiscoverMethodOtherTypedDict(
    TypedDict
):
    discover_method: RestAuthenticationBasicRestDiscoveryDiscoverTypeHTTPDiscoverMethodOtherDiscoverMethod
    discover_verb: Any
    discover_type: RestAuthenticationBasicRestDiscoveryDiscoverTypeHTTPDiscoverMethodOtherDiscoverType
    r"""Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task."""
    discover_url: str
    r"""URL to use for the Discover operation. Can be a constant URL, or a JavaScript expression to derive the URL."""
    discover_body: NotRequired[Any]
    discover_request_params: NotRequired[Any]
    discover_request_headers: NotRequired[
        List[ItemsTypeRestCollectMethodGetCollectRequestParamsTypedDict]
    ]
    pagination: NotRequired[
        RestAuthenticationBasicRestDiscoveryDiscoverTypeHTTPDiscoverMethodOtherPaginationTypedDict
    ]
    discover_data_field: NotRequired[str]
    r"""Path to field in the response object that contains discovery results (ex: level1.name). Leave blank if the result is an array."""
    enable_strict_discover_parsing: NotRequired[bool]
    r"""Explicitly set the discover response format. When disabled, best effort parsing is used."""
    discover_response_format: NotRequired[Any]
    enable_discover_code: NotRequired[bool]


class RestAuthenticationBasicRestDiscoveryDiscoverTypeHTTPDiscoverMethodOther(
    BaseModel
):
    discover_method: Annotated[
        RestAuthenticationBasicRestDiscoveryDiscoverTypeHTTPDiscoverMethodOtherDiscoverMethod,
        pydantic.Field(alias="discoverMethod"),
    ]

    discover_verb: Annotated[Any, pydantic.Field(alias="discoverVerb")]

    discover_type: Annotated[
        RestAuthenticationBasicRestDiscoveryDiscoverTypeHTTPDiscoverMethodOtherDiscoverType,
        pydantic.Field(alias="discoverType"),
    ]
    r"""Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task."""

    discover_url: Annotated[str, pydantic.Field(alias="discoverUrl")]
    r"""URL to use for the Discover operation. Can be a constant URL, or a JavaScript expression to derive the URL."""

    discover_body: Annotated[Optional[Any], pydantic.Field(alias="discoverBody")] = None

    discover_request_params: Annotated[
        Optional[Any], pydantic.Field(alias="discoverRequestParams")
    ] = None

    discover_request_headers: Annotated[
        Optional[List[ItemsTypeRestCollectMethodGetCollectRequestParams]],
        pydantic.Field(alias="discoverRequestHeaders"),
    ] = None

    pagination: Optional[
        RestAuthenticationBasicRestDiscoveryDiscoverTypeHTTPDiscoverMethodOtherPagination
    ] = None

    discover_data_field: Annotated[
        Optional[str], pydantic.Field(alias="discoverDataField")
    ] = None
    r"""Path to field in the response object that contains discovery results (ex: level1.name). Leave blank if the result is an array."""

    enable_strict_discover_parsing: Annotated[
        Optional[bool], pydantic.Field(alias="enableStrictDiscoverParsing")
    ] = None
    r"""Explicitly set the discover response format. When disabled, best effort parsing is used."""

    discover_response_format: Annotated[
        Optional[Any], pydantic.Field(alias="discoverResponseFormat")
    ] = None

    enable_discover_code: Annotated[
        Optional[bool], pydantic.Field(alias="enableDiscoverCode")
    ] = None

    @field_serializer("discover_method")
    def serialize_discover_method(self, value):
        if isinstance(value, str):
            try:
                return models.RestAuthenticationBasicRestDiscoveryDiscoverTypeHTTPDiscoverMethodOtherDiscoverMethod(
                    value
                )
            except ValueError:
                return value
        return value

    @field_serializer("discover_type")
    def serialize_discover_type(self, value):
        if isinstance(value, str):
            try:
                return models.RestAuthenticationBasicRestDiscoveryDiscoverTypeHTTPDiscoverMethodOtherDiscoverType(
                    value
                )
            except ValueError:
                return value
        return value

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(
            [
                "discoverBody",
                "discoverRequestParams",
                "discoverRequestHeaders",
                "pagination",
                "discoverDataField",
                "enableStrictDiscoverParsing",
                "discoverResponseFormat",
                "enableDiscoverCode",
            ]
        )
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


class RestAuthenticationBasicRestDiscoveryDiscoverTypeHTTPDiscoverMethodPostWithBodyDiscoverMethod(
    str, Enum, metaclass=utils.OpenEnumMeta
):
    # GET
    GET = "get"
    # POST
    POST = "post"
    # POST with Body
    POST_WITH_BODY = "post_with_body"
    # Other
    OTHER = "other"


class RestAuthenticationBasicRestDiscoveryDiscoverTypeHTTPDiscoverMethodPostWithBodyDiscoverType(
    str, Enum, metaclass=utils.OpenEnumMeta
):
    r"""Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task."""

    HTTP = "http"
    JSON = "json"
    LIST = "list"
    NONE = "none"


class RestAuthenticationBasicRestDiscoveryDiscoverTypeHTTPDiscoverMethodPostWithBodyPaginationTypedDict(
    TypedDict
):
    type: PaginationOptionsRestDiscoveryDiscoverTypeHTTPPagination


class RestAuthenticationBasicRestDiscoveryDiscoverTypeHTTPDiscoverMethodPostWithBodyPagination(
    BaseModel
):
    type: PaginationOptionsRestDiscoveryDiscoverTypeHTTPPagination

    @field_serializer("type")
    def serialize_type(self, value):
        if isinstance(value, str):
            try:
                return models.PaginationOptionsRestDiscoveryDiscoverTypeHTTPPagination(
                    value
                )
            except ValueError:
                return value
        return value


class RestAuthenticationBasicRestDiscoveryDiscoverTypeHTTPDiscoverMethodPostWithBodyTypedDict(
    TypedDict
):
    discover_method: RestAuthenticationBasicRestDiscoveryDiscoverTypeHTTPDiscoverMethodPostWithBodyDiscoverMethod
    discover_body: Any
    discover_type: RestAuthenticationBasicRestDiscoveryDiscoverTypeHTTPDiscoverMethodPostWithBodyDiscoverType
    r"""Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task."""
    discover_url: str
    r"""URL to use for the Discover operation. Can be a constant URL, or a JavaScript expression to derive the URL."""
    discover_verb: NotRequired[Any]
    discover_request_params: NotRequired[Any]
    discover_request_headers: NotRequired[
        List[ItemsTypeRestCollectMethodGetCollectRequestParamsTypedDict]
    ]
    pagination: NotRequired[
        RestAuthenticationBasicRestDiscoveryDiscoverTypeHTTPDiscoverMethodPostWithBodyPaginationTypedDict
    ]
    discover_data_field: NotRequired[str]
    r"""Path to field in the response object that contains discovery results (ex: level1.name). Leave blank if the result is an array."""
    enable_strict_discover_parsing: NotRequired[bool]
    r"""Explicitly set the discover response format. When disabled, best effort parsing is used."""
    discover_response_format: NotRequired[Any]
    enable_discover_code: NotRequired[bool]


class RestAuthenticationBasicRestDiscoveryDiscoverTypeHTTPDiscoverMethodPostWithBody(
    BaseModel
):
    discover_method: Annotated[
        RestAuthenticationBasicRestDiscoveryDiscoverTypeHTTPDiscoverMethodPostWithBodyDiscoverMethod,
        pydantic.Field(alias="discoverMethod"),
    ]

    discover_body: Annotated[Any, pydantic.Field(alias="discoverBody")]

    discover_type: Annotated[
        RestAuthenticationBasicRestDiscoveryDiscoverTypeHTTPDiscoverMethodPostWithBodyDiscoverType,
        pydantic.Field(alias="discoverType"),
    ]
    r"""Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task."""

    discover_url: Annotated[str, pydantic.Field(alias="discoverUrl")]
    r"""URL to use for the Discover operation. Can be a constant URL, or a JavaScript expression to derive the URL."""

    discover_verb: Annotated[Optional[Any], pydantic.Field(alias="discoverVerb")] = None

    discover_request_params: Annotated[
        Optional[Any], pydantic.Field(alias="discoverRequestParams")
    ] = None

    discover_request_headers: Annotated[
        Optional[List[ItemsTypeRestCollectMethodGetCollectRequestParams]],
        pydantic.Field(alias="discoverRequestHeaders"),
    ] = None

    pagination: Optional[
        RestAuthenticationBasicRestDiscoveryDiscoverTypeHTTPDiscoverMethodPostWithBodyPagination
    ] = None

    discover_data_field: Annotated[
        Optional[str], pydantic.Field(alias="discoverDataField")
    ] = None
    r"""Path to field in the response object that contains discovery results (ex: level1.name). Leave blank if the result is an array."""

    enable_strict_discover_parsing: Annotated[
        Optional[bool], pydantic.Field(alias="enableStrictDiscoverParsing")
    ] = None
    r"""Explicitly set the discover response format. When disabled, best effort parsing is used."""

    discover_response_format: Annotated[
        Optional[Any], pydantic.Field(alias="discoverResponseFormat")
    ] = None

    enable_discover_code: Annotated[
        Optional[bool], pydantic.Field(alias="enableDiscoverCode")
    ] = None

    @field_serializer("discover_method")
    def serialize_discover_method(self, value):
        if isinstance(value, str):
            try:
                return models.RestAuthenticationBasicRestDiscoveryDiscoverTypeHTTPDiscoverMethodPostWithBodyDiscoverMethod(
                    value
                )
            except ValueError:
                return value
        return value

    @field_serializer("discover_type")
    def serialize_discover_type(self, value):
        if isinstance(value, str):
            try:
                return models.RestAuthenticationBasicRestDiscoveryDiscoverTypeHTTPDiscoverMethodPostWithBodyDiscoverType(
                    value
                )
            except ValueError:
                return value
        return value

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(
            [
                "discoverVerb",
                "discoverRequestParams",
                "discoverRequestHeaders",
                "pagination",
                "discoverDataField",
                "enableStrictDiscoverParsing",
                "discoverResponseFormat",
                "enableDiscoverCode",
            ]
        )
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


class RestAuthenticationBasicRestDiscoveryDiscoverTypeHTTPDiscoverMethodPostDiscoverMethod(
    str, Enum, metaclass=utils.OpenEnumMeta
):
    # GET
    GET = "get"
    # POST
    POST = "post"
    # POST with Body
    POST_WITH_BODY = "post_with_body"
    # Other
    OTHER = "other"


class RestAuthenticationBasicRestDiscoveryDiscoverTypeHTTPDiscoverMethodPostDiscoverType(
    str, Enum, metaclass=utils.OpenEnumMeta
):
    r"""Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task."""

    HTTP = "http"
    JSON = "json"
    LIST = "list"
    NONE = "none"


class RestAuthenticationBasicRestDiscoveryDiscoverTypeHTTPDiscoverMethodPostPaginationTypedDict(
    TypedDict
):
    type: PaginationOptionsRestDiscoveryDiscoverTypeHTTPPagination


class RestAuthenticationBasicRestDiscoveryDiscoverTypeHTTPDiscoverMethodPostPagination(
    BaseModel
):
    type: PaginationOptionsRestDiscoveryDiscoverTypeHTTPPagination

    @field_serializer("type")
    def serialize_type(self, value):
        if isinstance(value, str):
            try:
                return models.PaginationOptionsRestDiscoveryDiscoverTypeHTTPPagination(
                    value
                )
            except ValueError:
                return value
        return value


class RestAuthenticationBasicRestDiscoveryDiscoverTypeHTTPDiscoverMethodPostTypedDict(
    TypedDict
):
    discover_method: RestAuthenticationBasicRestDiscoveryDiscoverTypeHTTPDiscoverMethodPostDiscoverMethod
    discover_type: RestAuthenticationBasicRestDiscoveryDiscoverTypeHTTPDiscoverMethodPostDiscoverType
    r"""Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task."""
    discover_url: str
    r"""URL to use for the Discover operation. Can be a constant URL, or a JavaScript expression to derive the URL."""
    discover_request_params: NotRequired[Any]
    discover_verb: NotRequired[Any]
    discover_body: NotRequired[Any]
    discover_request_headers: NotRequired[
        List[ItemsTypeRestCollectMethodGetCollectRequestParamsTypedDict]
    ]
    pagination: NotRequired[
        RestAuthenticationBasicRestDiscoveryDiscoverTypeHTTPDiscoverMethodPostPaginationTypedDict
    ]
    discover_data_field: NotRequired[str]
    r"""Path to field in the response object that contains discovery results (ex: level1.name). Leave blank if the result is an array."""
    enable_strict_discover_parsing: NotRequired[bool]
    r"""Explicitly set the discover response format. When disabled, best effort parsing is used."""
    discover_response_format: NotRequired[Any]
    enable_discover_code: NotRequired[bool]


class RestAuthenticationBasicRestDiscoveryDiscoverTypeHTTPDiscoverMethodPost(BaseModel):
    discover_method: Annotated[
        RestAuthenticationBasicRestDiscoveryDiscoverTypeHTTPDiscoverMethodPostDiscoverMethod,
        pydantic.Field(alias="discoverMethod"),
    ]

    discover_type: Annotated[
        RestAuthenticationBasicRestDiscoveryDiscoverTypeHTTPDiscoverMethodPostDiscoverType,
        pydantic.Field(alias="discoverType"),
    ]
    r"""Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task."""

    discover_url: Annotated[str, pydantic.Field(alias="discoverUrl")]
    r"""URL to use for the Discover operation. Can be a constant URL, or a JavaScript expression to derive the URL."""

    discover_request_params: Annotated[
        Optional[Any], pydantic.Field(alias="discoverRequestParams")
    ] = None

    discover_verb: Annotated[Optional[Any], pydantic.Field(alias="discoverVerb")] = None

    discover_body: Annotated[Optional[Any], pydantic.Field(alias="discoverBody")] = None

    discover_request_headers: Annotated[
        Optional[List[ItemsTypeRestCollectMethodGetCollectRequestParams]],
        pydantic.Field(alias="discoverRequestHeaders"),
    ] = None

    pagination: Optional[
        RestAuthenticationBasicRestDiscoveryDiscoverTypeHTTPDiscoverMethodPostPagination
    ] = None

    discover_data_field: Annotated[
        Optional[str], pydantic.Field(alias="discoverDataField")
    ] = None
    r"""Path to field in the response object that contains discovery results (ex: level1.name). Leave blank if the result is an array."""

    enable_strict_discover_parsing: Annotated[
        Optional[bool], pydantic.Field(alias="enableStrictDiscoverParsing")
    ] = None
    r"""Explicitly set the discover response format. When disabled, best effort parsing is used."""

    discover_response_format: Annotated[
        Optional[Any], pydantic.Field(alias="discoverResponseFormat")
    ] = None

    enable_discover_code: Annotated[
        Optional[bool], pydantic.Field(alias="enableDiscoverCode")
    ] = None

    @field_serializer("discover_method")
    def serialize_discover_method(self, value):
        if isinstance(value, str):
            try:
                return models.RestAuthenticationBasicRestDiscoveryDiscoverTypeHTTPDiscoverMethodPostDiscoverMethod(
                    value
                )
            except ValueError:
                return value
        return value

    @field_serializer("discover_type")
    def serialize_discover_type(self, value):
        if isinstance(value, str):
            try:
                return models.RestAuthenticationBasicRestDiscoveryDiscoverTypeHTTPDiscoverMethodPostDiscoverType(
                    value
                )
            except ValueError:
                return value
        return value

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(
            [
                "discoverRequestParams",
                "discoverVerb",
                "discoverBody",
                "discoverRequestHeaders",
                "pagination",
                "discoverDataField",
                "enableStrictDiscoverParsing",
                "discoverResponseFormat",
                "enableDiscoverCode",
            ]
        )
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


class RestAuthenticationBasicRestDiscoveryDiscoverTypeHTTPDiscoverMethodGetDiscoverMethod(
    str, Enum, metaclass=utils.OpenEnumMeta
):
    # GET
    GET = "get"
    # POST
    POST = "post"
    # POST with Body
    POST_WITH_BODY = "post_with_body"
    # Other
    OTHER = "other"


class RestAuthenticationBasicRestDiscoveryDiscoverTypeHTTPDiscoverMethodGetDiscoverType(
    str, Enum, metaclass=utils.OpenEnumMeta
):
    r"""Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task."""

    HTTP = "http"
    JSON = "json"
    LIST = "list"
    NONE = "none"


class RestAuthenticationBasicRestDiscoveryDiscoverTypeHTTPDiscoverMethodGetPaginationTypedDict(
    TypedDict
):
    type: PaginationOptionsRestDiscoveryDiscoverTypeHTTPPagination


class RestAuthenticationBasicRestDiscoveryDiscoverTypeHTTPDiscoverMethodGetPagination(
    BaseModel
):
    type: PaginationOptionsRestDiscoveryDiscoverTypeHTTPPagination

    @field_serializer("type")
    def serialize_type(self, value):
        if isinstance(value, str):
            try:
                return models.PaginationOptionsRestDiscoveryDiscoverTypeHTTPPagination(
                    value
                )
            except ValueError:
                return value
        return value


class RestAuthenticationBasicRestDiscoveryDiscoverTypeHTTPDiscoverMethodGetTypedDict(
    TypedDict
):
    discover_method: RestAuthenticationBasicRestDiscoveryDiscoverTypeHTTPDiscoverMethodGetDiscoverMethod
    discover_type: RestAuthenticationBasicRestDiscoveryDiscoverTypeHTTPDiscoverMethodGetDiscoverType
    r"""Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task."""
    discover_url: str
    r"""URL to use for the Discover operation. Can be a constant URL, or a JavaScript expression to derive the URL."""
    discover_request_params: NotRequired[Any]
    discover_verb: NotRequired[Any]
    discover_body: NotRequired[Any]
    discover_request_headers: NotRequired[
        List[ItemsTypeRestCollectMethodGetCollectRequestParamsTypedDict]
    ]
    pagination: NotRequired[
        RestAuthenticationBasicRestDiscoveryDiscoverTypeHTTPDiscoverMethodGetPaginationTypedDict
    ]
    discover_data_field: NotRequired[str]
    r"""Path to field in the response object that contains discovery results (ex: level1.name). Leave blank if the result is an array."""
    enable_strict_discover_parsing: NotRequired[bool]
    r"""Explicitly set the discover response format. When disabled, best effort parsing is used."""
    discover_response_format: NotRequired[Any]
    enable_discover_code: NotRequired[bool]


class RestAuthenticationBasicRestDiscoveryDiscoverTypeHTTPDiscoverMethodGet(BaseModel):
    discover_method: Annotated[
        RestAuthenticationBasicRestDiscoveryDiscoverTypeHTTPDiscoverMethodGetDiscoverMethod,
        pydantic.Field(alias="discoverMethod"),
    ]

    discover_type: Annotated[
        RestAuthenticationBasicRestDiscoveryDiscoverTypeHTTPDiscoverMethodGetDiscoverType,
        pydantic.Field(alias="discoverType"),
    ]
    r"""Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task."""

    discover_url: Annotated[str, pydantic.Field(alias="discoverUrl")]
    r"""URL to use for the Discover operation. Can be a constant URL, or a JavaScript expression to derive the URL."""

    discover_request_params: Annotated[
        Optional[Any], pydantic.Field(alias="discoverRequestParams")
    ] = None

    discover_verb: Annotated[Optional[Any], pydantic.Field(alias="discoverVerb")] = None

    discover_body: Annotated[Optional[Any], pydantic.Field(alias="discoverBody")] = None

    discover_request_headers: Annotated[
        Optional[List[ItemsTypeRestCollectMethodGetCollectRequestParams]],
        pydantic.Field(alias="discoverRequestHeaders"),
    ] = None

    pagination: Optional[
        RestAuthenticationBasicRestDiscoveryDiscoverTypeHTTPDiscoverMethodGetPagination
    ] = None

    discover_data_field: Annotated[
        Optional[str], pydantic.Field(alias="discoverDataField")
    ] = None
    r"""Path to field in the response object that contains discovery results (ex: level1.name). Leave blank if the result is an array."""

    enable_strict_discover_parsing: Annotated[
        Optional[bool], pydantic.Field(alias="enableStrictDiscoverParsing")
    ] = None
    r"""Explicitly set the discover response format. When disabled, best effort parsing is used."""

    discover_response_format: Annotated[
        Optional[Any], pydantic.Field(alias="discoverResponseFormat")
    ] = None

    enable_discover_code: Annotated[
        Optional[bool], pydantic.Field(alias="enableDiscoverCode")
    ] = None

    @field_serializer("discover_method")
    def serialize_discover_method(self, value):
        if isinstance(value, str):
            try:
                return models.RestAuthenticationBasicRestDiscoveryDiscoverTypeHTTPDiscoverMethodGetDiscoverMethod(
                    value
                )
            except ValueError:
                return value
        return value

    @field_serializer("discover_type")
    def serialize_discover_type(self, value):
        if isinstance(value, str):
            try:
                return models.RestAuthenticationBasicRestDiscoveryDiscoverTypeHTTPDiscoverMethodGetDiscoverType(
                    value
                )
            except ValueError:
                return value
        return value

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(
            [
                "discoverRequestParams",
                "discoverVerb",
                "discoverBody",
                "discoverRequestHeaders",
                "pagination",
                "discoverDataField",
                "enableStrictDiscoverParsing",
                "discoverResponseFormat",
                "enableDiscoverCode",
            ]
        )
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


RestAuthenticationBasicRestDiscoveryDiscoverTypeHTTPTypedDict = TypeAliasType(
    "RestAuthenticationBasicRestDiscoveryDiscoverTypeHTTPTypedDict",
    Union[
        RestAuthenticationBasicRestDiscoveryDiscoverTypeHTTPDiscoverMethodGetTypedDict,
        RestAuthenticationBasicRestDiscoveryDiscoverTypeHTTPDiscoverMethodPostTypedDict,
        RestAuthenticationBasicRestDiscoveryDiscoverTypeHTTPDiscoverMethodPostWithBodyTypedDict,
        RestAuthenticationBasicRestDiscoveryDiscoverTypeHTTPDiscoverMethodOtherTypedDict,
    ],
)


class UnknownRestAuthenticationBasicRestDiscoveryDiscoverTypeHTTP(BaseModel):
    r"""A RestAuthenticationBasicRestDiscoveryDiscoverTypeHTTP variant the SDK doesn't recognize. Preserves the raw payload."""

    discover_method: Literal["UNKNOWN"] = "UNKNOWN"
    raw: Any
    is_unknown: Literal[True] = True

    model_config = ConfigDict(frozen=True)


_REST_AUTHENTICATION_BASIC_REST_DISCOVERY_DISCOVER_TYPE_HTTP_VARIANTS: dict[
    str, Any
] = {
    "get": RestAuthenticationBasicRestDiscoveryDiscoverTypeHTTPDiscoverMethodGet,
    "post": RestAuthenticationBasicRestDiscoveryDiscoverTypeHTTPDiscoverMethodPost,
    "post_with_body": RestAuthenticationBasicRestDiscoveryDiscoverTypeHTTPDiscoverMethodPostWithBody,
    "other": RestAuthenticationBasicRestDiscoveryDiscoverTypeHTTPDiscoverMethodOther,
}


RestAuthenticationBasicRestDiscoveryDiscoverTypeHTTP = Annotated[
    Union[
        RestAuthenticationBasicRestDiscoveryDiscoverTypeHTTPDiscoverMethodGet,
        RestAuthenticationBasicRestDiscoveryDiscoverTypeHTTPDiscoverMethodPost,
        RestAuthenticationBasicRestDiscoveryDiscoverTypeHTTPDiscoverMethodPostWithBody,
        RestAuthenticationBasicRestDiscoveryDiscoverTypeHTTPDiscoverMethodOther,
        UnknownRestAuthenticationBasicRestDiscoveryDiscoverTypeHTTP,
    ],
    BeforeValidator(
        partial(
            parse_open_union,
            disc_key="discoverMethod",
            variants=_REST_AUTHENTICATION_BASIC_REST_DISCOVERY_DISCOVER_TYPE_HTTP_VARIANTS,
            unknown_cls=UnknownRestAuthenticationBasicRestDiscoveryDiscoverTypeHTTP,
            union_name="RestAuthenticationBasicRestDiscoveryDiscoverTypeHTTP",
        )
    ),
]


RestAuthenticationBasicDiscoveryTypedDict = TypeAliasType(
    "RestAuthenticationBasicDiscoveryTypedDict",
    Union[
        RestAuthenticationBasicRestDiscoveryDiscoverTypeNoneTypedDict,
        RestAuthenticationBasicRestDiscoveryDiscoverTypeListTypedDict,
        RestAuthenticationBasicRestDiscoveryDiscoverTypeJSONTypedDict,
        RestAuthenticationBasicRestDiscoveryDiscoverTypeHTTPTypedDict,
    ],
)


class UnknownRestAuthenticationBasicDiscovery(BaseModel):
    r"""A RestAuthenticationBasicDiscovery variant the SDK doesn't recognize. Preserves the raw payload."""

    discover_type: Literal["UNKNOWN"] = "UNKNOWN"
    raw: Any
    is_unknown: Literal[True] = True

    model_config = ConfigDict(frozen=True)


_REST_AUTHENTICATION_BASIC_DISCOVERY_VARIANTS: dict[str, Any] = {
    "http": RestAuthenticationBasicRestDiscoveryDiscoverTypeHTTP,
    "json": RestAuthenticationBasicRestDiscoveryDiscoverTypeJSON,
    "list": RestAuthenticationBasicRestDiscoveryDiscoverTypeList,
    "none": RestAuthenticationBasicRestDiscoveryDiscoverTypeNone,
}


RestAuthenticationBasicDiscovery = Annotated[
    Union[
        RestAuthenticationBasicRestDiscoveryDiscoverTypeHTTP,
        RestAuthenticationBasicRestDiscoveryDiscoverTypeJSON,
        RestAuthenticationBasicRestDiscoveryDiscoverTypeList,
        RestAuthenticationBasicRestDiscoveryDiscoverTypeNone,
        UnknownRestAuthenticationBasicDiscovery,
    ],
    BeforeValidator(
        partial(
            parse_open_union,
            disc_key="discoverType",
            variants=_REST_AUTHENTICATION_BASIC_DISCOVERY_VARIANTS,
            unknown_cls=UnknownRestAuthenticationBasicDiscovery,
            union_name="RestAuthenticationBasicDiscovery",
        )
    ),
]


class RestAuthenticationBasicCollectMethod(str, Enum, metaclass=utils.OpenEnumMeta):
    # GET
    GET = "get"
    # POST
    POST = "post"
    # POST with Body
    POST_WITH_BODY = "post_with_body"
    # Other
    OTHER = "other"


class RestAuthenticationBasicRestPaginationTypeRequestPageTypedDict(TypedDict):
    type: PaginationOptionsRestDiscoveryDiscoverTypeHTTPPagination
    page_field: str
    r"""Query string parameter that sets the page index to be returned. Example: /api/v1/query?term=cribl&page_size=100&page_number=0"""
    size_field: str
    r"""Query string parameter that sets the number of records retrieved per request. Example: /api/v1/query?term=cribl&page_size=100&page_number=0"""
    size: float
    r"""Maximum number of records to collect per page"""
    max_pages: float
    r"""Maximum number of pages to retrieve per collection task. Defaults to 50 pages. Set to 0 to retrieve all pages."""
    zero_indexed: bool
    r"""Enable to indicate that the first page in the requested data is at index 0. Disabled by default, which indicates index 1."""
    page: NotRequired[float]
    r"""Page number from which to start request. Defaults to undefined, which will start collection from the first page."""
    total_page_field: NotRequired[str]
    r"""Name of the attribute in the response that contains the total number of pages for the query"""
    total_record_field: NotRequired[str]
    r"""Name of the attribute in the response that contains the total number of records for the query"""


class RestAuthenticationBasicRestPaginationTypeRequestPage(BaseModel):
    type: PaginationOptionsRestDiscoveryDiscoverTypeHTTPPagination

    page_field: Annotated[str, pydantic.Field(alias="pageField")]
    r"""Query string parameter that sets the page index to be returned. Example: /api/v1/query?term=cribl&page_size=100&page_number=0"""

    size_field: Annotated[str, pydantic.Field(alias="sizeField")]
    r"""Query string parameter that sets the number of records retrieved per request. Example: /api/v1/query?term=cribl&page_size=100&page_number=0"""

    size: float
    r"""Maximum number of records to collect per page"""

    max_pages: Annotated[float, pydantic.Field(alias="maxPages")]
    r"""Maximum number of pages to retrieve per collection task. Defaults to 50 pages. Set to 0 to retrieve all pages."""

    zero_indexed: Annotated[bool, pydantic.Field(alias="zeroIndexed")]
    r"""Enable to indicate that the first page in the requested data is at index 0. Disabled by default, which indicates index 1."""

    page: Optional[float] = None
    r"""Page number from which to start request. Defaults to undefined, which will start collection from the first page."""

    total_page_field: Annotated[
        Optional[str], pydantic.Field(alias="totalPageField")
    ] = None
    r"""Name of the attribute in the response that contains the total number of pages for the query"""

    total_record_field: Annotated[
        Optional[str], pydantic.Field(alias="totalRecordField")
    ] = None
    r"""Name of the attribute in the response that contains the total number of records for the query"""

    @field_serializer("type")
    def serialize_type(self, value):
        if isinstance(value, str):
            try:
                return models.PaginationOptionsRestDiscoveryDiscoverTypeHTTPPagination(
                    value
                )
            except ValueError:
                return value
        return value

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(["page", "totalPageField", "totalRecordField"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


class RestAuthenticationBasicRestPaginationTypeRequestOffsetTypedDict(TypedDict):
    type: PaginationOptionsRestDiscoveryDiscoverTypeHTTPPagination
    offset_field: str
    r"""Query string parameter that sets the index from which to begin returning records. Example: /api/v1/query?term=cribl&limit=100&offset=0"""
    limit_field: str
    r"""Query string parameter that sets the number of records retrieved per request. Example: /api/v1/query?term=cribl&limit=100&offset=0"""
    limit: float
    r"""Maximum number of records to collect per request"""
    max_pages: float
    r"""Maximum number of pages to retrieve per collection task. Defaults to 50 pages. Set to 0 to retrieve all pages."""
    zero_indexed: bool
    r"""Enable to indicate that the first page in the requested data is at index 0. Disabled by default, which indicates index 1."""
    offset: NotRequired[float]
    r"""Offset index from which to start request. Defaults to undefined, which will start collection from the first record."""
    total_record_field: NotRequired[str]
    r"""Name of the attribute in the response that contains the total number of records for the query"""


class RestAuthenticationBasicRestPaginationTypeRequestOffset(BaseModel):
    type: PaginationOptionsRestDiscoveryDiscoverTypeHTTPPagination

    offset_field: Annotated[str, pydantic.Field(alias="offsetField")]
    r"""Query string parameter that sets the index from which to begin returning records. Example: /api/v1/query?term=cribl&limit=100&offset=0"""

    limit_field: Annotated[str, pydantic.Field(alias="limitField")]
    r"""Query string parameter that sets the number of records retrieved per request. Example: /api/v1/query?term=cribl&limit=100&offset=0"""

    limit: float
    r"""Maximum number of records to collect per request"""

    max_pages: Annotated[float, pydantic.Field(alias="maxPages")]
    r"""Maximum number of pages to retrieve per collection task. Defaults to 50 pages. Set to 0 to retrieve all pages."""

    zero_indexed: Annotated[bool, pydantic.Field(alias="zeroIndexed")]
    r"""Enable to indicate that the first page in the requested data is at index 0. Disabled by default, which indicates index 1."""

    offset: Optional[float] = None
    r"""Offset index from which to start request. Defaults to undefined, which will start collection from the first record."""

    total_record_field: Annotated[
        Optional[str], pydantic.Field(alias="totalRecordField")
    ] = None
    r"""Name of the attribute in the response that contains the total number of records for the query"""

    @field_serializer("type")
    def serialize_type(self, value):
        if isinstance(value, str):
            try:
                return models.PaginationOptionsRestDiscoveryDiscoverTypeHTTPPagination(
                    value
                )
            except ValueError:
                return value
        return value

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(["offset", "totalRecordField"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


class RestAuthenticationBasicRestPaginationTypeResponseHeaderLinkTypedDict(TypedDict):
    type: PaginationOptionsRestDiscoveryDiscoverTypeHTTPPagination
    next_relation_attribute: str
    r"""Relation name used in the link header that refers to the next page in the result set. Example: rel=\"next\" refers to the next page of results: <https://myHost/nextPage>; rel=\"next\" """
    max_pages: float
    r"""Maximum number of pages to retrieve per collection task. Defaults to 50 pages. Set to 0 to retrieve all pages."""
    cur_relation_attribute: NotRequired[str]
    r"""Relation name used in the link header that refers to the current result set. Example: rel=\"self\" refers to the current page of results: <https://myHost/curPage>; rel=\"self\" """


class RestAuthenticationBasicRestPaginationTypeResponseHeaderLink(BaseModel):
    type: PaginationOptionsRestDiscoveryDiscoverTypeHTTPPagination

    next_relation_attribute: Annotated[
        str, pydantic.Field(alias="nextRelationAttribute")
    ]
    r"""Relation name used in the link header that refers to the next page in the result set. Example: rel=\"next\" refers to the next page of results: <https://myHost/nextPage>; rel=\"next\" """

    max_pages: Annotated[float, pydantic.Field(alias="maxPages")]
    r"""Maximum number of pages to retrieve per collection task. Defaults to 50 pages. Set to 0 to retrieve all pages."""

    cur_relation_attribute: Annotated[
        Optional[str], pydantic.Field(alias="curRelationAttribute")
    ] = None
    r"""Relation name used in the link header that refers to the current result set. Example: rel=\"self\" refers to the current page of results: <https://myHost/curPage>; rel=\"self\" """

    @field_serializer("type")
    def serialize_type(self, value):
        if isinstance(value, str):
            try:
                return models.PaginationOptionsRestDiscoveryDiscoverTypeHTTPPagination(
                    value
                )
            except ValueError:
                return value
        return value

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(["curRelationAttribute"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


class RestAuthenticationBasicRestPaginationTypeResponseHeaderTypedDict(TypedDict):
    type: PaginationOptionsRestDiscoveryDiscoverTypeHTTPPagination
    attribute: List[str]
    r"""Names of attributes within the response that contain next-page information"""
    max_pages: float
    r"""Maximum number of pages to retrieve per collection task. Defaults to 50 pages. Set to 0 to retrieve all pages."""


class RestAuthenticationBasicRestPaginationTypeResponseHeader(BaseModel):
    type: PaginationOptionsRestDiscoveryDiscoverTypeHTTPPagination

    attribute: List[str]
    r"""Names of attributes within the response that contain next-page information"""

    max_pages: Annotated[float, pydantic.Field(alias="maxPages")]
    r"""Maximum number of pages to retrieve per collection task. Defaults to 50 pages. Set to 0 to retrieve all pages."""

    @field_serializer("type")
    def serialize_type(self, value):
        if isinstance(value, str):
            try:
                return models.PaginationOptionsRestDiscoveryDiscoverTypeHTTPPagination(
                    value
                )
            except ValueError:
                return value
        return value


class RestAuthenticationBasicRestPaginationTypeResponseBodyTypedDict(TypedDict):
    type: PaginationOptionsRestDiscoveryDiscoverTypeHTTPPagination
    attribute: List[str]
    r"""Names of attributes within the response that contain next-page information"""
    max_pages: float
    r"""Maximum number of pages to retrieve per collection task. Defaults to 50 pages. Set to 0 to retrieve all pages."""
    last_page_expr: NotRequired[str]
    r"""JavaScript expression used to determine when the last page has been reached. The values tested by this expression must be in the Response attributes section."""


class RestAuthenticationBasicRestPaginationTypeResponseBody(BaseModel):
    type: PaginationOptionsRestDiscoveryDiscoverTypeHTTPPagination

    attribute: List[str]
    r"""Names of attributes within the response that contain next-page information"""

    max_pages: Annotated[float, pydantic.Field(alias="maxPages")]
    r"""Maximum number of pages to retrieve per collection task. Defaults to 50 pages. Set to 0 to retrieve all pages."""

    last_page_expr: Annotated[Optional[str], pydantic.Field(alias="lastPageExpr")] = (
        None
    )
    r"""JavaScript expression used to determine when the last page has been reached. The values tested by this expression must be in the Response attributes section."""

    @field_serializer("type")
    def serialize_type(self, value):
        if isinstance(value, str):
            try:
                return models.PaginationOptionsRestDiscoveryDiscoverTypeHTTPPagination(
                    value
                )
            except ValueError:
                return value
        return value

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(["lastPageExpr"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


class RestAuthenticationBasicRestPaginationTypeNoneTypedDict(TypedDict):
    type: PaginationOptionsRestDiscoveryDiscoverTypeHTTPPagination


class RestAuthenticationBasicRestPaginationTypeNone(BaseModel):
    type: PaginationOptionsRestDiscoveryDiscoverTypeHTTPPagination

    @field_serializer("type")
    def serialize_type(self, value):
        if isinstance(value, str):
            try:
                return models.PaginationOptionsRestDiscoveryDiscoverTypeHTTPPagination(
                    value
                )
            except ValueError:
                return value
        return value


RestAuthenticationBasicPaginationUnionTypedDict = TypeAliasType(
    "RestAuthenticationBasicPaginationUnionTypedDict",
    Union[
        RestAuthenticationBasicRestPaginationTypeNoneTypedDict,
        RestAuthenticationBasicRestPaginationTypeResponseHeaderTypedDict,
        RestAuthenticationBasicRestPaginationTypeResponseBodyTypedDict,
        RestAuthenticationBasicRestPaginationTypeResponseHeaderLinkTypedDict,
        RestAuthenticationBasicRestPaginationTypeRequestOffsetTypedDict,
        RestAuthenticationBasicRestPaginationTypeRequestPageTypedDict,
    ],
)


class UnknownRestAuthenticationBasicPaginationUnion(BaseModel):
    r"""A RestAuthenticationBasicPaginationUnion variant the SDK doesn't recognize. Preserves the raw payload."""

    type: Literal["UNKNOWN"] = "UNKNOWN"
    raw: Any
    is_unknown: Literal[True] = True

    model_config = ConfigDict(frozen=True)


_REST_AUTHENTICATION_BASIC_PAGINATION_UNION_VARIANTS: dict[str, Any] = {
    "none": RestAuthenticationBasicRestPaginationTypeNone,
    "response_body": RestAuthenticationBasicRestPaginationTypeResponseBody,
    "response_header": RestAuthenticationBasicRestPaginationTypeResponseHeader,
    "response_header_link": RestAuthenticationBasicRestPaginationTypeResponseHeaderLink,
    "request_offset": RestAuthenticationBasicRestPaginationTypeRequestOffset,
    "request_page": RestAuthenticationBasicRestPaginationTypeRequestPage,
}


RestAuthenticationBasicPaginationUnion = Annotated[
    Union[
        RestAuthenticationBasicRestPaginationTypeNone,
        RestAuthenticationBasicRestPaginationTypeResponseBody,
        RestAuthenticationBasicRestPaginationTypeResponseHeader,
        RestAuthenticationBasicRestPaginationTypeResponseHeaderLink,
        RestAuthenticationBasicRestPaginationTypeRequestOffset,
        RestAuthenticationBasicRestPaginationTypeRequestPage,
        UnknownRestAuthenticationBasicPaginationUnion,
    ],
    BeforeValidator(
        partial(
            parse_open_union,
            disc_key="type",
            variants=_REST_AUTHENTICATION_BASIC_PAGINATION_UNION_VARIANTS,
            unknown_cls=UnknownRestAuthenticationBasicPaginationUnion,
            union_name="RestAuthenticationBasicPaginationUnion",
        )
    ),
]


class RestAuthenticationBasicRestRetryRulesTypeBackoffTypedDict(TypedDict):
    type: RetryTypeOptionsHealthCheckCollectorConfRetryRules
    r"""The algorithm to use when performing HTTP retries"""
    interval: NotRequired[Any]
    limit: NotRequired[Any]
    multiplier: NotRequired[Any]
    max_interval_ms: NotRequired[Any]
    codes: NotRequired[Any]
    enable_header: NotRequired[Any]
    retry_connect_timeout: NotRequired[Any]
    retry_connect_reset: NotRequired[Any]


class RestAuthenticationBasicRestRetryRulesTypeBackoff(BaseModel):
    type: RetryTypeOptionsHealthCheckCollectorConfRetryRules
    r"""The algorithm to use when performing HTTP retries"""

    interval: Optional[Any] = None

    limit: Optional[Any] = None

    multiplier: Optional[Any] = None

    max_interval_ms: Annotated[Optional[Any], pydantic.Field(alias="maxIntervalMs")] = (
        None
    )

    codes: Optional[Any] = None

    enable_header: Annotated[Optional[Any], pydantic.Field(alias="enableHeader")] = None

    retry_connect_timeout: Annotated[
        Optional[Any], pydantic.Field(alias="retryConnectTimeout")
    ] = None

    retry_connect_reset: Annotated[
        Optional[Any], pydantic.Field(alias="retryConnectReset")
    ] = None

    @field_serializer("type")
    def serialize_type(self, value):
        if isinstance(value, str):
            try:
                return models.RetryTypeOptionsHealthCheckCollectorConfRetryRules(value)
            except ValueError:
                return value
        return value

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(
            [
                "interval",
                "limit",
                "multiplier",
                "maxIntervalMs",
                "codes",
                "enableHeader",
                "retryConnectTimeout",
                "retryConnectReset",
            ]
        )
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


class RestAuthenticationBasicRestRetryRulesTypeStaticTypedDict(TypedDict):
    type: RetryTypeOptionsHealthCheckCollectorConfRetryRules
    r"""The algorithm to use when performing HTTP retries"""
    interval: NotRequired[Any]
    limit: NotRequired[Any]
    codes: NotRequired[Any]
    enable_header: NotRequired[Any]
    retry_connect_timeout: NotRequired[Any]
    retry_connect_reset: NotRequired[Any]
    multiplier: NotRequired[Any]
    max_interval_ms: NotRequired[Any]


class RestAuthenticationBasicRestRetryRulesTypeStatic(BaseModel):
    type: RetryTypeOptionsHealthCheckCollectorConfRetryRules
    r"""The algorithm to use when performing HTTP retries"""

    interval: Optional[Any] = None

    limit: Optional[Any] = None

    codes: Optional[Any] = None

    enable_header: Annotated[Optional[Any], pydantic.Field(alias="enableHeader")] = None

    retry_connect_timeout: Annotated[
        Optional[Any], pydantic.Field(alias="retryConnectTimeout")
    ] = None

    retry_connect_reset: Annotated[
        Optional[Any], pydantic.Field(alias="retryConnectReset")
    ] = None

    multiplier: Optional[Any] = None

    max_interval_ms: Annotated[Optional[Any], pydantic.Field(alias="maxIntervalMs")] = (
        None
    )

    @field_serializer("type")
    def serialize_type(self, value):
        if isinstance(value, str):
            try:
                return models.RetryTypeOptionsHealthCheckCollectorConfRetryRules(value)
            except ValueError:
                return value
        return value

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(
            [
                "interval",
                "limit",
                "codes",
                "enableHeader",
                "retryConnectTimeout",
                "retryConnectReset",
                "multiplier",
                "maxIntervalMs",
            ]
        )
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


class RestAuthenticationBasicRestRetryRulesTypeNoneTypedDict(TypedDict):
    type: RetryTypeOptionsHealthCheckCollectorConfRetryRules
    r"""The algorithm to use when performing HTTP retries"""
    interval: NotRequired[Any]
    limit: NotRequired[Any]
    multiplier: NotRequired[Any]
    max_interval_ms: NotRequired[Any]
    codes: NotRequired[Any]
    enable_header: NotRequired[Any]
    retry_connect_timeout: NotRequired[Any]
    retry_connect_reset: NotRequired[Any]


class RestAuthenticationBasicRestRetryRulesTypeNone(BaseModel):
    type: RetryTypeOptionsHealthCheckCollectorConfRetryRules
    r"""The algorithm to use when performing HTTP retries"""

    interval: Optional[Any] = None

    limit: Optional[Any] = None

    multiplier: Optional[Any] = None

    max_interval_ms: Annotated[Optional[Any], pydantic.Field(alias="maxIntervalMs")] = (
        None
    )

    codes: Optional[Any] = None

    enable_header: Annotated[Optional[Any], pydantic.Field(alias="enableHeader")] = None

    retry_connect_timeout: Annotated[
        Optional[Any], pydantic.Field(alias="retryConnectTimeout")
    ] = None

    retry_connect_reset: Annotated[
        Optional[Any], pydantic.Field(alias="retryConnectReset")
    ] = None

    @field_serializer("type")
    def serialize_type(self, value):
        if isinstance(value, str):
            try:
                return models.RetryTypeOptionsHealthCheckCollectorConfRetryRules(value)
            except ValueError:
                return value
        return value

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(
            [
                "interval",
                "limit",
                "multiplier",
                "maxIntervalMs",
                "codes",
                "enableHeader",
                "retryConnectTimeout",
                "retryConnectReset",
            ]
        )
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


RestAuthenticationBasicRetryRulesTypedDict = TypeAliasType(
    "RestAuthenticationBasicRetryRulesTypedDict",
    Union[
        RestAuthenticationBasicRestRetryRulesTypeNoneTypedDict,
        RestAuthenticationBasicRestRetryRulesTypeStaticTypedDict,
        RestAuthenticationBasicRestRetryRulesTypeBackoffTypedDict,
    ],
)


class UnknownRestAuthenticationBasicRetryRules(BaseModel):
    r"""A RestAuthenticationBasicRetryRules variant the SDK doesn't recognize. Preserves the raw payload."""

    type: Literal["UNKNOWN"] = "UNKNOWN"
    raw: Any
    is_unknown: Literal[True] = True

    model_config = ConfigDict(frozen=True)


_REST_AUTHENTICATION_BASIC_RETRY_RULES_VARIANTS: dict[str, Any] = {
    "none": RestAuthenticationBasicRestRetryRulesTypeNone,
    "static": RestAuthenticationBasicRestRetryRulesTypeStatic,
    "backoff": RestAuthenticationBasicRestRetryRulesTypeBackoff,
}


RestAuthenticationBasicRetryRules = Annotated[
    Union[
        RestAuthenticationBasicRestRetryRulesTypeNone,
        RestAuthenticationBasicRestRetryRulesTypeStatic,
        RestAuthenticationBasicRestRetryRulesTypeBackoff,
        UnknownRestAuthenticationBasicRetryRules,
    ],
    BeforeValidator(
        partial(
            parse_open_union,
            disc_key="type",
            variants=_REST_AUTHENTICATION_BASIC_RETRY_RULES_VARIANTS,
            unknown_cls=UnknownRestAuthenticationBasicRetryRules,
            union_name="RestAuthenticationBasicRetryRules",
        )
    ),
]


class RestAuthenticationBasicStateTrackingTypedDict(TypedDict):
    enabled: NotRequired[bool]
    r"""Track collection progress between consecutive scheduled executions"""


class RestAuthenticationBasicStateTracking(BaseModel):
    enabled: Optional[bool] = None
    r"""Track collection progress between consecutive scheduled executions"""

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(["enabled"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


class RestAuthenticationBasicSchedulingTypedDict(TypedDict):
    state_tracking: NotRequired[RestAuthenticationBasicStateTrackingTypedDict]


class RestAuthenticationBasicScheduling(BaseModel):
    state_tracking: Annotated[
        Optional[RestAuthenticationBasicStateTracking],
        pydantic.Field(alias="stateTracking"),
    ] = None

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(["stateTracking"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


class RestAuthenticationBasicTypedDict(TypedDict):
    authentication: RestAuthenticationBasicAuthentication
    r"""Authentication method for Discover and Collect REST calls. You can specify API key–based authentication by adding the appropriate Collect headers."""
    username: str
    password: str
    collect_url: str
    r"""URL (constant or JavaScript expression) to use for the Collect operation"""
    collect_method: RestAuthenticationBasicCollectMethod
    discovery: NotRequired[RestAuthenticationBasicDiscoveryTypedDict]
    collect_verb: NotRequired[Any]
    collect_request_params: NotRequired[Any]
    collect_body: NotRequired[Any]
    collect_request_headers: NotRequired[
        List[ItemsTypeRestCollectMethodGetCollectRequestParamsTypedDict]
    ]
    pagination: NotRequired[RestAuthenticationBasicPaginationUnionTypedDict]
    timeout: NotRequired[float]
    r"""HTTP request inactivity timeout. Use 0 to disable."""
    use_round_robin_dns: NotRequired[bool]
    r"""Use round-robin DNS lookup. Suitable when DNS server returns multiple addresses in sort order."""
    disable_time_filter: NotRequired[bool]
    r"""Disable Collector event time filtering when a date range is specified"""
    decode_url: NotRequired[bool]
    r"""Decode the URL before sending requests (including pagination requests)"""
    reject_unauthorized: NotRequired[bool]
    r"""Reject certificates that cannot be verified against a valid CA (such as self-signed certificates)"""
    capture_headers: NotRequired[bool]
    r"""Enable to add response headers to the resHeaders field under the __collectible object"""
    stop_on_empty_results: NotRequired[bool]
    r"""Stop pagination when the Event Breaker produces no events"""
    safe_headers: NotRequired[List[str]]
    r"""List of headers that are safe to log in plain text"""
    retry_rules: NotRequired[RestAuthenticationBasicRetryRulesTypedDict]
    scheduling: NotRequired[RestAuthenticationBasicSchedulingTypedDict]


class RestAuthenticationBasic(BaseModel):
    authentication: RestAuthenticationBasicAuthentication
    r"""Authentication method for Discover and Collect REST calls. You can specify API key–based authentication by adding the appropriate Collect headers."""

    username: str

    password: str

    collect_url: Annotated[str, pydantic.Field(alias="collectUrl")]
    r"""URL (constant or JavaScript expression) to use for the Collect operation"""

    collect_method: Annotated[
        RestAuthenticationBasicCollectMethod, pydantic.Field(alias="collectMethod")
    ]

    discovery: Optional[RestAuthenticationBasicDiscovery] = None

    collect_verb: Annotated[Optional[Any], pydantic.Field(alias="collectVerb")] = None

    collect_request_params: Annotated[
        Optional[Any], pydantic.Field(alias="collectRequestParams")
    ] = None

    collect_body: Annotated[Optional[Any], pydantic.Field(alias="collectBody")] = None

    collect_request_headers: Annotated[
        Optional[List[ItemsTypeRestCollectMethodGetCollectRequestParams]],
        pydantic.Field(alias="collectRequestHeaders"),
    ] = None

    pagination: Optional[RestAuthenticationBasicPaginationUnion] = None

    timeout: Optional[float] = None
    r"""HTTP request inactivity timeout. Use 0 to disable."""

    use_round_robin_dns: Annotated[
        Optional[bool], pydantic.Field(alias="useRoundRobinDns")
    ] = None
    r"""Use round-robin DNS lookup. Suitable when DNS server returns multiple addresses in sort order."""

    disable_time_filter: Annotated[
        Optional[bool], pydantic.Field(alias="disableTimeFilter")
    ] = None
    r"""Disable Collector event time filtering when a date range is specified"""

    decode_url: Annotated[Optional[bool], pydantic.Field(alias="decodeUrl")] = None
    r"""Decode the URL before sending requests (including pagination requests)"""

    reject_unauthorized: Annotated[
        Optional[bool], pydantic.Field(alias="rejectUnauthorized")
    ] = None
    r"""Reject certificates that cannot be verified against a valid CA (such as self-signed certificates)"""

    capture_headers: Annotated[
        Optional[bool], pydantic.Field(alias="captureHeaders")
    ] = None
    r"""Enable to add response headers to the resHeaders field under the __collectible object"""

    stop_on_empty_results: Annotated[
        Optional[bool], pydantic.Field(alias="stopOnEmptyResults")
    ] = None
    r"""Stop pagination when the Event Breaker produces no events"""

    safe_headers: Annotated[
        Optional[List[str]], pydantic.Field(alias="safeHeaders")
    ] = None
    r"""List of headers that are safe to log in plain text"""

    retry_rules: Annotated[
        Optional[RestAuthenticationBasicRetryRules], pydantic.Field(alias="retryRules")
    ] = None

    scheduling: Annotated[
        Optional[RestAuthenticationBasicScheduling],
        pydantic.Field(alias="__scheduling"),
    ] = None

    @field_serializer("authentication")
    def serialize_authentication(self, value):
        if isinstance(value, str):
            try:
                return models.RestAuthenticationBasicAuthentication(value)
            except ValueError:
                return value
        return value

    @field_serializer("collect_method")
    def serialize_collect_method(self, value):
        if isinstance(value, str):
            try:
                return models.RestAuthenticationBasicCollectMethod(value)
            except ValueError:
                return value
        return value

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(
            [
                "discovery",
                "collectVerb",
                "collectRequestParams",
                "collectBody",
                "collectRequestHeaders",
                "pagination",
                "timeout",
                "useRoundRobinDns",
                "disableTimeFilter",
                "decodeUrl",
                "rejectUnauthorized",
                "captureHeaders",
                "stopOnEmptyResults",
                "safeHeaders",
                "retryRules",
                "__scheduling",
            ]
        )
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


class RestAuthenticationNoneAuthentication(str, Enum, metaclass=utils.OpenEnumMeta):
    r"""Authentication method for Discover and Collect REST calls. You can specify API key–based authentication by adding the appropriate Collect headers."""

    NONE = "none"
    BASIC = "basic"
    BASIC_SECRET = "basicSecret"
    LOGIN = "login"
    LOGIN_SECRET = "loginSecret"
    OAUTH = "oauth"
    OAUTH_SECRET = "oauthSecret"
    GOOGLE_OAUTH = "google_oauth"
    GOOGLE_OAUTH_SECRET = "google_oauthSecret"
    HMAC = "hmac"


class RestAuthenticationNoneRestDiscoveryDiscoverTypeNoneDiscoverType(
    str, Enum, metaclass=utils.OpenEnumMeta
):
    r"""Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task."""

    HTTP = "http"
    JSON = "json"
    LIST = "list"
    NONE = "none"


class RestAuthenticationNoneRestDiscoveryDiscoverTypeNoneTypedDict(TypedDict):
    discover_type: RestAuthenticationNoneRestDiscoveryDiscoverTypeNoneDiscoverType
    r"""Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task."""


class RestAuthenticationNoneRestDiscoveryDiscoverTypeNone(BaseModel):
    discover_type: Annotated[
        RestAuthenticationNoneRestDiscoveryDiscoverTypeNoneDiscoverType,
        pydantic.Field(alias="discoverType"),
    ]
    r"""Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task."""

    @field_serializer("discover_type")
    def serialize_discover_type(self, value):
        if isinstance(value, str):
            try:
                return models.RestAuthenticationNoneRestDiscoveryDiscoverTypeNoneDiscoverType(
                    value
                )
            except ValueError:
                return value
        return value


class RestAuthenticationNoneRestDiscoveryDiscoverTypeListDiscoverType(
    str, Enum, metaclass=utils.OpenEnumMeta
):
    r"""Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task."""

    HTTP = "http"
    JSON = "json"
    LIST = "list"
    NONE = "none"


class RestAuthenticationNoneRestDiscoveryDiscoverTypeListTypedDict(TypedDict):
    discover_type: RestAuthenticationNoneRestDiscoveryDiscoverTypeListDiscoverType
    r"""Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task."""
    item_list: List[str]
    r"""Comma-separated list of items to return from the Discover task. Each item returned generates a Collect task and can be referenced using `${id}` in the Collect URL, headers, or parameters."""


class RestAuthenticationNoneRestDiscoveryDiscoverTypeList(BaseModel):
    discover_type: Annotated[
        RestAuthenticationNoneRestDiscoveryDiscoverTypeListDiscoverType,
        pydantic.Field(alias="discoverType"),
    ]
    r"""Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task."""

    item_list: Annotated[List[str], pydantic.Field(alias="itemList")]
    r"""Comma-separated list of items to return from the Discover task. Each item returned generates a Collect task and can be referenced using `${id}` in the Collect URL, headers, or parameters."""

    @field_serializer("discover_type")
    def serialize_discover_type(self, value):
        if isinstance(value, str):
            try:
                return models.RestAuthenticationNoneRestDiscoveryDiscoverTypeListDiscoverType(
                    value
                )
            except ValueError:
                return value
        return value


class RestAuthenticationNoneRestDiscoveryDiscoverTypeJSONDiscoverType(
    str, Enum, metaclass=utils.OpenEnumMeta
):
    r"""Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task."""

    HTTP = "http"
    JSON = "json"
    LIST = "list"
    NONE = "none"


class RestAuthenticationNoneRestDiscoveryDiscoverTypeJSONTypedDict(TypedDict):
    discover_type: RestAuthenticationNoneRestDiscoveryDiscoverTypeJSONDiscoverType
    r"""Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task."""
    manual_discover_result: str
    r"""Allows hard-coding the Discover result. Must be a JSON object or array. Works with Discover data field."""
    discover_data_field: NotRequired[str]
    r"""Within the response JSON, the name of the field to pull results from, typically a JSON array. Leave blank if the result itself is an array of values. Sample entry: items, json: { items: [{id: 'first'},{id: 'second'}] }"""


class RestAuthenticationNoneRestDiscoveryDiscoverTypeJSON(BaseModel):
    discover_type: Annotated[
        RestAuthenticationNoneRestDiscoveryDiscoverTypeJSONDiscoverType,
        pydantic.Field(alias="discoverType"),
    ]
    r"""Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task."""

    manual_discover_result: Annotated[str, pydantic.Field(alias="manualDiscoverResult")]
    r"""Allows hard-coding the Discover result. Must be a JSON object or array. Works with Discover data field."""

    discover_data_field: Annotated[
        Optional[str], pydantic.Field(alias="discoverDataField")
    ] = None
    r"""Within the response JSON, the name of the field to pull results from, typically a JSON array. Leave blank if the result itself is an array of values. Sample entry: items, json: { items: [{id: 'first'},{id: 'second'}] }"""

    @field_serializer("discover_type")
    def serialize_discover_type(self, value):
        if isinstance(value, str):
            try:
                return models.RestAuthenticationNoneRestDiscoveryDiscoverTypeJSONDiscoverType(
                    value
                )
            except ValueError:
                return value
        return value

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(["discoverDataField"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


class RestAuthenticationNoneRestDiscoveryDiscoverTypeHTTPDiscoverMethodOtherDiscoverMethod(
    str, Enum, metaclass=utils.OpenEnumMeta
):
    # GET
    GET = "get"
    # POST
    POST = "post"
    # POST with Body
    POST_WITH_BODY = "post_with_body"
    # Other
    OTHER = "other"


class RestAuthenticationNoneRestDiscoveryDiscoverTypeHTTPDiscoverMethodOtherDiscoverType(
    str, Enum, metaclass=utils.OpenEnumMeta
):
    r"""Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task."""

    HTTP = "http"
    JSON = "json"
    LIST = "list"
    NONE = "none"


class RestAuthenticationNoneRestDiscoveryDiscoverTypeHTTPDiscoverMethodOtherPaginationTypedDict(
    TypedDict
):
    type: PaginationOptionsRestDiscoveryDiscoverTypeHTTPPagination


class RestAuthenticationNoneRestDiscoveryDiscoverTypeHTTPDiscoverMethodOtherPagination(
    BaseModel
):
    type: PaginationOptionsRestDiscoveryDiscoverTypeHTTPPagination

    @field_serializer("type")
    def serialize_type(self, value):
        if isinstance(value, str):
            try:
                return models.PaginationOptionsRestDiscoveryDiscoverTypeHTTPPagination(
                    value
                )
            except ValueError:
                return value
        return value


class RestAuthenticationNoneRestDiscoveryDiscoverTypeHTTPDiscoverMethodOtherTypedDict(
    TypedDict
):
    discover_method: RestAuthenticationNoneRestDiscoveryDiscoverTypeHTTPDiscoverMethodOtherDiscoverMethod
    discover_verb: Any
    discover_type: RestAuthenticationNoneRestDiscoveryDiscoverTypeHTTPDiscoverMethodOtherDiscoverType
    r"""Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task."""
    discover_url: str
    r"""URL to use for the Discover operation. Can be a constant URL, or a JavaScript expression to derive the URL."""
    discover_body: NotRequired[Any]
    discover_request_params: NotRequired[Any]
    discover_request_headers: NotRequired[
        List[ItemsTypeRestCollectMethodGetCollectRequestParamsTypedDict]
    ]
    pagination: NotRequired[
        RestAuthenticationNoneRestDiscoveryDiscoverTypeHTTPDiscoverMethodOtherPaginationTypedDict
    ]
    discover_data_field: NotRequired[str]
    r"""Path to field in the response object that contains discovery results (ex: level1.name). Leave blank if the result is an array."""
    enable_strict_discover_parsing: NotRequired[bool]
    r"""Explicitly set the discover response format. When disabled, best effort parsing is used."""
    discover_response_format: NotRequired[Any]
    enable_discover_code: NotRequired[bool]


class RestAuthenticationNoneRestDiscoveryDiscoverTypeHTTPDiscoverMethodOther(BaseModel):
    discover_method: Annotated[
        RestAuthenticationNoneRestDiscoveryDiscoverTypeHTTPDiscoverMethodOtherDiscoverMethod,
        pydantic.Field(alias="discoverMethod"),
    ]

    discover_verb: Annotated[Any, pydantic.Field(alias="discoverVerb")]

    discover_type: Annotated[
        RestAuthenticationNoneRestDiscoveryDiscoverTypeHTTPDiscoverMethodOtherDiscoverType,
        pydantic.Field(alias="discoverType"),
    ]
    r"""Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task."""

    discover_url: Annotated[str, pydantic.Field(alias="discoverUrl")]
    r"""URL to use for the Discover operation. Can be a constant URL, or a JavaScript expression to derive the URL."""

    discover_body: Annotated[Optional[Any], pydantic.Field(alias="discoverBody")] = None

    discover_request_params: Annotated[
        Optional[Any], pydantic.Field(alias="discoverRequestParams")
    ] = None

    discover_request_headers: Annotated[
        Optional[List[ItemsTypeRestCollectMethodGetCollectRequestParams]],
        pydantic.Field(alias="discoverRequestHeaders"),
    ] = None

    pagination: Optional[
        RestAuthenticationNoneRestDiscoveryDiscoverTypeHTTPDiscoverMethodOtherPagination
    ] = None

    discover_data_field: Annotated[
        Optional[str], pydantic.Field(alias="discoverDataField")
    ] = None
    r"""Path to field in the response object that contains discovery results (ex: level1.name). Leave blank if the result is an array."""

    enable_strict_discover_parsing: Annotated[
        Optional[bool], pydantic.Field(alias="enableStrictDiscoverParsing")
    ] = None
    r"""Explicitly set the discover response format. When disabled, best effort parsing is used."""

    discover_response_format: Annotated[
        Optional[Any], pydantic.Field(alias="discoverResponseFormat")
    ] = None

    enable_discover_code: Annotated[
        Optional[bool], pydantic.Field(alias="enableDiscoverCode")
    ] = None

    @field_serializer("discover_method")
    def serialize_discover_method(self, value):
        if isinstance(value, str):
            try:
                return models.RestAuthenticationNoneRestDiscoveryDiscoverTypeHTTPDiscoverMethodOtherDiscoverMethod(
                    value
                )
            except ValueError:
                return value
        return value

    @field_serializer("discover_type")
    def serialize_discover_type(self, value):
        if isinstance(value, str):
            try:
                return models.RestAuthenticationNoneRestDiscoveryDiscoverTypeHTTPDiscoverMethodOtherDiscoverType(
                    value
                )
            except ValueError:
                return value
        return value

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(
            [
                "discoverBody",
                "discoverRequestParams",
                "discoverRequestHeaders",
                "pagination",
                "discoverDataField",
                "enableStrictDiscoverParsing",
                "discoverResponseFormat",
                "enableDiscoverCode",
            ]
        )
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


class RestAuthenticationNoneRestDiscoveryDiscoverTypeHTTPDiscoverMethodPostWithBodyDiscoverMethod(
    str, Enum, metaclass=utils.OpenEnumMeta
):
    # GET
    GET = "get"
    # POST
    POST = "post"
    # POST with Body
    POST_WITH_BODY = "post_with_body"
    # Other
    OTHER = "other"


class RestAuthenticationNoneRestDiscoveryDiscoverTypeHTTPDiscoverMethodPostWithBodyDiscoverType(
    str, Enum, metaclass=utils.OpenEnumMeta
):
    r"""Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task."""

    HTTP = "http"
    JSON = "json"
    LIST = "list"
    NONE = "none"


class RestAuthenticationNoneRestDiscoveryDiscoverTypeHTTPDiscoverMethodPostWithBodyPaginationTypedDict(
    TypedDict
):
    type: PaginationOptionsRestDiscoveryDiscoverTypeHTTPPagination


class RestAuthenticationNoneRestDiscoveryDiscoverTypeHTTPDiscoverMethodPostWithBodyPagination(
    BaseModel
):
    type: PaginationOptionsRestDiscoveryDiscoverTypeHTTPPagination

    @field_serializer("type")
    def serialize_type(self, value):
        if isinstance(value, str):
            try:
                return models.PaginationOptionsRestDiscoveryDiscoverTypeHTTPPagination(
                    value
                )
            except ValueError:
                return value
        return value


class RestAuthenticationNoneRestDiscoveryDiscoverTypeHTTPDiscoverMethodPostWithBodyTypedDict(
    TypedDict
):
    discover_method: RestAuthenticationNoneRestDiscoveryDiscoverTypeHTTPDiscoverMethodPostWithBodyDiscoverMethod
    discover_body: Any
    discover_type: RestAuthenticationNoneRestDiscoveryDiscoverTypeHTTPDiscoverMethodPostWithBodyDiscoverType
    r"""Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task."""
    discover_url: str
    r"""URL to use for the Discover operation. Can be a constant URL, or a JavaScript expression to derive the URL."""
    discover_verb: NotRequired[Any]
    discover_request_params: NotRequired[Any]
    discover_request_headers: NotRequired[
        List[ItemsTypeRestCollectMethodGetCollectRequestParamsTypedDict]
    ]
    pagination: NotRequired[
        RestAuthenticationNoneRestDiscoveryDiscoverTypeHTTPDiscoverMethodPostWithBodyPaginationTypedDict
    ]
    discover_data_field: NotRequired[str]
    r"""Path to field in the response object that contains discovery results (ex: level1.name). Leave blank if the result is an array."""
    enable_strict_discover_parsing: NotRequired[bool]
    r"""Explicitly set the discover response format. When disabled, best effort parsing is used."""
    discover_response_format: NotRequired[Any]
    enable_discover_code: NotRequired[bool]


class RestAuthenticationNoneRestDiscoveryDiscoverTypeHTTPDiscoverMethodPostWithBody(
    BaseModel
):
    discover_method: Annotated[
        RestAuthenticationNoneRestDiscoveryDiscoverTypeHTTPDiscoverMethodPostWithBodyDiscoverMethod,
        pydantic.Field(alias="discoverMethod"),
    ]

    discover_body: Annotated[Any, pydantic.Field(alias="discoverBody")]

    discover_type: Annotated[
        RestAuthenticationNoneRestDiscoveryDiscoverTypeHTTPDiscoverMethodPostWithBodyDiscoverType,
        pydantic.Field(alias="discoverType"),
    ]
    r"""Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task."""

    discover_url: Annotated[str, pydantic.Field(alias="discoverUrl")]
    r"""URL to use for the Discover operation. Can be a constant URL, or a JavaScript expression to derive the URL."""

    discover_verb: Annotated[Optional[Any], pydantic.Field(alias="discoverVerb")] = None

    discover_request_params: Annotated[
        Optional[Any], pydantic.Field(alias="discoverRequestParams")
    ] = None

    discover_request_headers: Annotated[
        Optional[List[ItemsTypeRestCollectMethodGetCollectRequestParams]],
        pydantic.Field(alias="discoverRequestHeaders"),
    ] = None

    pagination: Optional[
        RestAuthenticationNoneRestDiscoveryDiscoverTypeHTTPDiscoverMethodPostWithBodyPagination
    ] = None

    discover_data_field: Annotated[
        Optional[str], pydantic.Field(alias="discoverDataField")
    ] = None
    r"""Path to field in the response object that contains discovery results (ex: level1.name). Leave blank if the result is an array."""

    enable_strict_discover_parsing: Annotated[
        Optional[bool], pydantic.Field(alias="enableStrictDiscoverParsing")
    ] = None
    r"""Explicitly set the discover response format. When disabled, best effort parsing is used."""

    discover_response_format: Annotated[
        Optional[Any], pydantic.Field(alias="discoverResponseFormat")
    ] = None

    enable_discover_code: Annotated[
        Optional[bool], pydantic.Field(alias="enableDiscoverCode")
    ] = None

    @field_serializer("discover_method")
    def serialize_discover_method(self, value):
        if isinstance(value, str):
            try:
                return models.RestAuthenticationNoneRestDiscoveryDiscoverTypeHTTPDiscoverMethodPostWithBodyDiscoverMethod(
                    value
                )
            except ValueError:
                return value
        return value

    @field_serializer("discover_type")
    def serialize_discover_type(self, value):
        if isinstance(value, str):
            try:
                return models.RestAuthenticationNoneRestDiscoveryDiscoverTypeHTTPDiscoverMethodPostWithBodyDiscoverType(
                    value
                )
            except ValueError:
                return value
        return value

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(
            [
                "discoverVerb",
                "discoverRequestParams",
                "discoverRequestHeaders",
                "pagination",
                "discoverDataField",
                "enableStrictDiscoverParsing",
                "discoverResponseFormat",
                "enableDiscoverCode",
            ]
        )
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


class RestAuthenticationNoneRestDiscoveryDiscoverTypeHTTPDiscoverMethodPostDiscoverMethod(
    str, Enum, metaclass=utils.OpenEnumMeta
):
    # GET
    GET = "get"
    # POST
    POST = "post"
    # POST with Body
    POST_WITH_BODY = "post_with_body"
    # Other
    OTHER = "other"


class RestAuthenticationNoneRestDiscoveryDiscoverTypeHTTPDiscoverMethodPostDiscoverType(
    str, Enum, metaclass=utils.OpenEnumMeta
):
    r"""Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task."""

    HTTP = "http"
    JSON = "json"
    LIST = "list"
    NONE = "none"


class RestAuthenticationNoneRestDiscoveryDiscoverTypeHTTPDiscoverMethodPostPaginationTypedDict(
    TypedDict
):
    type: PaginationOptionsRestDiscoveryDiscoverTypeHTTPPagination


class RestAuthenticationNoneRestDiscoveryDiscoverTypeHTTPDiscoverMethodPostPagination(
    BaseModel
):
    type: PaginationOptionsRestDiscoveryDiscoverTypeHTTPPagination

    @field_serializer("type")
    def serialize_type(self, value):
        if isinstance(value, str):
            try:
                return models.PaginationOptionsRestDiscoveryDiscoverTypeHTTPPagination(
                    value
                )
            except ValueError:
                return value
        return value


class RestAuthenticationNoneRestDiscoveryDiscoverTypeHTTPDiscoverMethodPostTypedDict(
    TypedDict
):
    discover_method: RestAuthenticationNoneRestDiscoveryDiscoverTypeHTTPDiscoverMethodPostDiscoverMethod
    discover_type: RestAuthenticationNoneRestDiscoveryDiscoverTypeHTTPDiscoverMethodPostDiscoverType
    r"""Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task."""
    discover_url: str
    r"""URL to use for the Discover operation. Can be a constant URL, or a JavaScript expression to derive the URL."""
    discover_request_params: NotRequired[Any]
    discover_verb: NotRequired[Any]
    discover_body: NotRequired[Any]
    discover_request_headers: NotRequired[
        List[ItemsTypeRestCollectMethodGetCollectRequestParamsTypedDict]
    ]
    pagination: NotRequired[
        RestAuthenticationNoneRestDiscoveryDiscoverTypeHTTPDiscoverMethodPostPaginationTypedDict
    ]
    discover_data_field: NotRequired[str]
    r"""Path to field in the response object that contains discovery results (ex: level1.name). Leave blank if the result is an array."""
    enable_strict_discover_parsing: NotRequired[bool]
    r"""Explicitly set the discover response format. When disabled, best effort parsing is used."""
    discover_response_format: NotRequired[Any]
    enable_discover_code: NotRequired[bool]


class RestAuthenticationNoneRestDiscoveryDiscoverTypeHTTPDiscoverMethodPost(BaseModel):
    discover_method: Annotated[
        RestAuthenticationNoneRestDiscoveryDiscoverTypeHTTPDiscoverMethodPostDiscoverMethod,
        pydantic.Field(alias="discoverMethod"),
    ]

    discover_type: Annotated[
        RestAuthenticationNoneRestDiscoveryDiscoverTypeHTTPDiscoverMethodPostDiscoverType,
        pydantic.Field(alias="discoverType"),
    ]
    r"""Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task."""

    discover_url: Annotated[str, pydantic.Field(alias="discoverUrl")]
    r"""URL to use for the Discover operation. Can be a constant URL, or a JavaScript expression to derive the URL."""

    discover_request_params: Annotated[
        Optional[Any], pydantic.Field(alias="discoverRequestParams")
    ] = None

    discover_verb: Annotated[Optional[Any], pydantic.Field(alias="discoverVerb")] = None

    discover_body: Annotated[Optional[Any], pydantic.Field(alias="discoverBody")] = None

    discover_request_headers: Annotated[
        Optional[List[ItemsTypeRestCollectMethodGetCollectRequestParams]],
        pydantic.Field(alias="discoverRequestHeaders"),
    ] = None

    pagination: Optional[
        RestAuthenticationNoneRestDiscoveryDiscoverTypeHTTPDiscoverMethodPostPagination
    ] = None

    discover_data_field: Annotated[
        Optional[str], pydantic.Field(alias="discoverDataField")
    ] = None
    r"""Path to field in the response object that contains discovery results (ex: level1.name). Leave blank if the result is an array."""

    enable_strict_discover_parsing: Annotated[
        Optional[bool], pydantic.Field(alias="enableStrictDiscoverParsing")
    ] = None
    r"""Explicitly set the discover response format. When disabled, best effort parsing is used."""

    discover_response_format: Annotated[
        Optional[Any], pydantic.Field(alias="discoverResponseFormat")
    ] = None

    enable_discover_code: Annotated[
        Optional[bool], pydantic.Field(alias="enableDiscoverCode")
    ] = None

    @field_serializer("discover_method")
    def serialize_discover_method(self, value):
        if isinstance(value, str):
            try:
                return models.RestAuthenticationNoneRestDiscoveryDiscoverTypeHTTPDiscoverMethodPostDiscoverMethod(
                    value
                )
            except ValueError:
                return value
        return value

    @field_serializer("discover_type")
    def serialize_discover_type(self, value):
        if isinstance(value, str):
            try:
                return models.RestAuthenticationNoneRestDiscoveryDiscoverTypeHTTPDiscoverMethodPostDiscoverType(
                    value
                )
            except ValueError:
                return value
        return value

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(
            [
                "discoverRequestParams",
                "discoverVerb",
                "discoverBody",
                "discoverRequestHeaders",
                "pagination",
                "discoverDataField",
                "enableStrictDiscoverParsing",
                "discoverResponseFormat",
                "enableDiscoverCode",
            ]
        )
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


class RestAuthenticationNoneRestDiscoveryDiscoverTypeHTTPDiscoverMethodGetDiscoverMethod(
    str, Enum, metaclass=utils.OpenEnumMeta
):
    # GET
    GET = "get"
    # POST
    POST = "post"
    # POST with Body
    POST_WITH_BODY = "post_with_body"
    # Other
    OTHER = "other"


class RestAuthenticationNoneRestDiscoveryDiscoverTypeHTTPDiscoverMethodGetDiscoverType(
    str, Enum, metaclass=utils.OpenEnumMeta
):
    r"""Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task."""

    HTTP = "http"
    JSON = "json"
    LIST = "list"
    NONE = "none"


class RestAuthenticationNoneRestDiscoveryDiscoverTypeHTTPDiscoverMethodGetPaginationTypedDict(
    TypedDict
):
    type: PaginationOptionsRestDiscoveryDiscoverTypeHTTPPagination


class RestAuthenticationNoneRestDiscoveryDiscoverTypeHTTPDiscoverMethodGetPagination(
    BaseModel
):
    type: PaginationOptionsRestDiscoveryDiscoverTypeHTTPPagination

    @field_serializer("type")
    def serialize_type(self, value):
        if isinstance(value, str):
            try:
                return models.PaginationOptionsRestDiscoveryDiscoverTypeHTTPPagination(
                    value
                )
            except ValueError:
                return value
        return value


class RestAuthenticationNoneRestDiscoveryDiscoverTypeHTTPDiscoverMethodGetTypedDict(
    TypedDict
):
    discover_method: RestAuthenticationNoneRestDiscoveryDiscoverTypeHTTPDiscoverMethodGetDiscoverMethod
    discover_type: (
        RestAuthenticationNoneRestDiscoveryDiscoverTypeHTTPDiscoverMethodGetDiscoverType
    )
    r"""Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task."""
    discover_url: str
    r"""URL to use for the Discover operation. Can be a constant URL, or a JavaScript expression to derive the URL."""
    discover_request_params: NotRequired[Any]
    discover_verb: NotRequired[Any]
    discover_body: NotRequired[Any]
    discover_request_headers: NotRequired[
        List[ItemsTypeRestCollectMethodGetCollectRequestParamsTypedDict]
    ]
    pagination: NotRequired[
        RestAuthenticationNoneRestDiscoveryDiscoverTypeHTTPDiscoverMethodGetPaginationTypedDict
    ]
    discover_data_field: NotRequired[str]
    r"""Path to field in the response object that contains discovery results (ex: level1.name). Leave blank if the result is an array."""
    enable_strict_discover_parsing: NotRequired[bool]
    r"""Explicitly set the discover response format. When disabled, best effort parsing is used."""
    discover_response_format: NotRequired[Any]
    enable_discover_code: NotRequired[bool]


class RestAuthenticationNoneRestDiscoveryDiscoverTypeHTTPDiscoverMethodGet(BaseModel):
    discover_method: Annotated[
        RestAuthenticationNoneRestDiscoveryDiscoverTypeHTTPDiscoverMethodGetDiscoverMethod,
        pydantic.Field(alias="discoverMethod"),
    ]

    discover_type: Annotated[
        RestAuthenticationNoneRestDiscoveryDiscoverTypeHTTPDiscoverMethodGetDiscoverType,
        pydantic.Field(alias="discoverType"),
    ]
    r"""Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task."""

    discover_url: Annotated[str, pydantic.Field(alias="discoverUrl")]
    r"""URL to use for the Discover operation. Can be a constant URL, or a JavaScript expression to derive the URL."""

    discover_request_params: Annotated[
        Optional[Any], pydantic.Field(alias="discoverRequestParams")
    ] = None

    discover_verb: Annotated[Optional[Any], pydantic.Field(alias="discoverVerb")] = None

    discover_body: Annotated[Optional[Any], pydantic.Field(alias="discoverBody")] = None

    discover_request_headers: Annotated[
        Optional[List[ItemsTypeRestCollectMethodGetCollectRequestParams]],
        pydantic.Field(alias="discoverRequestHeaders"),
    ] = None

    pagination: Optional[
        RestAuthenticationNoneRestDiscoveryDiscoverTypeHTTPDiscoverMethodGetPagination
    ] = None

    discover_data_field: Annotated[
        Optional[str], pydantic.Field(alias="discoverDataField")
    ] = None
    r"""Path to field in the response object that contains discovery results (ex: level1.name). Leave blank if the result is an array."""

    enable_strict_discover_parsing: Annotated[
        Optional[bool], pydantic.Field(alias="enableStrictDiscoverParsing")
    ] = None
    r"""Explicitly set the discover response format. When disabled, best effort parsing is used."""

    discover_response_format: Annotated[
        Optional[Any], pydantic.Field(alias="discoverResponseFormat")
    ] = None

    enable_discover_code: Annotated[
        Optional[bool], pydantic.Field(alias="enableDiscoverCode")
    ] = None

    @field_serializer("discover_method")
    def serialize_discover_method(self, value):
        if isinstance(value, str):
            try:
                return models.RestAuthenticationNoneRestDiscoveryDiscoverTypeHTTPDiscoverMethodGetDiscoverMethod(
                    value
                )
            except ValueError:
                return value
        return value

    @field_serializer("discover_type")
    def serialize_discover_type(self, value):
        if isinstance(value, str):
            try:
                return models.RestAuthenticationNoneRestDiscoveryDiscoverTypeHTTPDiscoverMethodGetDiscoverType(
                    value
                )
            except ValueError:
                return value
        return value

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(
            [
                "discoverRequestParams",
                "discoverVerb",
                "discoverBody",
                "discoverRequestHeaders",
                "pagination",
                "discoverDataField",
                "enableStrictDiscoverParsing",
                "discoverResponseFormat",
                "enableDiscoverCode",
            ]
        )
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


RestAuthenticationNoneRestDiscoveryDiscoverTypeHTTPTypedDict = TypeAliasType(
    "RestAuthenticationNoneRestDiscoveryDiscoverTypeHTTPTypedDict",
    Union[
        RestAuthenticationNoneRestDiscoveryDiscoverTypeHTTPDiscoverMethodGetTypedDict,
        RestAuthenticationNoneRestDiscoveryDiscoverTypeHTTPDiscoverMethodPostTypedDict,
        RestAuthenticationNoneRestDiscoveryDiscoverTypeHTTPDiscoverMethodPostWithBodyTypedDict,
        RestAuthenticationNoneRestDiscoveryDiscoverTypeHTTPDiscoverMethodOtherTypedDict,
    ],
)


class UnknownRestAuthenticationNoneRestDiscoveryDiscoverTypeHTTP(BaseModel):
    r"""A RestAuthenticationNoneRestDiscoveryDiscoverTypeHTTP variant the SDK doesn't recognize. Preserves the raw payload."""

    discover_method: Literal["UNKNOWN"] = "UNKNOWN"
    raw: Any
    is_unknown: Literal[True] = True

    model_config = ConfigDict(frozen=True)


_REST_AUTHENTICATION_NONE_REST_DISCOVERY_DISCOVER_TYPE_HTTP_VARIANTS: dict[str, Any] = {
    "get": RestAuthenticationNoneRestDiscoveryDiscoverTypeHTTPDiscoverMethodGet,
    "post": RestAuthenticationNoneRestDiscoveryDiscoverTypeHTTPDiscoverMethodPost,
    "post_with_body": RestAuthenticationNoneRestDiscoveryDiscoverTypeHTTPDiscoverMethodPostWithBody,
    "other": RestAuthenticationNoneRestDiscoveryDiscoverTypeHTTPDiscoverMethodOther,
}


RestAuthenticationNoneRestDiscoveryDiscoverTypeHTTP = Annotated[
    Union[
        RestAuthenticationNoneRestDiscoveryDiscoverTypeHTTPDiscoverMethodGet,
        RestAuthenticationNoneRestDiscoveryDiscoverTypeHTTPDiscoverMethodPost,
        RestAuthenticationNoneRestDiscoveryDiscoverTypeHTTPDiscoverMethodPostWithBody,
        RestAuthenticationNoneRestDiscoveryDiscoverTypeHTTPDiscoverMethodOther,
        UnknownRestAuthenticationNoneRestDiscoveryDiscoverTypeHTTP,
    ],
    BeforeValidator(
        partial(
            parse_open_union,
            disc_key="discoverMethod",
            variants=_REST_AUTHENTICATION_NONE_REST_DISCOVERY_DISCOVER_TYPE_HTTP_VARIANTS,
            unknown_cls=UnknownRestAuthenticationNoneRestDiscoveryDiscoverTypeHTTP,
            union_name="RestAuthenticationNoneRestDiscoveryDiscoverTypeHTTP",
        )
    ),
]


RestAuthenticationNoneDiscoveryTypedDict = TypeAliasType(
    "RestAuthenticationNoneDiscoveryTypedDict",
    Union[
        RestAuthenticationNoneRestDiscoveryDiscoverTypeNoneTypedDict,
        RestAuthenticationNoneRestDiscoveryDiscoverTypeListTypedDict,
        RestAuthenticationNoneRestDiscoveryDiscoverTypeJSONTypedDict,
        RestAuthenticationNoneRestDiscoveryDiscoverTypeHTTPTypedDict,
    ],
)


class UnknownRestAuthenticationNoneDiscovery(BaseModel):
    r"""A RestAuthenticationNoneDiscovery variant the SDK doesn't recognize. Preserves the raw payload."""

    discover_type: Literal["UNKNOWN"] = "UNKNOWN"
    raw: Any
    is_unknown: Literal[True] = True

    model_config = ConfigDict(frozen=True)


_REST_AUTHENTICATION_NONE_DISCOVERY_VARIANTS: dict[str, Any] = {
    "http": RestAuthenticationNoneRestDiscoveryDiscoverTypeHTTP,
    "json": RestAuthenticationNoneRestDiscoveryDiscoverTypeJSON,
    "list": RestAuthenticationNoneRestDiscoveryDiscoverTypeList,
    "none": RestAuthenticationNoneRestDiscoveryDiscoverTypeNone,
}


RestAuthenticationNoneDiscovery = Annotated[
    Union[
        RestAuthenticationNoneRestDiscoveryDiscoverTypeHTTP,
        RestAuthenticationNoneRestDiscoveryDiscoverTypeJSON,
        RestAuthenticationNoneRestDiscoveryDiscoverTypeList,
        RestAuthenticationNoneRestDiscoveryDiscoverTypeNone,
        UnknownRestAuthenticationNoneDiscovery,
    ],
    BeforeValidator(
        partial(
            parse_open_union,
            disc_key="discoverType",
            variants=_REST_AUTHENTICATION_NONE_DISCOVERY_VARIANTS,
            unknown_cls=UnknownRestAuthenticationNoneDiscovery,
            union_name="RestAuthenticationNoneDiscovery",
        )
    ),
]


class RestAuthenticationNoneCollectMethod(str, Enum, metaclass=utils.OpenEnumMeta):
    # GET
    GET = "get"
    # POST
    POST = "post"
    # POST with Body
    POST_WITH_BODY = "post_with_body"
    # Other
    OTHER = "other"


class RestAuthenticationNoneRestPaginationTypeRequestPageTypedDict(TypedDict):
    type: PaginationOptionsRestDiscoveryDiscoverTypeHTTPPagination
    page_field: str
    r"""Query string parameter that sets the page index to be returned. Example: /api/v1/query?term=cribl&page_size=100&page_number=0"""
    size_field: str
    r"""Query string parameter that sets the number of records retrieved per request. Example: /api/v1/query?term=cribl&page_size=100&page_number=0"""
    size: float
    r"""Maximum number of records to collect per page"""
    max_pages: float
    r"""Maximum number of pages to retrieve per collection task. Defaults to 50 pages. Set to 0 to retrieve all pages."""
    zero_indexed: bool
    r"""Enable to indicate that the first page in the requested data is at index 0. Disabled by default, which indicates index 1."""
    page: NotRequired[float]
    r"""Page number from which to start request. Defaults to undefined, which will start collection from the first page."""
    total_page_field: NotRequired[str]
    r"""Name of the attribute in the response that contains the total number of pages for the query"""
    total_record_field: NotRequired[str]
    r"""Name of the attribute in the response that contains the total number of records for the query"""


class RestAuthenticationNoneRestPaginationTypeRequestPage(BaseModel):
    type: PaginationOptionsRestDiscoveryDiscoverTypeHTTPPagination

    page_field: Annotated[str, pydantic.Field(alias="pageField")]
    r"""Query string parameter that sets the page index to be returned. Example: /api/v1/query?term=cribl&page_size=100&page_number=0"""

    size_field: Annotated[str, pydantic.Field(alias="sizeField")]
    r"""Query string parameter that sets the number of records retrieved per request. Example: /api/v1/query?term=cribl&page_size=100&page_number=0"""

    size: float
    r"""Maximum number of records to collect per page"""

    max_pages: Annotated[float, pydantic.Field(alias="maxPages")]
    r"""Maximum number of pages to retrieve per collection task. Defaults to 50 pages. Set to 0 to retrieve all pages."""

    zero_indexed: Annotated[bool, pydantic.Field(alias="zeroIndexed")]
    r"""Enable to indicate that the first page in the requested data is at index 0. Disabled by default, which indicates index 1."""

    page: Optional[float] = None
    r"""Page number from which to start request. Defaults to undefined, which will start collection from the first page."""

    total_page_field: Annotated[
        Optional[str], pydantic.Field(alias="totalPageField")
    ] = None
    r"""Name of the attribute in the response that contains the total number of pages for the query"""

    total_record_field: Annotated[
        Optional[str], pydantic.Field(alias="totalRecordField")
    ] = None
    r"""Name of the attribute in the response that contains the total number of records for the query"""

    @field_serializer("type")
    def serialize_type(self, value):
        if isinstance(value, str):
            try:
                return models.PaginationOptionsRestDiscoveryDiscoverTypeHTTPPagination(
                    value
                )
            except ValueError:
                return value
        return value

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(["page", "totalPageField", "totalRecordField"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


class RestAuthenticationNoneRestPaginationTypeRequestOffsetTypedDict(TypedDict):
    type: PaginationOptionsRestDiscoveryDiscoverTypeHTTPPagination
    offset_field: str
    r"""Query string parameter that sets the index from which to begin returning records. Example: /api/v1/query?term=cribl&limit=100&offset=0"""
    limit_field: str
    r"""Query string parameter that sets the number of records retrieved per request. Example: /api/v1/query?term=cribl&limit=100&offset=0"""
    limit: float
    r"""Maximum number of records to collect per request"""
    max_pages: float
    r"""Maximum number of pages to retrieve per collection task. Defaults to 50 pages. Set to 0 to retrieve all pages."""
    zero_indexed: bool
    r"""Enable to indicate that the first page in the requested data is at index 0. Disabled by default, which indicates index 1."""
    offset: NotRequired[float]
    r"""Offset index from which to start request. Defaults to undefined, which will start collection from the first record."""
    total_record_field: NotRequired[str]
    r"""Name of the attribute in the response that contains the total number of records for the query"""


class RestAuthenticationNoneRestPaginationTypeRequestOffset(BaseModel):
    type: PaginationOptionsRestDiscoveryDiscoverTypeHTTPPagination

    offset_field: Annotated[str, pydantic.Field(alias="offsetField")]
    r"""Query string parameter that sets the index from which to begin returning records. Example: /api/v1/query?term=cribl&limit=100&offset=0"""

    limit_field: Annotated[str, pydantic.Field(alias="limitField")]
    r"""Query string parameter that sets the number of records retrieved per request. Example: /api/v1/query?term=cribl&limit=100&offset=0"""

    limit: float
    r"""Maximum number of records to collect per request"""

    max_pages: Annotated[float, pydantic.Field(alias="maxPages")]
    r"""Maximum number of pages to retrieve per collection task. Defaults to 50 pages. Set to 0 to retrieve all pages."""

    zero_indexed: Annotated[bool, pydantic.Field(alias="zeroIndexed")]
    r"""Enable to indicate that the first page in the requested data is at index 0. Disabled by default, which indicates index 1."""

    offset: Optional[float] = None
    r"""Offset index from which to start request. Defaults to undefined, which will start collection from the first record."""

    total_record_field: Annotated[
        Optional[str], pydantic.Field(alias="totalRecordField")
    ] = None
    r"""Name of the attribute in the response that contains the total number of records for the query"""

    @field_serializer("type")
    def serialize_type(self, value):
        if isinstance(value, str):
            try:
                return models.PaginationOptionsRestDiscoveryDiscoverTypeHTTPPagination(
                    value
                )
            except ValueError:
                return value
        return value

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(["offset", "totalRecordField"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


class RestAuthenticationNoneRestPaginationTypeResponseHeaderLinkTypedDict(TypedDict):
    type: PaginationOptionsRestDiscoveryDiscoverTypeHTTPPagination
    next_relation_attribute: str
    r"""Relation name used in the link header that refers to the next page in the result set. Example: rel=\"next\" refers to the next page of results: <https://myHost/nextPage>; rel=\"next\" """
    max_pages: float
    r"""Maximum number of pages to retrieve per collection task. Defaults to 50 pages. Set to 0 to retrieve all pages."""
    cur_relation_attribute: NotRequired[str]
    r"""Relation name used in the link header that refers to the current result set. Example: rel=\"self\" refers to the current page of results: <https://myHost/curPage>; rel=\"self\" """


class RestAuthenticationNoneRestPaginationTypeResponseHeaderLink(BaseModel):
    type: PaginationOptionsRestDiscoveryDiscoverTypeHTTPPagination

    next_relation_attribute: Annotated[
        str, pydantic.Field(alias="nextRelationAttribute")
    ]
    r"""Relation name used in the link header that refers to the next page in the result set. Example: rel=\"next\" refers to the next page of results: <https://myHost/nextPage>; rel=\"next\" """

    max_pages: Annotated[float, pydantic.Field(alias="maxPages")]
    r"""Maximum number of pages to retrieve per collection task. Defaults to 50 pages. Set to 0 to retrieve all pages."""

    cur_relation_attribute: Annotated[
        Optional[str], pydantic.Field(alias="curRelationAttribute")
    ] = None
    r"""Relation name used in the link header that refers to the current result set. Example: rel=\"self\" refers to the current page of results: <https://myHost/curPage>; rel=\"self\" """

    @field_serializer("type")
    def serialize_type(self, value):
        if isinstance(value, str):
            try:
                return models.PaginationOptionsRestDiscoveryDiscoverTypeHTTPPagination(
                    value
                )
            except ValueError:
                return value
        return value

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(["curRelationAttribute"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


class RestAuthenticationNoneRestPaginationTypeResponseHeaderTypedDict(TypedDict):
    type: PaginationOptionsRestDiscoveryDiscoverTypeHTTPPagination
    attribute: List[str]
    r"""Names of attributes within the response that contain next-page information"""
    max_pages: float
    r"""Maximum number of pages to retrieve per collection task. Defaults to 50 pages. Set to 0 to retrieve all pages."""


class RestAuthenticationNoneRestPaginationTypeResponseHeader(BaseModel):
    type: PaginationOptionsRestDiscoveryDiscoverTypeHTTPPagination

    attribute: List[str]
    r"""Names of attributes within the response that contain next-page information"""

    max_pages: Annotated[float, pydantic.Field(alias="maxPages")]
    r"""Maximum number of pages to retrieve per collection task. Defaults to 50 pages. Set to 0 to retrieve all pages."""

    @field_serializer("type")
    def serialize_type(self, value):
        if isinstance(value, str):
            try:
                return models.PaginationOptionsRestDiscoveryDiscoverTypeHTTPPagination(
                    value
                )
            except ValueError:
                return value
        return value


class RestAuthenticationNoneRestPaginationTypeResponseBodyTypedDict(TypedDict):
    type: PaginationOptionsRestDiscoveryDiscoverTypeHTTPPagination
    attribute: List[str]
    r"""Names of attributes within the response that contain next-page information"""
    max_pages: float
    r"""Maximum number of pages to retrieve per collection task. Defaults to 50 pages. Set to 0 to retrieve all pages."""
    last_page_expr: NotRequired[str]
    r"""JavaScript expression used to determine when the last page has been reached. The values tested by this expression must be in the Response attributes section."""


class RestAuthenticationNoneRestPaginationTypeResponseBody(BaseModel):
    type: PaginationOptionsRestDiscoveryDiscoverTypeHTTPPagination

    attribute: List[str]
    r"""Names of attributes within the response that contain next-page information"""

    max_pages: Annotated[float, pydantic.Field(alias="maxPages")]
    r"""Maximum number of pages to retrieve per collection task. Defaults to 50 pages. Set to 0 to retrieve all pages."""

    last_page_expr: Annotated[Optional[str], pydantic.Field(alias="lastPageExpr")] = (
        None
    )
    r"""JavaScript expression used to determine when the last page has been reached. The values tested by this expression must be in the Response attributes section."""

    @field_serializer("type")
    def serialize_type(self, value):
        if isinstance(value, str):
            try:
                return models.PaginationOptionsRestDiscoveryDiscoverTypeHTTPPagination(
                    value
                )
            except ValueError:
                return value
        return value

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(["lastPageExpr"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


class RestAuthenticationNoneRestPaginationTypeNoneTypedDict(TypedDict):
    type: PaginationOptionsRestDiscoveryDiscoverTypeHTTPPagination


class RestAuthenticationNoneRestPaginationTypeNone(BaseModel):
    type: PaginationOptionsRestDiscoveryDiscoverTypeHTTPPagination

    @field_serializer("type")
    def serialize_type(self, value):
        if isinstance(value, str):
            try:
                return models.PaginationOptionsRestDiscoveryDiscoverTypeHTTPPagination(
                    value
                )
            except ValueError:
                return value
        return value


RestAuthenticationNonePaginationUnionTypedDict = TypeAliasType(
    "RestAuthenticationNonePaginationUnionTypedDict",
    Union[
        RestAuthenticationNoneRestPaginationTypeNoneTypedDict,
        RestAuthenticationNoneRestPaginationTypeResponseHeaderTypedDict,
        RestAuthenticationNoneRestPaginationTypeResponseBodyTypedDict,
        RestAuthenticationNoneRestPaginationTypeResponseHeaderLinkTypedDict,
        RestAuthenticationNoneRestPaginationTypeRequestOffsetTypedDict,
        RestAuthenticationNoneRestPaginationTypeRequestPageTypedDict,
    ],
)


class UnknownRestAuthenticationNonePaginationUnion(BaseModel):
    r"""A RestAuthenticationNonePaginationUnion variant the SDK doesn't recognize. Preserves the raw payload."""

    type: Literal["UNKNOWN"] = "UNKNOWN"
    raw: Any
    is_unknown: Literal[True] = True

    model_config = ConfigDict(frozen=True)


_REST_AUTHENTICATION_NONE_PAGINATION_UNION_VARIANTS: dict[str, Any] = {
    "none": RestAuthenticationNoneRestPaginationTypeNone,
    "response_body": RestAuthenticationNoneRestPaginationTypeResponseBody,
    "response_header": RestAuthenticationNoneRestPaginationTypeResponseHeader,
    "response_header_link": RestAuthenticationNoneRestPaginationTypeResponseHeaderLink,
    "request_offset": RestAuthenticationNoneRestPaginationTypeRequestOffset,
    "request_page": RestAuthenticationNoneRestPaginationTypeRequestPage,
}


RestAuthenticationNonePaginationUnion = Annotated[
    Union[
        RestAuthenticationNoneRestPaginationTypeNone,
        RestAuthenticationNoneRestPaginationTypeResponseBody,
        RestAuthenticationNoneRestPaginationTypeResponseHeader,
        RestAuthenticationNoneRestPaginationTypeResponseHeaderLink,
        RestAuthenticationNoneRestPaginationTypeRequestOffset,
        RestAuthenticationNoneRestPaginationTypeRequestPage,
        UnknownRestAuthenticationNonePaginationUnion,
    ],
    BeforeValidator(
        partial(
            parse_open_union,
            disc_key="type",
            variants=_REST_AUTHENTICATION_NONE_PAGINATION_UNION_VARIANTS,
            unknown_cls=UnknownRestAuthenticationNonePaginationUnion,
            union_name="RestAuthenticationNonePaginationUnion",
        )
    ),
]


class RestAuthenticationNoneRestRetryRulesTypeBackoffTypedDict(TypedDict):
    type: RetryTypeOptionsHealthCheckCollectorConfRetryRules
    r"""The algorithm to use when performing HTTP retries"""
    interval: NotRequired[Any]
    limit: NotRequired[Any]
    multiplier: NotRequired[Any]
    max_interval_ms: NotRequired[Any]
    codes: NotRequired[Any]
    enable_header: NotRequired[Any]
    retry_connect_timeout: NotRequired[Any]
    retry_connect_reset: NotRequired[Any]


class RestAuthenticationNoneRestRetryRulesTypeBackoff(BaseModel):
    type: RetryTypeOptionsHealthCheckCollectorConfRetryRules
    r"""The algorithm to use when performing HTTP retries"""

    interval: Optional[Any] = None

    limit: Optional[Any] = None

    multiplier: Optional[Any] = None

    max_interval_ms: Annotated[Optional[Any], pydantic.Field(alias="maxIntervalMs")] = (
        None
    )

    codes: Optional[Any] = None

    enable_header: Annotated[Optional[Any], pydantic.Field(alias="enableHeader")] = None

    retry_connect_timeout: Annotated[
        Optional[Any], pydantic.Field(alias="retryConnectTimeout")
    ] = None

    retry_connect_reset: Annotated[
        Optional[Any], pydantic.Field(alias="retryConnectReset")
    ] = None

    @field_serializer("type")
    def serialize_type(self, value):
        if isinstance(value, str):
            try:
                return models.RetryTypeOptionsHealthCheckCollectorConfRetryRules(value)
            except ValueError:
                return value
        return value

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(
            [
                "interval",
                "limit",
                "multiplier",
                "maxIntervalMs",
                "codes",
                "enableHeader",
                "retryConnectTimeout",
                "retryConnectReset",
            ]
        )
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


class RestAuthenticationNoneRestRetryRulesTypeStaticTypedDict(TypedDict):
    type: RetryTypeOptionsHealthCheckCollectorConfRetryRules
    r"""The algorithm to use when performing HTTP retries"""
    interval: NotRequired[Any]
    limit: NotRequired[Any]
    codes: NotRequired[Any]
    enable_header: NotRequired[Any]
    retry_connect_timeout: NotRequired[Any]
    retry_connect_reset: NotRequired[Any]
    multiplier: NotRequired[Any]
    max_interval_ms: NotRequired[Any]


class RestAuthenticationNoneRestRetryRulesTypeStatic(BaseModel):
    type: RetryTypeOptionsHealthCheckCollectorConfRetryRules
    r"""The algorithm to use when performing HTTP retries"""

    interval: Optional[Any] = None

    limit: Optional[Any] = None

    codes: Optional[Any] = None

    enable_header: Annotated[Optional[Any], pydantic.Field(alias="enableHeader")] = None

    retry_connect_timeout: Annotated[
        Optional[Any], pydantic.Field(alias="retryConnectTimeout")
    ] = None

    retry_connect_reset: Annotated[
        Optional[Any], pydantic.Field(alias="retryConnectReset")
    ] = None

    multiplier: Optional[Any] = None

    max_interval_ms: Annotated[Optional[Any], pydantic.Field(alias="maxIntervalMs")] = (
        None
    )

    @field_serializer("type")
    def serialize_type(self, value):
        if isinstance(value, str):
            try:
                return models.RetryTypeOptionsHealthCheckCollectorConfRetryRules(value)
            except ValueError:
                return value
        return value

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(
            [
                "interval",
                "limit",
                "codes",
                "enableHeader",
                "retryConnectTimeout",
                "retryConnectReset",
                "multiplier",
                "maxIntervalMs",
            ]
        )
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


class RestAuthenticationNoneRestRetryRulesTypeNoneTypedDict(TypedDict):
    type: RetryTypeOptionsHealthCheckCollectorConfRetryRules
    r"""The algorithm to use when performing HTTP retries"""
    interval: NotRequired[Any]
    limit: NotRequired[Any]
    multiplier: NotRequired[Any]
    max_interval_ms: NotRequired[Any]
    codes: NotRequired[Any]
    enable_header: NotRequired[Any]
    retry_connect_timeout: NotRequired[Any]
    retry_connect_reset: NotRequired[Any]


class RestAuthenticationNoneRestRetryRulesTypeNone(BaseModel):
    type: RetryTypeOptionsHealthCheckCollectorConfRetryRules
    r"""The algorithm to use when performing HTTP retries"""

    interval: Optional[Any] = None

    limit: Optional[Any] = None

    multiplier: Optional[Any] = None

    max_interval_ms: Annotated[Optional[Any], pydantic.Field(alias="maxIntervalMs")] = (
        None
    )

    codes: Optional[Any] = None

    enable_header: Annotated[Optional[Any], pydantic.Field(alias="enableHeader")] = None

    retry_connect_timeout: Annotated[
        Optional[Any], pydantic.Field(alias="retryConnectTimeout")
    ] = None

    retry_connect_reset: Annotated[
        Optional[Any], pydantic.Field(alias="retryConnectReset")
    ] = None

    @field_serializer("type")
    def serialize_type(self, value):
        if isinstance(value, str):
            try:
                return models.RetryTypeOptionsHealthCheckCollectorConfRetryRules(value)
            except ValueError:
                return value
        return value

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(
            [
                "interval",
                "limit",
                "multiplier",
                "maxIntervalMs",
                "codes",
                "enableHeader",
                "retryConnectTimeout",
                "retryConnectReset",
            ]
        )
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


RestAuthenticationNoneRetryRulesTypedDict = TypeAliasType(
    "RestAuthenticationNoneRetryRulesTypedDict",
    Union[
        RestAuthenticationNoneRestRetryRulesTypeNoneTypedDict,
        RestAuthenticationNoneRestRetryRulesTypeStaticTypedDict,
        RestAuthenticationNoneRestRetryRulesTypeBackoffTypedDict,
    ],
)


class UnknownRestAuthenticationNoneRetryRules(BaseModel):
    r"""A RestAuthenticationNoneRetryRules variant the SDK doesn't recognize. Preserves the raw payload."""

    type: Literal["UNKNOWN"] = "UNKNOWN"
    raw: Any
    is_unknown: Literal[True] = True

    model_config = ConfigDict(frozen=True)


_REST_AUTHENTICATION_NONE_RETRY_RULES_VARIANTS: dict[str, Any] = {
    "none": RestAuthenticationNoneRestRetryRulesTypeNone,
    "static": RestAuthenticationNoneRestRetryRulesTypeStatic,
    "backoff": RestAuthenticationNoneRestRetryRulesTypeBackoff,
}


RestAuthenticationNoneRetryRules = Annotated[
    Union[
        RestAuthenticationNoneRestRetryRulesTypeNone,
        RestAuthenticationNoneRestRetryRulesTypeStatic,
        RestAuthenticationNoneRestRetryRulesTypeBackoff,
        UnknownRestAuthenticationNoneRetryRules,
    ],
    BeforeValidator(
        partial(
            parse_open_union,
            disc_key="type",
            variants=_REST_AUTHENTICATION_NONE_RETRY_RULES_VARIANTS,
            unknown_cls=UnknownRestAuthenticationNoneRetryRules,
            union_name="RestAuthenticationNoneRetryRules",
        )
    ),
]


class RestAuthenticationNoneStateTrackingTypedDict(TypedDict):
    enabled: NotRequired[bool]
    r"""Track collection progress between consecutive scheduled executions"""


class RestAuthenticationNoneStateTracking(BaseModel):
    enabled: Optional[bool] = None
    r"""Track collection progress between consecutive scheduled executions"""

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(["enabled"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


class RestAuthenticationNoneSchedulingTypedDict(TypedDict):
    state_tracking: NotRequired[RestAuthenticationNoneStateTrackingTypedDict]


class RestAuthenticationNoneScheduling(BaseModel):
    state_tracking: Annotated[
        Optional[RestAuthenticationNoneStateTracking],
        pydantic.Field(alias="stateTracking"),
    ] = None

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(["stateTracking"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


class RestAuthenticationNoneTypedDict(TypedDict):
    authentication: RestAuthenticationNoneAuthentication
    r"""Authentication method for Discover and Collect REST calls. You can specify API key–based authentication by adding the appropriate Collect headers."""
    collect_url: str
    r"""URL (constant or JavaScript expression) to use for the Collect operation"""
    collect_method: RestAuthenticationNoneCollectMethod
    discovery: NotRequired[RestAuthenticationNoneDiscoveryTypedDict]
    collect_verb: NotRequired[Any]
    collect_request_params: NotRequired[Any]
    collect_body: NotRequired[Any]
    collect_request_headers: NotRequired[
        List[ItemsTypeRestCollectMethodGetCollectRequestParamsTypedDict]
    ]
    pagination: NotRequired[RestAuthenticationNonePaginationUnionTypedDict]
    timeout: NotRequired[float]
    r"""HTTP request inactivity timeout. Use 0 to disable."""
    use_round_robin_dns: NotRequired[bool]
    r"""Use round-robin DNS lookup. Suitable when DNS server returns multiple addresses in sort order."""
    disable_time_filter: NotRequired[bool]
    r"""Disable Collector event time filtering when a date range is specified"""
    decode_url: NotRequired[bool]
    r"""Decode the URL before sending requests (including pagination requests)"""
    reject_unauthorized: NotRequired[bool]
    r"""Reject certificates that cannot be verified against a valid CA (such as self-signed certificates)"""
    capture_headers: NotRequired[bool]
    r"""Enable to add response headers to the resHeaders field under the __collectible object"""
    stop_on_empty_results: NotRequired[bool]
    r"""Stop pagination when the Event Breaker produces no events"""
    safe_headers: NotRequired[List[str]]
    r"""List of headers that are safe to log in plain text"""
    retry_rules: NotRequired[RestAuthenticationNoneRetryRulesTypedDict]
    scheduling: NotRequired[RestAuthenticationNoneSchedulingTypedDict]


class RestAuthenticationNone(BaseModel):
    authentication: RestAuthenticationNoneAuthentication
    r"""Authentication method for Discover and Collect REST calls. You can specify API key–based authentication by adding the appropriate Collect headers."""

    collect_url: Annotated[str, pydantic.Field(alias="collectUrl")]
    r"""URL (constant or JavaScript expression) to use for the Collect operation"""

    collect_method: Annotated[
        RestAuthenticationNoneCollectMethod, pydantic.Field(alias="collectMethod")
    ]

    discovery: Optional[RestAuthenticationNoneDiscovery] = None

    collect_verb: Annotated[Optional[Any], pydantic.Field(alias="collectVerb")] = None

    collect_request_params: Annotated[
        Optional[Any], pydantic.Field(alias="collectRequestParams")
    ] = None

    collect_body: Annotated[Optional[Any], pydantic.Field(alias="collectBody")] = None

    collect_request_headers: Annotated[
        Optional[List[ItemsTypeRestCollectMethodGetCollectRequestParams]],
        pydantic.Field(alias="collectRequestHeaders"),
    ] = None

    pagination: Optional[RestAuthenticationNonePaginationUnion] = None

    timeout: Optional[float] = None
    r"""HTTP request inactivity timeout. Use 0 to disable."""

    use_round_robin_dns: Annotated[
        Optional[bool], pydantic.Field(alias="useRoundRobinDns")
    ] = None
    r"""Use round-robin DNS lookup. Suitable when DNS server returns multiple addresses in sort order."""

    disable_time_filter: Annotated[
        Optional[bool], pydantic.Field(alias="disableTimeFilter")
    ] = None
    r"""Disable Collector event time filtering when a date range is specified"""

    decode_url: Annotated[Optional[bool], pydantic.Field(alias="decodeUrl")] = None
    r"""Decode the URL before sending requests (including pagination requests)"""

    reject_unauthorized: Annotated[
        Optional[bool], pydantic.Field(alias="rejectUnauthorized")
    ] = None
    r"""Reject certificates that cannot be verified against a valid CA (such as self-signed certificates)"""

    capture_headers: Annotated[
        Optional[bool], pydantic.Field(alias="captureHeaders")
    ] = None
    r"""Enable to add response headers to the resHeaders field under the __collectible object"""

    stop_on_empty_results: Annotated[
        Optional[bool], pydantic.Field(alias="stopOnEmptyResults")
    ] = None
    r"""Stop pagination when the Event Breaker produces no events"""

    safe_headers: Annotated[
        Optional[List[str]], pydantic.Field(alias="safeHeaders")
    ] = None
    r"""List of headers that are safe to log in plain text"""

    retry_rules: Annotated[
        Optional[RestAuthenticationNoneRetryRules], pydantic.Field(alias="retryRules")
    ] = None

    scheduling: Annotated[
        Optional[RestAuthenticationNoneScheduling], pydantic.Field(alias="__scheduling")
    ] = None

    @field_serializer("authentication")
    def serialize_authentication(self, value):
        if isinstance(value, str):
            try:
                return models.RestAuthenticationNoneAuthentication(value)
            except ValueError:
                return value
        return value

    @field_serializer("collect_method")
    def serialize_collect_method(self, value):
        if isinstance(value, str):
            try:
                return models.RestAuthenticationNoneCollectMethod(value)
            except ValueError:
                return value
        return value

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(
            [
                "discovery",
                "collectVerb",
                "collectRequestParams",
                "collectBody",
                "collectRequestHeaders",
                "pagination",
                "timeout",
                "useRoundRobinDns",
                "disableTimeFilter",
                "decodeUrl",
                "rejectUnauthorized",
                "captureHeaders",
                "stopOnEmptyResults",
                "safeHeaders",
                "retryRules",
                "__scheduling",
            ]
        )
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


class RestCollectMethodOtherCollectMethod(str, Enum, metaclass=utils.OpenEnumMeta):
    # GET
    GET = "get"
    # POST
    POST = "post"
    # POST with Body
    POST_WITH_BODY = "post_with_body"
    # Other
    OTHER = "other"


class RestCollectMethodOtherRestDiscoveryDiscoverTypeNoneDiscoverType(
    str, Enum, metaclass=utils.OpenEnumMeta
):
    r"""Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task."""

    HTTP = "http"
    JSON = "json"
    LIST = "list"
    NONE = "none"


class RestCollectMethodOtherRestDiscoveryDiscoverTypeNoneTypedDict(TypedDict):
    discover_type: RestCollectMethodOtherRestDiscoveryDiscoverTypeNoneDiscoverType
    r"""Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task."""


class RestCollectMethodOtherRestDiscoveryDiscoverTypeNone(BaseModel):
    discover_type: Annotated[
        RestCollectMethodOtherRestDiscoveryDiscoverTypeNoneDiscoverType,
        pydantic.Field(alias="discoverType"),
    ]
    r"""Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task."""

    @field_serializer("discover_type")
    def serialize_discover_type(self, value):
        if isinstance(value, str):
            try:
                return models.RestCollectMethodOtherRestDiscoveryDiscoverTypeNoneDiscoverType(
                    value
                )
            except ValueError:
                return value
        return value


class RestCollectMethodOtherRestDiscoveryDiscoverTypeListDiscoverType(
    str, Enum, metaclass=utils.OpenEnumMeta
):
    r"""Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task."""

    HTTP = "http"
    JSON = "json"
    LIST = "list"
    NONE = "none"


class RestCollectMethodOtherRestDiscoveryDiscoverTypeListTypedDict(TypedDict):
    discover_type: RestCollectMethodOtherRestDiscoveryDiscoverTypeListDiscoverType
    r"""Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task."""
    item_list: List[str]
    r"""Comma-separated list of items to return from the Discover task. Each item returned generates a Collect task and can be referenced using `${id}` in the Collect URL, headers, or parameters."""


class RestCollectMethodOtherRestDiscoveryDiscoverTypeList(BaseModel):
    discover_type: Annotated[
        RestCollectMethodOtherRestDiscoveryDiscoverTypeListDiscoverType,
        pydantic.Field(alias="discoverType"),
    ]
    r"""Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task."""

    item_list: Annotated[List[str], pydantic.Field(alias="itemList")]
    r"""Comma-separated list of items to return from the Discover task. Each item returned generates a Collect task and can be referenced using `${id}` in the Collect URL, headers, or parameters."""

    @field_serializer("discover_type")
    def serialize_discover_type(self, value):
        if isinstance(value, str):
            try:
                return models.RestCollectMethodOtherRestDiscoveryDiscoverTypeListDiscoverType(
                    value
                )
            except ValueError:
                return value
        return value


class RestCollectMethodOtherRestDiscoveryDiscoverTypeJSONDiscoverType(
    str, Enum, metaclass=utils.OpenEnumMeta
):
    r"""Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task."""

    HTTP = "http"
    JSON = "json"
    LIST = "list"
    NONE = "none"


class RestCollectMethodOtherRestDiscoveryDiscoverTypeJSONTypedDict(TypedDict):
    discover_type: RestCollectMethodOtherRestDiscoveryDiscoverTypeJSONDiscoverType
    r"""Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task."""
    manual_discover_result: str
    r"""Allows hard-coding the Discover result. Must be a JSON object or array. Works with Discover data field."""
    discover_data_field: NotRequired[str]
    r"""Within the response JSON, the name of the field to pull results from, typically a JSON array. Leave blank if the result itself is an array of values. Sample entry: items, json: { items: [{id: 'first'},{id: 'second'}] }"""


class RestCollectMethodOtherRestDiscoveryDiscoverTypeJSON(BaseModel):
    discover_type: Annotated[
        RestCollectMethodOtherRestDiscoveryDiscoverTypeJSONDiscoverType,
        pydantic.Field(alias="discoverType"),
    ]
    r"""Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task."""

    manual_discover_result: Annotated[str, pydantic.Field(alias="manualDiscoverResult")]
    r"""Allows hard-coding the Discover result. Must be a JSON object or array. Works with Discover data field."""

    discover_data_field: Annotated[
        Optional[str], pydantic.Field(alias="discoverDataField")
    ] = None
    r"""Within the response JSON, the name of the field to pull results from, typically a JSON array. Leave blank if the result itself is an array of values. Sample entry: items, json: { items: [{id: 'first'},{id: 'second'}] }"""

    @field_serializer("discover_type")
    def serialize_discover_type(self, value):
        if isinstance(value, str):
            try:
                return models.RestCollectMethodOtherRestDiscoveryDiscoverTypeJSONDiscoverType(
                    value
                )
            except ValueError:
                return value
        return value

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(["discoverDataField"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


class RestCollectMethodOtherRestDiscoveryDiscoverTypeHTTPDiscoverMethodOtherDiscoverMethod(
    str, Enum, metaclass=utils.OpenEnumMeta
):
    # GET
    GET = "get"
    # POST
    POST = "post"
    # POST with Body
    POST_WITH_BODY = "post_with_body"
    # Other
    OTHER = "other"


class RestCollectMethodOtherRestDiscoveryDiscoverTypeHTTPDiscoverMethodOtherDiscoverType(
    str, Enum, metaclass=utils.OpenEnumMeta
):
    r"""Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task."""

    HTTP = "http"
    JSON = "json"
    LIST = "list"
    NONE = "none"


class RestCollectMethodOtherRestDiscoveryDiscoverTypeHTTPDiscoverMethodOtherPaginationTypedDict(
    TypedDict
):
    type: PaginationOptionsRestDiscoveryDiscoverTypeHTTPPagination


class RestCollectMethodOtherRestDiscoveryDiscoverTypeHTTPDiscoverMethodOtherPagination(
    BaseModel
):
    type: PaginationOptionsRestDiscoveryDiscoverTypeHTTPPagination

    @field_serializer("type")
    def serialize_type(self, value):
        if isinstance(value, str):
            try:
                return models.PaginationOptionsRestDiscoveryDiscoverTypeHTTPPagination(
                    value
                )
            except ValueError:
                return value
        return value


class RestCollectMethodOtherRestDiscoveryDiscoverTypeHTTPDiscoverMethodOtherTypedDict(
    TypedDict
):
    discover_method: RestCollectMethodOtherRestDiscoveryDiscoverTypeHTTPDiscoverMethodOtherDiscoverMethod
    discover_verb: Any
    discover_type: RestCollectMethodOtherRestDiscoveryDiscoverTypeHTTPDiscoverMethodOtherDiscoverType
    r"""Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task."""
    discover_url: str
    r"""URL to use for the Discover operation. Can be a constant URL, or a JavaScript expression to derive the URL."""
    discover_body: NotRequired[Any]
    discover_request_params: NotRequired[Any]
    discover_request_headers: NotRequired[
        List[ItemsTypeRestCollectMethodGetCollectRequestParamsTypedDict]
    ]
    pagination: NotRequired[
        RestCollectMethodOtherRestDiscoveryDiscoverTypeHTTPDiscoverMethodOtherPaginationTypedDict
    ]
    discover_data_field: NotRequired[str]
    r"""Path to field in the response object that contains discovery results (ex: level1.name). Leave blank if the result is an array."""
    enable_strict_discover_parsing: NotRequired[bool]
    r"""Explicitly set the discover response format. When disabled, best effort parsing is used."""
    discover_response_format: NotRequired[Any]
    enable_discover_code: NotRequired[bool]


class RestCollectMethodOtherRestDiscoveryDiscoverTypeHTTPDiscoverMethodOther(BaseModel):
    discover_method: Annotated[
        RestCollectMethodOtherRestDiscoveryDiscoverTypeHTTPDiscoverMethodOtherDiscoverMethod,
        pydantic.Field(alias="discoverMethod"),
    ]

    discover_verb: Annotated[Any, pydantic.Field(alias="discoverVerb")]

    discover_type: Annotated[
        RestCollectMethodOtherRestDiscoveryDiscoverTypeHTTPDiscoverMethodOtherDiscoverType,
        pydantic.Field(alias="discoverType"),
    ]
    r"""Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task."""

    discover_url: Annotated[str, pydantic.Field(alias="discoverUrl")]
    r"""URL to use for the Discover operation. Can be a constant URL, or a JavaScript expression to derive the URL."""

    discover_body: Annotated[Optional[Any], pydantic.Field(alias="discoverBody")] = None

    discover_request_params: Annotated[
        Optional[Any], pydantic.Field(alias="discoverRequestParams")
    ] = None

    discover_request_headers: Annotated[
        Optional[List[ItemsTypeRestCollectMethodGetCollectRequestParams]],
        pydantic.Field(alias="discoverRequestHeaders"),
    ] = None

    pagination: Optional[
        RestCollectMethodOtherRestDiscoveryDiscoverTypeHTTPDiscoverMethodOtherPagination
    ] = None

    discover_data_field: Annotated[
        Optional[str], pydantic.Field(alias="discoverDataField")
    ] = None
    r"""Path to field in the response object that contains discovery results (ex: level1.name). Leave blank if the result is an array."""

    enable_strict_discover_parsing: Annotated[
        Optional[bool], pydantic.Field(alias="enableStrictDiscoverParsing")
    ] = None
    r"""Explicitly set the discover response format. When disabled, best effort parsing is used."""

    discover_response_format: Annotated[
        Optional[Any], pydantic.Field(alias="discoverResponseFormat")
    ] = None

    enable_discover_code: Annotated[
        Optional[bool], pydantic.Field(alias="enableDiscoverCode")
    ] = None

    @field_serializer("discover_method")
    def serialize_discover_method(self, value):
        if isinstance(value, str):
            try:
                return models.RestCollectMethodOtherRestDiscoveryDiscoverTypeHTTPDiscoverMethodOtherDiscoverMethod(
                    value
                )
            except ValueError:
                return value
        return value

    @field_serializer("discover_type")
    def serialize_discover_type(self, value):
        if isinstance(value, str):
            try:
                return models.RestCollectMethodOtherRestDiscoveryDiscoverTypeHTTPDiscoverMethodOtherDiscoverType(
                    value
                )
            except ValueError:
                return value
        return value

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(
            [
                "discoverBody",
                "discoverRequestParams",
                "discoverRequestHeaders",
                "pagination",
                "discoverDataField",
                "enableStrictDiscoverParsing",
                "discoverResponseFormat",
                "enableDiscoverCode",
            ]
        )
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


class RestCollectMethodOtherRestDiscoveryDiscoverTypeHTTPDiscoverMethodPostWithBodyDiscoverMethod(
    str, Enum, metaclass=utils.OpenEnumMeta
):
    # GET
    GET = "get"
    # POST
    POST = "post"
    # POST with Body
    POST_WITH_BODY = "post_with_body"
    # Other
    OTHER = "other"


class RestCollectMethodOtherRestDiscoveryDiscoverTypeHTTPDiscoverMethodPostWithBodyDiscoverType(
    str, Enum, metaclass=utils.OpenEnumMeta
):
    r"""Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task."""

    HTTP = "http"
    JSON = "json"
    LIST = "list"
    NONE = "none"


class RestCollectMethodOtherRestDiscoveryDiscoverTypeHTTPDiscoverMethodPostWithBodyPaginationTypedDict(
    TypedDict
):
    type: PaginationOptionsRestDiscoveryDiscoverTypeHTTPPagination


class RestCollectMethodOtherRestDiscoveryDiscoverTypeHTTPDiscoverMethodPostWithBodyPagination(
    BaseModel
):
    type: PaginationOptionsRestDiscoveryDiscoverTypeHTTPPagination

    @field_serializer("type")
    def serialize_type(self, value):
        if isinstance(value, str):
            try:
                return models.PaginationOptionsRestDiscoveryDiscoverTypeHTTPPagination(
                    value
                )
            except ValueError:
                return value
        return value


class RestCollectMethodOtherRestDiscoveryDiscoverTypeHTTPDiscoverMethodPostWithBodyTypedDict(
    TypedDict
):
    discover_method: RestCollectMethodOtherRestDiscoveryDiscoverTypeHTTPDiscoverMethodPostWithBodyDiscoverMethod
    discover_body: Any
    discover_type: RestCollectMethodOtherRestDiscoveryDiscoverTypeHTTPDiscoverMethodPostWithBodyDiscoverType
    r"""Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task."""
    discover_url: str
    r"""URL to use for the Discover operation. Can be a constant URL, or a JavaScript expression to derive the URL."""
    discover_verb: NotRequired[Any]
    discover_request_params: NotRequired[Any]
    discover_request_headers: NotRequired[
        List[ItemsTypeRestCollectMethodGetCollectRequestParamsTypedDict]
    ]
    pagination: NotRequired[
        RestCollectMethodOtherRestDiscoveryDiscoverTypeHTTPDiscoverMethodPostWithBodyPaginationTypedDict
    ]
    discover_data_field: NotRequired[str]
    r"""Path to field in the response object that contains discovery results (ex: level1.name). Leave blank if the result is an array."""
    enable_strict_discover_parsing: NotRequired[bool]
    r"""Explicitly set the discover response format. When disabled, best effort parsing is used."""
    discover_response_format: NotRequired[Any]
    enable_discover_code: NotRequired[bool]


class RestCollectMethodOtherRestDiscoveryDiscoverTypeHTTPDiscoverMethodPostWithBody(
    BaseModel
):
    discover_method: Annotated[
        RestCollectMethodOtherRestDiscoveryDiscoverTypeHTTPDiscoverMethodPostWithBodyDiscoverMethod,
        pydantic.Field(alias="discoverMethod"),
    ]

    discover_body: Annotated[Any, pydantic.Field(alias="discoverBody")]

    discover_type: Annotated[
        RestCollectMethodOtherRestDiscoveryDiscoverTypeHTTPDiscoverMethodPostWithBodyDiscoverType,
        pydantic.Field(alias="discoverType"),
    ]
    r"""Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task."""

    discover_url: Annotated[str, pydantic.Field(alias="discoverUrl")]
    r"""URL to use for the Discover operation. Can be a constant URL, or a JavaScript expression to derive the URL."""

    discover_verb: Annotated[Optional[Any], pydantic.Field(alias="discoverVerb")] = None

    discover_request_params: Annotated[
        Optional[Any], pydantic.Field(alias="discoverRequestParams")
    ] = None

    discover_request_headers: Annotated[
        Optional[List[ItemsTypeRestCollectMethodGetCollectRequestParams]],
        pydantic.Field(alias="discoverRequestHeaders"),
    ] = None

    pagination: Optional[
        RestCollectMethodOtherRestDiscoveryDiscoverTypeHTTPDiscoverMethodPostWithBodyPagination
    ] = None

    discover_data_field: Annotated[
        Optional[str], pydantic.Field(alias="discoverDataField")
    ] = None
    r"""Path to field in the response object that contains discovery results (ex: level1.name). Leave blank if the result is an array."""

    enable_strict_discover_parsing: Annotated[
        Optional[bool], pydantic.Field(alias="enableStrictDiscoverParsing")
    ] = None
    r"""Explicitly set the discover response format. When disabled, best effort parsing is used."""

    discover_response_format: Annotated[
        Optional[Any], pydantic.Field(alias="discoverResponseFormat")
    ] = None

    enable_discover_code: Annotated[
        Optional[bool], pydantic.Field(alias="enableDiscoverCode")
    ] = None

    @field_serializer("discover_method")
    def serialize_discover_method(self, value):
        if isinstance(value, str):
            try:
                return models.RestCollectMethodOtherRestDiscoveryDiscoverTypeHTTPDiscoverMethodPostWithBodyDiscoverMethod(
                    value
                )
            except ValueError:
                return value
        return value

    @field_serializer("discover_type")
    def serialize_discover_type(self, value):
        if isinstance(value, str):
            try:
                return models.RestCollectMethodOtherRestDiscoveryDiscoverTypeHTTPDiscoverMethodPostWithBodyDiscoverType(
                    value
                )
            except ValueError:
                return value
        return value

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(
            [
                "discoverVerb",
                "discoverRequestParams",
                "discoverRequestHeaders",
                "pagination",
                "discoverDataField",
                "enableStrictDiscoverParsing",
                "discoverResponseFormat",
                "enableDiscoverCode",
            ]
        )
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


class RestCollectMethodOtherRestDiscoveryDiscoverTypeHTTPDiscoverMethodPostDiscoverMethod(
    str, Enum, metaclass=utils.OpenEnumMeta
):
    # GET
    GET = "get"
    # POST
    POST = "post"
    # POST with Body
    POST_WITH_BODY = "post_with_body"
    # Other
    OTHER = "other"


class RestCollectMethodOtherRestDiscoveryDiscoverTypeHTTPDiscoverMethodPostDiscoverType(
    str, Enum, metaclass=utils.OpenEnumMeta
):
    r"""Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task."""

    HTTP = "http"
    JSON = "json"
    LIST = "list"
    NONE = "none"


class RestCollectMethodOtherRestDiscoveryDiscoverTypeHTTPDiscoverMethodPostPaginationTypedDict(
    TypedDict
):
    type: PaginationOptionsRestDiscoveryDiscoverTypeHTTPPagination


class RestCollectMethodOtherRestDiscoveryDiscoverTypeHTTPDiscoverMethodPostPagination(
    BaseModel
):
    type: PaginationOptionsRestDiscoveryDiscoverTypeHTTPPagination

    @field_serializer("type")
    def serialize_type(self, value):
        if isinstance(value, str):
            try:
                return models.PaginationOptionsRestDiscoveryDiscoverTypeHTTPPagination(
                    value
                )
            except ValueError:
                return value
        return value


class RestCollectMethodOtherRestDiscoveryDiscoverTypeHTTPDiscoverMethodPostTypedDict(
    TypedDict
):
    discover_method: RestCollectMethodOtherRestDiscoveryDiscoverTypeHTTPDiscoverMethodPostDiscoverMethod
    discover_type: RestCollectMethodOtherRestDiscoveryDiscoverTypeHTTPDiscoverMethodPostDiscoverType
    r"""Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task."""
    discover_url: str
    r"""URL to use for the Discover operation. Can be a constant URL, or a JavaScript expression to derive the URL."""
    discover_request_params: NotRequired[Any]
    discover_verb: NotRequired[Any]
    discover_body: NotRequired[Any]
    discover_request_headers: NotRequired[
        List[ItemsTypeRestCollectMethodGetCollectRequestParamsTypedDict]
    ]
    pagination: NotRequired[
        RestCollectMethodOtherRestDiscoveryDiscoverTypeHTTPDiscoverMethodPostPaginationTypedDict
    ]
    discover_data_field: NotRequired[str]
    r"""Path to field in the response object that contains discovery results (ex: level1.name). Leave blank if the result is an array."""
    enable_strict_discover_parsing: NotRequired[bool]
    r"""Explicitly set the discover response format. When disabled, best effort parsing is used."""
    discover_response_format: NotRequired[Any]
    enable_discover_code: NotRequired[bool]


class RestCollectMethodOtherRestDiscoveryDiscoverTypeHTTPDiscoverMethodPost(BaseModel):
    discover_method: Annotated[
        RestCollectMethodOtherRestDiscoveryDiscoverTypeHTTPDiscoverMethodPostDiscoverMethod,
        pydantic.Field(alias="discoverMethod"),
    ]

    discover_type: Annotated[
        RestCollectMethodOtherRestDiscoveryDiscoverTypeHTTPDiscoverMethodPostDiscoverType,
        pydantic.Field(alias="discoverType"),
    ]
    r"""Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task."""

    discover_url: Annotated[str, pydantic.Field(alias="discoverUrl")]
    r"""URL to use for the Discover operation. Can be a constant URL, or a JavaScript expression to derive the URL."""

    discover_request_params: Annotated[
        Optional[Any], pydantic.Field(alias="discoverRequestParams")
    ] = None

    discover_verb: Annotated[Optional[Any], pydantic.Field(alias="discoverVerb")] = None

    discover_body: Annotated[Optional[Any], pydantic.Field(alias="discoverBody")] = None

    discover_request_headers: Annotated[
        Optional[List[ItemsTypeRestCollectMethodGetCollectRequestParams]],
        pydantic.Field(alias="discoverRequestHeaders"),
    ] = None

    pagination: Optional[
        RestCollectMethodOtherRestDiscoveryDiscoverTypeHTTPDiscoverMethodPostPagination
    ] = None

    discover_data_field: Annotated[
        Optional[str], pydantic.Field(alias="discoverDataField")
    ] = None
    r"""Path to field in the response object that contains discovery results (ex: level1.name). Leave blank if the result is an array."""

    enable_strict_discover_parsing: Annotated[
        Optional[bool], pydantic.Field(alias="enableStrictDiscoverParsing")
    ] = None
    r"""Explicitly set the discover response format. When disabled, best effort parsing is used."""

    discover_response_format: Annotated[
        Optional[Any], pydantic.Field(alias="discoverResponseFormat")
    ] = None

    enable_discover_code: Annotated[
        Optional[bool], pydantic.Field(alias="enableDiscoverCode")
    ] = None

    @field_serializer("discover_method")
    def serialize_discover_method(self, value):
        if isinstance(value, str):
            try:
                return models.RestCollectMethodOtherRestDiscoveryDiscoverTypeHTTPDiscoverMethodPostDiscoverMethod(
                    value
                )
            except ValueError:
                return value
        return value

    @field_serializer("discover_type")
    def serialize_discover_type(self, value):
        if isinstance(value, str):
            try:
                return models.RestCollectMethodOtherRestDiscoveryDiscoverTypeHTTPDiscoverMethodPostDiscoverType(
                    value
                )
            except ValueError:
                return value
        return value

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(
            [
                "discoverRequestParams",
                "discoverVerb",
                "discoverBody",
                "discoverRequestHeaders",
                "pagination",
                "discoverDataField",
                "enableStrictDiscoverParsing",
                "discoverResponseFormat",
                "enableDiscoverCode",
            ]
        )
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


class RestCollectMethodOtherRestDiscoveryDiscoverTypeHTTPDiscoverMethodGetDiscoverMethod(
    str, Enum, metaclass=utils.OpenEnumMeta
):
    # GET
    GET = "get"
    # POST
    POST = "post"
    # POST with Body
    POST_WITH_BODY = "post_with_body"
    # Other
    OTHER = "other"


class RestCollectMethodOtherRestDiscoveryDiscoverTypeHTTPDiscoverMethodGetDiscoverType(
    str, Enum, metaclass=utils.OpenEnumMeta
):
    r"""Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task."""

    HTTP = "http"
    JSON = "json"
    LIST = "list"
    NONE = "none"


class RestCollectMethodOtherRestDiscoveryDiscoverTypeHTTPDiscoverMethodGetPaginationTypedDict(
    TypedDict
):
    type: PaginationOptionsRestDiscoveryDiscoverTypeHTTPPagination


class RestCollectMethodOtherRestDiscoveryDiscoverTypeHTTPDiscoverMethodGetPagination(
    BaseModel
):
    type: PaginationOptionsRestDiscoveryDiscoverTypeHTTPPagination

    @field_serializer("type")
    def serialize_type(self, value):
        if isinstance(value, str):
            try:
                return models.PaginationOptionsRestDiscoveryDiscoverTypeHTTPPagination(
                    value
                )
            except ValueError:
                return value
        return value


class RestCollectMethodOtherRestDiscoveryDiscoverTypeHTTPDiscoverMethodGetTypedDict(
    TypedDict
):
    discover_method: RestCollectMethodOtherRestDiscoveryDiscoverTypeHTTPDiscoverMethodGetDiscoverMethod
    discover_type: (
        RestCollectMethodOtherRestDiscoveryDiscoverTypeHTTPDiscoverMethodGetDiscoverType
    )
    r"""Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task."""
    discover_url: str
    r"""URL to use for the Discover operation. Can be a constant URL, or a JavaScript expression to derive the URL."""
    discover_request_params: NotRequired[Any]
    discover_verb: NotRequired[Any]
    discover_body: NotRequired[Any]
    discover_request_headers: NotRequired[
        List[ItemsTypeRestCollectMethodGetCollectRequestParamsTypedDict]
    ]
    pagination: NotRequired[
        RestCollectMethodOtherRestDiscoveryDiscoverTypeHTTPDiscoverMethodGetPaginationTypedDict
    ]
    discover_data_field: NotRequired[str]
    r"""Path to field in the response object that contains discovery results (ex: level1.name). Leave blank if the result is an array."""
    enable_strict_discover_parsing: NotRequired[bool]
    r"""Explicitly set the discover response format. When disabled, best effort parsing is used."""
    discover_response_format: NotRequired[Any]
    enable_discover_code: NotRequired[bool]


class RestCollectMethodOtherRestDiscoveryDiscoverTypeHTTPDiscoverMethodGet(BaseModel):
    discover_method: Annotated[
        RestCollectMethodOtherRestDiscoveryDiscoverTypeHTTPDiscoverMethodGetDiscoverMethod,
        pydantic.Field(alias="discoverMethod"),
    ]

    discover_type: Annotated[
        RestCollectMethodOtherRestDiscoveryDiscoverTypeHTTPDiscoverMethodGetDiscoverType,
        pydantic.Field(alias="discoverType"),
    ]
    r"""Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task."""

    discover_url: Annotated[str, pydantic.Field(alias="discoverUrl")]
    r"""URL to use for the Discover operation. Can be a constant URL, or a JavaScript expression to derive the URL."""

    discover_request_params: Annotated[
        Optional[Any], pydantic.Field(alias="discoverRequestParams")
    ] = None

    discover_verb: Annotated[Optional[Any], pydantic.Field(alias="discoverVerb")] = None

    discover_body: Annotated[Optional[Any], pydantic.Field(alias="discoverBody")] = None

    discover_request_headers: Annotated[
        Optional[List[ItemsTypeRestCollectMethodGetCollectRequestParams]],
        pydantic.Field(alias="discoverRequestHeaders"),
    ] = None

    pagination: Optional[
        RestCollectMethodOtherRestDiscoveryDiscoverTypeHTTPDiscoverMethodGetPagination
    ] = None

    discover_data_field: Annotated[
        Optional[str], pydantic.Field(alias="discoverDataField")
    ] = None
    r"""Path to field in the response object that contains discovery results (ex: level1.name). Leave blank if the result is an array."""

    enable_strict_discover_parsing: Annotated[
        Optional[bool], pydantic.Field(alias="enableStrictDiscoverParsing")
    ] = None
    r"""Explicitly set the discover response format. When disabled, best effort parsing is used."""

    discover_response_format: Annotated[
        Optional[Any], pydantic.Field(alias="discoverResponseFormat")
    ] = None

    enable_discover_code: Annotated[
        Optional[bool], pydantic.Field(alias="enableDiscoverCode")
    ] = None

    @field_serializer("discover_method")
    def serialize_discover_method(self, value):
        if isinstance(value, str):
            try:
                return models.RestCollectMethodOtherRestDiscoveryDiscoverTypeHTTPDiscoverMethodGetDiscoverMethod(
                    value
                )
            except ValueError:
                return value
        return value

    @field_serializer("discover_type")
    def serialize_discover_type(self, value):
        if isinstance(value, str):
            try:
                return models.RestCollectMethodOtherRestDiscoveryDiscoverTypeHTTPDiscoverMethodGetDiscoverType(
                    value
                )
            except ValueError:
                return value
        return value

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(
            [
                "discoverRequestParams",
                "discoverVerb",
                "discoverBody",
                "discoverRequestHeaders",
                "pagination",
                "discoverDataField",
                "enableStrictDiscoverParsing",
                "discoverResponseFormat",
                "enableDiscoverCode",
            ]
        )
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


RestCollectMethodOtherRestDiscoveryDiscoverTypeHTTPTypedDict = TypeAliasType(
    "RestCollectMethodOtherRestDiscoveryDiscoverTypeHTTPTypedDict",
    Union[
        RestCollectMethodOtherRestDiscoveryDiscoverTypeHTTPDiscoverMethodGetTypedDict,
        RestCollectMethodOtherRestDiscoveryDiscoverTypeHTTPDiscoverMethodPostTypedDict,
        RestCollectMethodOtherRestDiscoveryDiscoverTypeHTTPDiscoverMethodPostWithBodyTypedDict,
        RestCollectMethodOtherRestDiscoveryDiscoverTypeHTTPDiscoverMethodOtherTypedDict,
    ],
)


class UnknownRestCollectMethodOtherRestDiscoveryDiscoverTypeHTTP(BaseModel):
    r"""A RestCollectMethodOtherRestDiscoveryDiscoverTypeHTTP variant the SDK doesn't recognize. Preserves the raw payload."""

    discover_method: Literal["UNKNOWN"] = "UNKNOWN"
    raw: Any
    is_unknown: Literal[True] = True

    model_config = ConfigDict(frozen=True)


_REST_COLLECT_METHOD_OTHER_REST_DISCOVERY_DISCOVER_TYPE_HTTP_VARIANTS: dict[
    str, Any
] = {
    "get": RestCollectMethodOtherRestDiscoveryDiscoverTypeHTTPDiscoverMethodGet,
    "post": RestCollectMethodOtherRestDiscoveryDiscoverTypeHTTPDiscoverMethodPost,
    "post_with_body": RestCollectMethodOtherRestDiscoveryDiscoverTypeHTTPDiscoverMethodPostWithBody,
    "other": RestCollectMethodOtherRestDiscoveryDiscoverTypeHTTPDiscoverMethodOther,
}


RestCollectMethodOtherRestDiscoveryDiscoverTypeHTTP = Annotated[
    Union[
        RestCollectMethodOtherRestDiscoveryDiscoverTypeHTTPDiscoverMethodGet,
        RestCollectMethodOtherRestDiscoveryDiscoverTypeHTTPDiscoverMethodPost,
        RestCollectMethodOtherRestDiscoveryDiscoverTypeHTTPDiscoverMethodPostWithBody,
        RestCollectMethodOtherRestDiscoveryDiscoverTypeHTTPDiscoverMethodOther,
        UnknownRestCollectMethodOtherRestDiscoveryDiscoverTypeHTTP,
    ],
    BeforeValidator(
        partial(
            parse_open_union,
            disc_key="discoverMethod",
            variants=_REST_COLLECT_METHOD_OTHER_REST_DISCOVERY_DISCOVER_TYPE_HTTP_VARIANTS,
            unknown_cls=UnknownRestCollectMethodOtherRestDiscoveryDiscoverTypeHTTP,
            union_name="RestCollectMethodOtherRestDiscoveryDiscoverTypeHTTP",
        )
    ),
]


RestCollectMethodOtherDiscoveryTypedDict = TypeAliasType(
    "RestCollectMethodOtherDiscoveryTypedDict",
    Union[
        RestCollectMethodOtherRestDiscoveryDiscoverTypeNoneTypedDict,
        RestCollectMethodOtherRestDiscoveryDiscoverTypeListTypedDict,
        RestCollectMethodOtherRestDiscoveryDiscoverTypeJSONTypedDict,
        RestCollectMethodOtherRestDiscoveryDiscoverTypeHTTPTypedDict,
    ],
)


class UnknownRestCollectMethodOtherDiscovery(BaseModel):
    r"""A RestCollectMethodOtherDiscovery variant the SDK doesn't recognize. Preserves the raw payload."""

    discover_type: Literal["UNKNOWN"] = "UNKNOWN"
    raw: Any
    is_unknown: Literal[True] = True

    model_config = ConfigDict(frozen=True)


_REST_COLLECT_METHOD_OTHER_DISCOVERY_VARIANTS: dict[str, Any] = {
    "http": RestCollectMethodOtherRestDiscoveryDiscoverTypeHTTP,
    "json": RestCollectMethodOtherRestDiscoveryDiscoverTypeJSON,
    "list": RestCollectMethodOtherRestDiscoveryDiscoverTypeList,
    "none": RestCollectMethodOtherRestDiscoveryDiscoverTypeNone,
}


RestCollectMethodOtherDiscovery = Annotated[
    Union[
        RestCollectMethodOtherRestDiscoveryDiscoverTypeHTTP,
        RestCollectMethodOtherRestDiscoveryDiscoverTypeJSON,
        RestCollectMethodOtherRestDiscoveryDiscoverTypeList,
        RestCollectMethodOtherRestDiscoveryDiscoverTypeNone,
        UnknownRestCollectMethodOtherDiscovery,
    ],
    BeforeValidator(
        partial(
            parse_open_union,
            disc_key="discoverType",
            variants=_REST_COLLECT_METHOD_OTHER_DISCOVERY_VARIANTS,
            unknown_cls=UnknownRestCollectMethodOtherDiscovery,
            union_name="RestCollectMethodOtherDiscovery",
        )
    ),
]


class RestCollectMethodOtherRestPaginationTypeRequestPageTypedDict(TypedDict):
    type: PaginationOptionsRestDiscoveryDiscoverTypeHTTPPagination
    page_field: str
    r"""Query string parameter that sets the page index to be returned. Example: /api/v1/query?term=cribl&page_size=100&page_number=0"""
    size_field: str
    r"""Query string parameter that sets the number of records retrieved per request. Example: /api/v1/query?term=cribl&page_size=100&page_number=0"""
    size: float
    r"""Maximum number of records to collect per page"""
    max_pages: float
    r"""Maximum number of pages to retrieve per collection task. Defaults to 50 pages. Set to 0 to retrieve all pages."""
    zero_indexed: bool
    r"""Enable to indicate that the first page in the requested data is at index 0. Disabled by default, which indicates index 1."""
    page: NotRequired[float]
    r"""Page number from which to start request. Defaults to undefined, which will start collection from the first page."""
    total_page_field: NotRequired[str]
    r"""Name of the attribute in the response that contains the total number of pages for the query"""
    total_record_field: NotRequired[str]
    r"""Name of the attribute in the response that contains the total number of records for the query"""


class RestCollectMethodOtherRestPaginationTypeRequestPage(BaseModel):
    type: PaginationOptionsRestDiscoveryDiscoverTypeHTTPPagination

    page_field: Annotated[str, pydantic.Field(alias="pageField")]
    r"""Query string parameter that sets the page index to be returned. Example: /api/v1/query?term=cribl&page_size=100&page_number=0"""

    size_field: Annotated[str, pydantic.Field(alias="sizeField")]
    r"""Query string parameter that sets the number of records retrieved per request. Example: /api/v1/query?term=cribl&page_size=100&page_number=0"""

    size: float
    r"""Maximum number of records to collect per page"""

    max_pages: Annotated[float, pydantic.Field(alias="maxPages")]
    r"""Maximum number of pages to retrieve per collection task. Defaults to 50 pages. Set to 0 to retrieve all pages."""

    zero_indexed: Annotated[bool, pydantic.Field(alias="zeroIndexed")]
    r"""Enable to indicate that the first page in the requested data is at index 0. Disabled by default, which indicates index 1."""

    page: Optional[float] = None
    r"""Page number from which to start request. Defaults to undefined, which will start collection from the first page."""

    total_page_field: Annotated[
        Optional[str], pydantic.Field(alias="totalPageField")
    ] = None
    r"""Name of the attribute in the response that contains the total number of pages for the query"""

    total_record_field: Annotated[
        Optional[str], pydantic.Field(alias="totalRecordField")
    ] = None
    r"""Name of the attribute in the response that contains the total number of records for the query"""

    @field_serializer("type")
    def serialize_type(self, value):
        if isinstance(value, str):
            try:
                return models.PaginationOptionsRestDiscoveryDiscoverTypeHTTPPagination(
                    value
                )
            except ValueError:
                return value
        return value

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(["page", "totalPageField", "totalRecordField"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


class RestCollectMethodOtherRestPaginationTypeRequestOffsetTypedDict(TypedDict):
    type: PaginationOptionsRestDiscoveryDiscoverTypeHTTPPagination
    offset_field: str
    r"""Query string parameter that sets the index from which to begin returning records. Example: /api/v1/query?term=cribl&limit=100&offset=0"""
    limit_field: str
    r"""Query string parameter that sets the number of records retrieved per request. Example: /api/v1/query?term=cribl&limit=100&offset=0"""
    limit: float
    r"""Maximum number of records to collect per request"""
    max_pages: float
    r"""Maximum number of pages to retrieve per collection task. Defaults to 50 pages. Set to 0 to retrieve all pages."""
    zero_indexed: bool
    r"""Enable to indicate that the first page in the requested data is at index 0. Disabled by default, which indicates index 1."""
    offset: NotRequired[float]
    r"""Offset index from which to start request. Defaults to undefined, which will start collection from the first record."""
    total_record_field: NotRequired[str]
    r"""Name of the attribute in the response that contains the total number of records for the query"""


class RestCollectMethodOtherRestPaginationTypeRequestOffset(BaseModel):
    type: PaginationOptionsRestDiscoveryDiscoverTypeHTTPPagination

    offset_field: Annotated[str, pydantic.Field(alias="offsetField")]
    r"""Query string parameter that sets the index from which to begin returning records. Example: /api/v1/query?term=cribl&limit=100&offset=0"""

    limit_field: Annotated[str, pydantic.Field(alias="limitField")]
    r"""Query string parameter that sets the number of records retrieved per request. Example: /api/v1/query?term=cribl&limit=100&offset=0"""

    limit: float
    r"""Maximum number of records to collect per request"""

    max_pages: Annotated[float, pydantic.Field(alias="maxPages")]
    r"""Maximum number of pages to retrieve per collection task. Defaults to 50 pages. Set to 0 to retrieve all pages."""

    zero_indexed: Annotated[bool, pydantic.Field(alias="zeroIndexed")]
    r"""Enable to indicate that the first page in the requested data is at index 0. Disabled by default, which indicates index 1."""

    offset: Optional[float] = None
    r"""Offset index from which to start request. Defaults to undefined, which will start collection from the first record."""

    total_record_field: Annotated[
        Optional[str], pydantic.Field(alias="totalRecordField")
    ] = None
    r"""Name of the attribute in the response that contains the total number of records for the query"""

    @field_serializer("type")
    def serialize_type(self, value):
        if isinstance(value, str):
            try:
                return models.PaginationOptionsRestDiscoveryDiscoverTypeHTTPPagination(
                    value
                )
            except ValueError:
                return value
        return value

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(["offset", "totalRecordField"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


class RestCollectMethodOtherRestPaginationTypeResponseHeaderLinkTypedDict(TypedDict):
    type: PaginationOptionsRestDiscoveryDiscoverTypeHTTPPagination
    next_relation_attribute: str
    r"""Relation name used in the link header that refers to the next page in the result set. Example: rel=\"next\" refers to the next page of results: <https://myHost/nextPage>; rel=\"next\" """
    max_pages: float
    r"""Maximum number of pages to retrieve per collection task. Defaults to 50 pages. Set to 0 to retrieve all pages."""
    cur_relation_attribute: NotRequired[str]
    r"""Relation name used in the link header that refers to the current result set. Example: rel=\"self\" refers to the current page of results: <https://myHost/curPage>; rel=\"self\" """


class RestCollectMethodOtherRestPaginationTypeResponseHeaderLink(BaseModel):
    type: PaginationOptionsRestDiscoveryDiscoverTypeHTTPPagination

    next_relation_attribute: Annotated[
        str, pydantic.Field(alias="nextRelationAttribute")
    ]
    r"""Relation name used in the link header that refers to the next page in the result set. Example: rel=\"next\" refers to the next page of results: <https://myHost/nextPage>; rel=\"next\" """

    max_pages: Annotated[float, pydantic.Field(alias="maxPages")]
    r"""Maximum number of pages to retrieve per collection task. Defaults to 50 pages. Set to 0 to retrieve all pages."""

    cur_relation_attribute: Annotated[
        Optional[str], pydantic.Field(alias="curRelationAttribute")
    ] = None
    r"""Relation name used in the link header that refers to the current result set. Example: rel=\"self\" refers to the current page of results: <https://myHost/curPage>; rel=\"self\" """

    @field_serializer("type")
    def serialize_type(self, value):
        if isinstance(value, str):
            try:
                return models.PaginationOptionsRestDiscoveryDiscoverTypeHTTPPagination(
                    value
                )
            except ValueError:
                return value
        return value

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(["curRelationAttribute"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


class RestCollectMethodOtherRestPaginationTypeResponseHeaderTypedDict(TypedDict):
    type: PaginationOptionsRestDiscoveryDiscoverTypeHTTPPagination
    attribute: List[str]
    r"""Names of attributes within the response that contain next-page information"""
    max_pages: float
    r"""Maximum number of pages to retrieve per collection task. Defaults to 50 pages. Set to 0 to retrieve all pages."""


class RestCollectMethodOtherRestPaginationTypeResponseHeader(BaseModel):
    type: PaginationOptionsRestDiscoveryDiscoverTypeHTTPPagination

    attribute: List[str]
    r"""Names of attributes within the response that contain next-page information"""

    max_pages: Annotated[float, pydantic.Field(alias="maxPages")]
    r"""Maximum number of pages to retrieve per collection task. Defaults to 50 pages. Set to 0 to retrieve all pages."""

    @field_serializer("type")
    def serialize_type(self, value):
        if isinstance(value, str):
            try:
                return models.PaginationOptionsRestDiscoveryDiscoverTypeHTTPPagination(
                    value
                )
            except ValueError:
                return value
        return value


class RestCollectMethodOtherRestPaginationTypeResponseBodyTypedDict(TypedDict):
    type: PaginationOptionsRestDiscoveryDiscoverTypeHTTPPagination
    attribute: List[str]
    r"""Names of attributes within the response that contain next-page information"""
    max_pages: float
    r"""Maximum number of pages to retrieve per collection task. Defaults to 50 pages. Set to 0 to retrieve all pages."""
    last_page_expr: NotRequired[str]
    r"""JavaScript expression used to determine when the last page has been reached. The values tested by this expression must be in the Response attributes section."""


class RestCollectMethodOtherRestPaginationTypeResponseBody(BaseModel):
    type: PaginationOptionsRestDiscoveryDiscoverTypeHTTPPagination

    attribute: List[str]
    r"""Names of attributes within the response that contain next-page information"""

    max_pages: Annotated[float, pydantic.Field(alias="maxPages")]
    r"""Maximum number of pages to retrieve per collection task. Defaults to 50 pages. Set to 0 to retrieve all pages."""

    last_page_expr: Annotated[Optional[str], pydantic.Field(alias="lastPageExpr")] = (
        None
    )
    r"""JavaScript expression used to determine when the last page has been reached. The values tested by this expression must be in the Response attributes section."""

    @field_serializer("type")
    def serialize_type(self, value):
        if isinstance(value, str):
            try:
                return models.PaginationOptionsRestDiscoveryDiscoverTypeHTTPPagination(
                    value
                )
            except ValueError:
                return value
        return value

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(["lastPageExpr"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


class RestCollectMethodOtherRestPaginationTypeNoneTypedDict(TypedDict):
    type: PaginationOptionsRestDiscoveryDiscoverTypeHTTPPagination


class RestCollectMethodOtherRestPaginationTypeNone(BaseModel):
    type: PaginationOptionsRestDiscoveryDiscoverTypeHTTPPagination

    @field_serializer("type")
    def serialize_type(self, value):
        if isinstance(value, str):
            try:
                return models.PaginationOptionsRestDiscoveryDiscoverTypeHTTPPagination(
                    value
                )
            except ValueError:
                return value
        return value


RestCollectMethodOtherPaginationUnionTypedDict = TypeAliasType(
    "RestCollectMethodOtherPaginationUnionTypedDict",
    Union[
        RestCollectMethodOtherRestPaginationTypeNoneTypedDict,
        RestCollectMethodOtherRestPaginationTypeResponseHeaderTypedDict,
        RestCollectMethodOtherRestPaginationTypeResponseBodyTypedDict,
        RestCollectMethodOtherRestPaginationTypeResponseHeaderLinkTypedDict,
        RestCollectMethodOtherRestPaginationTypeRequestOffsetTypedDict,
        RestCollectMethodOtherRestPaginationTypeRequestPageTypedDict,
    ],
)


class UnknownRestCollectMethodOtherPaginationUnion(BaseModel):
    r"""A RestCollectMethodOtherPaginationUnion variant the SDK doesn't recognize. Preserves the raw payload."""

    type: Literal["UNKNOWN"] = "UNKNOWN"
    raw: Any
    is_unknown: Literal[True] = True

    model_config = ConfigDict(frozen=True)


_REST_COLLECT_METHOD_OTHER_PAGINATION_UNION_VARIANTS: dict[str, Any] = {
    "none": RestCollectMethodOtherRestPaginationTypeNone,
    "response_body": RestCollectMethodOtherRestPaginationTypeResponseBody,
    "response_header": RestCollectMethodOtherRestPaginationTypeResponseHeader,
    "response_header_link": RestCollectMethodOtherRestPaginationTypeResponseHeaderLink,
    "request_offset": RestCollectMethodOtherRestPaginationTypeRequestOffset,
    "request_page": RestCollectMethodOtherRestPaginationTypeRequestPage,
}


RestCollectMethodOtherPaginationUnion = Annotated[
    Union[
        RestCollectMethodOtherRestPaginationTypeNone,
        RestCollectMethodOtherRestPaginationTypeResponseBody,
        RestCollectMethodOtherRestPaginationTypeResponseHeader,
        RestCollectMethodOtherRestPaginationTypeResponseHeaderLink,
        RestCollectMethodOtherRestPaginationTypeRequestOffset,
        RestCollectMethodOtherRestPaginationTypeRequestPage,
        UnknownRestCollectMethodOtherPaginationUnion,
    ],
    BeforeValidator(
        partial(
            parse_open_union,
            disc_key="type",
            variants=_REST_COLLECT_METHOD_OTHER_PAGINATION_UNION_VARIANTS,
            unknown_cls=UnknownRestCollectMethodOtherPaginationUnion,
            union_name="RestCollectMethodOtherPaginationUnion",
        )
    ),
]


class RestCollectMethodOtherAuthentication(str, Enum, metaclass=utils.OpenEnumMeta):
    r"""Authentication method for Discover and Collect REST calls. You can specify API key–based authentication by adding the appropriate Collect headers."""

    NONE = "none"
    BASIC = "basic"
    BASIC_SECRET = "basicSecret"
    LOGIN = "login"
    LOGIN_SECRET = "loginSecret"
    OAUTH = "oauth"
    OAUTH_SECRET = "oauthSecret"
    GOOGLE_OAUTH = "google_oauth"
    GOOGLE_OAUTH_SECRET = "google_oauthSecret"
    HMAC = "hmac"


class RestCollectMethodOtherRestRetryRulesTypeBackoffTypedDict(TypedDict):
    type: RetryTypeOptionsHealthCheckCollectorConfRetryRules
    r"""The algorithm to use when performing HTTP retries"""
    interval: NotRequired[Any]
    limit: NotRequired[Any]
    multiplier: NotRequired[Any]
    max_interval_ms: NotRequired[Any]
    codes: NotRequired[Any]
    enable_header: NotRequired[Any]
    retry_connect_timeout: NotRequired[Any]
    retry_connect_reset: NotRequired[Any]


class RestCollectMethodOtherRestRetryRulesTypeBackoff(BaseModel):
    type: RetryTypeOptionsHealthCheckCollectorConfRetryRules
    r"""The algorithm to use when performing HTTP retries"""

    interval: Optional[Any] = None

    limit: Optional[Any] = None

    multiplier: Optional[Any] = None

    max_interval_ms: Annotated[Optional[Any], pydantic.Field(alias="maxIntervalMs")] = (
        None
    )

    codes: Optional[Any] = None

    enable_header: Annotated[Optional[Any], pydantic.Field(alias="enableHeader")] = None

    retry_connect_timeout: Annotated[
        Optional[Any], pydantic.Field(alias="retryConnectTimeout")
    ] = None

    retry_connect_reset: Annotated[
        Optional[Any], pydantic.Field(alias="retryConnectReset")
    ] = None

    @field_serializer("type")
    def serialize_type(self, value):
        if isinstance(value, str):
            try:
                return models.RetryTypeOptionsHealthCheckCollectorConfRetryRules(value)
            except ValueError:
                return value
        return value

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(
            [
                "interval",
                "limit",
                "multiplier",
                "maxIntervalMs",
                "codes",
                "enableHeader",
                "retryConnectTimeout",
                "retryConnectReset",
            ]
        )
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


class RestCollectMethodOtherRestRetryRulesTypeStaticTypedDict(TypedDict):
    type: RetryTypeOptionsHealthCheckCollectorConfRetryRules
    r"""The algorithm to use when performing HTTP retries"""
    interval: NotRequired[Any]
    limit: NotRequired[Any]
    codes: NotRequired[Any]
    enable_header: NotRequired[Any]
    retry_connect_timeout: NotRequired[Any]
    retry_connect_reset: NotRequired[Any]
    multiplier: NotRequired[Any]
    max_interval_ms: NotRequired[Any]


class RestCollectMethodOtherRestRetryRulesTypeStatic(BaseModel):
    type: RetryTypeOptionsHealthCheckCollectorConfRetryRules
    r"""The algorithm to use when performing HTTP retries"""

    interval: Optional[Any] = None

    limit: Optional[Any] = None

    codes: Optional[Any] = None

    enable_header: Annotated[Optional[Any], pydantic.Field(alias="enableHeader")] = None

    retry_connect_timeout: Annotated[
        Optional[Any], pydantic.Field(alias="retryConnectTimeout")
    ] = None

    retry_connect_reset: Annotated[
        Optional[Any], pydantic.Field(alias="retryConnectReset")
    ] = None

    multiplier: Optional[Any] = None

    max_interval_ms: Annotated[Optional[Any], pydantic.Field(alias="maxIntervalMs")] = (
        None
    )

    @field_serializer("type")
    def serialize_type(self, value):
        if isinstance(value, str):
            try:
                return models.RetryTypeOptionsHealthCheckCollectorConfRetryRules(value)
            except ValueError:
                return value
        return value

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(
            [
                "interval",
                "limit",
                "codes",
                "enableHeader",
                "retryConnectTimeout",
                "retryConnectReset",
                "multiplier",
                "maxIntervalMs",
            ]
        )
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


class RestCollectMethodOtherRestRetryRulesTypeNoneTypedDict(TypedDict):
    type: RetryTypeOptionsHealthCheckCollectorConfRetryRules
    r"""The algorithm to use when performing HTTP retries"""
    interval: NotRequired[Any]
    limit: NotRequired[Any]
    multiplier: NotRequired[Any]
    max_interval_ms: NotRequired[Any]
    codes: NotRequired[Any]
    enable_header: NotRequired[Any]
    retry_connect_timeout: NotRequired[Any]
    retry_connect_reset: NotRequired[Any]


class RestCollectMethodOtherRestRetryRulesTypeNone(BaseModel):
    type: RetryTypeOptionsHealthCheckCollectorConfRetryRules
    r"""The algorithm to use when performing HTTP retries"""

    interval: Optional[Any] = None

    limit: Optional[Any] = None

    multiplier: Optional[Any] = None

    max_interval_ms: Annotated[Optional[Any], pydantic.Field(alias="maxIntervalMs")] = (
        None
    )

    codes: Optional[Any] = None

    enable_header: Annotated[Optional[Any], pydantic.Field(alias="enableHeader")] = None

    retry_connect_timeout: Annotated[
        Optional[Any], pydantic.Field(alias="retryConnectTimeout")
    ] = None

    retry_connect_reset: Annotated[
        Optional[Any], pydantic.Field(alias="retryConnectReset")
    ] = None

    @field_serializer("type")
    def serialize_type(self, value):
        if isinstance(value, str):
            try:
                return models.RetryTypeOptionsHealthCheckCollectorConfRetryRules(value)
            except ValueError:
                return value
        return value

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(
            [
                "interval",
                "limit",
                "multiplier",
                "maxIntervalMs",
                "codes",
                "enableHeader",
                "retryConnectTimeout",
                "retryConnectReset",
            ]
        )
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


RestCollectMethodOtherRetryRulesTypedDict = TypeAliasType(
    "RestCollectMethodOtherRetryRulesTypedDict",
    Union[
        RestCollectMethodOtherRestRetryRulesTypeNoneTypedDict,
        RestCollectMethodOtherRestRetryRulesTypeStaticTypedDict,
        RestCollectMethodOtherRestRetryRulesTypeBackoffTypedDict,
    ],
)


class UnknownRestCollectMethodOtherRetryRules(BaseModel):
    r"""A RestCollectMethodOtherRetryRules variant the SDK doesn't recognize. Preserves the raw payload."""

    type: Literal["UNKNOWN"] = "UNKNOWN"
    raw: Any
    is_unknown: Literal[True] = True

    model_config = ConfigDict(frozen=True)


_REST_COLLECT_METHOD_OTHER_RETRY_RULES_VARIANTS: dict[str, Any] = {
    "none": RestCollectMethodOtherRestRetryRulesTypeNone,
    "static": RestCollectMethodOtherRestRetryRulesTypeStatic,
    "backoff": RestCollectMethodOtherRestRetryRulesTypeBackoff,
}


RestCollectMethodOtherRetryRules = Annotated[
    Union[
        RestCollectMethodOtherRestRetryRulesTypeNone,
        RestCollectMethodOtherRestRetryRulesTypeStatic,
        RestCollectMethodOtherRestRetryRulesTypeBackoff,
        UnknownRestCollectMethodOtherRetryRules,
    ],
    BeforeValidator(
        partial(
            parse_open_union,
            disc_key="type",
            variants=_REST_COLLECT_METHOD_OTHER_RETRY_RULES_VARIANTS,
            unknown_cls=UnknownRestCollectMethodOtherRetryRules,
            union_name="RestCollectMethodOtherRetryRules",
        )
    ),
]


class RestCollectMethodOtherStateTrackingTypedDict(TypedDict):
    enabled: NotRequired[bool]
    r"""Track collection progress between consecutive scheduled executions"""


class RestCollectMethodOtherStateTracking(BaseModel):
    enabled: Optional[bool] = None
    r"""Track collection progress between consecutive scheduled executions"""

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(["enabled"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


class RestCollectMethodOtherSchedulingTypedDict(TypedDict):
    state_tracking: NotRequired[RestCollectMethodOtherStateTrackingTypedDict]


class RestCollectMethodOtherScheduling(BaseModel):
    state_tracking: Annotated[
        Optional[RestCollectMethodOtherStateTracking],
        pydantic.Field(alias="stateTracking"),
    ] = None

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(["stateTracking"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


class RestCollectMethodOtherTypedDict(TypedDict):
    collect_method: RestCollectMethodOtherCollectMethod
    collect_verb: Any
    collect_url: str
    r"""URL (constant or JavaScript expression) to use for the Collect operation"""
    authentication: RestCollectMethodOtherAuthentication
    r"""Authentication method for Discover and Collect REST calls. You can specify API key–based authentication by adding the appropriate Collect headers."""
    collect_body: NotRequired[Any]
    collect_request_params: NotRequired[Any]
    discovery: NotRequired[RestCollectMethodOtherDiscoveryTypedDict]
    collect_request_headers: NotRequired[
        List[ItemsTypeRestCollectMethodGetCollectRequestParamsTypedDict]
    ]
    pagination: NotRequired[RestCollectMethodOtherPaginationUnionTypedDict]
    timeout: NotRequired[float]
    r"""HTTP request inactivity timeout. Use 0 to disable."""
    use_round_robin_dns: NotRequired[bool]
    r"""Use round-robin DNS lookup. Suitable when DNS server returns multiple addresses in sort order."""
    disable_time_filter: NotRequired[bool]
    r"""Disable Collector event time filtering when a date range is specified"""
    decode_url: NotRequired[bool]
    r"""Decode the URL before sending requests (including pagination requests)"""
    reject_unauthorized: NotRequired[bool]
    r"""Reject certificates that cannot be verified against a valid CA (such as self-signed certificates)"""
    capture_headers: NotRequired[bool]
    r"""Enable to add response headers to the resHeaders field under the __collectible object"""
    stop_on_empty_results: NotRequired[bool]
    r"""Stop pagination when the Event Breaker produces no events"""
    safe_headers: NotRequired[List[str]]
    r"""List of headers that are safe to log in plain text"""
    retry_rules: NotRequired[RestCollectMethodOtherRetryRulesTypedDict]
    scheduling: NotRequired[RestCollectMethodOtherSchedulingTypedDict]


class RestCollectMethodOther(BaseModel):
    collect_method: Annotated[
        RestCollectMethodOtherCollectMethod, pydantic.Field(alias="collectMethod")
    ]

    collect_verb: Annotated[Any, pydantic.Field(alias="collectVerb")]

    collect_url: Annotated[str, pydantic.Field(alias="collectUrl")]
    r"""URL (constant or JavaScript expression) to use for the Collect operation"""

    authentication: RestCollectMethodOtherAuthentication
    r"""Authentication method for Discover and Collect REST calls. You can specify API key–based authentication by adding the appropriate Collect headers."""

    collect_body: Annotated[Optional[Any], pydantic.Field(alias="collectBody")] = None

    collect_request_params: Annotated[
        Optional[Any], pydantic.Field(alias="collectRequestParams")
    ] = None

    discovery: Optional[RestCollectMethodOtherDiscovery] = None

    collect_request_headers: Annotated[
        Optional[List[ItemsTypeRestCollectMethodGetCollectRequestParams]],
        pydantic.Field(alias="collectRequestHeaders"),
    ] = None

    pagination: Optional[RestCollectMethodOtherPaginationUnion] = None

    timeout: Optional[float] = None
    r"""HTTP request inactivity timeout. Use 0 to disable."""

    use_round_robin_dns: Annotated[
        Optional[bool], pydantic.Field(alias="useRoundRobinDns")
    ] = None
    r"""Use round-robin DNS lookup. Suitable when DNS server returns multiple addresses in sort order."""

    disable_time_filter: Annotated[
        Optional[bool], pydantic.Field(alias="disableTimeFilter")
    ] = None
    r"""Disable Collector event time filtering when a date range is specified"""

    decode_url: Annotated[Optional[bool], pydantic.Field(alias="decodeUrl")] = None
    r"""Decode the URL before sending requests (including pagination requests)"""

    reject_unauthorized: Annotated[
        Optional[bool], pydantic.Field(alias="rejectUnauthorized")
    ] = None
    r"""Reject certificates that cannot be verified against a valid CA (such as self-signed certificates)"""

    capture_headers: Annotated[
        Optional[bool], pydantic.Field(alias="captureHeaders")
    ] = None
    r"""Enable to add response headers to the resHeaders field under the __collectible object"""

    stop_on_empty_results: Annotated[
        Optional[bool], pydantic.Field(alias="stopOnEmptyResults")
    ] = None
    r"""Stop pagination when the Event Breaker produces no events"""

    safe_headers: Annotated[
        Optional[List[str]], pydantic.Field(alias="safeHeaders")
    ] = None
    r"""List of headers that are safe to log in plain text"""

    retry_rules: Annotated[
        Optional[RestCollectMethodOtherRetryRules], pydantic.Field(alias="retryRules")
    ] = None

    scheduling: Annotated[
        Optional[RestCollectMethodOtherScheduling], pydantic.Field(alias="__scheduling")
    ] = None

    @field_serializer("collect_method")
    def serialize_collect_method(self, value):
        if isinstance(value, str):
            try:
                return models.RestCollectMethodOtherCollectMethod(value)
            except ValueError:
                return value
        return value

    @field_serializer("authentication")
    def serialize_authentication(self, value):
        if isinstance(value, str):
            try:
                return models.RestCollectMethodOtherAuthentication(value)
            except ValueError:
                return value
        return value

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(
            [
                "collectBody",
                "collectRequestParams",
                "discovery",
                "collectRequestHeaders",
                "pagination",
                "timeout",
                "useRoundRobinDns",
                "disableTimeFilter",
                "decodeUrl",
                "rejectUnauthorized",
                "captureHeaders",
                "stopOnEmptyResults",
                "safeHeaders",
                "retryRules",
                "__scheduling",
            ]
        )
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


class RestCollectMethodPostWithBodyCollectMethod(
    str, Enum, metaclass=utils.OpenEnumMeta
):
    # GET
    GET = "get"
    # POST
    POST = "post"
    # POST with Body
    POST_WITH_BODY = "post_with_body"
    # Other
    OTHER = "other"


class RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeNoneDiscoverType(
    str, Enum, metaclass=utils.OpenEnumMeta
):
    r"""Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task."""

    HTTP = "http"
    JSON = "json"
    LIST = "list"
    NONE = "none"


class RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeNoneTypedDict(TypedDict):
    discover_type: (
        RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeNoneDiscoverType
    )
    r"""Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task."""


class RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeNone(BaseModel):
    discover_type: Annotated[
        RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeNoneDiscoverType,
        pydantic.Field(alias="discoverType"),
    ]
    r"""Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task."""

    @field_serializer("discover_type")
    def serialize_discover_type(self, value):
        if isinstance(value, str):
            try:
                return models.RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeNoneDiscoverType(
                    value
                )
            except ValueError:
                return value
        return value


class RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeListDiscoverType(
    str, Enum, metaclass=utils.OpenEnumMeta
):
    r"""Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task."""

    HTTP = "http"
    JSON = "json"
    LIST = "list"
    NONE = "none"


class RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeListTypedDict(TypedDict):
    discover_type: (
        RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeListDiscoverType
    )
    r"""Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task."""
    item_list: List[str]
    r"""Comma-separated list of items to return from the Discover task. Each item returned generates a Collect task and can be referenced using `${id}` in the Collect URL, headers, or parameters."""


class RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeList(BaseModel):
    discover_type: Annotated[
        RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeListDiscoverType,
        pydantic.Field(alias="discoverType"),
    ]
    r"""Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task."""

    item_list: Annotated[List[str], pydantic.Field(alias="itemList")]
    r"""Comma-separated list of items to return from the Discover task. Each item returned generates a Collect task and can be referenced using `${id}` in the Collect URL, headers, or parameters."""

    @field_serializer("discover_type")
    def serialize_discover_type(self, value):
        if isinstance(value, str):
            try:
                return models.RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeListDiscoverType(
                    value
                )
            except ValueError:
                return value
        return value


class RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeJSONDiscoverType(
    str, Enum, metaclass=utils.OpenEnumMeta
):
    r"""Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task."""

    HTTP = "http"
    JSON = "json"
    LIST = "list"
    NONE = "none"


class RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeJSONTypedDict(TypedDict):
    discover_type: (
        RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeJSONDiscoverType
    )
    r"""Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task."""
    manual_discover_result: str
    r"""Allows hard-coding the Discover result. Must be a JSON object or array. Works with Discover data field."""
    discover_data_field: NotRequired[str]
    r"""Within the response JSON, the name of the field to pull results from, typically a JSON array. Leave blank if the result itself is an array of values. Sample entry: items, json: { items: [{id: 'first'},{id: 'second'}] }"""


class RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeJSON(BaseModel):
    discover_type: Annotated[
        RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeJSONDiscoverType,
        pydantic.Field(alias="discoverType"),
    ]
    r"""Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task."""

    manual_discover_result: Annotated[str, pydantic.Field(alias="manualDiscoverResult")]
    r"""Allows hard-coding the Discover result. Must be a JSON object or array. Works with Discover data field."""

    discover_data_field: Annotated[
        Optional[str], pydantic.Field(alias="discoverDataField")
    ] = None
    r"""Within the response JSON, the name of the field to pull results from, typically a JSON array. Leave blank if the result itself is an array of values. Sample entry: items, json: { items: [{id: 'first'},{id: 'second'}] }"""

    @field_serializer("discover_type")
    def serialize_discover_type(self, value):
        if isinstance(value, str):
            try:
                return models.RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeJSONDiscoverType(
                    value
                )
            except ValueError:
                return value
        return value

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(["discoverDataField"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


class RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHTTPDiscoverMethodOtherDiscoverMethod(
    str, Enum, metaclass=utils.OpenEnumMeta
):
    # GET
    GET = "get"
    # POST
    POST = "post"
    # POST with Body
    POST_WITH_BODY = "post_with_body"
    # Other
    OTHER = "other"


class RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHTTPDiscoverMethodOtherDiscoverType(
    str, Enum, metaclass=utils.OpenEnumMeta
):
    r"""Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task."""

    HTTP = "http"
    JSON = "json"
    LIST = "list"
    NONE = "none"


class RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHTTPDiscoverMethodOtherPaginationTypedDict(
    TypedDict
):
    type: PaginationOptionsRestDiscoveryDiscoverTypeHTTPPagination


class RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHTTPDiscoverMethodOtherPagination(
    BaseModel
):
    type: PaginationOptionsRestDiscoveryDiscoverTypeHTTPPagination

    @field_serializer("type")
    def serialize_type(self, value):
        if isinstance(value, str):
            try:
                return models.PaginationOptionsRestDiscoveryDiscoverTypeHTTPPagination(
                    value
                )
            except ValueError:
                return value
        return value


try:
    RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHTTPDiscoverMethodGet.model_rebuild()
except NameError:
    pass
try:
    RestAuthenticationBasicSecretRestPaginationTypeRequestPage.model_rebuild()
except NameError:
    pass
try:
    RestAuthenticationBasicSecretRestPaginationTypeRequestOffset.model_rebuild()
except NameError:
    pass
try:
    RestAuthenticationBasicSecretRestPaginationTypeResponseHeaderLink.model_rebuild()
except NameError:
    pass
try:
    RestAuthenticationBasicSecretRestPaginationTypeResponseHeader.model_rebuild()
except NameError:
    pass
try:
    RestAuthenticationBasicSecretRestPaginationTypeResponseBody.model_rebuild()
except NameError:
    pass
try:
    RestAuthenticationBasicSecretRestRetryRulesTypeBackoff.model_rebuild()
except NameError:
    pass
try:
    RestAuthenticationBasicSecretRestRetryRulesTypeStatic.model_rebuild()
except NameError:
    pass
try:
    RestAuthenticationBasicSecretRestRetryRulesTypeNone.model_rebuild()
except NameError:
    pass
try:
    RestAuthenticationBasicSecretScheduling.model_rebuild()
except NameError:
    pass
try:
    RestAuthenticationBasicSecret.model_rebuild()
except NameError:
    pass
try:
    RestAuthenticationBasicRestDiscoveryDiscoverTypeNone.model_rebuild()
except NameError:
    pass
try:
    RestAuthenticationBasicRestDiscoveryDiscoverTypeList.model_rebuild()
except NameError:
    pass
try:
    RestAuthenticationBasicRestDiscoveryDiscoverTypeJSON.model_rebuild()
except NameError:
    pass
try:
    RestAuthenticationBasicRestDiscoveryDiscoverTypeHTTPDiscoverMethodOther.model_rebuild()
except NameError:
    pass
try:
    RestAuthenticationBasicRestDiscoveryDiscoverTypeHTTPDiscoverMethodPostWithBody.model_rebuild()
except NameError:
    pass
try:
    RestAuthenticationBasicRestDiscoveryDiscoverTypeHTTPDiscoverMethodPost.model_rebuild()
except NameError:
    pass
try:
    RestAuthenticationBasicRestDiscoveryDiscoverTypeHTTPDiscoverMethodGet.model_rebuild()
except NameError:
    pass
try:
    RestAuthenticationBasicRestPaginationTypeRequestPage.model_rebuild()
except NameError:
    pass
try:
    RestAuthenticationBasicRestPaginationTypeRequestOffset.model_rebuild()
except NameError:
    pass
try:
    RestAuthenticationBasicRestPaginationTypeResponseHeaderLink.model_rebuild()
except NameError:
    pass
try:
    RestAuthenticationBasicRestPaginationTypeResponseHeader.model_rebuild()
except NameError:
    pass
try:
    RestAuthenticationBasicRestPaginationTypeResponseBody.model_rebuild()
except NameError:
    pass
try:
    RestAuthenticationBasicRestRetryRulesTypeBackoff.model_rebuild()
except NameError:
    pass
try:
    RestAuthenticationBasicRestRetryRulesTypeStatic.model_rebuild()
except NameError:
    pass
try:
    RestAuthenticationBasicRestRetryRulesTypeNone.model_rebuild()
except NameError:
    pass
try:
    RestAuthenticationBasicScheduling.model_rebuild()
except NameError:
    pass
try:
    RestAuthenticationBasic.model_rebuild()
except NameError:
    pass
try:
    RestAuthenticationNoneRestDiscoveryDiscoverTypeNone.model_rebuild()
except NameError:
    pass
try:
    RestAuthenticationNoneRestDiscoveryDiscoverTypeList.model_rebuild()
except NameError:
    pass
try:
    RestAuthenticationNoneRestDiscoveryDiscoverTypeJSON.model_rebuild()
except NameError:
    pass
try:
    RestAuthenticationNoneRestDiscoveryDiscoverTypeHTTPDiscoverMethodOther.model_rebuild()
except NameError:
    pass
try:
    RestAuthenticationNoneRestDiscoveryDiscoverTypeHTTPDiscoverMethodPostWithBody.model_rebuild()
except NameError:
    pass
try:
    RestAuthenticationNoneRestDiscoveryDiscoverTypeHTTPDiscoverMethodPost.model_rebuild()
except NameError:
    pass
try:
    RestAuthenticationNoneRestDiscoveryDiscoverTypeHTTPDiscoverMethodGet.model_rebuild()
except NameError:
    pass
try:
    RestAuthenticationNoneRestPaginationTypeRequestPage.model_rebuild()
except NameError:
    pass
try:
    RestAuthenticationNoneRestPaginationTypeRequestOffset.model_rebuild()
except NameError:
    pass
try:
    RestAuthenticationNoneRestPaginationTypeResponseHeaderLink.model_rebuild()
except NameError:
    pass
try:
    RestAuthenticationNoneRestPaginationTypeResponseHeader.model_rebuild()
except NameError:
    pass
try:
    RestAuthenticationNoneRestPaginationTypeResponseBody.model_rebuild()
except NameError:
    pass
try:
    RestAuthenticationNoneRestRetryRulesTypeBackoff.model_rebuild()
except NameError:
    pass
try:
    RestAuthenticationNoneRestRetryRulesTypeStatic.model_rebuild()
except NameError:
    pass
try:
    RestAuthenticationNoneRestRetryRulesTypeNone.model_rebuild()
except NameError:
    pass
try:
    RestAuthenticationNoneScheduling.model_rebuild()
except NameError:
    pass
try:
    RestAuthenticationNone.model_rebuild()
except NameError:
    pass
try:
    RestCollectMethodOtherRestDiscoveryDiscoverTypeNone.model_rebuild()
except NameError:
    pass
try:
    RestCollectMethodOtherRestDiscoveryDiscoverTypeList.model_rebuild()
except NameError:
    pass
try:
    RestCollectMethodOtherRestDiscoveryDiscoverTypeJSON.model_rebuild()
except NameError:
    pass
try:
    RestCollectMethodOtherRestDiscoveryDiscoverTypeHTTPDiscoverMethodOther.model_rebuild()
except NameError:
    pass
try:
    RestCollectMethodOtherRestDiscoveryDiscoverTypeHTTPDiscoverMethodPostWithBody.model_rebuild()
except NameError:
    pass
try:
    RestCollectMethodOtherRestDiscoveryDiscoverTypeHTTPDiscoverMethodPost.model_rebuild()
except NameError:
    pass
try:
    RestCollectMethodOtherRestDiscoveryDiscoverTypeHTTPDiscoverMethodGet.model_rebuild()
except NameError:
    pass
try:
    RestCollectMethodOtherRestPaginationTypeRequestPage.model_rebuild()
except NameError:
    pass
try:
    RestCollectMethodOtherRestPaginationTypeRequestOffset.model_rebuild()
except NameError:
    pass
try:
    RestCollectMethodOtherRestPaginationTypeResponseHeaderLink.model_rebuild()
except NameError:
    pass
try:
    RestCollectMethodOtherRestPaginationTypeResponseHeader.model_rebuild()
except NameError:
    pass
try:
    RestCollectMethodOtherRestPaginationTypeResponseBody.model_rebuild()
except NameError:
    pass
try:
    RestCollectMethodOtherRestRetryRulesTypeBackoff.model_rebuild()
except NameError:
    pass
try:
    RestCollectMethodOtherRestRetryRulesTypeStatic.model_rebuild()
except NameError:
    pass
try:
    RestCollectMethodOtherRestRetryRulesTypeNone.model_rebuild()
except NameError:
    pass
try:
    RestCollectMethodOtherScheduling.model_rebuild()
except NameError:
    pass
try:
    RestCollectMethodOther.model_rebuild()
except NameError:
    pass
try:
    RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeNone.model_rebuild()
except NameError:
    pass
try:
    RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeList.model_rebuild()
except NameError:
    pass
try:
    RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeJSON.model_rebuild()
except NameError:
    pass
