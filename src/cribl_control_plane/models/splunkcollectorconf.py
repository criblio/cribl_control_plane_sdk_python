"""Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT."""

from __future__ import annotations
from .outputmodeoptionssplunkcollectorconf import OutputModeOptionsSplunkCollectorConf
from .retrytypeoptionshealthcheckcollectorconfretryrules import (
    RetryTypeOptionsHealthCheckCollectorConfRetryRules,
)
from cribl_control_plane import models, utils
from cribl_control_plane.types import BaseModel, UNSET_SENTINEL
from cribl_control_plane.utils.unions import parse_open_union
from enum import Enum
from functools import partial
import pydantic
from pydantic import ConfigDict, field_serializer, model_serializer
from pydantic.functional_validators import BeforeValidator
from typing import Any, List, Literal, Optional, Union
from typing_extensions import Annotated, NotRequired, TypeAliasType, TypedDict


class SplunkAuthenticationTokenSecretAuthentication(
    str, Enum, metaclass=utils.OpenEnumMeta
):
    r"""Authentication method for Discover and Collect REST calls"""

    # None
    NONE = "none"
    # Basic
    BASIC = "basic"
    # Basic (credentials secret)
    BASIC_SECRET = "basicSecret"
    # Bearer Token
    TOKEN = "token"
    # Bearer Token (text secret)
    TOKEN_SECRET = "tokenSecret"


class SplunkAuthenticationTokenSecretCollectRequestParamTypedDict(TypedDict):
    name: str
    value: str
    r"""JavaScript expression to compute the parameter's value, normally enclosed in backticks (`${earliest}`). If a constant, use single quotes ('earliest'). Values without delimiters (earliest) are evaluated as strings."""


class SplunkAuthenticationTokenSecretCollectRequestParam(BaseModel):
    name: str

    value: str
    r"""JavaScript expression to compute the parameter's value, normally enclosed in backticks (`${earliest}`). If a constant, use single quotes ('earliest'). Values without delimiters (earliest) are evaluated as strings."""


class SplunkAuthenticationTokenSecretCollectRequestHeaderTypedDict(TypedDict):
    name: str
    value: str
    r"""JavaScript expression to compute the header's value, normally enclosed in backticks (`${earliest}`). If a constant, use single quotes ('earliest'). Values without delimiters (earliest) are evaluated as strings."""


class SplunkAuthenticationTokenSecretCollectRequestHeader(BaseModel):
    name: str

    value: str
    r"""JavaScript expression to compute the header's value, normally enclosed in backticks (`${earliest}`). If a constant, use single quotes ('earliest'). Values without delimiters (earliest) are evaluated as strings."""


class SplunkAuthenticationTokenSecretSplunkRetryRulesTypeBackoffTypedDict(TypedDict):
    type: RetryTypeOptionsHealthCheckCollectorConfRetryRules
    r"""The algorithm to use when performing HTTP retries"""
    interval: NotRequired[float]
    r"""Time interval between failed request and first retry (kickoff). Maximum allowed value is 20,000 ms (1/3 minute)."""
    limit: NotRequired[float]
    r"""The maximum number of times to retry a failed HTTP request"""
    multiplier: NotRequired[float]
    r"""Base for exponential backoff. For example, base 2 means that retries will occur after 2, then 4, then 8 seconds, and so on."""
    codes: NotRequired[List[float]]
    r"""List of HTTP codes that trigger a retry. Leave empty to use the default list of 429 and 503."""
    enable_header: NotRequired[bool]
    r"""Honor any Retry-After header that specifies a delay (in seconds) or a timestamp after which to retry the request. The delay is limited to 20 seconds, even if the Retry-After header specifies a longer delay. When disabled, all Retry-After headers are ignored."""
    retry_connect_timeout: NotRequired[bool]
    r"""Make a single retry attempt when a connection timeout (ETIMEDOUT) error occurs"""
    retry_connect_reset: NotRequired[bool]
    r"""Retry request when a connection reset error (ECONNRESET) error occurs"""


class SplunkAuthenticationTokenSecretSplunkRetryRulesTypeBackoff(BaseModel):
    type: RetryTypeOptionsHealthCheckCollectorConfRetryRules
    r"""The algorithm to use when performing HTTP retries"""

    interval: Optional[float] = None
    r"""Time interval between failed request and first retry (kickoff). Maximum allowed value is 20,000 ms (1/3 minute)."""

    limit: Optional[float] = None
    r"""The maximum number of times to retry a failed HTTP request"""

    multiplier: Optional[float] = None
    r"""Base for exponential backoff. For example, base 2 means that retries will occur after 2, then 4, then 8 seconds, and so on."""

    codes: Optional[List[float]] = None
    r"""List of HTTP codes that trigger a retry. Leave empty to use the default list of 429 and 503."""

    enable_header: Annotated[Optional[bool], pydantic.Field(alias="enableHeader")] = (
        None
    )
    r"""Honor any Retry-After header that specifies a delay (in seconds) or a timestamp after which to retry the request. The delay is limited to 20 seconds, even if the Retry-After header specifies a longer delay. When disabled, all Retry-After headers are ignored."""

    retry_connect_timeout: Annotated[
        Optional[bool], pydantic.Field(alias="retryConnectTimeout")
    ] = None
    r"""Make a single retry attempt when a connection timeout (ETIMEDOUT) error occurs"""

    retry_connect_reset: Annotated[
        Optional[bool], pydantic.Field(alias="retryConnectReset")
    ] = None
    r"""Retry request when a connection reset error (ECONNRESET) error occurs"""

    @field_serializer("type")
    def serialize_type(self, value):
        if isinstance(value, str):
            try:
                return models.RetryTypeOptionsHealthCheckCollectorConfRetryRules(value)
            except ValueError:
                return value
        return value

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(
            [
                "interval",
                "limit",
                "multiplier",
                "codes",
                "enableHeader",
                "retryConnectTimeout",
                "retryConnectReset",
            ]
        )
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


class SplunkAuthenticationTokenSecretSplunkRetryRulesTypeStaticTypedDict(TypedDict):
    type: RetryTypeOptionsHealthCheckCollectorConfRetryRules
    r"""The algorithm to use when performing HTTP retries"""
    interval: NotRequired[float]
    r"""Time interval between retries. Maximum allowed value is 20,000 ms (1/3 minute)."""
    limit: NotRequired[float]
    r"""The maximum number of times to retry a failed HTTP request"""
    codes: NotRequired[List[float]]
    r"""List of HTTP codes that trigger a retry. Leave empty to use the default list of 429 and 503."""
    enable_header: NotRequired[bool]
    r"""Honor any Retry-After header that specifies a delay (in seconds) or a timestamp after which to retry the request. The delay is limited to 20 seconds, even if the Retry-After header specifies a longer delay. When disabled, all Retry-After headers are ignored."""
    retry_connect_timeout: NotRequired[bool]
    r"""Make a single retry attempt when a connection timeout (ETIMEDOUT) error occurs"""
    retry_connect_reset: NotRequired[bool]
    r"""Retry request when a connection reset error (ECONNRESET) error occurs"""


class SplunkAuthenticationTokenSecretSplunkRetryRulesTypeStatic(BaseModel):
    type: RetryTypeOptionsHealthCheckCollectorConfRetryRules
    r"""The algorithm to use when performing HTTP retries"""

    interval: Optional[float] = None
    r"""Time interval between retries. Maximum allowed value is 20,000 ms (1/3 minute)."""

    limit: Optional[float] = None
    r"""The maximum number of times to retry a failed HTTP request"""

    codes: Optional[List[float]] = None
    r"""List of HTTP codes that trigger a retry. Leave empty to use the default list of 429 and 503."""

    enable_header: Annotated[Optional[bool], pydantic.Field(alias="enableHeader")] = (
        None
    )
    r"""Honor any Retry-After header that specifies a delay (in seconds) or a timestamp after which to retry the request. The delay is limited to 20 seconds, even if the Retry-After header specifies a longer delay. When disabled, all Retry-After headers are ignored."""

    retry_connect_timeout: Annotated[
        Optional[bool], pydantic.Field(alias="retryConnectTimeout")
    ] = None
    r"""Make a single retry attempt when a connection timeout (ETIMEDOUT) error occurs"""

    retry_connect_reset: Annotated[
        Optional[bool], pydantic.Field(alias="retryConnectReset")
    ] = None
    r"""Retry request when a connection reset error (ECONNRESET) error occurs"""

    @field_serializer("type")
    def serialize_type(self, value):
        if isinstance(value, str):
            try:
                return models.RetryTypeOptionsHealthCheckCollectorConfRetryRules(value)
            except ValueError:
                return value
        return value

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(
            [
                "interval",
                "limit",
                "codes",
                "enableHeader",
                "retryConnectTimeout",
                "retryConnectReset",
            ]
        )
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


class SplunkAuthenticationTokenSecretSplunkRetryRulesTypeNoneTypedDict(TypedDict):
    type: RetryTypeOptionsHealthCheckCollectorConfRetryRules
    r"""The algorithm to use when performing HTTP retries"""


class SplunkAuthenticationTokenSecretSplunkRetryRulesTypeNone(BaseModel):
    type: RetryTypeOptionsHealthCheckCollectorConfRetryRules
    r"""The algorithm to use when performing HTTP retries"""

    @field_serializer("type")
    def serialize_type(self, value):
        if isinstance(value, str):
            try:
                return models.RetryTypeOptionsHealthCheckCollectorConfRetryRules(value)
            except ValueError:
                return value
        return value


SplunkAuthenticationTokenSecretRetryRulesTypedDict = TypeAliasType(
    "SplunkAuthenticationTokenSecretRetryRulesTypedDict",
    Union[
        SplunkAuthenticationTokenSecretSplunkRetryRulesTypeNoneTypedDict,
        SplunkAuthenticationTokenSecretSplunkRetryRulesTypeStaticTypedDict,
        SplunkAuthenticationTokenSecretSplunkRetryRulesTypeBackoffTypedDict,
    ],
)


class UnknownSplunkAuthenticationTokenSecretRetryRules(BaseModel):
    r"""A SplunkAuthenticationTokenSecretRetryRules variant the SDK doesn't recognize. Preserves the raw payload."""

    type: Literal["UNKNOWN"] = "UNKNOWN"
    raw: Any
    is_unknown: Literal[True] = True

    model_config = ConfigDict(frozen=True)


_SPLUNK_AUTHENTICATION_TOKEN_SECRET_RETRY_RULES_VARIANTS: dict[str, Any] = {
    "none": SplunkAuthenticationTokenSecretSplunkRetryRulesTypeNone,
    "static": SplunkAuthenticationTokenSecretSplunkRetryRulesTypeStatic,
    "backoff": SplunkAuthenticationTokenSecretSplunkRetryRulesTypeBackoff,
}


SplunkAuthenticationTokenSecretRetryRules = Annotated[
    Union[
        SplunkAuthenticationTokenSecretSplunkRetryRulesTypeNone,
        SplunkAuthenticationTokenSecretSplunkRetryRulesTypeStatic,
        SplunkAuthenticationTokenSecretSplunkRetryRulesTypeBackoff,
        UnknownSplunkAuthenticationTokenSecretRetryRules,
    ],
    BeforeValidator(
        partial(
            parse_open_union,
            disc_key="type",
            variants=_SPLUNK_AUTHENTICATION_TOKEN_SECRET_RETRY_RULES_VARIANTS,
            unknown_cls=UnknownSplunkAuthenticationTokenSecretRetryRules,
            union_name="SplunkAuthenticationTokenSecretRetryRules",
        )
    ),
]


class SplunkAuthenticationTokenSecretTypedDict(TypedDict):
    authentication: SplunkAuthenticationTokenSecretAuthentication
    r"""Authentication method for Discover and Collect REST calls"""
    token_secret: str
    r"""Select or create a stored secret that references your Bearer token"""
    search_head: str
    r"""Search head base URL. Can be an expression. Default is https://localhost:8089."""
    search: str
    r"""Examples: 'index=myAppLogs level=error channel=myApp' OR '| mstats avg(myStat) as myStat WHERE index=myStatsIndex.'"""
    endpoint: str
    r"""REST API used to create a search"""
    output_mode: OutputModeOptionsSplunkCollectorConf
    r"""Format of the returned output"""
    earliest: NotRequired[str]
    r"""The earliest time boundary for the search. Can be an exact or relative time. Examples: '2022-01-14T12:00:00Z' or '-16m@m'"""
    latest: NotRequired[str]
    r"""The latest time boundary for the search. Can be an exact or relative time. Examples: '2022-01-14T12:00:00Z' or '-1m@m'"""
    collect_request_params: NotRequired[
        List[SplunkAuthenticationTokenSecretCollectRequestParamTypedDict]
    ]
    r"""Optional collect request parameters"""
    collect_request_headers: NotRequired[
        List[SplunkAuthenticationTokenSecretCollectRequestHeaderTypedDict]
    ]
    r"""Optional collect request headers"""
    timeout: NotRequired[float]
    r"""HTTP request inactivity timeout. Use 0 for no timeout."""
    use_round_robin_dns: NotRequired[bool]
    r"""Use round-robin DNS lookup. Suitable when DNS server returns multiple addresses in sort order."""
    disable_time_filter: NotRequired[bool]
    r"""Disable collector event time filtering when a date range is specified"""
    reject_unauthorized: NotRequired[bool]
    r"""Reject certificates that cannot be verified against a valid CA (such as self-signed certificates)"""
    handle_escaped_chars: NotRequired[bool]
    r"""Escape characters (\\") in search queries will be passed directly to Splunk"""
    retry_rules: NotRequired[SplunkAuthenticationTokenSecretRetryRulesTypedDict]


class SplunkAuthenticationTokenSecret(BaseModel):
    authentication: SplunkAuthenticationTokenSecretAuthentication
    r"""Authentication method for Discover and Collect REST calls"""

    token_secret: Annotated[str, pydantic.Field(alias="tokenSecret")]
    r"""Select or create a stored secret that references your Bearer token"""

    search_head: Annotated[str, pydantic.Field(alias="searchHead")]
    r"""Search head base URL. Can be an expression. Default is https://localhost:8089."""

    search: str
    r"""Examples: 'index=myAppLogs level=error channel=myApp' OR '| mstats avg(myStat) as myStat WHERE index=myStatsIndex.'"""

    endpoint: str
    r"""REST API used to create a search"""

    output_mode: Annotated[
        OutputModeOptionsSplunkCollectorConf, pydantic.Field(alias="outputMode")
    ]
    r"""Format of the returned output"""

    earliest: Optional[str] = None
    r"""The earliest time boundary for the search. Can be an exact or relative time. Examples: '2022-01-14T12:00:00Z' or '-16m@m'"""

    latest: Optional[str] = None
    r"""The latest time boundary for the search. Can be an exact or relative time. Examples: '2022-01-14T12:00:00Z' or '-1m@m'"""

    collect_request_params: Annotated[
        Optional[List[SplunkAuthenticationTokenSecretCollectRequestParam]],
        pydantic.Field(alias="collectRequestParams"),
    ] = None
    r"""Optional collect request parameters"""

    collect_request_headers: Annotated[
        Optional[List[SplunkAuthenticationTokenSecretCollectRequestHeader]],
        pydantic.Field(alias="collectRequestHeaders"),
    ] = None
    r"""Optional collect request headers"""

    timeout: Optional[float] = None
    r"""HTTP request inactivity timeout. Use 0 for no timeout."""

    use_round_robin_dns: Annotated[
        Optional[bool], pydantic.Field(alias="useRoundRobinDns")
    ] = None
    r"""Use round-robin DNS lookup. Suitable when DNS server returns multiple addresses in sort order."""

    disable_time_filter: Annotated[
        Optional[bool], pydantic.Field(alias="disableTimeFilter")
    ] = None
    r"""Disable collector event time filtering when a date range is specified"""

    reject_unauthorized: Annotated[
        Optional[bool], pydantic.Field(alias="rejectUnauthorized")
    ] = None
    r"""Reject certificates that cannot be verified against a valid CA (such as self-signed certificates)"""

    handle_escaped_chars: Annotated[
        Optional[bool], pydantic.Field(alias="handleEscapedChars")
    ] = None
    r"""Escape characters (\\") in search queries will be passed directly to Splunk"""

    retry_rules: Annotated[
        Optional[SplunkAuthenticationTokenSecretRetryRules],
        pydantic.Field(alias="retryRules"),
    ] = None

    @field_serializer("authentication")
    def serialize_authentication(self, value):
        if isinstance(value, str):
            try:
                return models.SplunkAuthenticationTokenSecretAuthentication(value)
            except ValueError:
                return value
        return value

    @field_serializer("output_mode")
    def serialize_output_mode(self, value):
        if isinstance(value, str):
            try:
                return models.OutputModeOptionsSplunkCollectorConf(value)
            except ValueError:
                return value
        return value

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(
            [
                "earliest",
                "latest",
                "collectRequestParams",
                "collectRequestHeaders",
                "timeout",
                "useRoundRobinDns",
                "disableTimeFilter",
                "rejectUnauthorized",
                "handleEscapedChars",
                "retryRules",
            ]
        )
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


class SplunkAuthenticationTokenAuthentication(str, Enum, metaclass=utils.OpenEnumMeta):
    r"""Authentication method for Discover and Collect REST calls"""

    # None
    NONE = "none"
    # Basic
    BASIC = "basic"
    # Basic (credentials secret)
    BASIC_SECRET = "basicSecret"
    # Bearer Token
    TOKEN = "token"
    # Bearer Token (text secret)
    TOKEN_SECRET = "tokenSecret"


class SplunkAuthenticationTokenCollectRequestParamTypedDict(TypedDict):
    name: str
    value: str
    r"""JavaScript expression to compute the parameter's value, normally enclosed in backticks (`${earliest}`). If a constant, use single quotes ('earliest'). Values without delimiters (earliest) are evaluated as strings."""


class SplunkAuthenticationTokenCollectRequestParam(BaseModel):
    name: str

    value: str
    r"""JavaScript expression to compute the parameter's value, normally enclosed in backticks (`${earliest}`). If a constant, use single quotes ('earliest'). Values without delimiters (earliest) are evaluated as strings."""


class SplunkAuthenticationTokenCollectRequestHeaderTypedDict(TypedDict):
    name: str
    value: str
    r"""JavaScript expression to compute the header's value, normally enclosed in backticks (`${earliest}`). If a constant, use single quotes ('earliest'). Values without delimiters (earliest) are evaluated as strings."""


class SplunkAuthenticationTokenCollectRequestHeader(BaseModel):
    name: str

    value: str
    r"""JavaScript expression to compute the header's value, normally enclosed in backticks (`${earliest}`). If a constant, use single quotes ('earliest'). Values without delimiters (earliest) are evaluated as strings."""


class SplunkAuthenticationTokenSplunkRetryRulesTypeBackoffTypedDict(TypedDict):
    type: RetryTypeOptionsHealthCheckCollectorConfRetryRules
    r"""The algorithm to use when performing HTTP retries"""
    interval: NotRequired[float]
    r"""Time interval between failed request and first retry (kickoff). Maximum allowed value is 20,000 ms (1/3 minute)."""
    limit: NotRequired[float]
    r"""The maximum number of times to retry a failed HTTP request"""
    multiplier: NotRequired[float]
    r"""Base for exponential backoff. For example, base 2 means that retries will occur after 2, then 4, then 8 seconds, and so on."""
    codes: NotRequired[List[float]]
    r"""List of HTTP codes that trigger a retry. Leave empty to use the default list of 429 and 503."""
    enable_header: NotRequired[bool]
    r"""Honor any Retry-After header that specifies a delay (in seconds) or a timestamp after which to retry the request. The delay is limited to 20 seconds, even if the Retry-After header specifies a longer delay. When disabled, all Retry-After headers are ignored."""
    retry_connect_timeout: NotRequired[bool]
    r"""Make a single retry attempt when a connection timeout (ETIMEDOUT) error occurs"""
    retry_connect_reset: NotRequired[bool]
    r"""Retry request when a connection reset error (ECONNRESET) error occurs"""


class SplunkAuthenticationTokenSplunkRetryRulesTypeBackoff(BaseModel):
    type: RetryTypeOptionsHealthCheckCollectorConfRetryRules
    r"""The algorithm to use when performing HTTP retries"""

    interval: Optional[float] = None
    r"""Time interval between failed request and first retry (kickoff). Maximum allowed value is 20,000 ms (1/3 minute)."""

    limit: Optional[float] = None
    r"""The maximum number of times to retry a failed HTTP request"""

    multiplier: Optional[float] = None
    r"""Base for exponential backoff. For example, base 2 means that retries will occur after 2, then 4, then 8 seconds, and so on."""

    codes: Optional[List[float]] = None
    r"""List of HTTP codes that trigger a retry. Leave empty to use the default list of 429 and 503."""

    enable_header: Annotated[Optional[bool], pydantic.Field(alias="enableHeader")] = (
        None
    )
    r"""Honor any Retry-After header that specifies a delay (in seconds) or a timestamp after which to retry the request. The delay is limited to 20 seconds, even if the Retry-After header specifies a longer delay. When disabled, all Retry-After headers are ignored."""

    retry_connect_timeout: Annotated[
        Optional[bool], pydantic.Field(alias="retryConnectTimeout")
    ] = None
    r"""Make a single retry attempt when a connection timeout (ETIMEDOUT) error occurs"""

    retry_connect_reset: Annotated[
        Optional[bool], pydantic.Field(alias="retryConnectReset")
    ] = None
    r"""Retry request when a connection reset error (ECONNRESET) error occurs"""

    @field_serializer("type")
    def serialize_type(self, value):
        if isinstance(value, str):
            try:
                return models.RetryTypeOptionsHealthCheckCollectorConfRetryRules(value)
            except ValueError:
                return value
        return value

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(
            [
                "interval",
                "limit",
                "multiplier",
                "codes",
                "enableHeader",
                "retryConnectTimeout",
                "retryConnectReset",
            ]
        )
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


class SplunkAuthenticationTokenSplunkRetryRulesTypeStaticTypedDict(TypedDict):
    type: RetryTypeOptionsHealthCheckCollectorConfRetryRules
    r"""The algorithm to use when performing HTTP retries"""
    interval: NotRequired[float]
    r"""Time interval between retries. Maximum allowed value is 20,000 ms (1/3 minute)."""
    limit: NotRequired[float]
    r"""The maximum number of times to retry a failed HTTP request"""
    codes: NotRequired[List[float]]
    r"""List of HTTP codes that trigger a retry. Leave empty to use the default list of 429 and 503."""
    enable_header: NotRequired[bool]
    r"""Honor any Retry-After header that specifies a delay (in seconds) or a timestamp after which to retry the request. The delay is limited to 20 seconds, even if the Retry-After header specifies a longer delay. When disabled, all Retry-After headers are ignored."""
    retry_connect_timeout: NotRequired[bool]
    r"""Make a single retry attempt when a connection timeout (ETIMEDOUT) error occurs"""
    retry_connect_reset: NotRequired[bool]
    r"""Retry request when a connection reset error (ECONNRESET) error occurs"""


class SplunkAuthenticationTokenSplunkRetryRulesTypeStatic(BaseModel):
    type: RetryTypeOptionsHealthCheckCollectorConfRetryRules
    r"""The algorithm to use when performing HTTP retries"""

    interval: Optional[float] = None
    r"""Time interval between retries. Maximum allowed value is 20,000 ms (1/3 minute)."""

    limit: Optional[float] = None
    r"""The maximum number of times to retry a failed HTTP request"""

    codes: Optional[List[float]] = None
    r"""List of HTTP codes that trigger a retry. Leave empty to use the default list of 429 and 503."""

    enable_header: Annotated[Optional[bool], pydantic.Field(alias="enableHeader")] = (
        None
    )
    r"""Honor any Retry-After header that specifies a delay (in seconds) or a timestamp after which to retry the request. The delay is limited to 20 seconds, even if the Retry-After header specifies a longer delay. When disabled, all Retry-After headers are ignored."""

    retry_connect_timeout: Annotated[
        Optional[bool], pydantic.Field(alias="retryConnectTimeout")
    ] = None
    r"""Make a single retry attempt when a connection timeout (ETIMEDOUT) error occurs"""

    retry_connect_reset: Annotated[
        Optional[bool], pydantic.Field(alias="retryConnectReset")
    ] = None
    r"""Retry request when a connection reset error (ECONNRESET) error occurs"""

    @field_serializer("type")
    def serialize_type(self, value):
        if isinstance(value, str):
            try:
                return models.RetryTypeOptionsHealthCheckCollectorConfRetryRules(value)
            except ValueError:
                return value
        return value

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(
            [
                "interval",
                "limit",
                "codes",
                "enableHeader",
                "retryConnectTimeout",
                "retryConnectReset",
            ]
        )
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


class SplunkAuthenticationTokenSplunkRetryRulesTypeNoneTypedDict(TypedDict):
    type: RetryTypeOptionsHealthCheckCollectorConfRetryRules
    r"""The algorithm to use when performing HTTP retries"""


class SplunkAuthenticationTokenSplunkRetryRulesTypeNone(BaseModel):
    type: RetryTypeOptionsHealthCheckCollectorConfRetryRules
    r"""The algorithm to use when performing HTTP retries"""

    @field_serializer("type")
    def serialize_type(self, value):
        if isinstance(value, str):
            try:
                return models.RetryTypeOptionsHealthCheckCollectorConfRetryRules(value)
            except ValueError:
                return value
        return value


SplunkAuthenticationTokenRetryRulesTypedDict = TypeAliasType(
    "SplunkAuthenticationTokenRetryRulesTypedDict",
    Union[
        SplunkAuthenticationTokenSplunkRetryRulesTypeNoneTypedDict,
        SplunkAuthenticationTokenSplunkRetryRulesTypeStaticTypedDict,
        SplunkAuthenticationTokenSplunkRetryRulesTypeBackoffTypedDict,
    ],
)


class UnknownSplunkAuthenticationTokenRetryRules(BaseModel):
    r"""A SplunkAuthenticationTokenRetryRules variant the SDK doesn't recognize. Preserves the raw payload."""

    type: Literal["UNKNOWN"] = "UNKNOWN"
    raw: Any
    is_unknown: Literal[True] = True

    model_config = ConfigDict(frozen=True)


_SPLUNK_AUTHENTICATION_TOKEN_RETRY_RULES_VARIANTS: dict[str, Any] = {
    "none": SplunkAuthenticationTokenSplunkRetryRulesTypeNone,
    "static": SplunkAuthenticationTokenSplunkRetryRulesTypeStatic,
    "backoff": SplunkAuthenticationTokenSplunkRetryRulesTypeBackoff,
}


SplunkAuthenticationTokenRetryRules = Annotated[
    Union[
        SplunkAuthenticationTokenSplunkRetryRulesTypeNone,
        SplunkAuthenticationTokenSplunkRetryRulesTypeStatic,
        SplunkAuthenticationTokenSplunkRetryRulesTypeBackoff,
        UnknownSplunkAuthenticationTokenRetryRules,
    ],
    BeforeValidator(
        partial(
            parse_open_union,
            disc_key="type",
            variants=_SPLUNK_AUTHENTICATION_TOKEN_RETRY_RULES_VARIANTS,
            unknown_cls=UnknownSplunkAuthenticationTokenRetryRules,
            union_name="SplunkAuthenticationTokenRetryRules",
        )
    ),
]


class SplunkAuthenticationTokenTypedDict(TypedDict):
    authentication: SplunkAuthenticationTokenAuthentication
    r"""Authentication method for Discover and Collect REST calls"""
    token: str
    search_head: str
    r"""Search head base URL. Can be an expression. Default is https://localhost:8089."""
    search: str
    r"""Examples: 'index=myAppLogs level=error channel=myApp' OR '| mstats avg(myStat) as myStat WHERE index=myStatsIndex.'"""
    endpoint: str
    r"""REST API used to create a search"""
    output_mode: OutputModeOptionsSplunkCollectorConf
    r"""Format of the returned output"""
    earliest: NotRequired[str]
    r"""The earliest time boundary for the search. Can be an exact or relative time. Examples: '2022-01-14T12:00:00Z' or '-16m@m'"""
    latest: NotRequired[str]
    r"""The latest time boundary for the search. Can be an exact or relative time. Examples: '2022-01-14T12:00:00Z' or '-1m@m'"""
    collect_request_params: NotRequired[
        List[SplunkAuthenticationTokenCollectRequestParamTypedDict]
    ]
    r"""Optional collect request parameters"""
    collect_request_headers: NotRequired[
        List[SplunkAuthenticationTokenCollectRequestHeaderTypedDict]
    ]
    r"""Optional collect request headers"""
    timeout: NotRequired[float]
    r"""HTTP request inactivity timeout. Use 0 for no timeout."""
    use_round_robin_dns: NotRequired[bool]
    r"""Use round-robin DNS lookup. Suitable when DNS server returns multiple addresses in sort order."""
    disable_time_filter: NotRequired[bool]
    r"""Disable collector event time filtering when a date range is specified"""
    reject_unauthorized: NotRequired[bool]
    r"""Reject certificates that cannot be verified against a valid CA (such as self-signed certificates)"""
    handle_escaped_chars: NotRequired[bool]
    r"""Escape characters (\\") in search queries will be passed directly to Splunk"""
    retry_rules: NotRequired[SplunkAuthenticationTokenRetryRulesTypedDict]


class SplunkAuthenticationToken(BaseModel):
    authentication: SplunkAuthenticationTokenAuthentication
    r"""Authentication method for Discover and Collect REST calls"""

    token: str

    search_head: Annotated[str, pydantic.Field(alias="searchHead")]
    r"""Search head base URL. Can be an expression. Default is https://localhost:8089."""

    search: str
    r"""Examples: 'index=myAppLogs level=error channel=myApp' OR '| mstats avg(myStat) as myStat WHERE index=myStatsIndex.'"""

    endpoint: str
    r"""REST API used to create a search"""

    output_mode: Annotated[
        OutputModeOptionsSplunkCollectorConf, pydantic.Field(alias="outputMode")
    ]
    r"""Format of the returned output"""

    earliest: Optional[str] = None
    r"""The earliest time boundary for the search. Can be an exact or relative time. Examples: '2022-01-14T12:00:00Z' or '-16m@m'"""

    latest: Optional[str] = None
    r"""The latest time boundary for the search. Can be an exact or relative time. Examples: '2022-01-14T12:00:00Z' or '-1m@m'"""

    collect_request_params: Annotated[
        Optional[List[SplunkAuthenticationTokenCollectRequestParam]],
        pydantic.Field(alias="collectRequestParams"),
    ] = None
    r"""Optional collect request parameters"""

    collect_request_headers: Annotated[
        Optional[List[SplunkAuthenticationTokenCollectRequestHeader]],
        pydantic.Field(alias="collectRequestHeaders"),
    ] = None
    r"""Optional collect request headers"""

    timeout: Optional[float] = None
    r"""HTTP request inactivity timeout. Use 0 for no timeout."""

    use_round_robin_dns: Annotated[
        Optional[bool], pydantic.Field(alias="useRoundRobinDns")
    ] = None
    r"""Use round-robin DNS lookup. Suitable when DNS server returns multiple addresses in sort order."""

    disable_time_filter: Annotated[
        Optional[bool], pydantic.Field(alias="disableTimeFilter")
    ] = None
    r"""Disable collector event time filtering when a date range is specified"""

    reject_unauthorized: Annotated[
        Optional[bool], pydantic.Field(alias="rejectUnauthorized")
    ] = None
    r"""Reject certificates that cannot be verified against a valid CA (such as self-signed certificates)"""

    handle_escaped_chars: Annotated[
        Optional[bool], pydantic.Field(alias="handleEscapedChars")
    ] = None
    r"""Escape characters (\\") in search queries will be passed directly to Splunk"""

    retry_rules: Annotated[
        Optional[SplunkAuthenticationTokenRetryRules],
        pydantic.Field(alias="retryRules"),
    ] = None

    @field_serializer("authentication")
    def serialize_authentication(self, value):
        if isinstance(value, str):
            try:
                return models.SplunkAuthenticationTokenAuthentication(value)
            except ValueError:
                return value
        return value

    @field_serializer("output_mode")
    def serialize_output_mode(self, value):
        if isinstance(value, str):
            try:
                return models.OutputModeOptionsSplunkCollectorConf(value)
            except ValueError:
                return value
        return value

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(
            [
                "earliest",
                "latest",
                "collectRequestParams",
                "collectRequestHeaders",
                "timeout",
                "useRoundRobinDns",
                "disableTimeFilter",
                "rejectUnauthorized",
                "handleEscapedChars",
                "retryRules",
            ]
        )
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


class SplunkAuthenticationBasicSecretAuthentication(
    str, Enum, metaclass=utils.OpenEnumMeta
):
    r"""Authentication method for Discover and Collect REST calls"""

    # None
    NONE = "none"
    # Basic
    BASIC = "basic"
    # Basic (credentials secret)
    BASIC_SECRET = "basicSecret"
    # Bearer Token
    TOKEN = "token"
    # Bearer Token (text secret)
    TOKEN_SECRET = "tokenSecret"


class SplunkAuthenticationBasicSecretCollectRequestParamTypedDict(TypedDict):
    name: str
    value: str
    r"""JavaScript expression to compute the parameter's value, normally enclosed in backticks (`${earliest}`). If a constant, use single quotes ('earliest'). Values without delimiters (earliest) are evaluated as strings."""


class SplunkAuthenticationBasicSecretCollectRequestParam(BaseModel):
    name: str

    value: str
    r"""JavaScript expression to compute the parameter's value, normally enclosed in backticks (`${earliest}`). If a constant, use single quotes ('earliest'). Values without delimiters (earliest) are evaluated as strings."""


class SplunkAuthenticationBasicSecretCollectRequestHeaderTypedDict(TypedDict):
    name: str
    value: str
    r"""JavaScript expression to compute the header's value, normally enclosed in backticks (`${earliest}`). If a constant, use single quotes ('earliest'). Values without delimiters (earliest) are evaluated as strings."""


class SplunkAuthenticationBasicSecretCollectRequestHeader(BaseModel):
    name: str

    value: str
    r"""JavaScript expression to compute the header's value, normally enclosed in backticks (`${earliest}`). If a constant, use single quotes ('earliest'). Values without delimiters (earliest) are evaluated as strings."""


class SplunkAuthenticationBasicSecretSplunkRetryRulesTypeBackoffTypedDict(TypedDict):
    type: RetryTypeOptionsHealthCheckCollectorConfRetryRules
    r"""The algorithm to use when performing HTTP retries"""
    interval: NotRequired[float]
    r"""Time interval between failed request and first retry (kickoff). Maximum allowed value is 20,000 ms (1/3 minute)."""
    limit: NotRequired[float]
    r"""The maximum number of times to retry a failed HTTP request"""
    multiplier: NotRequired[float]
    r"""Base for exponential backoff. For example, base 2 means that retries will occur after 2, then 4, then 8 seconds, and so on."""
    codes: NotRequired[List[float]]
    r"""List of HTTP codes that trigger a retry. Leave empty to use the default list of 429 and 503."""
    enable_header: NotRequired[bool]
    r"""Honor any Retry-After header that specifies a delay (in seconds) or a timestamp after which to retry the request. The delay is limited to 20 seconds, even if the Retry-After header specifies a longer delay. When disabled, all Retry-After headers are ignored."""
    retry_connect_timeout: NotRequired[bool]
    r"""Make a single retry attempt when a connection timeout (ETIMEDOUT) error occurs"""
    retry_connect_reset: NotRequired[bool]
    r"""Retry request when a connection reset error (ECONNRESET) error occurs"""


class SplunkAuthenticationBasicSecretSplunkRetryRulesTypeBackoff(BaseModel):
    type: RetryTypeOptionsHealthCheckCollectorConfRetryRules
    r"""The algorithm to use when performing HTTP retries"""

    interval: Optional[float] = None
    r"""Time interval between failed request and first retry (kickoff). Maximum allowed value is 20,000 ms (1/3 minute)."""

    limit: Optional[float] = None
    r"""The maximum number of times to retry a failed HTTP request"""

    multiplier: Optional[float] = None
    r"""Base for exponential backoff. For example, base 2 means that retries will occur after 2, then 4, then 8 seconds, and so on."""

    codes: Optional[List[float]] = None
    r"""List of HTTP codes that trigger a retry. Leave empty to use the default list of 429 and 503."""

    enable_header: Annotated[Optional[bool], pydantic.Field(alias="enableHeader")] = (
        None
    )
    r"""Honor any Retry-After header that specifies a delay (in seconds) or a timestamp after which to retry the request. The delay is limited to 20 seconds, even if the Retry-After header specifies a longer delay. When disabled, all Retry-After headers are ignored."""

    retry_connect_timeout: Annotated[
        Optional[bool], pydantic.Field(alias="retryConnectTimeout")
    ] = None
    r"""Make a single retry attempt when a connection timeout (ETIMEDOUT) error occurs"""

    retry_connect_reset: Annotated[
        Optional[bool], pydantic.Field(alias="retryConnectReset")
    ] = None
    r"""Retry request when a connection reset error (ECONNRESET) error occurs"""

    @field_serializer("type")
    def serialize_type(self, value):
        if isinstance(value, str):
            try:
                return models.RetryTypeOptionsHealthCheckCollectorConfRetryRules(value)
            except ValueError:
                return value
        return value

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(
            [
                "interval",
                "limit",
                "multiplier",
                "codes",
                "enableHeader",
                "retryConnectTimeout",
                "retryConnectReset",
            ]
        )
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


class SplunkAuthenticationBasicSecretSplunkRetryRulesTypeStaticTypedDict(TypedDict):
    type: RetryTypeOptionsHealthCheckCollectorConfRetryRules
    r"""The algorithm to use when performing HTTP retries"""
    interval: NotRequired[float]
    r"""Time interval between retries. Maximum allowed value is 20,000 ms (1/3 minute)."""
    limit: NotRequired[float]
    r"""The maximum number of times to retry a failed HTTP request"""
    codes: NotRequired[List[float]]
    r"""List of HTTP codes that trigger a retry. Leave empty to use the default list of 429 and 503."""
    enable_header: NotRequired[bool]
    r"""Honor any Retry-After header that specifies a delay (in seconds) or a timestamp after which to retry the request. The delay is limited to 20 seconds, even if the Retry-After header specifies a longer delay. When disabled, all Retry-After headers are ignored."""
    retry_connect_timeout: NotRequired[bool]
    r"""Make a single retry attempt when a connection timeout (ETIMEDOUT) error occurs"""
    retry_connect_reset: NotRequired[bool]
    r"""Retry request when a connection reset error (ECONNRESET) error occurs"""


class SplunkAuthenticationBasicSecretSplunkRetryRulesTypeStatic(BaseModel):
    type: RetryTypeOptionsHealthCheckCollectorConfRetryRules
    r"""The algorithm to use when performing HTTP retries"""

    interval: Optional[float] = None
    r"""Time interval between retries. Maximum allowed value is 20,000 ms (1/3 minute)."""

    limit: Optional[float] = None
    r"""The maximum number of times to retry a failed HTTP request"""

    codes: Optional[List[float]] = None
    r"""List of HTTP codes that trigger a retry. Leave empty to use the default list of 429 and 503."""

    enable_header: Annotated[Optional[bool], pydantic.Field(alias="enableHeader")] = (
        None
    )
    r"""Honor any Retry-After header that specifies a delay (in seconds) or a timestamp after which to retry the request. The delay is limited to 20 seconds, even if the Retry-After header specifies a longer delay. When disabled, all Retry-After headers are ignored."""

    retry_connect_timeout: Annotated[
        Optional[bool], pydantic.Field(alias="retryConnectTimeout")
    ] = None
    r"""Make a single retry attempt when a connection timeout (ETIMEDOUT) error occurs"""

    retry_connect_reset: Annotated[
        Optional[bool], pydantic.Field(alias="retryConnectReset")
    ] = None
    r"""Retry request when a connection reset error (ECONNRESET) error occurs"""

    @field_serializer("type")
    def serialize_type(self, value):
        if isinstance(value, str):
            try:
                return models.RetryTypeOptionsHealthCheckCollectorConfRetryRules(value)
            except ValueError:
                return value
        return value

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(
            [
                "interval",
                "limit",
                "codes",
                "enableHeader",
                "retryConnectTimeout",
                "retryConnectReset",
            ]
        )
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


class SplunkAuthenticationBasicSecretSplunkRetryRulesTypeNoneTypedDict(TypedDict):
    type: RetryTypeOptionsHealthCheckCollectorConfRetryRules
    r"""The algorithm to use when performing HTTP retries"""


class SplunkAuthenticationBasicSecretSplunkRetryRulesTypeNone(BaseModel):
    type: RetryTypeOptionsHealthCheckCollectorConfRetryRules
    r"""The algorithm to use when performing HTTP retries"""

    @field_serializer("type")
    def serialize_type(self, value):
        if isinstance(value, str):
            try:
                return models.RetryTypeOptionsHealthCheckCollectorConfRetryRules(value)
            except ValueError:
                return value
        return value


SplunkAuthenticationBasicSecretRetryRulesTypedDict = TypeAliasType(
    "SplunkAuthenticationBasicSecretRetryRulesTypedDict",
    Union[
        SplunkAuthenticationBasicSecretSplunkRetryRulesTypeNoneTypedDict,
        SplunkAuthenticationBasicSecretSplunkRetryRulesTypeStaticTypedDict,
        SplunkAuthenticationBasicSecretSplunkRetryRulesTypeBackoffTypedDict,
    ],
)


class UnknownSplunkAuthenticationBasicSecretRetryRules(BaseModel):
    r"""A SplunkAuthenticationBasicSecretRetryRules variant the SDK doesn't recognize. Preserves the raw payload."""

    type: Literal["UNKNOWN"] = "UNKNOWN"
    raw: Any
    is_unknown: Literal[True] = True

    model_config = ConfigDict(frozen=True)


_SPLUNK_AUTHENTICATION_BASIC_SECRET_RETRY_RULES_VARIANTS: dict[str, Any] = {
    "none": SplunkAuthenticationBasicSecretSplunkRetryRulesTypeNone,
    "static": SplunkAuthenticationBasicSecretSplunkRetryRulesTypeStatic,
    "backoff": SplunkAuthenticationBasicSecretSplunkRetryRulesTypeBackoff,
}


SplunkAuthenticationBasicSecretRetryRules = Annotated[
    Union[
        SplunkAuthenticationBasicSecretSplunkRetryRulesTypeNone,
        SplunkAuthenticationBasicSecretSplunkRetryRulesTypeStatic,
        SplunkAuthenticationBasicSecretSplunkRetryRulesTypeBackoff,
        UnknownSplunkAuthenticationBasicSecretRetryRules,
    ],
    BeforeValidator(
        partial(
            parse_open_union,
            disc_key="type",
            variants=_SPLUNK_AUTHENTICATION_BASIC_SECRET_RETRY_RULES_VARIANTS,
            unknown_cls=UnknownSplunkAuthenticationBasicSecretRetryRules,
            union_name="SplunkAuthenticationBasicSecretRetryRules",
        )
    ),
]


class SplunkAuthenticationBasicSecretTypedDict(TypedDict):
    authentication: SplunkAuthenticationBasicSecretAuthentication
    r"""Authentication method for Discover and Collect REST calls"""
    credentials_secret: str
    r"""Select or create a stored secret that references your credentials"""
    search_head: str
    r"""Search head base URL. Can be an expression. Default is https://localhost:8089."""
    search: str
    r"""Examples: 'index=myAppLogs level=error channel=myApp' OR '| mstats avg(myStat) as myStat WHERE index=myStatsIndex.'"""
    endpoint: str
    r"""REST API used to create a search"""
    output_mode: OutputModeOptionsSplunkCollectorConf
    r"""Format of the returned output"""
    earliest: NotRequired[str]
    r"""The earliest time boundary for the search. Can be an exact or relative time. Examples: '2022-01-14T12:00:00Z' or '-16m@m'"""
    latest: NotRequired[str]
    r"""The latest time boundary for the search. Can be an exact or relative time. Examples: '2022-01-14T12:00:00Z' or '-1m@m'"""
    collect_request_params: NotRequired[
        List[SplunkAuthenticationBasicSecretCollectRequestParamTypedDict]
    ]
    r"""Optional collect request parameters"""
    collect_request_headers: NotRequired[
        List[SplunkAuthenticationBasicSecretCollectRequestHeaderTypedDict]
    ]
    r"""Optional collect request headers"""
    timeout: NotRequired[float]
    r"""HTTP request inactivity timeout. Use 0 for no timeout."""
    use_round_robin_dns: NotRequired[bool]
    r"""Use round-robin DNS lookup. Suitable when DNS server returns multiple addresses in sort order."""
    disable_time_filter: NotRequired[bool]
    r"""Disable collector event time filtering when a date range is specified"""
    reject_unauthorized: NotRequired[bool]
    r"""Reject certificates that cannot be verified against a valid CA (such as self-signed certificates)"""
    handle_escaped_chars: NotRequired[bool]
    r"""Escape characters (\\") in search queries will be passed directly to Splunk"""
    retry_rules: NotRequired[SplunkAuthenticationBasicSecretRetryRulesTypedDict]


class SplunkAuthenticationBasicSecret(BaseModel):
    authentication: SplunkAuthenticationBasicSecretAuthentication
    r"""Authentication method for Discover and Collect REST calls"""

    credentials_secret: Annotated[str, pydantic.Field(alias="credentialsSecret")]
    r"""Select or create a stored secret that references your credentials"""

    search_head: Annotated[str, pydantic.Field(alias="searchHead")]
    r"""Search head base URL. Can be an expression. Default is https://localhost:8089."""

    search: str
    r"""Examples: 'index=myAppLogs level=error channel=myApp' OR '| mstats avg(myStat) as myStat WHERE index=myStatsIndex.'"""

    endpoint: str
    r"""REST API used to create a search"""

    output_mode: Annotated[
        OutputModeOptionsSplunkCollectorConf, pydantic.Field(alias="outputMode")
    ]
    r"""Format of the returned output"""

    earliest: Optional[str] = None
    r"""The earliest time boundary for the search. Can be an exact or relative time. Examples: '2022-01-14T12:00:00Z' or '-16m@m'"""

    latest: Optional[str] = None
    r"""The latest time boundary for the search. Can be an exact or relative time. Examples: '2022-01-14T12:00:00Z' or '-1m@m'"""

    collect_request_params: Annotated[
        Optional[List[SplunkAuthenticationBasicSecretCollectRequestParam]],
        pydantic.Field(alias="collectRequestParams"),
    ] = None
    r"""Optional collect request parameters"""

    collect_request_headers: Annotated[
        Optional[List[SplunkAuthenticationBasicSecretCollectRequestHeader]],
        pydantic.Field(alias="collectRequestHeaders"),
    ] = None
    r"""Optional collect request headers"""

    timeout: Optional[float] = None
    r"""HTTP request inactivity timeout. Use 0 for no timeout."""

    use_round_robin_dns: Annotated[
        Optional[bool], pydantic.Field(alias="useRoundRobinDns")
    ] = None
    r"""Use round-robin DNS lookup. Suitable when DNS server returns multiple addresses in sort order."""

    disable_time_filter: Annotated[
        Optional[bool], pydantic.Field(alias="disableTimeFilter")
    ] = None
    r"""Disable collector event time filtering when a date range is specified"""

    reject_unauthorized: Annotated[
        Optional[bool], pydantic.Field(alias="rejectUnauthorized")
    ] = None
    r"""Reject certificates that cannot be verified against a valid CA (such as self-signed certificates)"""

    handle_escaped_chars: Annotated[
        Optional[bool], pydantic.Field(alias="handleEscapedChars")
    ] = None
    r"""Escape characters (\\") in search queries will be passed directly to Splunk"""

    retry_rules: Annotated[
        Optional[SplunkAuthenticationBasicSecretRetryRules],
        pydantic.Field(alias="retryRules"),
    ] = None

    @field_serializer("authentication")
    def serialize_authentication(self, value):
        if isinstance(value, str):
            try:
                return models.SplunkAuthenticationBasicSecretAuthentication(value)
            except ValueError:
                return value
        return value

    @field_serializer("output_mode")
    def serialize_output_mode(self, value):
        if isinstance(value, str):
            try:
                return models.OutputModeOptionsSplunkCollectorConf(value)
            except ValueError:
                return value
        return value

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(
            [
                "earliest",
                "latest",
                "collectRequestParams",
                "collectRequestHeaders",
                "timeout",
                "useRoundRobinDns",
                "disableTimeFilter",
                "rejectUnauthorized",
                "handleEscapedChars",
                "retryRules",
            ]
        )
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


class SplunkAuthenticationBasicAuthentication(str, Enum, metaclass=utils.OpenEnumMeta):
    r"""Authentication method for Discover and Collect REST calls"""

    # None
    NONE = "none"
    # Basic
    BASIC = "basic"
    # Basic (credentials secret)
    BASIC_SECRET = "basicSecret"
    # Bearer Token
    TOKEN = "token"
    # Bearer Token (text secret)
    TOKEN_SECRET = "tokenSecret"


class SplunkAuthenticationBasicCollectRequestParamTypedDict(TypedDict):
    name: str
    value: str
    r"""JavaScript expression to compute the parameter's value, normally enclosed in backticks (`${earliest}`). If a constant, use single quotes ('earliest'). Values without delimiters (earliest) are evaluated as strings."""


class SplunkAuthenticationBasicCollectRequestParam(BaseModel):
    name: str

    value: str
    r"""JavaScript expression to compute the parameter's value, normally enclosed in backticks (`${earliest}`). If a constant, use single quotes ('earliest'). Values without delimiters (earliest) are evaluated as strings."""


class SplunkAuthenticationBasicCollectRequestHeaderTypedDict(TypedDict):
    name: str
    value: str
    r"""JavaScript expression to compute the header's value, normally enclosed in backticks (`${earliest}`). If a constant, use single quotes ('earliest'). Values without delimiters (earliest) are evaluated as strings."""


class SplunkAuthenticationBasicCollectRequestHeader(BaseModel):
    name: str

    value: str
    r"""JavaScript expression to compute the header's value, normally enclosed in backticks (`${earliest}`). If a constant, use single quotes ('earliest'). Values without delimiters (earliest) are evaluated as strings."""


class SplunkAuthenticationBasicSplunkRetryRulesTypeBackoffTypedDict(TypedDict):
    type: RetryTypeOptionsHealthCheckCollectorConfRetryRules
    r"""The algorithm to use when performing HTTP retries"""
    interval: NotRequired[float]
    r"""Time interval between failed request and first retry (kickoff). Maximum allowed value is 20,000 ms (1/3 minute)."""
    limit: NotRequired[float]
    r"""The maximum number of times to retry a failed HTTP request"""
    multiplier: NotRequired[float]
    r"""Base for exponential backoff. For example, base 2 means that retries will occur after 2, then 4, then 8 seconds, and so on."""
    codes: NotRequired[List[float]]
    r"""List of HTTP codes that trigger a retry. Leave empty to use the default list of 429 and 503."""
    enable_header: NotRequired[bool]
    r"""Honor any Retry-After header that specifies a delay (in seconds) or a timestamp after which to retry the request. The delay is limited to 20 seconds, even if the Retry-After header specifies a longer delay. When disabled, all Retry-After headers are ignored."""
    retry_connect_timeout: NotRequired[bool]
    r"""Make a single retry attempt when a connection timeout (ETIMEDOUT) error occurs"""
    retry_connect_reset: NotRequired[bool]
    r"""Retry request when a connection reset error (ECONNRESET) error occurs"""


class SplunkAuthenticationBasicSplunkRetryRulesTypeBackoff(BaseModel):
    type: RetryTypeOptionsHealthCheckCollectorConfRetryRules
    r"""The algorithm to use when performing HTTP retries"""

    interval: Optional[float] = None
    r"""Time interval between failed request and first retry (kickoff). Maximum allowed value is 20,000 ms (1/3 minute)."""

    limit: Optional[float] = None
    r"""The maximum number of times to retry a failed HTTP request"""

    multiplier: Optional[float] = None
    r"""Base for exponential backoff. For example, base 2 means that retries will occur after 2, then 4, then 8 seconds, and so on."""

    codes: Optional[List[float]] = None
    r"""List of HTTP codes that trigger a retry. Leave empty to use the default list of 429 and 503."""

    enable_header: Annotated[Optional[bool], pydantic.Field(alias="enableHeader")] = (
        None
    )
    r"""Honor any Retry-After header that specifies a delay (in seconds) or a timestamp after which to retry the request. The delay is limited to 20 seconds, even if the Retry-After header specifies a longer delay. When disabled, all Retry-After headers are ignored."""

    retry_connect_timeout: Annotated[
        Optional[bool], pydantic.Field(alias="retryConnectTimeout")
    ] = None
    r"""Make a single retry attempt when a connection timeout (ETIMEDOUT) error occurs"""

    retry_connect_reset: Annotated[
        Optional[bool], pydantic.Field(alias="retryConnectReset")
    ] = None
    r"""Retry request when a connection reset error (ECONNRESET) error occurs"""

    @field_serializer("type")
    def serialize_type(self, value):
        if isinstance(value, str):
            try:
                return models.RetryTypeOptionsHealthCheckCollectorConfRetryRules(value)
            except ValueError:
                return value
        return value

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(
            [
                "interval",
                "limit",
                "multiplier",
                "codes",
                "enableHeader",
                "retryConnectTimeout",
                "retryConnectReset",
            ]
        )
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


class SplunkAuthenticationBasicSplunkRetryRulesTypeStaticTypedDict(TypedDict):
    type: RetryTypeOptionsHealthCheckCollectorConfRetryRules
    r"""The algorithm to use when performing HTTP retries"""
    interval: NotRequired[float]
    r"""Time interval between retries. Maximum allowed value is 20,000 ms (1/3 minute)."""
    limit: NotRequired[float]
    r"""The maximum number of times to retry a failed HTTP request"""
    codes: NotRequired[List[float]]
    r"""List of HTTP codes that trigger a retry. Leave empty to use the default list of 429 and 503."""
    enable_header: NotRequired[bool]
    r"""Honor any Retry-After header that specifies a delay (in seconds) or a timestamp after which to retry the request. The delay is limited to 20 seconds, even if the Retry-After header specifies a longer delay. When disabled, all Retry-After headers are ignored."""
    retry_connect_timeout: NotRequired[bool]
    r"""Make a single retry attempt when a connection timeout (ETIMEDOUT) error occurs"""
    retry_connect_reset: NotRequired[bool]
    r"""Retry request when a connection reset error (ECONNRESET) error occurs"""


class SplunkAuthenticationBasicSplunkRetryRulesTypeStatic(BaseModel):
    type: RetryTypeOptionsHealthCheckCollectorConfRetryRules
    r"""The algorithm to use when performing HTTP retries"""

    interval: Optional[float] = None
    r"""Time interval between retries. Maximum allowed value is 20,000 ms (1/3 minute)."""

    limit: Optional[float] = None
    r"""The maximum number of times to retry a failed HTTP request"""

    codes: Optional[List[float]] = None
    r"""List of HTTP codes that trigger a retry. Leave empty to use the default list of 429 and 503."""

    enable_header: Annotated[Optional[bool], pydantic.Field(alias="enableHeader")] = (
        None
    )
    r"""Honor any Retry-After header that specifies a delay (in seconds) or a timestamp after which to retry the request. The delay is limited to 20 seconds, even if the Retry-After header specifies a longer delay. When disabled, all Retry-After headers are ignored."""

    retry_connect_timeout: Annotated[
        Optional[bool], pydantic.Field(alias="retryConnectTimeout")
    ] = None
    r"""Make a single retry attempt when a connection timeout (ETIMEDOUT) error occurs"""

    retry_connect_reset: Annotated[
        Optional[bool], pydantic.Field(alias="retryConnectReset")
    ] = None
    r"""Retry request when a connection reset error (ECONNRESET) error occurs"""

    @field_serializer("type")
    def serialize_type(self, value):
        if isinstance(value, str):
            try:
                return models.RetryTypeOptionsHealthCheckCollectorConfRetryRules(value)
            except ValueError:
                return value
        return value

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(
            [
                "interval",
                "limit",
                "codes",
                "enableHeader",
                "retryConnectTimeout",
                "retryConnectReset",
            ]
        )
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


class SplunkAuthenticationBasicSplunkRetryRulesTypeNoneTypedDict(TypedDict):
    type: RetryTypeOptionsHealthCheckCollectorConfRetryRules
    r"""The algorithm to use when performing HTTP retries"""


class SplunkAuthenticationBasicSplunkRetryRulesTypeNone(BaseModel):
    type: RetryTypeOptionsHealthCheckCollectorConfRetryRules
    r"""The algorithm to use when performing HTTP retries"""

    @field_serializer("type")
    def serialize_type(self, value):
        if isinstance(value, str):
            try:
                return models.RetryTypeOptionsHealthCheckCollectorConfRetryRules(value)
            except ValueError:
                return value
        return value


SplunkAuthenticationBasicRetryRulesTypedDict = TypeAliasType(
    "SplunkAuthenticationBasicRetryRulesTypedDict",
    Union[
        SplunkAuthenticationBasicSplunkRetryRulesTypeNoneTypedDict,
        SplunkAuthenticationBasicSplunkRetryRulesTypeStaticTypedDict,
        SplunkAuthenticationBasicSplunkRetryRulesTypeBackoffTypedDict,
    ],
)


class UnknownSplunkAuthenticationBasicRetryRules(BaseModel):
    r"""A SplunkAuthenticationBasicRetryRules variant the SDK doesn't recognize. Preserves the raw payload."""

    type: Literal["UNKNOWN"] = "UNKNOWN"
    raw: Any
    is_unknown: Literal[True] = True

    model_config = ConfigDict(frozen=True)


_SPLUNK_AUTHENTICATION_BASIC_RETRY_RULES_VARIANTS: dict[str, Any] = {
    "none": SplunkAuthenticationBasicSplunkRetryRulesTypeNone,
    "static": SplunkAuthenticationBasicSplunkRetryRulesTypeStatic,
    "backoff": SplunkAuthenticationBasicSplunkRetryRulesTypeBackoff,
}


SplunkAuthenticationBasicRetryRules = Annotated[
    Union[
        SplunkAuthenticationBasicSplunkRetryRulesTypeNone,
        SplunkAuthenticationBasicSplunkRetryRulesTypeStatic,
        SplunkAuthenticationBasicSplunkRetryRulesTypeBackoff,
        UnknownSplunkAuthenticationBasicRetryRules,
    ],
    BeforeValidator(
        partial(
            parse_open_union,
            disc_key="type",
            variants=_SPLUNK_AUTHENTICATION_BASIC_RETRY_RULES_VARIANTS,
            unknown_cls=UnknownSplunkAuthenticationBasicRetryRules,
            union_name="SplunkAuthenticationBasicRetryRules",
        )
    ),
]


class SplunkAuthenticationBasicTypedDict(TypedDict):
    authentication: SplunkAuthenticationBasicAuthentication
    r"""Authentication method for Discover and Collect REST calls"""
    username: str
    r"""Basic authentication username"""
    password: str
    r"""Basic authentication password"""
    search_head: str
    r"""Search head base URL. Can be an expression. Default is https://localhost:8089."""
    search: str
    r"""Examples: 'index=myAppLogs level=error channel=myApp' OR '| mstats avg(myStat) as myStat WHERE index=myStatsIndex.'"""
    endpoint: str
    r"""REST API used to create a search"""
    output_mode: OutputModeOptionsSplunkCollectorConf
    r"""Format of the returned output"""
    earliest: NotRequired[str]
    r"""The earliest time boundary for the search. Can be an exact or relative time. Examples: '2022-01-14T12:00:00Z' or '-16m@m'"""
    latest: NotRequired[str]
    r"""The latest time boundary for the search. Can be an exact or relative time. Examples: '2022-01-14T12:00:00Z' or '-1m@m'"""
    collect_request_params: NotRequired[
        List[SplunkAuthenticationBasicCollectRequestParamTypedDict]
    ]
    r"""Optional collect request parameters"""
    collect_request_headers: NotRequired[
        List[SplunkAuthenticationBasicCollectRequestHeaderTypedDict]
    ]
    r"""Optional collect request headers"""
    timeout: NotRequired[float]
    r"""HTTP request inactivity timeout. Use 0 for no timeout."""
    use_round_robin_dns: NotRequired[bool]
    r"""Use round-robin DNS lookup. Suitable when DNS server returns multiple addresses in sort order."""
    disable_time_filter: NotRequired[bool]
    r"""Disable collector event time filtering when a date range is specified"""
    reject_unauthorized: NotRequired[bool]
    r"""Reject certificates that cannot be verified against a valid CA (such as self-signed certificates)"""
    handle_escaped_chars: NotRequired[bool]
    r"""Escape characters (\\") in search queries will be passed directly to Splunk"""
    retry_rules: NotRequired[SplunkAuthenticationBasicRetryRulesTypedDict]


class SplunkAuthenticationBasic(BaseModel):
    authentication: SplunkAuthenticationBasicAuthentication
    r"""Authentication method for Discover and Collect REST calls"""

    username: str
    r"""Basic authentication username"""

    password: str
    r"""Basic authentication password"""

    search_head: Annotated[str, pydantic.Field(alias="searchHead")]
    r"""Search head base URL. Can be an expression. Default is https://localhost:8089."""

    search: str
    r"""Examples: 'index=myAppLogs level=error channel=myApp' OR '| mstats avg(myStat) as myStat WHERE index=myStatsIndex.'"""

    endpoint: str
    r"""REST API used to create a search"""

    output_mode: Annotated[
        OutputModeOptionsSplunkCollectorConf, pydantic.Field(alias="outputMode")
    ]
    r"""Format of the returned output"""

    earliest: Optional[str] = None
    r"""The earliest time boundary for the search. Can be an exact or relative time. Examples: '2022-01-14T12:00:00Z' or '-16m@m'"""

    latest: Optional[str] = None
    r"""The latest time boundary for the search. Can be an exact or relative time. Examples: '2022-01-14T12:00:00Z' or '-1m@m'"""

    collect_request_params: Annotated[
        Optional[List[SplunkAuthenticationBasicCollectRequestParam]],
        pydantic.Field(alias="collectRequestParams"),
    ] = None
    r"""Optional collect request parameters"""

    collect_request_headers: Annotated[
        Optional[List[SplunkAuthenticationBasicCollectRequestHeader]],
        pydantic.Field(alias="collectRequestHeaders"),
    ] = None
    r"""Optional collect request headers"""

    timeout: Optional[float] = None
    r"""HTTP request inactivity timeout. Use 0 for no timeout."""

    use_round_robin_dns: Annotated[
        Optional[bool], pydantic.Field(alias="useRoundRobinDns")
    ] = None
    r"""Use round-robin DNS lookup. Suitable when DNS server returns multiple addresses in sort order."""

    disable_time_filter: Annotated[
        Optional[bool], pydantic.Field(alias="disableTimeFilter")
    ] = None
    r"""Disable collector event time filtering when a date range is specified"""

    reject_unauthorized: Annotated[
        Optional[bool], pydantic.Field(alias="rejectUnauthorized")
    ] = None
    r"""Reject certificates that cannot be verified against a valid CA (such as self-signed certificates)"""

    handle_escaped_chars: Annotated[
        Optional[bool], pydantic.Field(alias="handleEscapedChars")
    ] = None
    r"""Escape characters (\\") in search queries will be passed directly to Splunk"""

    retry_rules: Annotated[
        Optional[SplunkAuthenticationBasicRetryRules],
        pydantic.Field(alias="retryRules"),
    ] = None

    @field_serializer("authentication")
    def serialize_authentication(self, value):
        if isinstance(value, str):
            try:
                return models.SplunkAuthenticationBasicAuthentication(value)
            except ValueError:
                return value
        return value

    @field_serializer("output_mode")
    def serialize_output_mode(self, value):
        if isinstance(value, str):
            try:
                return models.OutputModeOptionsSplunkCollectorConf(value)
            except ValueError:
                return value
        return value

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(
            [
                "earliest",
                "latest",
                "collectRequestParams",
                "collectRequestHeaders",
                "timeout",
                "useRoundRobinDns",
                "disableTimeFilter",
                "rejectUnauthorized",
                "handleEscapedChars",
                "retryRules",
            ]
        )
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


class SplunkAuthenticationNoneAuthentication(str, Enum, metaclass=utils.OpenEnumMeta):
    r"""Authentication method for Discover and Collect REST calls"""

    # None
    NONE = "none"
    # Basic
    BASIC = "basic"
    # Basic (credentials secret)
    BASIC_SECRET = "basicSecret"
    # Bearer Token
    TOKEN = "token"
    # Bearer Token (text secret)
    TOKEN_SECRET = "tokenSecret"


class SplunkAuthenticationNoneCollectRequestParamTypedDict(TypedDict):
    name: str
    value: str
    r"""JavaScript expression to compute the parameter's value, normally enclosed in backticks (`${earliest}`). If a constant, use single quotes ('earliest'). Values without delimiters (earliest) are evaluated as strings."""


class SplunkAuthenticationNoneCollectRequestParam(BaseModel):
    name: str

    value: str
    r"""JavaScript expression to compute the parameter's value, normally enclosed in backticks (`${earliest}`). If a constant, use single quotes ('earliest'). Values without delimiters (earliest) are evaluated as strings."""


class SplunkAuthenticationNoneCollectRequestHeaderTypedDict(TypedDict):
    name: str
    value: str
    r"""JavaScript expression to compute the header's value, normally enclosed in backticks (`${earliest}`). If a constant, use single quotes ('earliest'). Values without delimiters (earliest) are evaluated as strings."""


class SplunkAuthenticationNoneCollectRequestHeader(BaseModel):
    name: str

    value: str
    r"""JavaScript expression to compute the header's value, normally enclosed in backticks (`${earliest}`). If a constant, use single quotes ('earliest'). Values without delimiters (earliest) are evaluated as strings."""


class SplunkAuthenticationNoneSplunkRetryRulesTypeBackoffTypedDict(TypedDict):
    type: RetryTypeOptionsHealthCheckCollectorConfRetryRules
    r"""The algorithm to use when performing HTTP retries"""
    interval: NotRequired[float]
    r"""Time interval between failed request and first retry (kickoff). Maximum allowed value is 20,000 ms (1/3 minute)."""
    limit: NotRequired[float]
    r"""The maximum number of times to retry a failed HTTP request"""
    multiplier: NotRequired[float]
    r"""Base for exponential backoff. For example, base 2 means that retries will occur after 2, then 4, then 8 seconds, and so on."""
    codes: NotRequired[List[float]]
    r"""List of HTTP codes that trigger a retry. Leave empty to use the default list of 429 and 503."""
    enable_header: NotRequired[bool]
    r"""Honor any Retry-After header that specifies a delay (in seconds) or a timestamp after which to retry the request. The delay is limited to 20 seconds, even if the Retry-After header specifies a longer delay. When disabled, all Retry-After headers are ignored."""
    retry_connect_timeout: NotRequired[bool]
    r"""Make a single retry attempt when a connection timeout (ETIMEDOUT) error occurs"""
    retry_connect_reset: NotRequired[bool]
    r"""Retry request when a connection reset error (ECONNRESET) error occurs"""


class SplunkAuthenticationNoneSplunkRetryRulesTypeBackoff(BaseModel):
    type: RetryTypeOptionsHealthCheckCollectorConfRetryRules
    r"""The algorithm to use when performing HTTP retries"""

    interval: Optional[float] = None
    r"""Time interval between failed request and first retry (kickoff). Maximum allowed value is 20,000 ms (1/3 minute)."""

    limit: Optional[float] = None
    r"""The maximum number of times to retry a failed HTTP request"""

    multiplier: Optional[float] = None
    r"""Base for exponential backoff. For example, base 2 means that retries will occur after 2, then 4, then 8 seconds, and so on."""

    codes: Optional[List[float]] = None
    r"""List of HTTP codes that trigger a retry. Leave empty to use the default list of 429 and 503."""

    enable_header: Annotated[Optional[bool], pydantic.Field(alias="enableHeader")] = (
        None
    )
    r"""Honor any Retry-After header that specifies a delay (in seconds) or a timestamp after which to retry the request. The delay is limited to 20 seconds, even if the Retry-After header specifies a longer delay. When disabled, all Retry-After headers are ignored."""

    retry_connect_timeout: Annotated[
        Optional[bool], pydantic.Field(alias="retryConnectTimeout")
    ] = None
    r"""Make a single retry attempt when a connection timeout (ETIMEDOUT) error occurs"""

    retry_connect_reset: Annotated[
        Optional[bool], pydantic.Field(alias="retryConnectReset")
    ] = None
    r"""Retry request when a connection reset error (ECONNRESET) error occurs"""

    @field_serializer("type")
    def serialize_type(self, value):
        if isinstance(value, str):
            try:
                return models.RetryTypeOptionsHealthCheckCollectorConfRetryRules(value)
            except ValueError:
                return value
        return value

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(
            [
                "interval",
                "limit",
                "multiplier",
                "codes",
                "enableHeader",
                "retryConnectTimeout",
                "retryConnectReset",
            ]
        )
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


class SplunkAuthenticationNoneSplunkRetryRulesTypeStaticTypedDict(TypedDict):
    type: RetryTypeOptionsHealthCheckCollectorConfRetryRules
    r"""The algorithm to use when performing HTTP retries"""
    interval: NotRequired[float]
    r"""Time interval between retries. Maximum allowed value is 20,000 ms (1/3 minute)."""
    limit: NotRequired[float]
    r"""The maximum number of times to retry a failed HTTP request"""
    codes: NotRequired[List[float]]
    r"""List of HTTP codes that trigger a retry. Leave empty to use the default list of 429 and 503."""
    enable_header: NotRequired[bool]
    r"""Honor any Retry-After header that specifies a delay (in seconds) or a timestamp after which to retry the request. The delay is limited to 20 seconds, even if the Retry-After header specifies a longer delay. When disabled, all Retry-After headers are ignored."""
    retry_connect_timeout: NotRequired[bool]
    r"""Make a single retry attempt when a connection timeout (ETIMEDOUT) error occurs"""
    retry_connect_reset: NotRequired[bool]
    r"""Retry request when a connection reset error (ECONNRESET) error occurs"""


class SplunkAuthenticationNoneSplunkRetryRulesTypeStatic(BaseModel):
    type: RetryTypeOptionsHealthCheckCollectorConfRetryRules
    r"""The algorithm to use when performing HTTP retries"""

    interval: Optional[float] = None
    r"""Time interval between retries. Maximum allowed value is 20,000 ms (1/3 minute)."""

    limit: Optional[float] = None
    r"""The maximum number of times to retry a failed HTTP request"""

    codes: Optional[List[float]] = None
    r"""List of HTTP codes that trigger a retry. Leave empty to use the default list of 429 and 503."""

    enable_header: Annotated[Optional[bool], pydantic.Field(alias="enableHeader")] = (
        None
    )
    r"""Honor any Retry-After header that specifies a delay (in seconds) or a timestamp after which to retry the request. The delay is limited to 20 seconds, even if the Retry-After header specifies a longer delay. When disabled, all Retry-After headers are ignored."""

    retry_connect_timeout: Annotated[
        Optional[bool], pydantic.Field(alias="retryConnectTimeout")
    ] = None
    r"""Make a single retry attempt when a connection timeout (ETIMEDOUT) error occurs"""

    retry_connect_reset: Annotated[
        Optional[bool], pydantic.Field(alias="retryConnectReset")
    ] = None
    r"""Retry request when a connection reset error (ECONNRESET) error occurs"""

    @field_serializer("type")
    def serialize_type(self, value):
        if isinstance(value, str):
            try:
                return models.RetryTypeOptionsHealthCheckCollectorConfRetryRules(value)
            except ValueError:
                return value
        return value

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(
            [
                "interval",
                "limit",
                "codes",
                "enableHeader",
                "retryConnectTimeout",
                "retryConnectReset",
            ]
        )
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


class SplunkAuthenticationNoneSplunkRetryRulesTypeNoneTypedDict(TypedDict):
    type: RetryTypeOptionsHealthCheckCollectorConfRetryRules
    r"""The algorithm to use when performing HTTP retries"""


class SplunkAuthenticationNoneSplunkRetryRulesTypeNone(BaseModel):
    type: RetryTypeOptionsHealthCheckCollectorConfRetryRules
    r"""The algorithm to use when performing HTTP retries"""

    @field_serializer("type")
    def serialize_type(self, value):
        if isinstance(value, str):
            try:
                return models.RetryTypeOptionsHealthCheckCollectorConfRetryRules(value)
            except ValueError:
                return value
        return value


SplunkAuthenticationNoneRetryRulesTypedDict = TypeAliasType(
    "SplunkAuthenticationNoneRetryRulesTypedDict",
    Union[
        SplunkAuthenticationNoneSplunkRetryRulesTypeNoneTypedDict,
        SplunkAuthenticationNoneSplunkRetryRulesTypeStaticTypedDict,
        SplunkAuthenticationNoneSplunkRetryRulesTypeBackoffTypedDict,
    ],
)


class UnknownSplunkAuthenticationNoneRetryRules(BaseModel):
    r"""A SplunkAuthenticationNoneRetryRules variant the SDK doesn't recognize. Preserves the raw payload."""

    type: Literal["UNKNOWN"] = "UNKNOWN"
    raw: Any
    is_unknown: Literal[True] = True

    model_config = ConfigDict(frozen=True)


_SPLUNK_AUTHENTICATION_NONE_RETRY_RULES_VARIANTS: dict[str, Any] = {
    "none": SplunkAuthenticationNoneSplunkRetryRulesTypeNone,
    "static": SplunkAuthenticationNoneSplunkRetryRulesTypeStatic,
    "backoff": SplunkAuthenticationNoneSplunkRetryRulesTypeBackoff,
}


SplunkAuthenticationNoneRetryRules = Annotated[
    Union[
        SplunkAuthenticationNoneSplunkRetryRulesTypeNone,
        SplunkAuthenticationNoneSplunkRetryRulesTypeStatic,
        SplunkAuthenticationNoneSplunkRetryRulesTypeBackoff,
        UnknownSplunkAuthenticationNoneRetryRules,
    ],
    BeforeValidator(
        partial(
            parse_open_union,
            disc_key="type",
            variants=_SPLUNK_AUTHENTICATION_NONE_RETRY_RULES_VARIANTS,
            unknown_cls=UnknownSplunkAuthenticationNoneRetryRules,
            union_name="SplunkAuthenticationNoneRetryRules",
        )
    ),
]


class SplunkAuthenticationNoneTypedDict(TypedDict):
    authentication: SplunkAuthenticationNoneAuthentication
    r"""Authentication method for Discover and Collect REST calls"""
    search_head: str
    r"""Search head base URL. Can be an expression. Default is https://localhost:8089."""
    search: str
    r"""Examples: 'index=myAppLogs level=error channel=myApp' OR '| mstats avg(myStat) as myStat WHERE index=myStatsIndex.'"""
    endpoint: str
    r"""REST API used to create a search"""
    output_mode: OutputModeOptionsSplunkCollectorConf
    r"""Format of the returned output"""
    earliest: NotRequired[str]
    r"""The earliest time boundary for the search. Can be an exact or relative time. Examples: '2022-01-14T12:00:00Z' or '-16m@m'"""
    latest: NotRequired[str]
    r"""The latest time boundary for the search. Can be an exact or relative time. Examples: '2022-01-14T12:00:00Z' or '-1m@m'"""
    collect_request_params: NotRequired[
        List[SplunkAuthenticationNoneCollectRequestParamTypedDict]
    ]
    r"""Optional collect request parameters"""
    collect_request_headers: NotRequired[
        List[SplunkAuthenticationNoneCollectRequestHeaderTypedDict]
    ]
    r"""Optional collect request headers"""
    timeout: NotRequired[float]
    r"""HTTP request inactivity timeout. Use 0 for no timeout."""
    use_round_robin_dns: NotRequired[bool]
    r"""Use round-robin DNS lookup. Suitable when DNS server returns multiple addresses in sort order."""
    disable_time_filter: NotRequired[bool]
    r"""Disable collector event time filtering when a date range is specified"""
    reject_unauthorized: NotRequired[bool]
    r"""Reject certificates that cannot be verified against a valid CA (such as self-signed certificates)"""
    handle_escaped_chars: NotRequired[bool]
    r"""Escape characters (\\") in search queries will be passed directly to Splunk"""
    retry_rules: NotRequired[SplunkAuthenticationNoneRetryRulesTypedDict]


class SplunkAuthenticationNone(BaseModel):
    authentication: SplunkAuthenticationNoneAuthentication
    r"""Authentication method for Discover and Collect REST calls"""

    search_head: Annotated[str, pydantic.Field(alias="searchHead")]
    r"""Search head base URL. Can be an expression. Default is https://localhost:8089."""

    search: str
    r"""Examples: 'index=myAppLogs level=error channel=myApp' OR '| mstats avg(myStat) as myStat WHERE index=myStatsIndex.'"""

    endpoint: str
    r"""REST API used to create a search"""

    output_mode: Annotated[
        OutputModeOptionsSplunkCollectorConf, pydantic.Field(alias="outputMode")
    ]
    r"""Format of the returned output"""

    earliest: Optional[str] = None
    r"""The earliest time boundary for the search. Can be an exact or relative time. Examples: '2022-01-14T12:00:00Z' or '-16m@m'"""

    latest: Optional[str] = None
    r"""The latest time boundary for the search. Can be an exact or relative time. Examples: '2022-01-14T12:00:00Z' or '-1m@m'"""

    collect_request_params: Annotated[
        Optional[List[SplunkAuthenticationNoneCollectRequestParam]],
        pydantic.Field(alias="collectRequestParams"),
    ] = None
    r"""Optional collect request parameters"""

    collect_request_headers: Annotated[
        Optional[List[SplunkAuthenticationNoneCollectRequestHeader]],
        pydantic.Field(alias="collectRequestHeaders"),
    ] = None
    r"""Optional collect request headers"""

    timeout: Optional[float] = None
    r"""HTTP request inactivity timeout. Use 0 for no timeout."""

    use_round_robin_dns: Annotated[
        Optional[bool], pydantic.Field(alias="useRoundRobinDns")
    ] = None
    r"""Use round-robin DNS lookup. Suitable when DNS server returns multiple addresses in sort order."""

    disable_time_filter: Annotated[
        Optional[bool], pydantic.Field(alias="disableTimeFilter")
    ] = None
    r"""Disable collector event time filtering when a date range is specified"""

    reject_unauthorized: Annotated[
        Optional[bool], pydantic.Field(alias="rejectUnauthorized")
    ] = None
    r"""Reject certificates that cannot be verified against a valid CA (such as self-signed certificates)"""

    handle_escaped_chars: Annotated[
        Optional[bool], pydantic.Field(alias="handleEscapedChars")
    ] = None
    r"""Escape characters (\\") in search queries will be passed directly to Splunk"""

    retry_rules: Annotated[
        Optional[SplunkAuthenticationNoneRetryRules], pydantic.Field(alias="retryRules")
    ] = None

    @field_serializer("authentication")
    def serialize_authentication(self, value):
        if isinstance(value, str):
            try:
                return models.SplunkAuthenticationNoneAuthentication(value)
            except ValueError:
                return value
        return value

    @field_serializer("output_mode")
    def serialize_output_mode(self, value):
        if isinstance(value, str):
            try:
                return models.OutputModeOptionsSplunkCollectorConf(value)
            except ValueError:
                return value
        return value

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(
            [
                "earliest",
                "latest",
                "collectRequestParams",
                "collectRequestHeaders",
                "timeout",
                "useRoundRobinDns",
                "disableTimeFilter",
                "rejectUnauthorized",
                "handleEscapedChars",
                "retryRules",
            ]
        )
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


SplunkCollectorConfTypedDict = TypeAliasType(
    "SplunkCollectorConfTypedDict",
    Union[
        SplunkAuthenticationNoneTypedDict,
        SplunkAuthenticationBasicSecretTypedDict,
        SplunkAuthenticationTokenTypedDict,
        SplunkAuthenticationTokenSecretTypedDict,
        SplunkAuthenticationBasicTypedDict,
    ],
)


class UnknownSplunkCollectorConf(BaseModel):
    r"""A SplunkCollectorConf variant the SDK doesn't recognize. Preserves the raw payload."""

    authentication: Literal["UNKNOWN"] = "UNKNOWN"
    raw: Any
    is_unknown: Literal[True] = True

    model_config = ConfigDict(frozen=True)


_SPLUNK_COLLECTOR_CONF_VARIANTS: dict[str, Any] = {
    "none": SplunkAuthenticationNone,
    "basic": SplunkAuthenticationBasic,
    "basicSecret": SplunkAuthenticationBasicSecret,
    "token": SplunkAuthenticationToken,
    "tokenSecret": SplunkAuthenticationTokenSecret,
}


SplunkCollectorConf = Annotated[
    Union[
        SplunkAuthenticationNone,
        SplunkAuthenticationBasic,
        SplunkAuthenticationBasicSecret,
        SplunkAuthenticationToken,
        SplunkAuthenticationTokenSecret,
        UnknownSplunkCollectorConf,
    ],
    BeforeValidator(
        partial(
            parse_open_union,
            disc_key="authentication",
            variants=_SPLUNK_COLLECTOR_CONF_VARIANTS,
            unknown_cls=UnknownSplunkCollectorConf,
            union_name="SplunkCollectorConf",
        )
    ),
]


try:
    SplunkAuthenticationTokenSecretSplunkRetryRulesTypeBackoff.model_rebuild()
except NameError:
    pass
try:
    SplunkAuthenticationTokenSecretSplunkRetryRulesTypeStatic.model_rebuild()
except NameError:
    pass
try:
    SplunkAuthenticationTokenSecret.model_rebuild()
except NameError:
    pass
try:
    SplunkAuthenticationTokenSplunkRetryRulesTypeBackoff.model_rebuild()
except NameError:
    pass
try:
    SplunkAuthenticationTokenSplunkRetryRulesTypeStatic.model_rebuild()
except NameError:
    pass
try:
    SplunkAuthenticationToken.model_rebuild()
except NameError:
    pass
try:
    SplunkAuthenticationBasicSecretSplunkRetryRulesTypeBackoff.model_rebuild()
except NameError:
    pass
try:
    SplunkAuthenticationBasicSecretSplunkRetryRulesTypeStatic.model_rebuild()
except NameError:
    pass
try:
    SplunkAuthenticationBasicSecret.model_rebuild()
except NameError:
    pass
try:
    SplunkAuthenticationBasicSplunkRetryRulesTypeBackoff.model_rebuild()
except NameError:
    pass
try:
    SplunkAuthenticationBasicSplunkRetryRulesTypeStatic.model_rebuild()
except NameError:
    pass
try:
    SplunkAuthenticationBasic.model_rebuild()
except NameError:
    pass
try:
    SplunkAuthenticationNoneSplunkRetryRulesTypeBackoff.model_rebuild()
except NameError:
    pass
try:
    SplunkAuthenticationNoneSplunkRetryRulesTypeStatic.model_rebuild()
except NameError:
    pass
try:
    SplunkAuthenticationNone.model_rebuild()
except NameError:
    pass
