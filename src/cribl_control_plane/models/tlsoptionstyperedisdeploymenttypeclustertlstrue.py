"""Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT."""

from __future__ import annotations
from .maximumtlsversionoptionsredisdeploymenttypestandalonetlsoptions import (
    MaximumTLSVersionOptionsRedisDeploymentTypeStandaloneTLSOptions,
)
from .minimumtlsversionoptionsredisdeploymenttypestandalonetlsoptions import (
    MinimumTLSVersionOptionsRedisDeploymentTypeStandaloneTLSOptions,
)
from cribl_control_plane import models
from cribl_control_plane.types import BaseModel, UNSET_SENTINEL
import pydantic
from pydantic import field_serializer, model_serializer
from typing import Optional
from typing_extensions import Annotated, NotRequired, TypedDict


class TLSOptionsTypeRedisDeploymentTypeClusterTLSTrueTypedDict(TypedDict):
    reject_unauthorized: NotRequired[bool]
    r"""Reject certs that are not authorized by a CA in the CA certificate path, or by another trusted CA (such as the system's CA)"""
    servername: NotRequired[str]
    r"""Server name for the SNI (Server Name Indication) TLS extension. Must be a host name, not an IP address."""
    certificate_name: NotRequired[str]
    r"""The name of the predefined certificate"""
    ca_path: NotRequired[str]
    r"""Path on client in which to find CA certificates to verify the server's certificate. PEM format. Can reference $ENV_VARS."""
    priv_key_path: NotRequired[str]
    r"""Path on client in which to find the private key to use. PEM format. Can reference $ENV_VARS."""
    cert_path: NotRequired[str]
    r"""Path on client in which to find certificates to use. PEM format. Can reference $ENV_VARS."""
    passphrase: NotRequired[str]
    r"""Passphrase to use to decrypt private key"""
    min_version: NotRequired[
        MinimumTLSVersionOptionsRedisDeploymentTypeStandaloneTLSOptions
    ]
    r"""Minimum TLS version to use when connecting"""
    max_version: NotRequired[
        MaximumTLSVersionOptionsRedisDeploymentTypeStandaloneTLSOptions
    ]
    r"""Maximum TLS version to use when connecting"""


class TLSOptionsTypeRedisDeploymentTypeClusterTLSTrue(BaseModel):
    reject_unauthorized: Annotated[
        Optional[bool], pydantic.Field(alias="rejectUnauthorized")
    ] = None
    r"""Reject certs that are not authorized by a CA in the CA certificate path, or by another trusted CA (such as the system's CA)"""

    servername: Optional[str] = None
    r"""Server name for the SNI (Server Name Indication) TLS extension. Must be a host name, not an IP address."""

    certificate_name: Annotated[
        Optional[str], pydantic.Field(alias="certificateName")
    ] = None
    r"""The name of the predefined certificate"""

    ca_path: Annotated[Optional[str], pydantic.Field(alias="caPath")] = None
    r"""Path on client in which to find CA certificates to verify the server's certificate. PEM format. Can reference $ENV_VARS."""

    priv_key_path: Annotated[Optional[str], pydantic.Field(alias="privKeyPath")] = None
    r"""Path on client in which to find the private key to use. PEM format. Can reference $ENV_VARS."""

    cert_path: Annotated[Optional[str], pydantic.Field(alias="certPath")] = None
    r"""Path on client in which to find certificates to use. PEM format. Can reference $ENV_VARS."""

    passphrase: Optional[str] = None
    r"""Passphrase to use to decrypt private key"""

    min_version: Annotated[
        Optional[MinimumTLSVersionOptionsRedisDeploymentTypeStandaloneTLSOptions],
        pydantic.Field(alias="minVersion"),
    ] = None
    r"""Minimum TLS version to use when connecting"""

    max_version: Annotated[
        Optional[MaximumTLSVersionOptionsRedisDeploymentTypeStandaloneTLSOptions],
        pydantic.Field(alias="maxVersion"),
    ] = None
    r"""Maximum TLS version to use when connecting"""

    @field_serializer("min_version")
    def serialize_min_version(self, value):
        if isinstance(value, str):
            try:
                return models.MinimumTLSVersionOptionsRedisDeploymentTypeStandaloneTLSOptions(
                    value
                )
            except ValueError:
                return value
        return value

    @field_serializer("max_version")
    def serialize_max_version(self, value):
        if isinstance(value, str):
            try:
                return models.MaximumTLSVersionOptionsRedisDeploymentTypeStandaloneTLSOptions(
                    value
                )
            except ValueError:
                return value
        return value

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(
            [
                "rejectUnauthorized",
                "servername",
                "certificateName",
                "caPath",
                "privKeyPath",
                "certPath",
                "passphrase",
                "minVersion",
                "maxVersion",
            ]
        )
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m
